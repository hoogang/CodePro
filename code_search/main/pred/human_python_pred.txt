Q_0	write csv	C_0_0	def write_csv ( filename , data , delimiter = csv_delimiter ) string string string with open ( filename , string ) as file csv_writer = csv . writer ( file , delimiter = delimiter ) for var in data csv_writer . writerow ( var )	1
Q_0	write csv	C_0_1	def write_to_csv ( fname , header , rows ) with open ( fname , string ) as csvfile csvwriter = csv . writer ( csvfile , delimiter = string , quotechar = string , quoting = csv . quote_minimal ) csvwriter . writerow ( header ) for var in rows csvwriter . writerow ( [ s . encode ( string ) . replace ( string , string ) . replace ( string , string ) for s in var ] )	1
Q_0	write csv	C_0_2	def write_csv ( self )	1
Q_0	write csv	C_0_3	"def to_csv ( self , fbuf , quotechar = string string , string "" , quoting = csv . quote_all ) if self . headers csvwriter . writerow ( self . headers ) for var in self . sylk_handler . stream_rows ( ) csvwriter . writerow ( var )"	1
Q_0	write csv	C_0_4	def write_to_csv ( self , filename ) string string string fid = open ( filename , string )	1
Q_0	write csv	C_0_5	def write_csv ( self )	1
Q_0	write csv	C_0_6	def write_csv ( filename , t , header = none ) with open ( filename , string ) as fh csv_writer = csv . writer ( fh , delimiter = string ) if header = none csv_writer . writerow ( header ) [ csv_writer . writerow ( t [ var ] ) for var in range ( len ( t ) ) ]	1
Q_0	write csv	C_0_7	def write_csv ( self )	1
Q_0	write csv	C_0_8	def write_to_csv ( fname , header , rows ) with open ( fname , string ) as csvfile csvwriter = csv . writer ( csvfile , delimiter = string , quotechar = string , quoting = csv . quote_minimal ) csvwriter . writerow ( header ) for var in rows csvwriter . writerow ( [ s . encode ( string ) . replace ( string , string ) . replace ( string , string ) for s in var ] )	1
Q_0	write csv	C_0_9	def write_csv_header ( mol , csv_writer ) string string string	1
Q_0	write csv	C_0_10	def write_csvs ( self , asset_map , show_progress = false , invalid_data_behavior = string ) string string warn string raise string ignore string string read = partial ( read_csv , parse_dates = [ string ] , index_col = string , dtype = self . _csv_dtypes , ) return self . write ( ( ( var , read ( var ) ) for var , var in iteritems ( asset_map ) ) , assets = viewkeys ( asset_map ) , show_progress = show_progress , invalid_data_behavior = invalid_data_behavior , )	1
Q_0	write csv	C_0_11	def write_csvs ( self , asset_map , show_progress = false , invalid_data_behavior = string ) string string warn string raise string ignore string string read = partial ( read_csv , parse_dates = [ string ] , index_col = string , dtype = self . _csv_dtypes , ) return self . write ( ( ( var , read ( var ) ) for var , var in iteritems ( asset_map ) ) , assets = viewkeys ( asset_map ) , show_progress = show_progress , invalid_data_behavior = invalid_data_behavior , )	1
Q_0	write csv	C_0_12	def expand ( self , datasets ) import json tf_graph_predictions , errors = datasets if self . _output_format = = string ( tf_graph_predictions string beam . io . textio . write_to_text ( os . path . join ( self . _output_dir , string ) , file_name_suffix = string , coder = raw_json_coder ( ) , shard_name_template = self . _shard_name_template ) ) elif self . _output_format = = string	1
Q_0	write csv	C_0_13	def csv_writer ( molecules , options , prefix ) string string string	1
Q_0	write csv	C_0_14	"def to_csv ( self , fbuf , quotechar = string string , string "" , quoting = csv . quote_all ) if self . headers csvwriter . writerow ( self . headers ) for var in self . sylk_handler . stream_rows ( ) csvwriter . writerow ( var )"	1
Q_0	write csv	C_0_15	def write_csv ( filename , t , header = none ) with open ( filename , string ) as fh csv_writer = csv . writer ( fh , delimiter = string ) if header = none csv_writer . writerow ( header ) [ csv_writer . writerow ( t [ var ] ) for var in range ( len ( t ) ) ]	1
Q_0	write csv	C_0_16	def write_to_csv ( self , filename ) string string string fid = open ( filename , string )	1
Q_0	write csv	C_0_17	"def to_csv ( self , fbuf , quotechar = string string , string "" , quoting = csv . quote_all ) if self . headers csvwriter . writerow ( self . headers ) for var in self . sylk_handler . stream_rows ( ) csvwriter . writerow ( var )"	1
Q_0	write csv	C_0_18	def write_to_csv ( self , filename ) string string string fid = open ( filename , string )	1
Q_0	write csv	C_0_19	def csv_writer ( molecules , options , prefix ) string string string	1
Q_0	write csv	C_0_20	def write_csv_header ( mol , csv_writer ) string string string	1
Q_0	write csv	C_0_21	def expand ( self , datasets ) import json tf_graph_predictions , errors = datasets if self . _output_format = = string ( tf_graph_predictions string beam . io . textio . write_to_text ( os . path . join ( self . _output_dir , string ) , file_name_suffix = string , coder = raw_json_coder ( ) , shard_name_template = self . _shard_name_template ) ) elif self . _output_format = = string	0
Q_1	unzip large file	C_1_0	def unzip ( self , in_file , out_file ) with zip_file ( in_file ) as zf zf . extract ( string , path = self . tempdir ) shutil . move ( os . path . join ( self . tempdir , string ) , out_file ) return out_file	1
Q_1	unzip large file	C_1_1	def unzip ( zip_content , dest_dir )	1
Q_1	unzip large file	C_1_2	def unzip_file ( zip_fname ) string string string print ( string . format ( zip_fname ) ) with zipfile . zip_file ( zip_fname ) as zf zf . extractall ( )	1
Q_1	unzip large file	C_1_3	def _unzip_file ( self , src_path , dest_path , filename ) string string string self . logger . info ( string )	1
Q_1	unzip large file	C_1_4	def unzip_file ( zip_fname ) string string string print ( string . format ( zip_fname ) ) with zipfile . zip_file ( zip_fname ) as zf zf . extractall ( )	1
Q_1	unzip large file	C_1_5	def unzip ( zip_content , dest_dir )	1
Q_1	unzip large file	C_1_6	def _unzip_file ( self , src_path , dest_path , filename ) string string string self . logger . info ( string )	1
Q_1	unzip large file	C_1_7	def unzip ( self , in_file , out_file ) with zip_file ( in_file ) as zf zf . extract ( string , path = self . tempdir ) shutil . move ( os . path . join ( self . tempdir , string ) , out_file ) return out_file	1
Q_1	unzip large file	C_1_8	def file_unzipper ( directory ) string string string debug . log ( string directory )	1
Q_1	unzip large file	C_1_9	def _zip_file ( command )	1
Q_1	unzip large file	C_1_10	def testzip ( self ) string string string chunk_size = number * * number for var in self . filelist try	1
Q_1	unzip large file	C_1_11	def unzip_recursive ( zip_file_name ) string string string logger . debug ( string + zip_file_name ) fnlist = unzip_one ( zip_file_name ) for var in fnlist if zipfile . is_zipfile ( var ) local_fnlist = unzip_recursive ( var ) fnlist . extend ( local_fnlist ) return fnlist	1
Q_1	unzip large file	C_1_12	def unzip_unicode ( output , version ) string string string unzipper = zipfile . zip_file ( os . path . join ( output , string , string version ) ) target = os . path . join ( output , string , version ) print ( string version ) os . makedirs ( target ) for var in unzipper . namelist ( )	1
Q_1	unzip large file	C_1_13	def unzip_unicode ( output , version ) string string string unzipper = zipfile . zip_file ( os . path . join ( output , string , string version ) ) target = os . path . join ( output , string , version ) print ( string version ) os . makedirs ( target ) for var in unzipper . namelist ( )	1
Q_1	unzip large file	C_1_14	def unzip_unicode ( output , version ) string string string unzipper = zipfile . zip_file ( os . path . join ( output , string , string version ) ) target = os . path . join ( output , string , version ) print ( string version ) os . makedirs ( target ) for var in unzipper . namelist ( )	1
Q_1	unzip large file	C_1_15	def file_unzipper ( directory ) string string string debug . log ( string directory )	1
Q_1	unzip large file	C_1_16	def file_unzipper ( directory ) string string string debug . log ( string directory )	1
Q_1	unzip large file	C_1_17	def _lfs_add ( files , git ) string string string	1
Q_1	unzip large file	C_1_18	def _lfs_add ( files , git ) string string string	1
Q_1	unzip large file	C_1_19	def _lfs_add ( files , git ) string string string	0
Q_1	unzip large file	C_1_20	def _zip_file ( command )	0
Q_1	unzip large file	C_1_21	def testzip ( self ) string string string chunk_size = number * * number for var in self . filelist try	0
Q_2	unique element	C_2_0	def unique ( list ) string string string unique = [ ] [ unique . append ( var ) for var in list if var not in unique ] return unique	1
Q_2	unique element	C_2_1	def unique_by_index ( sequence ) string string string uniques = [ ] for var in sequence if var not in uniques uniques . append ( var ) return uniques	1
Q_2	unique element	C_2_2	def unique_by_index ( sequence ) string string string uniques = [ ] for var in sequence if var not in uniques uniques . append ( var ) return uniques	1
Q_2	unique element	C_2_3	def unique_list_elements ( x ) unique_elements = [ ] for var in x if var not in unique_elements unique_elements . append ( var ) return unique_elements	1
Q_2	unique element	C_2_4	def unique ( list ) string string string unique = [ ] [ unique . append ( var ) for var in list if var not in unique ] return unique	1
Q_2	unique element	C_2_5	def uniq_stable ( elems ) string string string unique = [ ] unique_dict = { } for var in elems if var not in unique_dict unique . append ( var ) unique_dict [ var ] = none return unique	1
Q_2	unique element	C_2_6	def weld_unique ( array , weld_type ) string string string obj_id , weld_obj = create_weld_object ( array ) weld_template = string string string weld_obj . weld_code = weld_template . format ( array = obj_id , type = weld_type ) return weld_obj	1
Q_2	unique element	C_2_7	def unique_list_elements ( x ) unique_elements = [ ] for var in x if var not in unique_elements unique_elements . append ( var ) return unique_elements	1
Q_2	unique element	C_2_8	def uniq_stable ( elems ) string string string unique = [ ] unique_dict = { } for var in elems if var not in unique_dict unique . append ( var ) unique_dict [ var ] = none return unique	1
Q_2	unique element	C_2_9	def _make_unique ( self ) if not self . unique self . data = uniquer_hashables ( self . data ) self . unique = true	1
Q_2	unique element	C_2_10	def chk_unique ( old , new , ctx )	1
Q_2	unique element	C_2_11	def weld_unique ( array , weld_type ) string string string obj_id , weld_obj = create_weld_object ( array ) weld_template = string string string weld_obj . weld_code = weld_template . format ( array = obj_id , type = weld_type ) return weld_obj	1
Q_2	unique element	C_2_12	def random_elements ( self , elements = ( string , string , string ) , length = none , unique = false ) fn = choices_distribution_unique if unique else choices_distribution if length is none length = self . generator . random . randint ( number , len ( elements ) ) if unique and length > len ( elements ) raise value_error ( string ) if isinstance ( elements , dict ) choices = elements . keys ( ) probabilities = elements . values ( ) else if unique	1
Q_2	unique element	C_2_13	def random_choices ( self , elements = ( string , string , string ) , length = none ) string string { { variable_1 } } string { { variable_2 } } string { { variable_3 } } string { { variable_4 } } string string return self . random_elements ( elements , length , unique = false )	1
Q_2	unique element	C_2_14	def chk_unique ( old , new , ctx )	1
Q_2	unique element	C_2_15	def _make_unique ( self ) if not self . unique self . data = uniquer_hashables ( self . data ) self . unique = true	1
Q_2	unique element	C_2_16	def random_elements ( self , elements = ( string , string , string ) , length = none , unique = false ) fn = choices_distribution_unique if unique else choices_distribution if length is none length = self . generator . random . randint ( number , len ( elements ) ) if unique and length > len ( elements ) raise value_error ( string ) if isinstance ( elements , dict ) choices = elements . keys ( ) probabilities = elements . values ( ) else if unique	1
Q_2	unique element	C_2_17	def union_elements ( elements ) string string to string string if len ( elements ) < number return elements assert set ( [ var [ number ] for var in elements ] ) = = set ( [ elements [ number ] [ number ] ] ) , string el_id = elements [ number ] [ number ] unioned_elements = [ ] for ch , chgrp in groupby ( elements , key = itemgetter ( number ) ) for ( s , var ) in elem_u ( np . array ( [ itemgetter ( number , number ) ( _ ) for _ in chgrp ] , dtype = np . uint ) ) if ( s < var ) unioned_elements . append ( ( ch , s , var , el_id ) ) assert len ( unioned_elements ) < = len ( elements ) return unioned_elements	0
Q_2	unique element	C_2_18	def union_elements ( elements ) string string to string string if len ( elements ) < number return elements assert set ( [ var [ number ] for var in elements ] ) = = set ( [ elements [ number ] [ number ] ] ) , string el_id = elements [ number ] [ number ] unioned_elements = [ ] for ch , chgrp in groupby ( elements , key = itemgetter ( number ) ) for ( s , var ) in elem_u ( np . array ( [ itemgetter ( number , number ) ( _ ) for _ in chgrp ] , dtype = np . uint ) ) if ( s < var ) unioned_elements . append ( ( ch , s , var , el_id ) ) assert len ( unioned_elements ) < = len ( elements ) return unioned_elements	0
Q_2	unique element	C_2_19	def random_choices ( self , elements = ( string , string , string ) , length = none ) string string { { variable_1 } } string { { variable_2 } } string { { variable_3 } } string { { variable_4 } } string string return self . random_elements ( elements , length , unique = false )	0
Q_3	underline text in label widget	C_3_0	def underline ( self , text )	1
Q_3	underline text in label widget	C_3_1	def _underline ( self )	1
Q_3	underline text in label widget	C_3_2	def _underline ( self )	1
Q_3	underline text in label widget	C_3_3	def underline ( self , text )	1
Q_3	underline text in label widget	C_3_4	def set_show_rich_text ( self , state ) string string string self . _show_rich_text = state text = self . text ( ) if state label = self . rich_text_label ( ) label . set_text ( text ) label . show ( ) super ( x_push_button , self ) . set_text ( string ) else if self . _rich_text_label self . _rich_text_label . hide ( ) super ( x_push_button , self ) . set_text ( text )	1
Q_3	underline text in label widget	C_3_5	def _underline ( self )	1
Q_3	underline text in label widget	C_3_6	def _init_ ( self , * args , * * kwargs ) request = kwargs . pop ( string , none ) model = kwargs . pop ( string , none ) super ( widget_form , self ) . _init_ ( * args , * * kwargs ) if isinstance ( model , page ) self . fields [ string ] = page_select_field ( label = _ ( string ) , help_text = _ ( string ) ) else self . fields [ string ] . widget = forms . widgets . hidden_input ( ) initial = kwargs . get ( string , none ) if initial and initial . get ( string , none ) widget = self . _meta . model . objects . get ( id = initial [ string ] ) data = widget . dimensions self . init_content_themes ( ) elif string in kwargs widget = kwargs [ string ] data = widget . dimensions self . init_content_themes ( ) else data = [ ] widget = none	1
Q_3	underline text in label widget	C_3_7	def set_label ( self , label = none ) if label is none self . label . hide ( ) else self . label . set_text ( label ) self . label . show ( )	1
Q_3	underline text in label widget	C_3_8	def create_textedit ( self , text , option , default = no_default , tip = none , restart = false ) label = q_label ( text ) label . set_word_wrap ( true ) edit = q_plain_text_edit ( ) edit . set_word_wrap_mode ( q_text_option . word_wrap ) layout = qv_box_layout ( ) layout . add_widget ( label ) layout . add_widget ( edit ) layout . set_contents_margins ( number , number , number , number ) if tip edit . set_tool_tip ( tip ) self . textedits [ edit ] = ( option , default ) widget = q_widget ( self ) widget . label = label widget . textbox = edit widget . set_layout ( layout ) edit . restart_required = restart edit . label_text = text return widget	1
Q_3	underline text in label widget	C_3_9	def create_label_widget ( self , text = none ) label_widget = label_widget ( self . _ui ) label_widget . text = text return label_widget	1
Q_3	underline text in label widget	C_3_10	def create_label_widget ( self , text = none ) label_widget = label_widget ( self . _ui ) label_widget . text = text return label_widget	1
Q_3	underline text in label widget	C_3_11	def do_td_field ( self , indent , value , * * kwargs ) field_name = kwargs . pop ( string , none ) field = getattr ( self . form , field_name ) obj = self . form . fields [ field_name ] if string in kwargs label = kwargs . pop ( string ) else label = obj . label if label obj . label = label label_text = obj . get_label ( _class = string ) else label_text = string display = field . data or string if string not in kwargs kwargs [ string ] = number td = begin_tag ( string , * * kwargs ) + u_str ( display ) + end_tag ( string ) return indent * string + string ( label_text , td )	1
Q_3	underline text in label widget	C_3_12	def edit_label ( self ) if not self . canvas . editing ( ) return item = self . current_item ( ) if not item return text = self . label_dialog . pop_up ( item . text ( ) ) if text is not none item . set_text ( text ) item . set_background ( generate_color_by_text ( text ) ) self . set_dirty ( )	1
Q_3	underline text in label widget	C_3_13	def do_td_field ( self , indent , value , * * kwargs ) field_name = kwargs . pop ( string , none ) field = getattr ( self . form , field_name ) obj = self . form . fields [ field_name ] if string in kwargs label = kwargs . pop ( string ) else label = obj . label if label obj . label = label label_text = obj . get_label ( _class = string ) else label_text = string display = field . data or string if string not in kwargs kwargs [ string ] = number td = begin_tag ( string , * * kwargs ) + u_str ( display ) + end_tag ( string ) return indent * string + string ( label_text , td )	0
Q_3	underline text in label widget	C_3_14	def set_show_rich_text ( self , state ) string string string self . _show_rich_text = state text = self . text ( ) if state label = self . rich_text_label ( ) label . set_text ( text ) label . show ( ) super ( x_push_button , self ) . set_text ( string ) else if self . _rich_text_label self . _rich_text_label . hide ( ) super ( x_push_button , self ) . set_text ( text )	0
Q_3	underline text in label widget	C_3_15	def _init_ ( self , * args , * * kwargs ) request = kwargs . pop ( string , none ) model = kwargs . pop ( string , none ) super ( widget_form , self ) . _init_ ( * args , * * kwargs ) if isinstance ( model , page ) self . fields [ string ] = page_select_field ( label = _ ( string ) , help_text = _ ( string ) ) else self . fields [ string ] . widget = forms . widgets . hidden_input ( ) initial = kwargs . get ( string , none ) if initial and initial . get ( string , none ) widget = self . _meta . model . objects . get ( id = initial [ string ] ) data = widget . dimensions self . init_content_themes ( ) elif string in kwargs widget = kwargs [ string ] data = widget . dimensions self . init_content_themes ( ) else data = [ ] widget = none	0
Q_3	underline text in label widget	C_3_16	def edit_label ( self ) if not self . canvas . editing ( ) return item = self . current_item ( ) if not item return text = self . label_dialog . pop_up ( item . text ( ) ) if text is not none item . set_text ( text ) item . set_background ( generate_color_by_text ( text ) ) self . set_dirty ( )	0
Q_3	underline text in label widget	C_3_17	def new_shape ( self ) string string string if not self . use_default_label_checkbox . is_checked ( ) or not self . default_label_text_line . text ( ) if len ( self . label_hist ) > number self . label_dialog = label_dialog ( parent = self , list_item = self . label_hist )	0
Q_3	underline text in label widget	C_3_18	def set_label ( self , label = none ) if label is none self . label . hide ( ) else self . label . set_text ( label ) self . label . show ( )	0
Q_3	underline text in label widget	C_3_19	def create_textedit ( self , text , option , default = no_default , tip = none , restart = false ) label = q_label ( text ) label . set_word_wrap ( true ) edit = q_plain_text_edit ( ) edit . set_word_wrap_mode ( q_text_option . word_wrap ) layout = qv_box_layout ( ) layout . add_widget ( label ) layout . add_widget ( edit ) layout . set_contents_margins ( number , number , number , number ) if tip edit . set_tool_tip ( tip ) self . textedits [ edit ] = ( option , default ) widget = q_widget ( self ) widget . label = label widget . textbox = edit widget . set_layout ( layout ) edit . restart_required = restart edit . label_text = text return widget	0
Q_3	underline text in label widget	C_3_20	def new_shape ( self ) string string string if not self . use_default_label_checkbox . is_checked ( ) or not self . default_label_text_line . text ( ) if len ( self . label_hist ) > number self . label_dialog = label_dialog ( parent = self , list_item = self . label_hist )	0
Q_4	string to date	C_4_0	def parse_date ( date_str ) if date_str date = datetime . strptime ( date_str , string ) return date . year , date . month _ number , date . day return string , string , string	1
Q_4	string to date	C_4_1	def _convert_to_timestamp ( self , date , time ) string string string	1
Q_4	string to date	C_4_2	def get_date ( date_string ) d = none try d = datetime . datetime . strptime ( date_string , string ) . date ( ) except d = datetime . datetime . strptime ( date_string , string ) . date ( ) if d return d . strftime ( string ) else return date_string	1
Q_4	string to date	C_4_3	def datetime ( self ) string string string date_string = string ( self . _date , self . _year ) date_string = re . sub ( r string , string , date_string ) return datetime . strptime ( date_string , string )	1
Q_4	string to date	C_4_4	def parse_date ( date_str ) if date_str date = datetime . strptime ( date_str , string ) return date . year , date . month _ number , date . day return string , string , string	1
Q_4	string to date	C_4_5	def datestr2date ( date_str ) string string guessed string string if any ( var not in string for var in date_str ) raise value_error ( string ) if string in date_str try m , d , y = date_str . split ( string ) except raise value_error ( string . format ( date_str , valid_date_formats_text ) ) elif string in date_str try d , m , y = date_str . split ( string ) except raise value_error ( string . format ( date_str , valid_date_formats_text ) ) elif len ( date_str ) = = number or len ( date_str ) = = number d = date_str [ _ number ] m = date_str [ _ number _ number ] y = date_str [ _ number ] else raise value_error ( string . format ( valid_date_formats_text ) ) if len ( y ) = = number year = number + int ( y ) elif len ( y ) = = number year = int ( y ) else raise value_error ( string ) for s in ( m , d ) if number < = len ( s ) < = number month , day = int ( m ) , int ( d ) else raise value_error ( string ) try return datetime . date ( year , month , day ) except value_error raise value_error ( string . format ( date_str , valid_date_formats_text ) )	1
Q_4	string to date	C_4_6	def datetime ( self ) string string string date_string = string ( self . _date , self . _year ) date_string = re . sub ( r string , string , date_string ) return datetime . strptime ( date_string , string )	1
Q_4	string to date	C_4_7	def get_date ( date_string ) d = none try d = datetime . datetime . strptime ( date_string , string ) . date ( ) except d = datetime . datetime . strptime ( date_string , string ) . date ( ) if d return d . strftime ( string ) else return date_string	1
Q_4	string to date	C_4_8	def datetime ( self ) string string string date_string = string ( self . _date , self . _year ) date_string = re . sub ( r string , string , date_string ) return datetime . strptime ( date_string , string )	1
Q_4	string to date	C_4_9	def _convert_to_timestamp ( self , date , time ) string string string	1
Q_4	string to date	C_4_10	def _datetime_from_string ( date_string ) if date_string date_format = string date_string = date_string . replace ( string , string ) date = datetime . strptime ( date_string , date_format ) return pytz . utc . localize ( date ) return string	1
Q_4	string to date	C_4_11	def datestr2date ( date_str ) string string guessed string string if any ( var not in string for var in date_str ) raise value_error ( string ) if string in date_str try m , d , y = date_str . split ( string ) except raise value_error ( string . format ( date_str , valid_date_formats_text ) ) elif string in date_str try d , m , y = date_str . split ( string ) except raise value_error ( string . format ( date_str , valid_date_formats_text ) ) elif len ( date_str ) = = number or len ( date_str ) = = number d = date_str [ _ number ] m = date_str [ _ number _ number ] y = date_str [ _ number ] else raise value_error ( string . format ( valid_date_formats_text ) ) if len ( y ) = = number year = number + int ( y ) elif len ( y ) = = number year = int ( y ) else raise value_error ( string ) for s in ( m , d ) if number < = len ( s ) < = number month , day = int ( m ) , int ( d ) else raise value_error ( string ) try return datetime . date ( year , month , day ) except value_error raise value_error ( string . format ( date_str , valid_date_formats_text ) )	1
Q_4	string to date	C_4_12	def _datetime_from_string ( date_string ) if date_string date_format = string date_string = date_string . replace ( string , string ) date = datetime . strptime ( date_string , date_format ) return pytz . utc . localize ( date ) return string	1
Q_4	string to date	C_4_13	def timestamp_serializer ( self , date ) if not date return string	1
Q_4	string to date	C_4_14	def _str_ ( self ) if self . time is not none date = datetime . datetime . fromtimestamp ( self . time ) if date . date ( ) = = datetime . date . today ( ) string_date = string elif date . date ( ) = = ( datetime . date . today ( ) _ datetime . timedelta ( number ) ) string_date = string elif date . year = = datetime . date . today ( ) . year string_date = date . strftime ( string ) else string_date = date . strftime ( string ) string_time = date . strftime ( string ) string_time = string ( string_date , string_time ) return self . description + string + string_time return self . description	1
Q_4	string to date	C_4_15	def timestamp_serializer ( self , date ) if not date return string	0
Q_4	string to date	C_4_16	def _str_ ( self ) if self . time is not none date = datetime . datetime . fromtimestamp ( self . time ) if date . date ( ) = = datetime . date . today ( ) string_date = string elif date . date ( ) = = ( datetime . date . today ( ) _ datetime . timedelta ( number ) ) string_date = string elif date . year = = datetime . date . today ( ) . year string_date = date . strftime ( string ) else string_date = date . strftime ( string ) string_time = date . strftime ( string ) string_time = string ( string_date , string_time ) return self . description + string + string_time return self . description	0
Q_5	string similarity levenshtein	C_5_0	def levenshtein ( left , right ) string string kitten string sitting string l string r string l string r string d string string sc = spark_context . _active_spark_context jc = sc . _jvm . functions . levenshtein ( _to_java_column ( left ) , _to_java_column ( right ) ) return column ( jc )	1
Q_5	string similarity levenshtein	C_5_1	def levenshtein ( s1 , s2 , allow_substring = false ) string string edit difference string hello string hello there string string len1 , len2 = len ( s1 ) , len ( s2 ) lev = [ ] for var in range ( len1 + number ) lev . append ( [ number ] * ( len2 + number ) ) for var in range ( len1 + number ) lev [ var ] [ number ] = var for j in range ( len2 + number ) lev [ number ] [ j ] = number if allow_substring else j for var in range ( len1 ) for j in range ( len2 ) lev [ var + number ] [ j + number ] = min ( lev [ var ] [ j + number ] + number , lev [ var + number ] [ j ] + number , lev [ var ] [ j ] + ( s1 [ var ] = s2 [ j ] ) ) return min ( lev [ len1 ] ) if allow_substring else lev [ len1 ] [ len2 ]	1
Q_5	string similarity levenshtein	C_5_2	def diff ( s1 , s2 ) string string foo string foo string foo string fooo string foo string string number string number number string string return levenshtein ( s1 , s2 ) / max ( len ( s1 ) , len ( s2 ) )	1
Q_5	string similarity levenshtein	C_5_3	def levenshtein ( str1 , s2 ) string string string n1 = len ( str1 ) n2 = len ( s2 ) string_range = [ range ( n1 + number ) ] * ( n2 + number ) for var in range ( n2 + number ) string_range [ var ] = range ( var , var + n1 + number ) for var in range ( number , n2 ) for j in range ( number , n1 ) if str1 [ j ] = = s2 [ var ] string_range [ var + number ] [ j + number ] = min ( string_range [ var + number ] [ j ] + number , string_range [ var ] [ j + number ] + number , string_range [ var ] [ j ] ) else string_range [ var + number ] [ j + number ] = min ( string_range [ var + number ] [ j ] + number , string_range [ var ] [ j + number ] + number , string_range [ var ] [ j ] + number ) return string_range [ n2 ] [ n1 ]	1
Q_5	string similarity levenshtein	C_5_4	def levenshtein ( left , right ) string string kitten string sitting string l string r string l string r string d string string sc = spark_context . _active_spark_context jc = sc . _jvm . functions . levenshtein ( _to_java_column ( left ) , _to_java_column ( right ) ) return column ( jc )	1
Q_5	string similarity levenshtein	C_5_5	def levenshtein_dist ( s1 str , s2 str ) _ > int if len ( s1 ) < len ( s2 ) return levenshtein_dist ( s2 , s1 )	1
Q_5	string similarity levenshtein	C_5_6	def diff_levenshtein ( self , diffs ) string string string levenshtein = number insertions = number deletions = number for ( op , data ) in diffs if op = = self . diff_insert insertions + = len ( data ) elif op = = self . diff_delete deletions + = len ( data ) elif op = = self . diff_equal	1
Q_5	string similarity levenshtein	C_5_7	def levenshtein ( s1 , s2 , allow_substring = false ) string string edit difference string hello string hello there string string len1 , len2 = len ( s1 ) , len ( s2 ) lev = [ ] for var in range ( len1 + number ) lev . append ( [ number ] * ( len2 + number ) ) for var in range ( len1 + number ) lev [ var ] [ number ] = var for j in range ( len2 + number ) lev [ number ] [ j ] = number if allow_substring else j for var in range ( len1 ) for j in range ( len2 ) lev [ var + number ] [ j + number ] = min ( lev [ var ] [ j + number ] + number , lev [ var + number ] [ j ] + number , lev [ var ] [ j ] + ( s1 [ var ] = s2 [ j ] ) ) return min ( lev [ len1 ] ) if allow_substring else lev [ len1 ] [ len2 ]	1
Q_5	string similarity levenshtein	C_5_8	def levenshtein_distance ( word1 , word2 ) string string binary codes capable of correcting deletions , insertions , and reversals string string if len ( word1 ) < len ( word2 ) return levenshtein_distance ( word2 , word1 ) if len ( word2 ) = = number return len ( word1 ) previous_row = list ( range ( len ( word2 ) + number ) ) for var , var in enumerate ( word1 ) current_row = [ var + number ] for j , char2 in enumerate ( word2 ) insertions = previous_row [ j + number ] + number deletions = current_row [ j ] + number substitutions = previous_row [ j ] + ( var = char2 ) current_row . append ( min ( insertions , deletions , substitutions ) ) previous_row = current_row return previous_row [ _ number ]	1
Q_5	string similarity levenshtein	C_5_9	def levenshtein_dist ( s1 str , s2 str ) _ > int if len ( s1 ) < len ( s2 ) return levenshtein_dist ( s2 , s1 )	1
Q_5	string similarity levenshtein	C_5_10	def levenshtein_dist ( s1 str , s2 str ) _ > int if len ( s1 ) < len ( s2 ) return levenshtein_dist ( s2 , s1 )	1
Q_5	string similarity levenshtein	C_5_11	def levenshtein ( str1 , s2 ) string string string n1 = len ( str1 ) n2 = len ( s2 ) string_range = [ range ( n1 + number ) ] * ( n2 + number ) for var in range ( n2 + number ) string_range [ var ] = range ( var , var + n1 + number ) for var in range ( number , n2 ) for j in range ( number , n1 ) if str1 [ j ] = = s2 [ var ] string_range [ var + number ] [ j + number ] = min ( string_range [ var + number ] [ j ] + number , string_range [ var ] [ j + number ] + number , string_range [ var ] [ j ] ) else string_range [ var + number ] [ j + number ] = min ( string_range [ var + number ] [ j ] + number , string_range [ var ] [ j + number ] + number , string_range [ var ] [ j ] + number ) return string_range [ n2 ] [ n1 ]	1
Q_5	string similarity levenshtein	C_5_12	def diff_levenshtein ( self , diffs ) string string string levenshtein = number insertions = number deletions = number for ( op , data ) in diffs if op = = self . diff_insert insertions + = len ( data ) elif op = = self . diff_delete deletions + = len ( data ) elif op = = self . diff_equal	1
Q_5	string similarity levenshtein	C_5_13	def levenshtein_similarity ( s1 , s2 ) conc = pandas . series ( list ( zip ( s1 , s2 ) ) ) def levenshtein_apply ( x ) try return number _ jellyfish . levenshtein_distance ( x [ number ] , x [ number ] ) / np . max ( [ len ( x [ number ] ) , len ( x [ number ] ) ] ) except exception as err if pandas . isnull ( x [ number ] ) or pandas . isnull ( x [ number ] ) return np . nan else raise err return conc . apply ( levenshtein_apply )	1
Q_5	string similarity levenshtein	C_5_14	def levenshtein_similarity ( s1 , s2 ) conc = pandas . series ( list ( zip ( s1 , s2 ) ) ) def levenshtein_apply ( x ) try return number _ jellyfish . levenshtein_distance ( x [ number ] , x [ number ] ) / np . max ( [ len ( x [ number ] ) , len ( x [ number ] ) ] ) except exception as err if pandas . isnull ( x [ number ] ) or pandas . isnull ( x [ number ] ) return np . nan else raise err return conc . apply ( levenshtein_apply )	1
Q_5	string similarity levenshtein	C_5_15	def diff ( s1 , s2 ) string string foo string foo string foo string fooo string foo string string number string number number string string return levenshtein ( s1 , s2 ) / max ( len ( s1 ) , len ( s2 ) )	1
Q_6	sort multiple array base on another array sort order	C_6_0	def sort_numpy ( array , col = number , order_back = false ) string string string x = array [ , col ] sorted_index = np . argsort ( x , kind = string ) sorted_array = array [ sorted_index ] if not order_back return sorted_array else n_points = sorted_index . shape [ number ] order_back = np . empty ( n_points , dtype = int ) order_back [ sorted_index ] = np . arange ( n_points ) return [ sorted_array , order_back ]	1
Q_6	sort multiple array base on another array sort order	C_6_1	def var ( self , sort_list ) string string string order = [ ] for var in sort_list if sort_list [ var ] = = string order . append ( asc ( getattr ( self . model , var , none ) ) ) elif sort_list [ var ] = = string order . append ( desc ( getattr ( self . model , var , none ) ) ) return order	1
Q_6	sort multiple array base on another array sort order	C_6_2	def sort_numpy ( array , col = number , order_back = false ) string string string x = array [ , col ] sorted_index = np . argsort ( x , kind = string ) sorted_array = array [ sorted_index ] if not order_back return sorted_array else n_points = sorted_index . shape [ number ] order_back = np . empty ( n_points , dtype = int ) order_back [ sorted_index ] = np . arange ( n_points ) return [ sorted_array , order_back ]	1
Q_6	sort multiple array base on another array sort order	C_6_3	def _sort ( group_idx , a , size = none , fill_value = none , dtype = none , reverse = false ) sortidx = np . lexsort ( ( _ a if reverse else a , group_idx ) )	1
Q_6	sort multiple array base on another array sort order	C_6_4	def sort_numpy ( array , col = number , order_back = false ) string string string x = array [ , col ] sorted_index = np . argsort ( x , kind = string ) sorted_array = array [ sorted_index ] if not order_back return sorted_array else n_points = sorted_index . shape [ number ] order_back = np . empty ( n_points , dtype = int ) order_back [ sorted_index ] = np . arange ( n_points ) return [ sorted_array , order_back ]	1
Q_6	sort multiple array base on another array sort order	C_6_5	def multisorter ( * sorts ) def _sort ( aa , bb ) for var in sorts order = var ( aa , bb ) if order = number return order return number return _sort	1
Q_6	sort multiple array base on another array sort order	C_6_6	def _sort ( group_idx , a , size = none , fill_value = none , dtype = none , reverse = false ) sortidx = np . lexsort ( ( _ a if reverse else a , group_idx ) )	1
Q_6	sort multiple array base on another array sort order	C_6_7	def permute_data ( arrays , random_state = none ) string string string if any ( len ( var ) = len ( arrays [ number ] ) for var in arrays ) raise value_error ( string ) if not random_state random_state = np . random order = random_state . permutation ( len ( arrays [ number ] ) ) return [ var [ order ] for var in arrays ]	1
Q_6	sort multiple array base on another array sort order	C_6_8	def permute_data ( arrays , random_state = none ) string string string if any ( len ( var ) = len ( arrays [ number ] ) for var in arrays ) raise value_error ( string ) if not random_state random_state = np . random order = random_state . permutation ( len ( arrays [ number ] ) ) return [ var [ order ] for var in arrays ]	1
Q_6	sort multiple array base on another array sort order	C_6_9	def sort ( this , args )	1
Q_6	sort multiple array base on another array sort order	C_6_10	def _weld_sort ( arrays , weld_types , ascending = true ) obj_id , index_obj = create_weld_object ( arrays [ number ] ) index_obj . weld_code = string . format ( obj_id )	1
Q_6	sort multiple array base on another array sort order	C_6_11	"def from_arrays ( cls , arrays , sortorder = none , names = none ) string string s value for each data point . len ( arrays ) is the number of levels . sortorder int or none level of sortedness ( must be lexicographically sorted by that level ) . names list / sequence of str , optional names for the levels in the index . returns _ index multi_index see also _ multi_index . from_tuples convert list of tuples to multi_index . multi_index . from_product make a multi_index from cartesian product of iterables . multi_index . from_frame make a multi_index from a data_frame . examples _ arrays = [ [ number , number , number , number ] , [ string , string , string , string ] ] pd . multi_index . from_arrays ( arrays , names = ( string , string ) ) multi_index ( levels = [ [ number , number ] , [ string , string ] ] , codes = [ [ number , number , number , number ] , [ number , number , number , number ] ] , names = [ string , string ] ) string string input must be a list / sequence of var _ likes . string all arrays must be same length string name "" , none ) for arr in arrays ] return multi_index ( levels = levels , codes = codes , sortorder = sortorder , names = names , verify_integrity = false )"	1
Q_6	sort multiple array base on another array sort order	C_6_12	"def from_arrays ( cls , arrays , sortorder = none , names = none ) string string s value for each data point . len ( arrays ) is the number of levels . sortorder int or none level of sortedness ( must be lexicographically sorted by that level ) . names list / sequence of str , optional names for the levels in the index . returns _ index multi_index see also _ multi_index . from_tuples convert list of tuples to multi_index . multi_index . from_product make a multi_index from cartesian product of iterables . multi_index . from_frame make a multi_index from a data_frame . examples _ arrays = [ [ number , number , number , number ] , [ string , string , string , string ] ] pd . multi_index . from_arrays ( arrays , names = ( string , string ) ) multi_index ( levels = [ [ number , number ] , [ string , string ] ] , codes = [ [ number , number , number , number ] , [ number , number , number , number ] ] , names = [ string , string ] ) string string input must be a list / sequence of var _ likes . string all arrays must be same length string name "" , none ) for arr in arrays ] return multi_index ( levels = levels , codes = codes , sortorder = sortorder , names = names , verify_integrity = false )"	0
Q_6	sort multiple array base on another array sort order	C_6_13	def var ( self , sort_list ) string string string order = [ ] for var in sort_list if sort_list [ var ] = = string order . append ( asc ( getattr ( self . model , var , none ) ) ) elif sort_list [ var ] = = string order . append ( desc ( getattr ( self . model , var , none ) ) ) return order	0
Q_6	sort multiple array base on another array sort order	C_6_14	def _format_sort ( self , sort , order ) sorting = string if sort self . sort = sort sorting = string + self . sort if order self . order = order else self . order = sorting . order . desc sorting = sorting + string + self . order return sorting	0
Q_6	sort multiple array base on another array sort order	C_6_15	def _format_sort ( self , sort , order ) sorting = string if sort self . sort = sort sorting = string + self . sort if order self . order = order else self . order = sorting . order . desc sorting = sorting + string + self . order return sorting	0
Q_6	sort multiple array base on another array sort order	C_6_16	def multisorter ( * sorts ) def _sort ( aa , bb ) for var in sorts order = var ( aa , bb ) if order = number return order return number return _sort	0
Q_6	sort multiple array base on another array sort order	C_6_17	def _format_sort ( self , sort , order ) sorting = string if sort self . sort = sort sorting = string + self . sort if order self . order = order else self . order = sorting . order . desc sorting = sorting + string + self . order return sorting	0
Q_6	sort multiple array base on another array sort order	C_6_18	def _weld_sort ( arrays , weld_types , ascending = true ) obj_id , index_obj = create_weld_object ( arrays [ number ] ) index_obj . weld_code = string . format ( obj_id )	0
Q_6	sort multiple array base on another array sort order	C_6_19	def _format_sort ( self , sort , order ) sorting = string if sort self . sort = sort sorting = string + self . sort if order self . order = order else self . order = sorting . order . desc sorting = sorting + string + self . order return sorting	0
Q_6	sort multiple array base on another array sort order	C_6_20	def sort ( this , args )	0
Q_6	sort multiple array base on another array sort order	C_6_21	def var ( self , sort_list ) string string string order = [ ] for var in sort_list if sort_list [ var ] = = string order . append ( asc ( getattr ( self . model , var , none ) ) ) elif sort_list [ var ] = = string order . append ( desc ( getattr ( self . model , var , none ) ) ) return order	0
Q_7	sort string list	C_7_0	def list ( self , base , filter = none , type = none , sort = none , limit = none , page = none , format = none )	1
Q_7	sort string list	C_7_1	def _sort ( self , items , sort , language = string , reverse = false ) if sort is none sort = string if sort = = string sort = string items . sort ( key = lambda item item [ sort ] , reverse = reverse ) return items	1
Q_7	sort string list	C_7_2	def var ( self , sort_list ) string string string order = [ ] for var in sort_list if sort_list [ var ] = = string order . append ( asc ( getattr ( self . model , var , none ) ) ) elif sort_list [ var ] = = string order . append ( desc ( getattr ( self . model , var , none ) ) ) return order	1
Q_7	sort string list	C_7_3	def _sort ( self , short_list , sorts ) string string string sort_values = self . _index_columns ( sorts )	1
Q_7	sort string list	C_7_4	def _sort ( self , short_list , sorts ) string string string sort_values = self . _index_columns ( sorts )	1
Q_7	sort string list	C_7_5	def sort ( posts list [ post ] , by str ) _ > list [ post ] by_val = by . replace ( string , string ) . replace ( string , string ) in_dict = ( order_num if by_val in order_num else order_date if by_val in order_date else order_funcs if by_val in order_funcs else none ) if not in_dict raise value_error ( f string string . join ( set ( order_num ) set ( order_date ) set ( order_funcs ) ) ) if in_dict = = order_funcs posts . sort ( key = order_funcs [ by ] , reverse = ( by = string ) ) return posts by_full = by if by . startswith ( string ) or by . startswith ( string ) else f string in_dict [ by ] [ number ] def sort_key ( post post ) _ > int key = in_dict [ by_val ] [ number ] key = post . info [ key ] if not callable ( key ) else key ( post . info ) return pend . parse ( key ) if in_dict = = order_date else key posts . sort ( key = sort_key , reverse = by_full . startswith ( string ) ) return posts	1
Q_7	sort string list	C_7_6	def _sort ( self , items , sort , language = string , reverse = false ) if sort is none sort = string if sort = = string sort = string items . sort ( key = lambda item item [ sort ] , reverse = reverse ) return items	1
Q_7	sort string list	C_7_7	def sort ( self , ids ) string string string def extract_int ( string ) string string string return int ( re . sub ( r string , string , string ) ) tmp = list ( ids ) if self . algorithm = = id_sorting_algorithm . unsorted self . log ( u string ) elif self . algorithm = = id_sorting_algorithm . lexicographic self . log ( u string ) tmp = sorted ( ids ) elif self . algorithm = = id_sorting_algorithm . numeric self . log ( u string ) tmp = ids try tmp = sorted ( tmp , key = extract_int ) except ( value_error , type_error ) as exc self . log_exc ( u string , exc , false , none ) return tmp	1
Q_7	sort string list	C_7_8	def _sort ( self , items , sort , language = string , reverse = false ) if sort is none sort = string if sort = = string sort = string items . sort ( key = lambda item item [ sort ] , reverse = reverse ) return items	1
Q_7	sort string list	C_7_9	def sort ( self , ids ) string string string def extract_int ( string ) string string string return int ( re . sub ( r string , string , string ) ) tmp = list ( ids ) if self . algorithm = = id_sorting_algorithm . unsorted self . log ( u string ) elif self . algorithm = = id_sorting_algorithm . lexicographic self . log ( u string ) tmp = sorted ( ids ) elif self . algorithm = = id_sorting_algorithm . numeric self . log ( u string ) tmp = ids try tmp = sorted ( tmp , key = extract_int ) except ( value_error , type_error ) as exc self . log_exc ( u string , exc , false , none ) return tmp	1
Q_7	sort string list	C_7_10	def sort ( posts list [ post ] , by str ) _ > list [ post ] by_val = by . replace ( string , string ) . replace ( string , string ) in_dict = ( order_num if by_val in order_num else order_date if by_val in order_date else order_funcs if by_val in order_funcs else none ) if not in_dict raise value_error ( f string string . join ( set ( order_num ) set ( order_date ) set ( order_funcs ) ) ) if in_dict = = order_funcs posts . sort ( key = order_funcs [ by ] , reverse = ( by = string ) ) return posts by_full = by if by . startswith ( string ) or by . startswith ( string ) else f string in_dict [ by ] [ number ] def sort_key ( post post ) _ > int key = in_dict [ by_val ] [ number ] key = post . info [ key ] if not callable ( key ) else key ( post . info ) return pend . parse ( key ) if in_dict = = order_date else key posts . sort ( key = sort_key , reverse = by_full . startswith ( string ) ) return posts	1
Q_7	sort string list	C_7_11	def _sort ( self , items , sort , language = string , reverse = false ) if sort is none sort = string if sort = = string sort = string items . sort ( key = lambda item item [ sort ] , reverse = reverse ) return items	1
Q_7	sort string list	C_7_12	def get_sort_string ( self , sort = none ) if not sort sort = self . sort sort_string = string if not sort = = self . default_sort sort_string = self . sort_parameter + string + sort return sort_string	0
Q_7	sort string list	C_7_13	def get_sort_string ( self , sort = none ) if not sort sort = self . sort sort_string = string if not sort = = self . default_sort sort_string = self . sort_parameter + string + sort return sort_string	0
Q_7	sort string list	C_7_14	def model_to_dict ( model , sort = false ) string string genes string compartments string id string metabolites string notes string reactions string metabolites string genes string metabolites string string obj = ordered_dict ( ) obj [ string ] = list ( map ( metabolite_to_dict , model . metabolites ) ) obj [ string ] = list ( map ( reaction_to_dict , model . reactions ) ) obj [ string ] = list ( map ( gene_to_dict , model . genes ) ) obj [ string ] = model . id _update_optional ( model , obj , _optional_model_attributes , _ordered_optional_model_keys ) if sort get_id = itemgetter ( string ) obj [ string ] . sort ( key = get_id ) obj [ string ] . sort ( key = get_id ) obj [ string ] . sort ( key = get_id ) return obj	0
Q_7	sort string list	C_7_15	def var ( self , sort_list ) string string string order = [ ] for var in sort_list if sort_list [ var ] = = string order . append ( asc ( getattr ( self . model , var , none ) ) ) elif sort_list [ var ] = = string order . append ( desc ( getattr ( self . model , var , none ) ) ) return order	0
Q_7	sort string list	C_7_16	def model_to_dict ( model , sort = false ) string string genes string compartments string id string metabolites string notes string reactions string metabolites string genes string metabolites string string obj = ordered_dict ( ) obj [ string ] = list ( map ( metabolite_to_dict , model . metabolites ) ) obj [ string ] = list ( map ( reaction_to_dict , model . reactions ) ) obj [ string ] = list ( map ( gene_to_dict , model . genes ) ) obj [ string ] = model . id _update_optional ( model , obj , _optional_model_attributes , _ordered_optional_model_keys ) if sort get_id = itemgetter ( string ) obj [ string ] . sort ( key = get_id ) obj [ string ] . sort ( key = get_id ) obj [ string ] . sort ( key = get_id ) return obj	0
Q_8	socket recv timeout	C_8_0	def recvall ( self , timeout = number . number ) string string string response = string self . socket . setblocking ( false ) start = time . time ( ) while true if response and time . time ( ) _ start > timeout break elif time . time ( ) _ start > timeout * number break try data = self . socket . recv ( number ) if data response + = data . replace ( self . _rconreplystring , string ) start = time . time ( ) else time . sleep ( number . number ) except socket . error pass return response . strip ( )	1
Q_8	socket recv timeout	C_8_1	def recv_with_timeout ( self , timeout = number ) string string t block and returns the first frame in the receive buffer or none if there isn string string msg = self . ins . recv ( timeout ) t = time . time ( ) if msg is none raise scapy_exception ( string ) return self . basecls , msg , t	1
Q_8	socket recv timeout	C_8_2	def recv ( self , recv_socket , llc ) time . sleep ( number . number )	1
Q_8	socket recv timeout	C_8_3	def recv ( self ) try msg_bytes = self . c . recv ( ) except socket . timeout	1
Q_8	socket recv timeout	C_8_4	def recv ( self , amt , flags = number ) if select . select ( [ self . sock ] , [ ] , [ ] , self . timeout ) [ number ] return self . sock . recv ( amt , flags ) raise timeout_error ( string )	1
Q_8	socket recv timeout	C_8_5	def recv_response ( socket , acceptable_length , timeout ) if socket . poll ( string , timeout ) snep_response = socket . recv ( ) if len ( snep_response ) < number log . debug ( string ) return none version , status , length = struct . unpack ( string , snep_response [ number ] ) if length > acceptable_length log . debug ( string ) return none if len ( snep_response ) _ number < length	1
Q_8	socket recv timeout	C_8_6	def recv_response ( socket , acceptable_length , timeout ) if socket . poll ( string , timeout ) snep_response = socket . recv ( ) if len ( snep_response ) < number log . debug ( string ) return none version , status , length = struct . unpack ( string , snep_response [ number ] ) if length > acceptable_length log . debug ( string ) return none if len ( snep_response ) _ number < length	1
Q_8	socket recv timeout	C_8_7	def _set_socket_timeouts ( self ) string string string	1
Q_8	socket recv timeout	C_8_8	def _set_socket_timeouts ( self ) string string string	1
Q_8	socket recv timeout	C_8_9	def recv ( self ) try msg_bytes = self . c . recv ( ) except socket . timeout	1
Q_8	socket recv timeout	C_8_10	def recv_with_timeout ( self , timeout = number ) string string t block and returns the first frame in the receive buffer or none if there isn string string msg = self . ins . recv ( timeout ) t = time . time ( ) if msg is none raise scapy_exception ( string ) return self . basecls , msg , t	1
Q_8	socket recv timeout	C_8_11	def recv_raw ( self , timeout , opcodes , * * kwargs ) string string string orig_timeout = self . get_timeout ( timeout ) timeout = orig_timeout while timeout > number . number start = time . time ( ) if not self . connected self . connect ( timeout = timeout , * * kwargs ) with self . wstimeout ( timeout , * * kwargs ) as timeout logger . debug ( string . format ( self . client_id , timeout ) ) try opcode , data = self . ws . recv_data ( ) if opcode in opcodes timeout = number . number break else if opcode = = websocket . abnf . opcode_close raise websocket . web_socket_connection_closed_exception ( ) except websocket . web_socket_timeout_exception pass except websocket . web_socket_connection_closed_exception	1
Q_8	socket recv timeout	C_8_12	"def recvfrom ( self , bufsize , flags = number ) string string t necessarily a number _ number connection . note this method will block until data is available to be read param bufsize the maximum number of bytes to receive . fewer may be returned , however type bufsize int param flags flags for the receive call . consult the unix manpage for recv ( number ) for what flags are available type flags int returns a two _ tuple of ( data , address ) _ the string data received and the address from which it was received string string re string bad file descriptor string timed out string interrupted system call "" )"	1
Q_8	socket recv timeout	C_8_13	def recv_raw ( self , timeout , opcodes , * * kwargs ) string string string orig_timeout = self . get_timeout ( timeout ) timeout = orig_timeout while timeout > number . number start = time . time ( ) if not self . connected self . connect ( timeout = timeout , * * kwargs ) with self . wstimeout ( timeout , * * kwargs ) as timeout logger . debug ( string . format ( self . client_id , timeout ) ) try opcode , data = self . ws . recv_data ( ) if opcode in opcodes timeout = number . number break else if opcode = = websocket . abnf . opcode_close raise websocket . web_socket_connection_closed_exception ( ) except websocket . web_socket_timeout_exception pass except websocket . web_socket_connection_closed_exception	1
Q_8	socket recv timeout	C_8_14	"def recvfrom ( self , bufsize , flags = number ) string string t necessarily a number _ number connection . note this method will block until data is available to be read param bufsize the maximum number of bytes to receive . fewer may be returned , however type bufsize int param flags flags for the receive call . consult the unix manpage for recv ( number ) for what flags are available type flags int returns a two _ tuple of ( data , address ) _ the string data received and the address from which it was received string string re string bad file descriptor string timed out string interrupted system call "" )"	1
Q_8	socket recv timeout	C_8_15	def recv_response ( socket , acceptable_length , timeout ) if socket . poll ( string , timeout ) snep_response = socket . recv ( ) if len ( snep_response ) < number log . debug ( string ) return none version , status , length = struct . unpack ( string , snep_response [ number ] ) if length > acceptable_length log . debug ( string ) return none if len ( snep_response ) _ number < length	1
Q_8	socket recv timeout	C_8_16	def recv ( self , recv_socket , llc ) time . sleep ( number . number )	1
Q_9	set work directory	C_9_0	def set_working_dir ( self , working_dir ) string string string	1
Q_9	set work directory	C_9_1	def change_to_workdir ( self ) string string string logger . info ( string , self . workdir ) self . check_dir ( self . workdir ) try os . chdir ( self . workdir ) except os_error as exp self . exit_on_error ( string string string ( self . workdir , str ( exp ) , self . workdir , self . user , self . group ) , exit_code = number ) self . pre_log . append ( ( string , string os . path . abspath ( self . workdir ) ) )	1
Q_9	set work directory	C_9_2	def set_working_directory ( self , dirname ) string string string if dirname self . main . workingdirectory . chdir ( dirname , refresh_explorer = true , refresh_console = false )	1
Q_9	set work directory	C_9_3	def set_workdir ( self , workdir , chroot = false ) string string string super ( ) . set_workdir ( workdir , chroot = chroot )	1
Q_9	set work directory	C_9_4	def _set_workdir ( self ) string string string fname = self . get_current_filename ( ) if fname is not none directory = osp . dirname ( osp . abspath ( fname ) ) self . open_dir . emit ( directory )	1
Q_9	set work directory	C_9_5	def _set_working_dir ( self , path ) string string string self . _curr_working_dir = path try mkdir ( self . working_dir ) except os_error	1
Q_9	set work directory	C_9_6	def _set_workdir ( self ) string string string fname = self . get_current_filename ( ) if fname is not none directory = osp . dirname ( osp . abspath ( fname ) ) self . open_dir . emit ( directory )	1
Q_9	set work directory	C_9_7	def register_work ( self , work , deps = none , manager = none , workdir = none ) string string string if getattr ( self , string , none ) is not none	1
Q_9	set work directory	C_9_8	def set_working_directory ( self , dirname ) string string string if dirname self . main . workingdirectory . chdir ( dirname , refresh_explorer = true , refresh_console = false )	1
Q_9	set work directory	C_9_9	def set_workdir ( self , workdir , chroot = false ) string string string if not chroot and hasattr ( self , string ) and self . workdir = workdir raise value_error ( string ( self . workdir , workdir ) )	1
Q_9	set work directory	C_9_10	def set_workdir ( self , workdir , chroot = false ) string string string super ( ) . set_workdir ( workdir , chroot = chroot )	1
Q_9	set work directory	C_9_11	def set_workdir ( self , workdir , chroot = false ) string string string super ( ) . set_workdir ( workdir , chroot = chroot )	1
Q_9	set work directory	C_9_12	def change_to_workdir ( self ) string string string logger . info ( string , self . workdir ) self . check_dir ( self . workdir ) try os . chdir ( self . workdir ) except os_error as exp self . exit_on_error ( string string string ( self . workdir , str ( exp ) , self . workdir , self . user , self . group ) , exit_code = number ) self . pre_log . append ( ( string , string os . path . abspath ( self . workdir ) ) )	1
Q_9	set work directory	C_9_13	def set_workdir ( self , workdir , chroot = false ) string string string if not chroot and hasattr ( self , string ) and self . workdir = workdir raise value_error ( string ( self . workdir , workdir ) )	1
Q_9	set work directory	C_9_14	def _set_working_dir ( self , path ) string string string self . _curr_working_dir = path try mkdir ( self . working_dir ) except os_error	1
Q_9	set work directory	C_9_15	def set_working_directory ( self , dirname ) string string string if dirname self . main . workingdirectory . chdir ( dirname , refresh_explorer = true , refresh_console = false )	1
Q_9	set work directory	C_9_16	def set_working_directory ( self , dirname ) string string string if dirname self . main . workingdirectory . chdir ( dirname , refresh_explorer = true , refresh_console = false )	1
Q_9	set work directory	C_9_17	def do_set_workdir ( self , args ) string string string params = args . split ( ) workdir = none try workdir = params [ number ] except index_error _logging . error ( string ) self . do_help ( string ) if workdir self . tools . workdir = workdir	1
Q_9	set work directory	C_9_18	def set_workdir ( self , workdir , chroot = false ) string string string super ( ) . set_workdir ( workdir , chroot = chroot )	1
Q_9	set work directory	C_9_19	def register_work ( self , work , deps = none , manager = none , workdir = none ) string string string if getattr ( self , string , none ) is not none	0
Q_9	set work directory	C_9_20	def update_context ( self ) string string t exist then the working directory of attr context is cleared . this avoids external commands from failing due to an invalid ( non existing ) working directory . string string directory string s working directory . self . context . options . pop ( string , none )	0
Q_9	set work directory	C_9_21	def set_working_dir ( self , working_dir ) string string string	0
Q_9	set work directory	C_9_22	def do_set_workdir ( self , args ) string string string params = args . split ( ) workdir = none try workdir = params [ number ] except index_error _logging . error ( string ) self . do_help ( string ) if workdir self . tools . workdir = workdir	0
Q_9	set work directory	C_9_23	def _set_workdir ( self ) string string string fname = self . get_current_filename ( ) if fname is not none directory = osp . dirname ( osp . abspath ( fname ) ) self . open_dir . emit ( directory )	0
Q_9	set work directory	C_9_24	def set_workdir ( self , workdir , chroot = false ) string string string if not chroot and hasattr ( self , string ) and self . workdir = workdir raise value_error ( string ( self . workdir , workdir ) )	0
Q_9	set work directory	C_9_25	def do_set_workdir ( self , args ) string string string params = args . split ( ) workdir = none try workdir = params [ number ] except index_error _logging . error ( string ) self . do_help ( string ) if workdir self . tools . workdir = workdir	0
Q_9	set work directory	C_9_26	def update_context ( self ) string string t exist then the working directory of attr context is cleared . this avoids external commands from failing due to an invalid ( non existing ) working directory . string string directory string s working directory . self . context . options . pop ( string , none )	0
Q_10	set file attrib hide	C_10_0	def sub_el ( parent , tag , attrib = none ) attrib = attrib or { } tag = get_nstag ( tag ) attrib = update_attrib ( attrib ) el = et . sub_element ( parent , tag , attrib )	1
Q_10	set file attrib hide	C_10_1	def set_file ( self , file = none , is_modified = false , is_untitled = false ) string string string logger . debug ( string { number } string . format ( file ) ) self . _file = file self . _is_untitled = is_untitled self . set_modified ( is_modified ) self . set_title ( ) return true	1
Q_10	set file attrib hide	C_10_2	def _assert_tag_and_attributes_are_equal ( xml1 , xml2 , can_extend = false ) if xml1 . tag = xml2 . tag raise assertion_error ( u string . format ( tag1 = _describe_element ( xml1 ) , tag2 = _describe_element ( xml2 ) ) ) added_attributes = set ( xml2 . var ) . difference ( xml1 . var ) missing_attributes = set ( xml1 . var ) . difference ( xml2 . var ) if missing_attributes raise assertion_error ( u string . format ( path = _describe_element ( xml2 ) , attributes = string . join ( missing_attributes ) ) ) if not can_extend and added_attributes raise assertion_error ( u string . format ( path = _describe_element ( xml2 ) , attributes = string . join ( added_attributes ) ) ) for var in xml1 . var if not _xml_compare_text ( xml1 . var [ var ] , xml2 . var [ var ] , false ) raise assertion_error ( u string { v1 } string { v2 } string . format ( path = _describe_element ( xml1 ) , attribute = var , v1 = xml1 . var [ var ] , v2 = xml2 . var [ var ] ) ) if not _xml_compare_text ( xml1 . text , xml2 . text , true ) raise assertion_error ( u string { t1 } string { t2 } string . format ( path = _describe_element ( xml1 ) , t1 = xml1 . text , t2 = xml2 . text ) ) if not _xml_compare_text ( xml1 . tail , xml2 . tail , true ) raise assertion_error ( u string { t1 } string { t2 } string . format ( path = _describe_element ( xml1 ) , t1 = xml1 . tail , t2 = xml2 . tail ) )	1
Q_10	set file attrib hide	C_10_3	def xml ( self ) element = element_tree . element ( self . tagname ) for var in self . nodes element . append ( var . xml ( ) ) for attr in self . attributes attrib = getattr ( self , attr , none ) if attrib is not none if isinstance ( attrib , bool ) attrib = str ( attrib ) . lower ( ) elif isinstance ( attrib , int )	1
Q_10	set file attrib hide	C_10_4	def continuation ( self , regexp , txt ) txt_ = self . txt_list . body . pop ( ) . get_text ( ) self . txt_list . body . append ( console_text ( ( txt_ [ number ] [ number ] [ number ] , txt_ [ number ] + regexp . groups ( ) [ number ] ) ) ) pos = len ( self . txt_list . body ) _ number self . txt_list . set_focus ( pos ) return false	0
Q_10	set file attrib hide	C_10_5	def bsecurate_cli_handle_subcmd ( args ) handler_map = { string _bsecurate_cli_get_reader_formats , string _bsecurate_cli_elements_in_files , string _bsecurate_cli_component_file_refs , string _bsecurate_cli_print_component_file , string _bsecurate_cli_compare_basis_sets , string _bsecurate_cli_compare_basis_files , string _bsecurate_cli_make_diff , string _bsecurate_cli_view_graph , string _bsecurate_cli_make_graph_file } return handler_map [ args . subcmd ] ( args )	0
Q_10	set file attrib hide	C_10_6	def xml ( self ) element = element_tree . element ( self . tagname ) for var in self . nodes element . append ( var . xml ( ) ) for attr in self . attributes attrib = getattr ( self , attr , none ) if attrib is not none if isinstance ( attrib , bool ) attrib = str ( attrib ) . lower ( ) elif isinstance ( attrib , int )	0
Q_10	set file attrib hide	C_10_7	def _traceback_to_tree ( self , failure ) backtrace = et . element ( string ) frames = failure . stack + failure . frames for function_name , filename , line_number , localz , globalz in frames attrib = { string filename , string str ( line_number ) , string string ( function_name , linecache . getline ( filename , line_number ) . strip ( ) ) } backtrace . append ( et . element ( string , attrib = attrib ) ) return backtrace	0
Q_10	set file attrib hide	C_10_8	def sub_el ( parent , tag , attrib = none ) attrib = attrib or { } tag = get_nstag ( tag ) attrib = update_attrib ( attrib ) el = et . sub_element ( parent , tag , attrib )	0
Q_10	set file attrib hide	C_10_9	def set_file ( self , file = none , is_modified = false , is_untitled = false ) string string string logger . debug ( string { number } string . format ( file ) ) self . _file = file self . _is_untitled = is_untitled self . set_modified ( is_modified ) self . set_title ( ) return true	0
Q_10	set file attrib hide	C_10_10	def continuation ( self , regexp , txt ) txt_ = self . txt_list . body . pop ( ) . get_text ( ) self . txt_list . body . append ( console_text ( ( txt_ [ number ] [ number ] [ number ] , txt_ [ number ] + regexp . groups ( ) [ number ] ) ) ) pos = len ( self . txt_list . body ) _ number self . txt_list . set_focus ( pos ) return false	0
Q_10	set file attrib hide	C_10_11	def set_undo_redo ( self ) f = file_manager ( ) . current_file ( ) self . parent . toolbar . enable_tool ( wx . id_undo , f . undo ) self . parent . menu . enable ( wx . id_undo , f . undo )	0
Q_10	set file attrib hide	C_10_12	def bsecurate_cli_handle_subcmd ( args ) handler_map = { string _bsecurate_cli_get_reader_formats , string _bsecurate_cli_elements_in_files , string _bsecurate_cli_component_file_refs , string _bsecurate_cli_print_component_file , string _bsecurate_cli_compare_basis_sets , string _bsecurate_cli_compare_basis_files , string _bsecurate_cli_make_diff , string _bsecurate_cli_view_graph , string _bsecurate_cli_make_graph_file } return handler_map [ args . subcmd ] ( args )	0
Q_10	set file attrib hide	C_10_13	def parse_arguments ( argv ) string string string parser = datalab_parser ( epilog = ( string string ) , datalab_epilog = ( string string string ) )	0
Q_10	set file attrib hide	C_10_14	def set_undo_redo ( self ) f = file_manager ( ) . current_file ( ) self . parent . toolbar . enable_tool ( wx . id_undo , f . undo ) self . parent . menu . enable ( wx . id_undo , f . undo )	0
Q_10	set file attrib hide	C_10_15	def _assert_tag_and_attributes_are_equal ( xml1 , xml2 , can_extend = false ) if xml1 . tag = xml2 . tag raise assertion_error ( u string . format ( tag1 = _describe_element ( xml1 ) , tag2 = _describe_element ( xml2 ) ) ) added_attributes = set ( xml2 . var ) . difference ( xml1 . var ) missing_attributes = set ( xml1 . var ) . difference ( xml2 . var ) if missing_attributes raise assertion_error ( u string . format ( path = _describe_element ( xml2 ) , attributes = string . join ( missing_attributes ) ) ) if not can_extend and added_attributes raise assertion_error ( u string . format ( path = _describe_element ( xml2 ) , attributes = string . join ( added_attributes ) ) ) for var in xml1 . var if not _xml_compare_text ( xml1 . var [ var ] , xml2 . var [ var ] , false ) raise assertion_error ( u string { v1 } string { v2 } string . format ( path = _describe_element ( xml1 ) , attribute = var , v1 = xml1 . var [ var ] , v2 = xml2 . var [ var ] ) ) if not _xml_compare_text ( xml1 . text , xml2 . text , true ) raise assertion_error ( u string { t1 } string { t2 } string . format ( path = _describe_element ( xml1 ) , t1 = xml1 . text , t2 = xml2 . text ) ) if not _xml_compare_text ( xml1 . tail , xml2 . tail , true ) raise assertion_error ( u string { t1 } string { t2 } string . format ( path = _describe_element ( xml1 ) , t1 = xml1 . tail , t2 = xml2 . tail ) )	0
Q_10	set file attrib hide	C_10_16	def parse_arguments ( argv ) string string string parser = datalab_parser ( epilog = ( string string ) , datalab_epilog = ( string string string ) )	0
Q_11	send binary data over a serial connection	C_11_0	def write ( self , data ) string string string try	1
Q_11	send binary data over a serial connection	C_11_1	def send ( self , msg ) string string string	1
Q_11	send binary data over a serial connection	C_11_2	def send ( self , msg ) string string string	1
Q_11	send binary data over a serial connection	C_11_3	def serial_send ( msvr , msvr_ip , xsvr , xsvr_ip , node_sn , node_key , port )	1
Q_11	send binary data over a serial connection	C_11_4	def read ( self , size ) string string string data = self . serial_h . read ( size ) self . logger . debug ( string + str ( len ( data ) ) + string + binascii . b2a_hex ( data ) . decode ( string ) ) self . serial_h . write ( ack ) if sys . version_info [ number ] = = number data = bytearray ( data ) return data	1
Q_11	send binary data over a serial connection	C_11_5	def serial_send ( msvr , msvr_ip , xsvr , xsvr_ip , node_sn , node_key , port )	1
Q_11	send binary data over a serial connection	C_11_6	def serial_connect ( self ) string string string self . serial_get ( ) try self . serial_connection . start ( ) except c1218 . errors . c1218_io_error as error self . logger . error ( string ) raise error self . _serial_connected = true return true	1
Q_11	send binary data over a serial connection	C_11_7	def load_device ( self , serial = none ) string string adb devices string string serials = android_device . list_adb_devices ( ) if not serials raise error ( string )	1
Q_11	send binary data over a serial connection	C_11_8	def _send_binary_data ( port , data ) string string string _reset ( port ) time . sleep ( lead_in_out_delay ) for digit in data _send_bit ( port , digit ) time . sleep ( lead_in_out_delay )	1
Q_11	send binary data over a serial connection	C_11_9	def parse_sgtin_96 ( sgtin_96 ) string string string if not sgtin_96 raise exception ( string ) if not sgtin_96 . startswith ( string )	1
Q_11	send binary data over a serial connection	C_11_10	def data_to_binary ( self ) string string string return bytes ( [ command_code , self . channels_to_byte ( [ self . channel ] ) , self . disable_inhibit_forced , self . status , self . led_status ] ) + struct . pack ( string , self . delay_time ) [ _ number ]	1
Q_11	send binary data over a serial connection	C_11_11	def data_to_binary ( self ) string string string return chr ( command_code ) + chr ( self . module_type ) + struct . pack ( string , self . current_serial ) [ number ] + chr ( self . module_address ) + struct . pack ( string , self . new_serial ) [ number ]	1
Q_11	send binary data over a serial connection	C_11_12	def _send_binary_data ( port , data ) string string string _reset ( port ) time . sleep ( lead_in_out_delay ) for digit in data _send_bit ( port , digit ) time . sleep ( lead_in_out_delay )	1
Q_11	send binary data over a serial connection	C_11_13	def data_to_binary ( self ) string string string return chr ( command_code ) + chr ( self . module_type ) + struct . pack ( string , self . current_serial ) [ number ] + chr ( self . module_address ) + struct . pack ( string , self . new_serial ) [ number ]	1
Q_11	send binary data over a serial connection	C_11_14	def data_to_binary ( self ) string string string return bytes ( [ command_code , self . channels_to_byte ( [ self . channel ] ) , self . disable_inhibit_forced , self . status , self . led_status ] ) + struct . pack ( string , self . delay_time ) [ _ number ]	1
Q_11	send binary data over a serial connection	C_11_15	def write ( self , data ) string string string try	1
Q_11	send binary data over a serial connection	C_11_16	def read ( self , size ) string string string data = self . serial_h . read ( size ) self . logger . debug ( string + str ( len ( data ) ) + string + binascii . b2a_hex ( data ) . decode ( string ) ) self . serial_h . write ( ack ) if sys . version_info [ number ] = = number data = bytearray ( data ) return data	1
Q_11	send binary data over a serial connection	C_11_17	def load_device ( self , serial = none ) string string adb devices string string serials = android_device . list_adb_devices ( ) if not serials raise error ( string )	0
Q_11	send binary data over a serial connection	C_11_18	def data_to_binary ( self ) string string string return bytes ( [ command_code , self . channels_to_byte ( [ self . channel ] ) , self . disable_inhibit_forced , self . status , self . led_status ] ) + struct . pack ( string , self . delay_time ) [ _ number ]	0
Q_11	send binary data over a serial connection	C_11_19	def parse_sgtin_96 ( sgtin_96 ) string string string if not sgtin_96 raise exception ( string ) if not sgtin_96 . startswith ( string )	0
Q_12	scatter plot	C_12_0	"def scatter_plot ( self , ax , topic_dims , t = none , ms_limits = true , * * kwargs_plot ) string string s plot function , e . g . the style of the plotted points string param bool ms_limits if set to true , automatically set axes boundaries to the sensorimotor boundaries ( default true ) string string marker string o string linestyle string none string inf "" )"	1
Q_12	scatter plot	C_12_1	def plot ( self , sizescale = number , color = none , alpha = number . number , label = none , edgecolor = string , * * kw ) string string string	1
Q_12	scatter plot	C_12_2	def scatter ( x , y , * * kwargs ) string string x string x string x string x string string kwargs [ string ] = x kwargs [ string ] = y return _draw_mark ( scatter , * * kwargs )	1
Q_12	scatter plot	C_12_3	def sentiment_scatter ( sms = sms ) plt . figure ( figsize = ( number , number . number ) ) ax = plt . subplot ( number , number , number ) ax = sms . plot . scatter ( x = string , y = string , ax = ax , color = string , marker = string , alpha = . number ) ax = sms . plot . scatter ( x = string , y = string , ax = ax , color = string , marker = string , alpha = . number ) ax = sms . plot . scatter ( x = string , y = string , ax = ax , color = string , marker = string , alpha = . number ) ax = sms . plot . scatter ( x = string , y = string , ax = ax , color = string , marker = string , alpha = . number ) ax = sms . plot . scatter ( x = string , y = string , ax = ax , color = string , marker = string , alpha = . number ) plt . ylabel ( string ) plt . xlabel ( string ) plt . legend ( [ string , string , string , string , string ] ) plt . tight_layout ( ) plt . show ( )	1
Q_12	scatter plot	C_12_4	def scatter ( x , y , z , color = ( number , number , number ) , s = number . number number ) global _last_figure fig = _last_figure if fig is none fig = volshow ( none ) fig . scatter = scatter ( x = x , y = y , z = z , color = color , size = s ) fig . volume . scatter = fig . scatter return fig	1
Q_12	scatter plot	C_12_5	def scatter ( self , ax , x , y , z = none , color = tango . colors_hex [ string ] , label = none , marker = string , * * kwargs ) if z is not none return ax . scatter ( x , y , c = color , zs = z , label = label , marker = marker , * * kwargs ) return ax . scatter ( x , y , c = color , label = label , marker = marker , * * kwargs )	1
Q_12	scatter plot	C_12_6	def scatter ( adata , x = none , y = none , color = none , use_raw = none , layers = string , sort_order = true , alpha = none , basis = none , groups = none , components = none , projection = string , legend_loc = string , legend_fontsize = none , legend_fontweight = none , color_map = none , palette = none , frameon = none , right_margin = none , left_margin = none , size = none , title = none , show = none , save = none , ax = none ) string string ann1 string ann1 string ann2 string pca string tsne string umap string diffmap string draw_graph_fr string string if basis is not none axs = _scatter_obs ( adata = adata , x = x , y = y , color = color , use_raw = use_raw , layers = layers , sort_order = sort_order , alpha = alpha , basis = basis , groups = groups , components = components , projection = projection , legend_loc = legend_loc , legend_fontsize = legend_fontsize , legend_fontweight = legend_fontweight , color_map = color_map , palette = palette , frameon = frameon , right_margin = right_margin , left_margin = left_margin , size = size , title = title , show = show , save = save , ax = ax ) elif x is not none and y is not none if ( ( x in adata . obs . keys ( ) or x in adata . var . index ) and ( y in adata . obs . keys ( ) or y in adata . var . index ) and ( color is none or color in adata . obs . keys ( ) or color in adata . var . index ) ) axs = _scatter_obs ( adata = adata , x = x , y = y , color = color , use_raw = use_raw , layers = layers , sort_order = sort_order , alpha = alpha , basis = basis , groups = groups , components = components , projection = projection , legend_loc = legend_loc , legend_fontsize = legend_fontsize , legend_fontweight = legend_fontweight , color_map = color_map , palette = palette , frameon = frameon , right_margin = right_margin , left_margin = left_margin , size = size , title = title , show = show , save = save , ax = ax ) elif ( ( x in adata . var . keys ( ) or x in adata . obs . index ) and ( y in adata . var . keys ( ) or y in adata . obs . index ) and ( color is none or color in adata . var . keys ( ) or color in adata . obs . index ) ) axs = _scatter_var ( adata = adata , x = x , y = y , color = color , use_raw = use_raw , layers = layers , sort_order = sort_order , alpha = alpha , basis = basis , groups = groups , components = components , projection = projection , legend_loc = legend_loc , legend_fontsize = legend_fontsize , legend_fontweight = legend_fontweight , color_map = color_map , palette = palette , frameon = frameon , right_margin = right_margin , left_margin = left_margin , size = size , title = title , show = show , save = save , ax = ax ) else raise value_error ( string ) else raise value_error ( string ) return axs	1
Q_12	scatter plot	C_12_7	def scatter ( x , y , z , color = ( number , number , number ) , s = number . number number ) global _last_figure fig = _last_figure if fig is none fig = volshow ( none ) fig . scatter = scatter ( x = x , y = y , z = z , color = color , size = s ) fig . volume . scatter = fig . scatter return fig	1
Q_12	scatter plot	C_12_8	def plot ( self , sizescale = number , color = none , alpha = number . number , label = none , edgecolor = string , * * kw ) string string string	1
Q_12	scatter plot	C_12_9	"def scatter_plot ( self , ax , topic_dims , t = none , ms_limits = true , * * kwargs_plot ) string string s plot function , e . g . the style of the plotted points string param bool ms_limits if set to true , automatically set axes boundaries to the sensorimotor boundaries ( default true ) string string marker string o string linestyle string none string inf "" )"	1
Q_12	scatter plot	C_12_10	def sentiment_scatter ( sms = sms ) plt . figure ( figsize = ( number , number . number ) ) ax = plt . subplot ( number , number , number ) ax = sms . plot . scatter ( x = string , y = string , ax = ax , color = string , marker = string , alpha = . number ) ax = sms . plot . scatter ( x = string , y = string , ax = ax , color = string , marker = string , alpha = . number ) ax = sms . plot . scatter ( x = string , y = string , ax = ax , color = string , marker = string , alpha = . number ) ax = sms . plot . scatter ( x = string , y = string , ax = ax , color = string , marker = string , alpha = . number ) ax = sms . plot . scatter ( x = string , y = string , ax = ax , color = string , marker = string , alpha = . number ) plt . ylabel ( string ) plt . xlabel ( string ) plt . legend ( [ string , string , string , string , string ] ) plt . tight_layout ( ) plt . show ( )	1
Q_12	scatter plot	C_12_11	def scatter ( adata , x = none , y = none , color = none , use_raw = none , layers = string , sort_order = true , alpha = none , basis = none , groups = none , components = none , projection = string , legend_loc = string , legend_fontsize = none , legend_fontweight = none , color_map = none , palette = none , frameon = none , right_margin = none , left_margin = none , size = none , title = none , show = none , save = none , ax = none ) string string ann1 string ann1 string ann2 string pca string tsne string umap string diffmap string draw_graph_fr string string if basis is not none axs = _scatter_obs ( adata = adata , x = x , y = y , color = color , use_raw = use_raw , layers = layers , sort_order = sort_order , alpha = alpha , basis = basis , groups = groups , components = components , projection = projection , legend_loc = legend_loc , legend_fontsize = legend_fontsize , legend_fontweight = legend_fontweight , color_map = color_map , palette = palette , frameon = frameon , right_margin = right_margin , left_margin = left_margin , size = size , title = title , show = show , save = save , ax = ax ) elif x is not none and y is not none if ( ( x in adata . obs . keys ( ) or x in adata . var . index ) and ( y in adata . obs . keys ( ) or y in adata . var . index ) and ( color is none or color in adata . obs . keys ( ) or color in adata . var . index ) ) axs = _scatter_obs ( adata = adata , x = x , y = y , color = color , use_raw = use_raw , layers = layers , sort_order = sort_order , alpha = alpha , basis = basis , groups = groups , components = components , projection = projection , legend_loc = legend_loc , legend_fontsize = legend_fontsize , legend_fontweight = legend_fontweight , color_map = color_map , palette = palette , frameon = frameon , right_margin = right_margin , left_margin = left_margin , size = size , title = title , show = show , save = save , ax = ax ) elif ( ( x in adata . var . keys ( ) or x in adata . obs . index ) and ( y in adata . var . keys ( ) or y in adata . obs . index ) and ( color is none or color in adata . var . keys ( ) or color in adata . obs . index ) ) axs = _scatter_var ( adata = adata , x = x , y = y , color = color , use_raw = use_raw , layers = layers , sort_order = sort_order , alpha = alpha , basis = basis , groups = groups , components = components , projection = projection , legend_loc = legend_loc , legend_fontsize = legend_fontsize , legend_fontweight = legend_fontweight , color_map = color_map , palette = palette , frameon = frameon , right_margin = right_margin , left_margin = left_margin , size = size , title = title , show = show , save = save , ax = ax ) else raise value_error ( string ) else raise value_error ( string ) return axs	1
Q_12	scatter plot	C_12_12	def plotscatter ( irrad xarray . dataset , c1 dict [ str , any ] , log bool = false ) fg = figure ( ) axs = fg . subplots ( number , number , sharex = true ) transtxt = string ax = axs [ number ] ax . plot ( irrad . wavelength_nm , irrad [ string ] . squeeze ( ) ) ax . set_title ( transtxt ) ax . set_ylabel ( string ) ax . grid ( true ) ax . legend ( irrad . angle_deg . values ) ax = axs [ number ] if plot_np np = ( irrad [ string ] * number ) * ( irrad . wavelength_nm * number ) / ( h * c ) ax . plot ( irrad . wavelength_nm , np ) ax . set_ylabel ( string + units ) else ax . plot ( irrad . wavelength_nm , irrad [ string ] . squeeze ( ) ) ax . set_ylabel ( string + units ) ax . set_xlabel ( string ) ax . set_title ( string ) ax . invert_xaxis ( ) ax . autoscale ( true , axis = string , tight = true ) ax . grid ( true ) if log ax . set_yscale ( string )	1
Q_12	scatter plot	C_12_13	def scatter ( x , y , z , color = ( number , number , number ) , s = number . number number ) global _last_figure fig = _last_figure if fig is none fig = volshow ( none ) fig . scatter = scatter ( x = x , y = y , z = z , color = color , size = s ) fig . volume . scatter = fig . scatter return fig	1
Q_12	scatter plot	C_12_14	def scatter ( self , ax , x , y , z = none , color = tango . colors_hex [ string ] , label = none , marker = string , * * kwargs ) if z is not none return ax . scatter ( x , y , c = color , zs = z , label = label , marker = marker , * * kwargs ) return ax . scatter ( x , y , c = color , label = label , marker = marker , * * kwargs )	1
Q_12	scatter plot	C_12_15	def _add_plots_to_output ( out , data ) string string string out [ string ] = { } diagram_plot = _add_diagram_plot ( out , data ) if diagram_plot out [ string ] [ string ] = diagram_plot scatter = _add_scatter_plot ( out , data ) if scatter out [ string ] [ string ] = scatter scatter_global = _add_global_scatter_plot ( out , data ) if scatter_global out [ string ] [ string ] = scatter_global return out	1
Q_12	scatter plot	C_12_16	def scatter ( x , y , * * kwargs ) string string x string x string x string x string string kwargs [ string ] = x kwargs [ string ] = y return _draw_mark ( scatter , * * kwargs )	1
Q_12	scatter plot	C_12_17	def plotscatter ( irrad xarray . dataset , c1 dict [ str , any ] , log bool = false ) fg = figure ( ) axs = fg . subplots ( number , number , sharex = true ) transtxt = string ax = axs [ number ] ax . plot ( irrad . wavelength_nm , irrad [ string ] . squeeze ( ) ) ax . set_title ( transtxt ) ax . set_ylabel ( string ) ax . grid ( true ) ax . legend ( irrad . angle_deg . values ) ax = axs [ number ] if plot_np np = ( irrad [ string ] * number ) * ( irrad . wavelength_nm * number ) / ( h * c ) ax . plot ( irrad . wavelength_nm , np ) ax . set_ylabel ( string + units ) else ax . plot ( irrad . wavelength_nm , irrad [ string ] . squeeze ( ) ) ax . set_ylabel ( string + units ) ax . set_xlabel ( string ) ax . set_title ( string ) ax . invert_xaxis ( ) ax . autoscale ( true , axis = string , tight = true ) ax . grid ( true ) if log ax . set_yscale ( string )	1
Q_12	scatter plot	C_12_18	def scatter ( x , y , z , color = ( number , number , number ) , s = number . number number ) global _last_figure fig = _last_figure if fig is none fig = volshow ( none ) fig . scatter = scatter ( x = x , y = y , z = z , color = color , size = s ) fig . volume . scatter = fig . scatter return fig	1
Q_12	scatter plot	C_12_19	def _add_plots_to_output ( out , data ) string string string out [ string ] = { } diagram_plot = _add_diagram_plot ( out , data ) if diagram_plot out [ string ] [ string ] = diagram_plot scatter = _add_scatter_plot ( out , data ) if scatter out [ string ] [ string ] = scatter scatter_global = _add_global_scatter_plot ( out , data ) if scatter_global out [ string ] [ string ] = scatter_global return out	1
Q_12	scatter plot	C_12_20	def plotscatter ( irrad xarray . dataset , c1 dict [ str , any ] , log bool = false ) fg = figure ( ) axs = fg . subplots ( number , number , sharex = true ) transtxt = string ax = axs [ number ] ax . plot ( irrad . wavelength_nm , irrad [ string ] . squeeze ( ) ) ax . set_title ( transtxt ) ax . set_ylabel ( string ) ax . grid ( true ) ax . legend ( irrad . angle_deg . values ) ax = axs [ number ] if plot_np np = ( irrad [ string ] * number ) * ( irrad . wavelength_nm * number ) / ( h * c ) ax . plot ( irrad . wavelength_nm , np ) ax . set_ylabel ( string + units ) else ax . plot ( irrad . wavelength_nm , irrad [ string ] . squeeze ( ) ) ax . set_ylabel ( string + units ) ax . set_xlabel ( string ) ax . set_title ( string ) ax . invert_xaxis ( ) ax . autoscale ( true , axis = string , tight = true ) ax . grid ( true ) if log ax . set_yscale ( string )	0
Q_13	save list to file	C_13_0	def save_par_list ( self , * args , * * kw ) string string string if string in kw filename = kw [ string ] if not filename filename = self . get_filename ( ) if not filename raise value_error ( string ) if hasattr ( filename , string ) fh = filename abs_file_name = os . path . abspath ( fh . name ) else abs_file_name = os . path . expanduser ( filename ) abs_dir = os . path . dirname ( abs_file_name ) if len ( abs_dir ) and not os . path . isdir ( abs_dir ) os . makedirs ( abs_dir ) fh = open ( abs_file_name , string ) numpars = len ( self . _param_list ) if self . _for_use_with_epar numpars _ = number if not self . final_comment self . final_comment = [ string ]	1
Q_13	save list to file	C_13_1	def do_save ( self , fname ) self . save_file ( fname ) self . currentfile = fname self . is_changed = false logger . info ( _ ( string ) . format ( fname ) )	1
Q_13	save list to file	C_13_2	def save ( self , filename , metadata = { } , * * data ) super ( numpy_file , self ) . save ( filename , metadata , * * data ) savefn = numpy . savez_compressed if self . compress else numpy . savez savefn ( self . _savepath ( filename ) , metadata = metadata , * * data )	1
Q_13	save list to file	C_13_3	def save ( self ) filename_list = self . output [ string ] [ string ] if not isinstance ( filename_list , list ) filename_list = filename_list . split ( string ) contents_list = [ ] for var in filename_list file_path = os . path . join ( self . working_dir , var ) contents_list . append ( self . _read_file ( file_path ) ) self . output . update ( { string { string contents_list } } ) self . connection . update_task_attempt_output ( self . output [ string ] , self . output )	1
Q_13	save list to file	C_13_4	def save ( self , filename , metadata = { } , * * data ) super ( numpy_file , self ) . save ( filename , metadata , * * data ) savefn = numpy . savez_compressed if self . compress else numpy . savez savefn ( self . _savepath ( filename ) , metadata = metadata , * * data )	1
Q_13	save list to file	C_13_5	def save ( self ) filename_list = self . output [ string ] [ string ] file_path_list = [ os . path . join ( self . working_dir , var ) for var in filename_list ] self . import_manager . import_result_file_list ( self . output , file_path_list , retry = true )	1
Q_13	save list to file	C_13_6	def save_playlist_file ( self , station_file = string ) string string string if self . _playlist_format_changed ( ) self . dirty_playlist = true self . new_format = not self . new_format if station_file st_file = station_file else st_file = self . stations_file if not self . dirty_playlist if logger . is_enabled_for ( logging . debug ) logger . debug ( string ) return number st_new_file = st_file . replace ( string , string ) tmp_stations = self . stations [ ] tmp_stations . reverse ( ) if self . new_format tmp_stations . append ( [ string , string , string ] ) else tmp_stations . append ( [ string , string ] ) tmp_stations . reverse ( ) try with open ( st_new_file , string ) as cfgfile writter = csv . writer ( cfgfile ) for var in tmp_stations writter . writerow ( self . _format_playlist_row ( var ) ) except if logger . is_enabled_for ( logging . debug ) logger . debug ( string ) return _ number try move ( st_new_file , st_file ) except if logger . is_enabled_for ( logging . debug ) logger . debug ( string ) return _ number self . dirty_playlist = false return number	1
Q_13	save list to file	C_13_7	"def save ( self , savefile ) string string s an error with the api request . string string wb string saved to s "" , savefile )"	1
Q_13	save list to file	C_13_8	def save_par_list ( self , * args , * * kw ) string string string if string in kw filename = kw [ string ] if not filename filename = self . get_filename ( ) if not filename raise value_error ( string ) if hasattr ( filename , string ) fh = filename abs_file_name = os . path . abspath ( fh . name ) else abs_file_name = os . path . expanduser ( filename ) abs_dir = os . path . dirname ( abs_file_name ) if len ( abs_dir ) and not os . path . isdir ( abs_dir ) os . makedirs ( abs_dir ) fh = open ( abs_file_name , string ) numpars = len ( self . _param_list ) if self . _for_use_with_epar numpars _ = number if not self . final_comment self . final_comment = [ string ]	1
Q_13	save list to file	C_13_9	def save_app ( self , si , logger , vcenter_data_model , reservation_id , save_app_actions , cancellation_context ) string string string results = [ ] logger . info ( string + vcenter_data_model . default_datacenter ) if not save_app_actions raise exception ( string ) actions_grouped_by_save_types = groupby ( save_app_actions , lambda x x . action_params . save_deployment_model )	1
Q_13	save list to file	C_13_10	"def save_filelist ( self , op_file , op_format , delim = string , qu = string string string uses a list of files and collects meta data on them and saves to an text file as a list or with metadata depending on op_format . string string w string full_filename string string name string date string size string path string string ascii string ignore string utf _ number string string cant print line _ cls_filelist line number "" ) pass"	1
Q_13	save list to file	C_13_11	def save ( self ) filename_list = self . output [ string ] [ string ] if not isinstance ( filename_list , list ) filename_list = filename_list . split ( string ) contents_list = [ ] for var in filename_list file_path = os . path . join ( self . working_dir , var ) contents_list . append ( self . _read_file ( file_path ) ) self . output . update ( { string { string contents_list } } ) self . connection . update_task_attempt_output ( self . output [ string ] , self . output )	1
Q_13	save list to file	C_13_12	"def save_filelist ( self , op_file , op_format , delim = string , qu = string string string uses a list of files and collects meta data on them and saves to an text file as a list or with metadata depending on op_format . string string w string full_filename string string name string date string size string path string string ascii string ignore string utf _ number string string cant print line _ cls_filelist line number "" ) pass"	1
Q_13	save list to file	C_13_13	def save_playlist_file ( self , station_file = string ) string string string if self . _playlist_format_changed ( ) self . dirty_playlist = true self . new_format = not self . new_format if station_file st_file = station_file else st_file = self . stations_file if not self . dirty_playlist if logger . is_enabled_for ( logging . debug ) logger . debug ( string ) return number st_new_file = st_file . replace ( string , string ) tmp_stations = self . stations [ ] tmp_stations . reverse ( ) if self . new_format tmp_stations . append ( [ string , string , string ] ) else tmp_stations . append ( [ string , string ] ) tmp_stations . reverse ( ) try with open ( st_new_file , string ) as cfgfile writter = csv . writer ( cfgfile ) for var in tmp_stations writter . writerow ( self . _format_playlist_row ( var ) ) except if logger . is_enabled_for ( logging . debug ) logger . debug ( string ) return _ number try move ( st_new_file , st_file ) except if logger . is_enabled_for ( logging . debug ) logger . debug ( string ) return _ number self . dirty_playlist = false return number	1
Q_13	save list to file	C_13_14	"def save ( self , savefile ) string string s an error with the api request . string string wb string saved to s "" , savefile )"	1
Q_13	save list to file	C_13_15	def do_save ( self , fname ) self . save_file ( fname ) self . currentfile = fname self . is_changed = false logger . info ( _ ( string ) . format ( fname ) )	1
Q_13	save list to file	C_13_16	def save_app ( self , si , logger , vcenter_data_model , reservation_id , save_app_actions , cancellation_context ) string string string results = [ ] logger . info ( string + vcenter_data_model . default_datacenter ) if not save_app_actions raise exception ( string ) actions_grouped_by_save_types = groupby ( save_app_actions , lambda x x . action_params . save_deployment_model )	0
Q_13	save list to file	C_13_17	def save ( self ) filename_list = self . output [ string ] [ string ] file_path_list = [ os . path . join ( self . working_dir , var ) for var in filename_list ] self . import_manager . import_result_file_list ( self . output , file_path_list , retry = true )	0
Q_14	replace in file	C_14_0	def _replace_in_file ( self , dir_name , filename , args ) path = os . path . join ( dir_name , filename ) with open ( path , string ) as f s = f . read ( ) s = s . replace ( string , args . id ) s = s . replace ( string , self . _upper_slug ) s = s . replace ( string , self . _lower_slug ) s = s . replace ( string , args . name ) s = s . replace ( string , args . github_user ) with open ( path , string ) as f f . write ( s )	1
Q_14	replace in file	C_14_1	def replace_text ( filepath , to_replace , replacement ) string string to_replace string string with open ( filepath ) as file s = file . read ( ) s = s . replace ( to_replace , replacement ) with open ( filepath , string ) as file file . write ( s )	1
Q_14	replace in file	C_14_2	def replaces_in_file ( file , replacement_list ) rs = [ ( re . compile ( regexp ) , repl ) for ( regexp , repl ) in replacement_list ] file_tmp = file + string + str ( os . getpid ( ) ) + string with open ( file , string ) as f with open ( file_tmp , string ) as f_tmp for var in f for r , replace in rs match = r . search ( var ) if match var = replace + string f_tmp . write ( var ) shutil . move ( file_tmp , file )	1
Q_14	replace in file	C_14_3	def replace_text ( filepath , to_replace , replacement ) string string to_replace string string with open ( filepath ) as file s = file . read ( ) s = s . replace ( to_replace , replacement ) with open ( filepath , string ) as file file . write ( s )	1
Q_14	replace in file	C_14_4	def replaces_in_file ( file , replacement_list ) rs = [ ( re . compile ( regexp ) , repl ) for ( regexp , repl ) in replacement_list ] file_tmp = file + string + str ( os . getpid ( ) ) + string with open ( file , string ) as f with open ( file_tmp , string ) as f_tmp for var in f for r , replace in rs match = r . search ( var ) if match var = replace + string f_tmp . write ( var ) shutil . move ( file_tmp , file )	1
Q_14	replace in file	C_14_5	def replace_source ( self , body , name ) logging . debug ( _ ( string ) , name ) replaced = re . sub ( self . func_name_re , self . _func_replacer , body ) replaced = re . sub ( self . str_literal_re , self . _string_replacer , replaced ) return self . _build_strings ( ) + replaced return replaced	1
Q_14	replace in file	C_14_6	def replace_source ( self , body , name ) logging . debug ( _ ( string ) , name ) replaced = re . sub ( self . func_name_re , self . _func_replacer , body ) replaced = re . sub ( self . str_literal_re , self . _string_replacer , replaced ) return self . _build_strings ( ) + replaced return replaced	1
Q_14	replace in file	C_14_7	def replace_doc_text ( file , replacements ) document = document ( file ) paragraphs = document . paragraphs changes = false for var in paragraphs text = var . text for original , replace in replacements . items ( ) if original in replace and replace in text continue if original in text changes = true text = text . replace ( original , replace ) var . text = text if changes print ( string . format ( file ) ) document . save ( file )	1
Q_14	replace in file	C_14_8	def replace_doc_text ( file , replacements ) document = document ( file ) paragraphs = document . paragraphs changes = false for var in paragraphs text = var . text for original , replace in replacements . items ( ) if original in replace and replace in text continue if original in text changes = true text = text . replace ( original , replace ) var . text = text if changes print ( string . format ( file ) ) document . save ( file )	1
Q_14	replace in file	C_14_9	def replace_doc_text ( file , replacements ) document = document ( file ) paragraphs = document . paragraphs changes = false for var in paragraphs text = var . text for original , replace in replacements . items ( ) if original in replace and replace in text continue if original in text changes = true text = text . replace ( original , replace ) var . text = text if changes print ( string . format ( file ) ) document . save ( file )	1
Q_14	replace in file	C_14_10	def replace_f ( self , path , arg_name = none ) string string string root , file = os . path . split ( path ) pattern = re . compile ( r string ) file_path = path fh , abs_path = mkstemp ( ) with open ( abs_path , string ) as new_file with open ( file_path ) as old_file for var in old_file for ( o , var_name , c ) in re . findall ( pattern , var ) var = self . handle_args ( var , var_name , arg_name ) new_file . write ( var ) os . close ( fh )	1
Q_14	replace in file	C_14_11	def _load_file ( self , filename ) try	1
Q_14	replace in file	C_14_12	def _load_file ( self , filename ) try	1
Q_14	replace in file	C_14_13	def test_replacements ( clip_str , path_exists ) replaced_str = clip_str for var , var in conf . find_replace_map replaced_str = re . sub ( var , var , replaced_str ) match = re . search (	1
Q_14	replace in file	C_14_14	def test_replacements ( clip_str , path_exists ) replaced_str = clip_str for var , var in conf . find_replace_map replaced_str = re . sub ( var , var , replaced_str ) match = re . search (	1
Q_14	replace in file	C_14_15	def replace_f ( self , path , arg_name = none ) string string string root , file = os . path . split ( path ) pattern = re . compile ( r string ) file_path = path fh , abs_path = mkstemp ( ) with open ( abs_path , string ) as new_file with open ( file_path ) as old_file for var in old_file for ( o , var_name , c ) in re . findall ( pattern , var ) var = self . handle_args ( var , var_name , arg_name ) new_file . write ( var ) os . close ( fh )	0
Q_14	replace in file	C_14_16	"def _replace_file ( path , content ) string string t already exist with the same content . this is useful because cargo uses timestamps to decide whether to compile things . string string r string not overwriting { } because it is unchanged string w "" ) as f f . write ( content )"	0
Q_15	regex case insensitive	C_15_0	def match ( self , string ) string string string if self . casesensitive return self . pattern = = os . path . normcase ( string ) else return self . pattern . lower ( ) = = os . path . normcase ( string ) . lower ( )	1
Q_15	regex case insensitive	C_15_1	def get_search_regex ( query , ignore_case = true ) string string . * string string regex_text = [ var for var in query if var = string ] regex_text = string . join ( regex_text ) regex = r string . format ( regex_text ) if ignore_case pattern = re . compile ( regex , re . ignorecase ) else pattern = re . compile ( regex ) return pattern	1
Q_15	regex case insensitive	C_15_2	def regex ( regex , case = false , _value = none , * args , * * kwargs ) if kwargs . get ( string ) regex = re . compile ( regex ) else regex = re . compile ( regex , re . ignorecase ) if not regex . match ( _value ) raise validation_error ( string regex ) return _value	1
Q_15	regex case insensitive	C_15_3	def _regex_span ( _regex , _str , case_insensitive = true ) string string string if case_insensitive flags = regex . ignorecase regex . fullcase regex . version1 else flags = regex . version1 comp = regex . compile ( _regex , flags = flags ) matches = comp . finditer ( _str ) for var in matches yield var	1
Q_15	regex case insensitive	C_15_4	def _regex_span ( _regex , _str , case_insensitive = true ) string string string if case_insensitive flags = regex . ignorecase regex . fullcase regex . version1 else flags = regex . version1 comp = regex . compile ( _regex , flags = flags ) matches = comp . finditer ( _str ) for var in matches yield var	1
Q_15	regex case insensitive	C_15_5	def image_from ( from_value ) string string image tag string image tag as name string image tag string string regex = re . compile ( r string string as name string string ) match = re . match ( regex , from_value ) return match . group ( string , string ) if match else ( none , none )	1
Q_15	regex case insensitive	C_15_6	def _build_mongo_filter ( request , keys , icase = true ) _filter = { } keys = set ( keys ) _ set ( [ string ] ) for var in keys value = request . get . get ( var ) if value if var in _lower_fields _filter [ var ] = value . lower ( ) elif var . endswith ( string ) values = value . split ( string ) _filter [ var [ _ number ] ] = values elif var = = string _filter [ var ] = fix_bill_id ( value . upper ( ) ) else	1
Q_15	regex case insensitive	C_15_7	def _build_mongo_filter ( request , keys , icase = true ) _filter = { } keys = set ( keys ) _ set ( [ string ] ) for var in keys value = request . get . get ( var ) if value if var in _lower_fields _filter [ var ] = value . lower ( ) elif var . endswith ( string ) values = value . split ( string ) _filter [ var [ _ number ] ] = values elif var = = string _filter [ var ] = fix_bill_id ( value . upper ( ) ) else	1
Q_15	regex case insensitive	C_15_8	def regex ( regex , case = false , _value = none , * args , * * kwargs ) if kwargs . get ( string ) regex = re . compile ( regex ) else regex = re . compile ( regex , re . ignorecase ) if not regex . match ( _value ) raise validation_error ( string regex ) return _value	1
Q_15	regex case insensitive	C_15_9	def regex_match ( value , regex ) pattern = re . compile ( regex ) if pattern . match ( value ) return true	1
Q_15	regex case insensitive	C_15_10	def get_regex ( regex ) string string string string string string string if isinstance ( regex , basestring ) return re . compile ( regex ) elif not isinstance ( regex , re . _pattern_type ) raise type_error ( string ( regex , ) ) return regex	1
Q_15	regex case insensitive	C_15_11	def get_search_regex ( query , ignore_case = true ) string string . * string string regex_text = [ var for var in query if var = string ] regex_text = string . join ( regex_text ) regex = r string . format ( regex_text ) if ignore_case pattern = re . compile ( regex , re . ignorecase ) else pattern = re . compile ( regex ) return pattern	1
Q_15	regex case insensitive	C_15_12	def _filter_by_regex ( self , regex , text , group = number ) string string string match = re . search ( regex , text , re . multiline ) return match . group ( group ) . strip ( ) if ( match and match . groups ( ) ) else text	1
Q_15	regex case insensitive	C_15_13	def regex_match ( value , regex ) pattern = re . compile ( regex ) if pattern . match ( value ) return true	1
Q_15	regex case insensitive	C_15_14	def match ( self , string ) string string string if self . casesensitive return self . pattern = = os . path . normcase ( string ) else return self . pattern . lower ( ) = = os . path . normcase ( string ) . lower ( )	0
Q_15	regex case insensitive	C_15_15	def get_regex ( regex ) string string string string string string string if isinstance ( regex , basestring ) return re . compile ( regex ) elif not isinstance ( regex , re . _pattern_type ) raise type_error ( string ( regex , ) ) return regex	0
Q_15	regex case insensitive	C_15_16	def lower ( self ) new_string = i_string ( self . _irc_lower ( self ) ) new_string . set_std ( self . _std ) return new_string	0
Q_15	regex case insensitive	C_15_17	def image_from ( from_value ) string string image tag string image tag as name string image tag string string regex = re . compile ( r string string as name string string ) match = re . match ( regex , from_value ) return match . group ( string , string ) if match else ( none , none )	0
Q_15	regex case insensitive	C_15_18	def lower ( self ) new_string = i_string ( self . _irc_lower ( self ) ) new_string . set_std ( self . _std ) return new_string	0
Q_15	regex case insensitive	C_15_19	def _filter_by_regex ( self , regex , text , group = number ) string string string match = re . search ( regex , text , re . multiline ) return match . group ( group ) . strip ( ) if ( match and match . groups ( ) ) else text	0
Q_16	readonly array	C_16_0	def derive_readonly ( self ) string string string readonly = list ( self . readonly ) for var , var in self . field_config . items ( ) if string in var and var [ string ] readonly . append ( var ) return readonly	1
Q_16	readonly array	C_16_1	"def broadcast_to ( array , shape , subok = false ) string string s broadcasting rules . notes _ . versionadded number . number . number examples _ x = np . array ( [ number , number , number ] ) np . broadcast_to ( x , ( number , number ) ) array ( [ [ number , number , number ] , [ number , number , number ] , [ number , number , number ] ] ) string "" return _broadcast_to ( array , shape , subok = subok , readonly = true )"	1
Q_16	readonly array	C_16_2	def _readonly ( self , inplace = false )	1
Q_16	readonly array	C_16_3	def _broadcast_to ( array , shape , subok , readonly ) shape = tuple ( shape ) if np . iterable ( shape ) else ( shape , ) array = np . array ( array , copy = false , subok = subok ) if not shape and array . shape raise value_error ( string ) if any ( var < number for var in shape ) raise value_error ( string string ) broadcast = np . nditer ( ( array , ) , flags = [ string , string , string ] , op_flags = [ string ] , itershape = shape , order = string ) . itviews [ number ] result = _maybe_view_as_subclass ( array , broadcast ) if not readonly and array . flags . writeable result . flags . writeable = true return result	1
Q_16	readonly array	C_16_4	def read ( self , nrows = none ) if nrows is none nrows = self . nobs read_lines = min ( nrows , self . nobs _ self . _lines_read ) read_len = read_lines * self . record_length if read_len < = number self . close ( ) raise stop_iteration raw = self . filepath_or_buffer . read ( read_len ) data = np . frombuffer ( raw , dtype = self . _dtype , count = read_lines ) df = pd . data_frame ( index = range ( read_lines ) ) for var , var in enumerate ( self . columns ) vec = data [ string var ] ntype = self . fields [ var ] [ string ] if ntype = = string vec = _handle_truncated_float_vec ( vec , self . fields [ var ] [ string ] ) miss = self . _missing_double ( vec ) v = _parse_float_vec ( vec ) v [ miss ] = np . nan elif self . fields [ var ] [ string ] = = string v = [ y . rstrip ( ) for y in vec ] if self . _encoding is not none v = [ y . decode ( self . _encoding ) for y in v ] df [ var ] = v if self . _index is none df . index = range ( self . _lines_read , self . _lines_read + read_lines ) else df = df . set_index ( self . _index ) self . _lines_read + = read_lines return df	1
Q_16	readonly array	C_16_5	def _broadcast_to ( array , shape , subok , readonly ) shape = tuple ( shape ) if np . iterable ( shape ) else ( shape , ) array = np . array ( array , copy = false , subok = subok ) if not shape and array . shape raise value_error ( string ) if any ( var < number for var in shape ) raise value_error ( string string ) broadcast = np . nditer ( ( array , ) , flags = [ string , string , string ] , op_flags = [ string ] , itershape = shape , order = string ) . itviews [ number ] result = _maybe_view_as_subclass ( array , broadcast ) if not readonly and array . flags . writeable result . flags . writeable = true return result	1
Q_16	readonly array	C_16_6	"def broadcast_to ( array , shape , subok = false ) string string s broadcasting rules . notes _ . versionadded number . number . number examples _ x = np . array ( [ number , number , number ] ) np . broadcast_to ( x , ( number , number ) ) array ( [ [ number , number , number ] , [ number , number , number ] , [ number , number , number ] ] ) string "" return _broadcast_to ( array , shape , subok = subok , readonly = true )"	1
Q_16	readonly array	C_16_7	def read_array ( self ) array_length = unpack ( string , self . input . read ( number ) ) [ number ] array_data = amqp_reader ( self . input . read ( array_length ) ) result = [ ] while array_data . input . tell ( ) < array_length val = array_data . read_item ( ) result . append ( val ) return result	0
Q_16	readonly array	C_16_8	def _serve_ready ( self ) read_check = [ self . _wakeup_fd ] for var in self . sub_servers read_check . extend ( var . read_checkable_fds ) all_read_ready , _ , _ = select . select ( read_check , [ ] , [ ] ) for read_ready in all_read_ready if isinstance ( read_ready , ( _request_embryo , http . server . http_server ) ) read_ready . serve_ready ( )	0
Q_16	readonly array	C_16_9	def read ( self , read_size = none ) if read_size read_str = self . file . read ( read_size ) else read_str = self . file . read ( ) return len ( read_str ) , read_str	0
Q_16	readonly array	C_16_10	def read ( self , read_size = none ) if read_size read_str = self . file . read ( read_size ) else read_str = self . file . read ( ) return len ( read_str ) , read_str	0
Q_16	readonly array	C_16_11	def _svrc_read_array ( array ) empty_array_fix_pt_2 = string empty_array_val = number none_type = number res = array . read ( ) try if ( res . shape = = ( number , ) and res [ number ] = = empty_array_val and empty_array_fix_pt_2 in array . _v_attrs )	0
Q_16	readonly array	C_16_12	def read_array ( self ) array_length = unpack ( string , self . input . read ( number ) ) [ number ] array_data = amqp_reader ( self . input . read ( array_length ) ) result = [ ] while array_data . input . tell ( ) < array_length val = array_data . read_item ( ) result . append ( val ) return result	0
Q_16	readonly array	C_16_13	def read_array ( self , key , embedded = true ) string string string return self . read ( key , true , embedded )	0
Q_16	readonly array	C_16_14	def read_array ( self , key , embedded = true ) string string string return self . read ( key , true , embedded )	0
Q_16	readonly array	C_16_15	def _svrc_read_array ( array ) empty_array_fix_pt_2 = string empty_array_val = number none_type = number res = array . read ( ) try if ( res . shape = = ( number , ) and res [ number ] = = empty_array_val and empty_array_fix_pt_2 in array . _v_attrs )	0
Q_16	readonly array	C_16_16	def _readonly ( self , inplace = false )	0
Q_16	readonly array	C_16_17	def derive_readonly ( self ) string string string readonly = list ( self . readonly ) for var , var in self . field_config . items ( ) if string in var and var [ string ] readonly . append ( var ) return readonly	0
Q_16	readonly array	C_16_18	def _serve_ready ( self ) read_check = [ self . _wakeup_fd ] for var in self . sub_servers read_check . extend ( var . read_checkable_fds ) all_read_ready , _ , _ = select . select ( read_check , [ ] , [ ] ) for read_ready in all_read_ready if isinstance ( read_ready , ( _request_embryo , http . server . http_server ) ) read_ready . serve_ready ( )	0
Q_17	read element from html _ td	C_17_0	def html_row_with_ordered_headers ( data , headers ) string string administrators string key string leader string project string key string demo string project string demonstration string leader string leader example . com string administrators string admin1 example . com string admin2 example . com string t < tr > < td > < ul > < li > < a href = string > admin1 example . com < / a > < / li > < li > < a href = string > admin2 example . com < / a > < / li > < / ul > < / td > < td > demo < / td > < td > leader example . com < / td > < td > demonstration < / td > < / tr > string key string project string leader string administrators string t < tr > < td > demo < / td > < td > demonstration < / td > < td > leader example . com < / td > < td > < ul > < li > < a href = string > admin1 example . com < / a > < / li > < li > < a href = string > admin2 example . com < / a > < / li > < / ul > < / td > < / tr > string string html = string for var in headers element = data [ var ] if isinstance ( element , list ) element = html_list ( element ) if is_email ( element ) element = html_email ( element ) html + = string . format ( element ) return html + string	1
Q_17	read element from html _ td	C_17_1	"def tag_to_dict ( html ) string string s attributes into a dict . string string / / html / body / child * string text "" ] = element . text_content ( ) return attributes"	1
Q_17	read element from html _ td	C_17_2	def get_elements ( html_file , tags ) string string re interested in . returns a list of tuples with the attribute as first item and the list of elements as the second item . string string html . parser string t include external links return lambda x x . name = = var and not x . get ( var , string ) . startswith ( ( string , string ) ) all_tags = [ ( var , document . find_all ( condition ( var , var ) ) ) for var , var in tags ] return all_tags	1
Q_17	read element from html _ td	C_17_3	def output ( self )	1
Q_17	read element from html _ td	C_17_4	def get_body ( doc ) [ var . drop_tree ( ) for var in doc . xpath ( string ) ] raw_html = tostring ( doc . body or doc ) . decode ( string ) print ( raw_html ) cleaned = clean_attributes ( raw_html ) try	1
Q_17	read element from html _ td	C_17_5	def from_html ( html , * args , * * kwargs ) string string string source = beautiful_soup ( html , string , * args , * * kwargs ) return toc ( string , source = source , descendants = source . children )	1
Q_17	read element from html _ td	C_17_6	def thread ( data , default = u string , id = none ) string string string html = html5lib . parse ( data , treebuilder = string ) assert html . last_child . node_name = = string html = html . last_child	1
Q_17	read element from html _ td	C_17_7	"def tag_to_dict ( html ) string string s attributes into a dict . string string / / html / body / child * string text "" ] = element . text_content ( ) return attributes"	1
Q_17	read element from html _ td	C_17_8	def get_elements ( html_file , tags ) string string re interested in . returns a list of tuples with the attribute as first item and the list of elements as the second item . string string html . parser string t include external links return lambda x x . name = = var and not x . get ( var , string ) . startswith ( ( string , string ) ) all_tags = [ ( var , document . find_all ( condition ( var , var ) ) ) for var , var in tags ] return all_tags	1
Q_17	read element from html _ td	C_17_9	def get_body ( doc ) [ var . drop_tree ( ) for var in doc . xpath ( string ) ] raw_html = tostring ( doc . body or doc ) . decode ( string ) print ( raw_html ) cleaned = clean_attributes ( raw_html ) try	1
Q_17	read element from html _ td	C_17_10	"def tag_to_dict ( html ) string string s attributes into a dict . string string / / html / body / child * string text "" ] = element . text_content ( ) return attributes"	1
Q_17	read element from html _ td	C_17_11	def _telescope_pointing_widget ( cluster_name ) html = string html + = string html + = string html + = string html + = string html + = string html + = string html + = string http / / assets . lsst . rocks / data / sphere . png string html + = string cluster_name html + = string html + = string html + = string html + = string return div ( text = html , width = number , height = number )	1
Q_17	read element from html _ td	C_17_12	def output ( self )	1
Q_17	read element from html _ td	C_17_13	"def tag_to_dict ( html ) string string s attributes into a dict . string string / / html / body / child * string text "" ] = element . text_content ( ) return attributes"	1
Q_17	read element from html _ td	C_17_14	def thread ( data , default = u string , id = none ) string string string html = html5lib . parse ( data , treebuilder = string ) assert html . last_child . node_name = = string html = html . last_child	1
Q_17	read element from html _ td	C_17_15	def fill_input_radio ( self , value , skip_reset = false ) elm = self . form_elm . get_elm ( xpath = string radio string s string s string ( self . elm_name , self . convert_value ( value ) , ) ) self . _click_on_elm_or_his_ancestor ( elm )	1
Q_17	read element from html _ td	C_17_16	def fill_input_radio ( self , value , skip_reset = false ) elm = self . form_elm . get_elm ( xpath = string radio string s string s string ( self . elm_name , self . convert_value ( value ) , ) ) self . _click_on_elm_or_his_ancestor ( elm )	0
Q_17	read element from html _ td	C_17_17	def _parsehtml ( self ) parser = pdfhtml_parser ( ) parser . feed ( self . htmltext ) self . commandlist = parser . get_commandlist ( )	0
Q_17	read element from html _ td	C_17_18	def html_row_with_ordered_headers ( data , headers ) string string administrators string key string leader string project string key string demo string project string demonstration string leader string leader example . com string administrators string admin1 example . com string admin2 example . com string t < tr > < td > < ul > < li > < a href = string > admin1 example . com < / a > < / li > < li > < a href = string > admin2 example . com < / a > < / li > < / ul > < / td > < td > demo < / td > < td > leader example . com < / td > < td > demonstration < / td > < / tr > string key string project string leader string administrators string t < tr > < td > demo < / td > < td > demonstration < / td > < td > leader example . com < / td > < td > < ul > < li > < a href = string > admin1 example . com < / a > < / li > < li > < a href = string > admin2 example . com < / a > < / li > < / ul > < / td > < / tr > string string html = string for var in headers element = data [ var ] if isinstance ( element , list ) element = html_list ( element ) if is_email ( element ) element = html_email ( element ) html + = string . format ( element ) return html + string	0
Q_17	read element from html _ td	C_17_19	def _telescope_pointing_widget ( cluster_name ) html = string html + = string html + = string html + = string html + = string html + = string html + = string html + = string http / / assets . lsst . rocks / data / sphere . png string html + = string cluster_name html + = string html + = string html + = string html + = string return div ( text = html , width = number , height = number )	0
Q_17	read element from html _ td	C_17_20	def from_html ( html , * args , * * kwargs ) string string string source = beautiful_soup ( html , string , * args , * * kwargs ) return toc ( string , source = source , descendants = source . children )	0
Q_18	read text file line by line	C_18_0	def check ( conf , line ) if line . end = = len ( line . buffer ) and line . end > line . start yield lint_problem ( line . line_no , line . end _ line . start + number , string )	1
Q_18	read text file line by line	C_18_1	def readline ( self ) if self . _current_line > = len ( self . _linelist ) line = string else line = self . _linelist [ self . _current_line ] + string self . _current_line + = number self . _current_indx + = len ( string . join ( self . _linelist [ number self . _current_line ] ) ) if self . _encoding is not none line = line . encode ( self . _encoding ) return line	1
Q_18	read text file line by line	C_18_2	def readline ( self , f ) string string string while true line = f . readline ( ) if len ( line ) = = number raise eof_error line = line [ line . find ( string ) ] line = line . strip ( ) if len ( line ) > number return line	1
Q_18	read text file line by line	C_18_3	def reindent ( text , filename ) new_lines = [ ] k = number c = number for var , var in enumerate ( text . splitlines ( ) ) line = var . strip ( ) if not line or line [ number ] = = string new_lines . append ( line ) continue line3 = line [ number ] line4 = line [ number ] line5 = line [ number ] line6 = line [ number ] line7 = line [ number ] if line3 = = string or line4 in ( string , string , string ) or line6 = = string or line6 = = string or line5 = = string new_lines . append ( string * k + line ) k + = number continue elif line5 = = string or line5 = = string or line7 = = string or line7 = = string or line7 = = string c = k _ number if c < number	1
Q_18	read text file line by line	C_18_4	def _readline ( self , ignore_comments = true ) string string string while true line = self . _det_file . readline ( ) if line = = string return line	1
Q_18	read text file line by line	C_18_5	def get_text_line ( self , line_nb ) string string string	1
Q_18	read text file line by line	C_18_6	def fetch_line ( self , strip = true , require_line = true , report = string ) if ( strip = = none ) line = self . file . readline ( ) elif ( strip = = true ) line = self . file . readline ( ) . strip ( ) else line = self . file . readline ( ) . strip ( ) . strip ( strip ) self . line_number + = number if ( require_line ) assert ( line ) , string ( report , self . line_number ) return line	1
Q_18	read text file line by line	C_18_7	def _read_header_lines ( base_record_name , dir_name , pb_dir ) string string number string http / / physionet . org / physiobank / database / mitdb string mitdb string string file_name = base_record_name + string	1
Q_18	read text file line by line	C_18_8	def _read_header_lines ( base_record_name , dir_name , pb_dir ) string string number string http / / physionet . org / physiobank / database / mitdb string mitdb string string file_name = base_record_name + string	1
Q_18	read text file line by line	C_18_9	def reindent ( text , filename ) new_lines = [ ] k = number c = number for var , var in enumerate ( text . splitlines ( ) ) line = var . strip ( ) if not line or line [ number ] = = string new_lines . append ( line ) continue line3 = line [ number ] line4 = line [ number ] line5 = line [ number ] line6 = line [ number ] line7 = line [ number ] if line3 = = string or line4 in ( string , string , string ) or line6 = = string or line6 = = string or line5 = = string new_lines . append ( string * k + line ) k + = number continue elif line5 = = string or line5 = = string or line7 = = string or line7 = = string or line7 = = string c = k _ number if c < number	1
Q_18	read text file line by line	C_18_10	def fetch_line ( self , strip = true , require_line = true , report = string ) if ( strip = = none ) line = self . file . readline ( ) elif ( strip = = true ) line = self . file . readline ( ) . strip ( ) else line = self . file . readline ( ) . strip ( ) . strip ( strip ) self . line_number + = number if ( require_line ) assert ( line ) , string ( report , self . line_number ) return line	1
Q_18	read text file line by line	C_18_11	def _readline ( self , ignore_comments = true ) string string string while true line = self . _det_file . readline ( ) if line = = string return line	1
Q_18	read text file line by line	C_18_12	def read_line ( self , line ) string string string if not self . _read_line_init self . init_read_line ( ) match = self . _re . match ( line ) assert match is not none , f string matched_values = [ ] for var in range ( self . _re . groups ) cvt_re = self . _match_exps [ var ] cvt_div = self . _divisors [ var ] cvt_fn = self . _in_cvt_fns [ var ] match_str = match . group ( var + number ) match0 = re . match ( cvt_re , match_str ) if match0 is not none if cvt_fn = = string if string in match_str val = float ( match_str ) else val = int ( match_str ) / cvt_div elif cvt_fn = = string val = int ( match_str ) else sys . stderr . write ( f string ) else sys . stderr . write ( f string ) matched_values . append ( val ) return tuple ( matched_values )	1
Q_18	read text file line by line	C_18_13	def default_line ( self , line ) if line . endswith ( b string ) line = line [ _ number ] if line . endswith ( b string ) line = line [ _ number ] try line = line . decode ( string ) except unicode_decode_error pass print ( line )	1
Q_18	read text file line by line	C_18_14	def readline ( self , f ) string string string while true line = f . readline ( ) if len ( line ) = = number raise eof_error line = line [ line . find ( string ) ] line = line . strip ( ) if len ( line ) > number return line	1
Q_18	read text file line by line	C_18_15	def read_line ( self , line ) string string string if not self . _read_line_init self . init_read_line ( ) match = self . _re . match ( line ) assert match is not none , f string matched_values = [ ] for var in range ( self . _re . groups ) cvt_re = self . _match_exps [ var ] cvt_div = self . _divisors [ var ] cvt_fn = self . _in_cvt_fns [ var ] match_str = match . group ( var + number ) match0 = re . match ( cvt_re , match_str ) if match0 is not none if cvt_fn = = string if string in match_str val = float ( match_str ) else val = int ( match_str ) / cvt_div elif cvt_fn = = string val = int ( match_str ) else sys . stderr . write ( f string ) else sys . stderr . write ( f string ) matched_values . append ( val ) return tuple ( matched_values )	1
Q_18	read text file line by line	C_18_16	def fetch_line ( self , strip = true , require_line = true , report = string ) if ( strip = = none ) line = self . file . readline ( ) elif ( strip = = true ) line = self . file . readline ( ) . strip ( ) else line = self . file . readline ( ) . strip ( ) . strip ( strip ) self . line_number + = number if ( require_line ) assert ( line ) , string ( report , self . line_number ) return line	1
Q_18	read text file line by line	C_18_17	def default_line ( self , line ) if line . endswith ( b string ) line = line [ _ number ] if line . endswith ( b string ) line = line [ _ number ] try line = line . decode ( string ) except unicode_decode_error pass print ( line )	0
Q_18	read text file line by line	C_18_18	def _read_header_lines ( base_record_name , dir_name , pb_dir ) string string number string http / / physionet . org / physiobank / database / mitdb string mitdb string string file_name = base_record_name + string	0
Q_18	read text file line by line	C_18_19	def readline ( self ) if self . _current_line > = len ( self . _linelist ) line = string else line = self . _linelist [ self . _current_line ] + string self . _current_line + = number self . _current_indx + = len ( string . join ( self . _linelist [ number self . _current_line ] ) ) if self . _encoding is not none line = line . encode ( self . _encoding ) return line	0
Q_18	read text file line by line	C_18_20	def check ( conf , line ) if line . end = = len ( line . buffer ) and line . end > line . start yield lint_problem ( line . line_no , line . end _ line . start + number , string )	0
Q_18	read text file line by line	C_18_21	def readline ( self ) if self . _current_line > = len ( self . _linelist ) line = string else line = self . _linelist [ self . _current_line ] + string self . _current_line + = number self . _current_indx + = len ( string . join ( self . _linelist [ number self . _current_line ] ) ) if self . _encoding is not none line = line . encode ( self . _encoding ) return line	0
Q_19	read property file	C_19_0	def _read_properties ( ) init_path = os . path . abspath ( os . path . join ( string , string ) ) regex = re . compile ( string ( ? p < value > . * ) string ) with open ( init_path , string ) as f props = { } for var in f . readlines ( ) m = regex . match ( var ) if m is not none props [ m . group ( string ) ] = m . group ( string ) return props	1
Q_19	read property file	C_19_1	def read_properties ( fname ) parser = configparser . safe_config_parser ( ) parser . optionxform = str	1
Q_19	read property file	C_19_2	def read_properties ( fname ) parser = configparser . safe_config_parser ( ) parser . optionxform = str	1
Q_19	read property file	C_19_3	def read_properties ( entry ) stream = entry . get ( string ) if stream is none raise exception ( string ) s = stream . open ( )	1
Q_19	read property file	C_19_4	def read_properties ( self ) stream = self . dir . get ( string ) if stream is none return s = stream . open ( )	1
Q_19	read property file	C_19_5	def read ( self , read_size = _ number ) string string string read_str = self . file . read ( read_size ) return len ( read_str ) , read_str	1
Q_19	read property file	C_19_6	def _read_properties ( self ) properties = dict ( ) if self . _filepath and os . path . exists ( self . _filepath ) try with open ( self . _filepath , string ) as fp properties = json . load ( fp ) except exception os . replace ( self . _filepath , self . _filepath + string )	1
Q_19	read property file	C_19_7	def read_properties ( self ) stream = self . dir . get ( string ) if stream is none return s = stream . open ( )	1
Q_19	read property file	C_19_8	def read ( self , read_size = _ number ) string string string read_str = self . file . read ( read_size ) return len ( read_str ) , read_str	1
Q_19	read property file	C_19_9	def read_properties ( fname ) parser = configparser . safe_config_parser ( ) parser . optionxform = str	1
Q_19	read property file	C_19_10	def read ( self , read_size = _ number ) string string string read_str = self . file . read ( read_size ) return len ( read_str ) , read_str	1
Q_19	read property file	C_19_11	def read_properties ( entry ) stream = entry . get ( string ) if stream is none raise exception ( string ) s = stream . open ( )	1
Q_19	read property file	C_19_12	def read ( self , read_size = none ) if read_size read_str = self . file . read ( read_size ) else read_str = self . file . read ( ) return len ( read_str ) , read_str	1
Q_19	read property file	C_19_13	def read_properties ( self ) string string string with self . _lock absolute_file_path = self . _file_path with open ( absolute_file_path , string ) as fp local_files , dir_files , eocd = parse_zip ( fp ) properties = read_json ( fp , local_files , dir_files , b string ) return properties	1
Q_19	read property file	C_19_14	def read_properties ( self ) string string string self . log ( u string )	1
Q_19	read property file	C_19_15	def from_file ( cls , file ) string string string opf_xml = etree . parse ( file )	1
Q_19	read property file	C_19_16	def read_properties ( self ) string string string self . log ( u string )	1
Q_19	read property file	C_19_17	def _read_properties ( ) init_path = os . path . abspath ( os . path . join ( string , string ) ) regex = re . compile ( string ( ? p < value > . * ) string ) with open ( init_path , string ) as f props = { } for var in f . readlines ( ) m = regex . match ( var ) if m is not none props [ m . group ( string ) ] = m . group ( string ) return props	1
Q_19	read property file	C_19_18	def read_properties ( self ) string string string with self . _lock absolute_file_path = self . _file_path with open ( absolute_file_path , string ) as fp local_files , dir_files , eocd = parse_zip ( fp ) properties = read_json ( fp , local_files , dir_files , b string ) return properties	1
Q_19	read property file	C_19_19	def from_file ( cls , file ) string string string opf_xml = etree . parse ( file )	0
Q_19	read property file	C_19_20	def read ( self , read_size = none ) if read_size read_str = self . file . read ( read_size ) else read_str = self . file . read ( ) return len ( read_str ) , read_str	0
Q_20	randomly extract x item from a list	C_20_0	def sample_lists ( items_list , num = number , seed = none ) r string string samples_list = s string string if seed is not none rng = np . random . random_state ( seed ) else rng = np . random def random_choice ( var , num ) size = min ( len ( var ) , num ) return rng . choice ( var , size , replace = false ) . tolist ( ) samples_list = [ random_choice ( var , num ) if len ( var ) > number else [ ] for var in items_list ] return samples_list	1
Q_20	randomly extract x item from a list	C_20_1	def random_sample ( list_ , n_sample , strict = false , rng = none , seed = none ) string string sample_list = s string string rng = ensure_rng ( seed if rng is none else rng ) if isinstance ( list_ , list ) list2_ = list_ [ ] else list2_ = np . copy ( list_ ) if len ( list2_ ) = = number and not strict return list2_ rng . shuffle ( list2_ ) if n_sample is none and strict is false return list2_ if not strict n_sample = min ( max ( number , n_sample ) , len ( list2_ ) ) sample_list = list2_ [ n_sample ] return sample_list	1
Q_20	randomly extract x item from a list	C_20_2	def random_sample ( list_ , n_sample , strict = false , rng = none , seed = none ) string string sample_list = s string string rng = ensure_rng ( seed if rng is none else rng ) if isinstance ( list_ , list ) list2_ = list_ [ ] else list2_ = np . copy ( list_ ) if len ( list2_ ) = = number and not strict return list2_ rng . shuffle ( list2_ ) if n_sample is none and strict is false return list2_ if not strict n_sample = min ( max ( number , n_sample ) , len ( list2_ ) ) sample_list = list2_ [ n_sample ] return sample_list	1
Q_20	randomly extract x item from a list	C_20_3	def weighted_random_choice ( items ) string string string l = list ( items ) r = random . random ( ) * sum ( [ var [ number ] for var in l ] ) for x , p in l if p > r return x r _ = p return none	1
Q_20	randomly extract x item from a list	C_20_4	def random_output ( self , max = number ) string string string output = [ ] item1 = item2 = markov_chain . start for var in range ( max _ number ) item3 = self [ ( item1 , item2 ) ] . roll ( ) if item3 is markov_chain . end break output . append ( item3 ) item1 = item2 item2 = item3 return output	1
Q_20	randomly extract x item from a list	C_20_5	def weighted_random_choice ( items ) string string string l = list ( items ) r = random . random ( ) * sum ( [ var [ number ] for var in l ] ) for x , p in l if p > r return x r _ = p return none	1
Q_20	randomly extract x item from a list	C_20_6	"def shuffle_sattolo ( items ) string string s algorithm . string "" _randrange = random . randrange for var in reversed ( range ( number , len ( items ) ) ) j = _randrange ( var )"	1
Q_20	randomly extract x item from a list	C_20_7	def find_a_prime ( a , b , k ) string string string x = random . randint ( a , b ) for var in range ( number , int ( number * math . log ( x ) + number ) ) if miller_rabin ( x , k ) return x else x + = number raise value_error	1
Q_20	randomly extract x item from a list	C_20_8	def _init_ ( self , query = none , extraction_sort = none , from_index = none , size = none , random_results = none , random_seed = none , score_relevance = none , return_max_score = none , timeout = none , * * kwargs ) string string string super ( base_returning_query , self ) . _init_ ( query = query , extraction_sort = extraction_sort , * * kwargs ) if string in string self . from_index = kwargs [ string ] self . _from = none self . from_index = from_index self . _size = none self . size = size self . _random_results = none self . random_results = random_results self . _random_seed = none self . random_seed = random_seed self . _score_relevance = none self . score_relevance = score_relevance self . _return_max_score = none self . return_max_score = return_max_score self . _timeout = none self . timeout = timeout	0
Q_20	randomly extract x item from a list	C_20_9	def solve_expensive_items_first ( capacity , items ) taken = [ number ] * len ( items ) value = number weight = number taken = [ number ] * len ( items ) sorted_list = sorted ( items , key = lambda dens dens [ number ] , reverse = true ) for var in sorted_list	0
Q_20	randomly extract x item from a list	C_20_10	def solve_expensive_items_first ( capacity , items ) taken = [ number ] * len ( items ) value = number weight = number taken = [ number ] * len ( items ) sorted_list = sorted ( items , key = lambda dens dens [ number ] , reverse = true ) for var in sorted_list	0
Q_20	randomly extract x item from a list	C_20_11	def _init_ ( self , query = none , extraction_sort = none , from_index = none , size = none , random_results = none , random_seed = none , score_relevance = none , return_max_score = none , timeout = none , * * kwargs ) string string string super ( base_returning_query , self ) . _init_ ( query = query , extraction_sort = extraction_sort , * * kwargs ) if string in string self . from_index = kwargs [ string ] self . _from = none self . from_index = from_index self . _size = none self . size = size self . _random_results = none self . random_results = random_results self . _random_seed = none self . random_seed = random_seed self . _score_relevance = none self . score_relevance = score_relevance self . _return_max_score = none self . return_max_score = return_max_score self . _timeout = none self . timeout = timeout	0
Q_20	randomly extract x item from a list	C_20_12	def tear_down_logger ( app_name ) logger = logging . get_logger ( app_name )	0
Q_20	randomly extract x item from a list	C_20_13	def flatten ( items , enter = lambda var isinstance ( var , list ) )	0
Q_20	randomly extract x item from a list	C_20_14	def flatten ( items , enter = lambda var isinstance ( var , list ) )	0
Q_20	randomly extract x item from a list	C_20_15	def find_a_prime ( a , b , k ) string string string x = random . randint ( a , b ) for var in range ( number , int ( number * math . log ( x ) + number ) ) if miller_rabin ( x , k ) return x else x + = number raise value_error	0
Q_20	randomly extract x item from a list	C_20_16	def random_output ( self , max = number ) string string string output = [ ] item1 = item2 = markov_chain . start for var in range ( max _ number ) item3 = self [ ( item1 , item2 ) ] . roll ( ) if item3 is markov_chain . end break output . append ( item3 ) item1 = item2 item2 = item3 return output	0
Q_20	randomly extract x item from a list	C_20_17	def tear_down_logger ( app_name ) logger = logging . get_logger ( app_name )	0
Q_20	randomly extract x item from a list	C_20_18	def flatten ( items , enter = lambda var isinstance ( var , list ) )	0
Q_20	randomly extract x item from a list	C_20_19	def flatten ( items , enter = lambda var isinstance ( var , list ) )	0
Q_21	priority queue	C_21_0	def push ( self , item , priority = none ) string string string priority = item if priority is none else priority node = priority_queue_node ( item , priority ) for var , var in enumerate ( self . priority_queue_list ) if var . priority < node . priority self . priority_queue_list . insert ( var , node ) return	1
Q_21	priority queue	C_21_1	def enqueue ( self , data , priority = none ) if priority raise not_implemented_error ( string string ) self . conn . lpush ( self . queue_key , data )	1
Q_21	priority queue	C_21_2	def _flush_queue ( self , q , ignore_priority = false ) string string string assert isinstance ( q , priority_queue ) current_timestamp = compute_release_time ( lag_in_minutes = number ) for var in range ( len ( q ) ) entry = q . pop ( ) assert isinstance ( entry , priority_entry ) if ignore_priority or entry . release_time < current_timestamp self . _resubmit_uow ( entry . entry ) else q . put ( entry ) break	1
Q_21	priority queue	C_21_3	def set_priority ( self , queue , priority ) string string string q = self . queueindex [ queue ] self . queues [ q [ number ] ] . remove_sub_queue ( q [ number ] ) new_priority = self . queues . setdefault ( priority , cb_queue . multi_queue ( self , priority ) ) q [ number ] = priority new_priority . add_sub_queue ( q [ number ] )	1
Q_21	priority queue	C_21_4	def push ( self , item , priority = none ) string string string priority = item if priority is none else priority node = priority_queue_node ( item , priority ) for var , var in enumerate ( self . priority_queue_list ) if var . priority < node . priority self . priority_queue_list . insert ( var , node ) return	1
Q_21	priority queue	C_21_5	def requeue_job ( self , job , queue , priority , delayed_for = none ) string string string job . requeue ( queue_name = queue . _cached_name , priority = priority , delayed_for = delayed_for , queue_model = self . queue_model ) if hasattr ( job , string ) job . on_requeued ( queue ) self . log ( self . job_requeue_message ( job , queue ) )	1
Q_21	priority queue	C_21_6	def on_priority ( self , * args ) if self . proxy [ string ] = self . priority self . proxy [ string ] = self . priority self . parent . restack ( )	1
Q_21	priority queue	C_21_7	def set_priority ( self , queue , priority ) string string string q = self . queueindex [ queue ] self . queues [ q [ number ] ] . remove_sub_queue ( q [ number ] ) new_priority = self . queues . setdefault ( priority , cb_queue . multi_queue ( self , priority ) ) q [ number ] = priority new_priority . add_sub_queue ( q [ number ] )	1
Q_21	priority queue	C_21_8	def _set_priority ( self , priority ) if not number < = priority < = number raise value_error ( string ) self . _priority = priority if self . is_alive ( ) self . priority = priority return priority	1
Q_21	priority queue	C_21_9	def requeue_job ( self , job , queue , priority , delayed_for = none ) string string string job . requeue ( queue_name = queue . _cached_name , priority = priority , delayed_for = delayed_for , queue_model = self . queue_model ) if hasattr ( job , string ) job . on_requeued ( queue ) self . log ( self . job_requeue_message ( job , queue ) )	1
Q_21	priority queue	C_21_10	def enqueue ( self , data , priority = none ) if priority raise not_implemented_error ( string string ) self . conn . lpush ( self . queue_key , data )	0
Q_21	priority queue	C_21_11	def _enqueue ( self , catcher , pillow , feathers , pass_thrower = false , * * ka ) if pillow . endswith ( string ) self . _enqueue_statefull ( catcher , pillow , pass_thrower ) else self . _normal_queue . append ( ( catcher , ( pillow , feathers ) , ka ) )	0
Q_21	priority queue	C_21_12	def on_priority ( self , * args ) if self . proxy [ string ] = self . priority self . proxy [ string ] = self . priority self . parent . restack ( )	0
Q_21	priority queue	C_21_13	def on_priority ( self , * args ) if self . proxy [ string ] = self . priority self . proxy [ string ] = self . priority self . parent . restack ( )	0
Q_21	priority queue	C_21_14	def _enqueue ( self , catcher , pillow , feathers , pass_thrower = false , * * ka ) if pillow . endswith ( string ) self . _enqueue_statefull ( catcher , pillow , pass_thrower ) else self . _normal_queue . append ( ( catcher , ( pillow , feathers ) , ka ) )	0
Q_21	priority queue	C_21_15	def _set_priority ( self , priority ) if not number < = priority < = number raise value_error ( string ) self . _priority = priority if self . is_alive ( ) self . priority = priority return priority	0
Q_21	priority queue	C_21_16	def get_priority ( priority ) string string string if isinstance ( priority , int ) if priority < number or priority > number raise value_error ( string ) return priority elif isinstance ( priority , priority ) return priority . value elif isinstance ( priority , str ) return priority [ priority . upper ( ) ] . value else raise type_error ( string )	0
Q_21	priority queue	C_21_17	def _flush_queue ( self , q , ignore_priority = false ) string string string assert isinstance ( q , priority_queue ) current_timestamp = compute_release_time ( lag_in_minutes = number ) for var in range ( len ( q ) ) entry = q . pop ( ) assert isinstance ( entry , priority_entry ) if ignore_priority or entry . release_time < current_timestamp self . _resubmit_uow ( entry . entry ) else q . put ( entry ) break	0
Q_21	priority queue	C_21_18	def on_priority ( self , * args ) if self . proxy [ string ] = self . priority self . proxy [ string ] = self . priority self . parent . restack ( )	0
Q_21	priority queue	C_21_19	def get_priority ( priority ) string string string if isinstance ( priority , int ) if priority < number or priority > number raise value_error ( string ) return priority elif isinstance ( priority , priority ) return priority . value elif isinstance ( priority , str ) return priority [ priority . upper ( ) ] . value else raise type_error ( string )	0
Q_21	priority queue	C_21_20	def _enqueue ( self , catcher , pillow , feathers , pass_thrower = false , * * ka ) if pillow . endswith ( string ) self . _enqueue_statefull ( catcher , pillow , pass_thrower ) else self . _normal_queue . append ( ( catcher , ( pillow , feathers ) , ka ) )	0
Q_22	print model summary	C_22_0	def summary ( self , header = true ) string string string table = [ ] for var in self . models model_summary = var . _model_json [ string ] [ string ] r_values = list ( model_summary . cell_values [ number ] ) r_values [ number ] = var . model_id table . append ( r_values )	1
Q_22	print model summary	C_22_1	def summary ( self , header = true ) string string string table = [ ] for var in self . models model_summary = var . _model_json [ string ] [ string ] r_values = list ( model_summary . cell_values [ number ] ) r_values [ number ] = var . model_id table . append ( r_values )	1
Q_22	print model summary	C_22_2	def summary ( model , print_layer_links , print_barracuda_json , print_tensors ) def array_without_brackets ( arr ) return str ( arr ) [ number _ number ]	1
Q_22	print model summary	C_22_3	def _print_summary ( module , case , summary ) try module . print_summary ( case , summary ) except ( not_implemented_error , attribute_error ) print ( string + case + string ) print ( string )	1
Q_22	print model summary	C_22_4	def _print_summary ( module , case , summary ) try try module . print_summary ( summary [ case ] ) except type_error module . print_summary ( case , summary [ case ] ) except ( not_implemented_error , attribute_error ) print ( string + case + string ) print ( string )	1
Q_22	print model summary	C_22_5	def summary ( model , input_size ) string string string def register_hook ( module ) def hook ( module , input , output ) class_name = str ( module . _class_ ) . split ( string ) [ _ number ] . split ( string string s _ i string input_shape string input_shape string output_shape string output_shape string output_shape string weight string size string trainable string bias string size string nb_params string _ string { > number } { > number } { > number } string layer ( type ) string output shape string param	1
Q_22	print model summary	C_22_6	def summary ( model , input_size ) string string string def register_hook ( module ) def hook ( module , input , output ) class_name = str ( module . _class_ ) . split ( string ) [ _ number ] . split ( string string s _ i string input_shape string input_shape string output_shape string output_shape string output_shape string weight string size string trainable string bias string size string nb_params string _ string { > number } { > number } { > number } string layer ( type ) string output shape string param	1
Q_22	print model summary	C_22_7	def summary ( self , input_size = none , hashsummary = false ) string string string if input_size is none print ( self ) print ( string * number ) number = sum ( var . numel ( ) for var in self . model . parameters ( ) ) print ( string . format ( number ) ) print ( string * number ) else summary ( self , input_size ) if hashsummary for idx , hashvalue in enumerate ( self . hashsummary ( ) ) print ( f string )	1
Q_22	print model summary	C_22_8	def _print_summary ( module , case , summary ) try try module . print_summary ( summary [ case ] ) except type_error module . print_summary ( case , summary [ case ] ) except ( not_implemented_error , attribute_error ) print ( string + case + string ) print ( string )	1
Q_22	print model summary	C_22_9	def summary ( self ) string string string if not self . _is_fitted raise attribute_error ( string )	1
Q_22	print model summary	C_22_10	def summary ( self ) string string string if not self . _is_fitted raise attribute_error ( string )	1
Q_22	print model summary	C_22_11	def print_summaries ( self ) string string string if hasattr ( self , string ) and hasattr ( self , string ) print ( string ) print ( self . fit_summary ) print ( string * number ) print ( self . summary ) else msg = string msg_2 = string raise not_implemented_error ( msg . format ( self . model_type ) + msg_2 ) return none	1
Q_22	print model summary	C_22_12	def summary ( model , print_layer_links , print_barracuda_json , print_tensors ) def array_without_brackets ( arr ) return str ( arr ) [ number _ number ]	1
Q_22	print model summary	C_22_13	def _print_summary ( module , case , summary ) try module . print_summary ( case , summary ) except ( not_implemented_error , attribute_error ) print ( string + case + string ) print ( string )	1
Q_22	print model summary	C_22_14	def summary ( self ) print ( string self . key ) print ( string self . max_steps ) self . _trace_summary ( ) ( val , arg ) = ( self . trace [ _ number ] ) if self . _termination_info ( success , best_val , arg ) = self . _termination_info condition = string if success else string print ( string ( condition , best_val , self . key , arg ) )	1
Q_22	print model summary	C_22_15	def summary ( self , input_size = none , hashsummary = false ) string string string if input_size is none print ( self ) print ( string * number ) number = sum ( var . numel ( ) for var in self . model . parameters ( ) ) print ( string . format ( number ) ) print ( string * number ) else summary ( self , input_size ) if hashsummary for idx , hashvalue in enumerate ( self . hashsummary ( ) ) print ( f string )	1
Q_22	print model summary	C_22_16	def print_diff ( self , summary1 = none , summary2 = none ) string string string summary . print_ ( self . diff ( summary1 = summary1 , summary2 = summary2 ) )	0
Q_22	print model summary	C_22_17	def print_diff ( self , summary1 = none , summary2 = none ) string string string summary . print_ ( self . diff ( summary1 = summary1 , summary2 = summary2 ) )	0
Q_22	print model summary	C_22_18	def print_diff ( self , summary1 = none , summary2 = none ) string string string summary . print_ ( self . diff ( summary1 = summary1 , summary2 = summary2 ) )	0
Q_23	pretty print json	C_23_0	def json_pretty_print ( d , file = none ) args = { string true , string number , string ( string , string ) } if file return json . dump ( d , file , * * args ) return json . dumps ( d , * * args )	1
Q_23	pretty print json	C_23_1	def to_json ( self , content , pretty_print = false ) string string string if py3 if isinstance ( content , bytes ) content = content . decode ( encoding = string ) if pretty_print json_ = self . _json_pretty_print ( content ) else json_ = json . loads ( content ) logger . info ( string ( content ) ) logger . info ( string ( pretty_print ) ) return json_	1
Q_23	pretty print json	C_23_2	def pprint ( j , no_pretty ) string string string if not no_pretty click . echo ( json . dumps ( j , cls = potion_json_encoder , sort_keys = true , indent = number , separators = ( string , string ) ) ) else click . echo ( j )	1
Q_23	pretty print json	C_23_3	def prettyprint ( d ) string string string print ( json . dumps ( d , sort_keys = true , indent = number , separators = ( string , string ) ) )	1
Q_23	pretty print json	C_23_4	def ppjson ( dumpit any , elide_to int = none ) _ > str string string . string string if elide_to is not none elide_to = max ( elide_to , number )	1
Q_23	pretty print json	C_23_5	def json_pretty_print ( s ) string string string s = json . loads ( s ) return json . dumps ( s , sort_keys = true , indent = number , separators = ( string , string ) )	1
Q_23	pretty print json	C_23_6	def json_pretty_print ( s ) string string string s = json . loads ( s ) return json . dumps ( s , sort_keys = true , indent = number , separators = ( string , string ) )	1
Q_23	pretty print json	C_23_7	def ppjson ( dumpit any , elide_to int = none ) _ > str string string . string string if elide_to is not none elide_to = max ( elide_to , number )	1
Q_23	pretty print json	C_23_8	def json_pretty_print ( d , file = none ) args = { string true , string number , string ( string , string ) } if file return json . dump ( d , file , * * args ) return json . dumps ( d , * * args )	1
Q_23	pretty print json	C_23_9	def pprint ( j , no_pretty ) string string string if not no_pretty click . echo ( json . dumps ( j , cls = potion_json_encoder , sort_keys = true , indent = number , separators = ( string , string ) ) ) else click . echo ( j )	1
Q_23	pretty print json	C_23_10	def output ( results , output_format = string ) if output_format = = string for var , var in results . items ( ) print ( string . format ( var , string . join ( var [ string ] ) ) ) elif output_format = = string print ( json . dumps ( results ) )	1
Q_23	pretty print json	C_23_11	def to_json ( self , content , pretty_print = false ) string string string if py3 if isinstance ( content , bytes ) content = content . decode ( encoding = string ) if pretty_print json_ = self . _json_pretty_print ( content ) else json_ = json . loads ( content ) logger . info ( string ( content ) ) logger . info ( string ( pretty_print ) ) return json_	1
Q_23	pretty print json	C_23_12	def output ( results , output_format = string ) if output_format = = string for var , var in results . items ( ) print ( string . format ( var , string . join ( var [ string ] ) ) ) elif output_format = = string print ( json . dumps ( results ) )	1
Q_24	postgresql connection	C_24_0	def get_connection ( engine , host , user , port , password , database , ssl = { } ) string string string if engine = = string	1
Q_24	postgresql connection	C_24_1	def initialize ( g , app ) string string string if string in app . config and string in app . config [ string ]	1
Q_24	postgresql connection	C_24_2	def initialize ( g , app ) string string string if string in app . config and string in app . config [ string ]	1
Q_24	postgresql connection	C_24_3	def _run_postgresql_commands ( host , user , password , database )	1
Q_24	postgresql connection	C_24_4	def _postgresql ( self , dbhost , dbport , dbname , dbuser , dbpass , dsn_style = none )	1
Q_24	postgresql connection	C_24_5	def conn ( host = none , user = none , password = none , init_fun = none , reset = false ) string string string if not hasattr ( conn , string ) or reset host = host if host is not none else config [ string ] user = user if user is not none else config [ string ] password = password if password is not none else config [ string ] if user is none	1
Q_24	postgresql connection	C_24_6	def get_connection ( engine , host , user , port , password , database , ssl = { } ) string string string if engine = = string	1
Q_24	postgresql connection	C_24_7	def get_conn ( self ) string string string conn = self . get_connection ( self . mssql_conn_id ) conn = pymssql . connect ( server = conn . host , user = conn . login , password = conn . password , database = self . schema or conn . schema , port = conn . port ) return conn	1
Q_24	postgresql connection	C_24_8	def conn ( host = none , user = none , password = none , init_fun = none , reset = false ) string string string if not hasattr ( conn , string ) or reset host = host if host is not none else config [ string ] user = user if user is not none else config [ string ] password = password if password is not none else config [ string ] if user is none	1
Q_24	postgresql connection	C_24_9	def role ( state , host , name , present = true , password = none , login = true , superuser = false , inherit = false , createdb = false , createrole = false , replication = false , connection_limit = none ,	1
Q_24	postgresql connection	C_24_10	def get_conn ( self ) string string string conn = self . get_connection ( self . mssql_conn_id ) conn = pymssql . connect ( server = conn . host , user = conn . login , password = conn . password , database = self . schema or conn . schema , port = conn . port ) return conn	1
Q_24	postgresql connection	C_24_11	def get_conn ( self ) string string string conn = self . get_connection ( self . mssql_conn_id ) conn = pymssql . connect ( server = conn . host , user = conn . login , password = conn . password , database = self . schema or conn . schema , port = conn . port ) return conn	1
Q_24	postgresql connection	C_24_12	def migrate ( self , connection )	1
Q_24	postgresql connection	C_24_13	def _postgresql ( self , dbhost , dbport , dbname , dbuser , dbpass , dsn_style = none )	1
Q_24	postgresql connection	C_24_14	def connection ( self ) string string string ctx = stack . top if ctx is none raise exception ( string string string string ) if hasattr ( ctx , string ) return ctx . ldap3_manager_main_connection else connection = self . _make_connection ( bind_user = self . config . get ( string ) , bind_password = self . config . get ( string ) , contextualise = false ) connection . bind ( ) if ctx is not none ctx . ldap3_manager_main_connection = connection return connection	1
Q_24	postgresql connection	C_24_15	def role ( state , host , name , present = true , password = none , login = true , superuser = false , inherit = false , createdb = false , createrole = false , replication = false , connection_limit = none ,	1
Q_24	postgresql connection	C_24_16	def get_conn ( self ) string string string conn = self . get_connection ( self . mssql_conn_id ) conn = pymssql . connect ( server = conn . host , user = conn . login , password = conn . password , database = self . schema or conn . schema , port = conn . port ) return conn	1
Q_24	postgresql connection	C_24_17	def _run_postgresql_commands ( host , user , password , database )	1
Q_24	postgresql connection	C_24_18	def conn ( host = none , user = none , password = none , init_fun = none , reset = false ) string string string if not hasattr ( conn , string ) or reset host = host if host is not none else config [ string ] user = user if user is not none else config [ string ] password = password if password is not none else config [ string ] if user is none	1
Q_24	postgresql connection	C_24_19	def connection ( self ) string string string ctx = stack . top if ctx is none raise exception ( string string string string ) if hasattr ( ctx , string ) return ctx . ldap3_manager_main_connection else connection = self . _make_connection ( bind_user = self . config . get ( string ) , bind_password = self . config . get ( string ) , contextualise = false ) connection . bind ( ) if ctx is not none ctx . ldap3_manager_main_connection = connection return connection	0
Q_24	postgresql connection	C_24_20	def migrate ( self , connection )	0
Q_24	postgresql connection	C_24_21	def get_conn ( self ) string string string conn = self . get_connection ( self . mssql_conn_id ) conn = pymssql . connect ( server = conn . host , user = conn . login , password = conn . password , database = self . schema or conn . schema , port = conn . port ) return conn	0
Q_24	postgresql connection	C_24_22	def get_conn ( self ) string string string conn = self . get_connection ( self . mssql_conn_id ) conn = pymssql . connect ( server = conn . host , user = conn . login , password = conn . password , database = self . schema or conn . schema , port = conn . port ) return conn	0
Q_25	position of substring in string	C_25_0	def substitute_globals ( string , globs = none ) sub = set ( re . findall ( string , string ) ) globs = globs or inspect . currentframe ( ) . f_back . f_globals if sub for var in map ( str , sub ) string = string . replace ( string var , globs [ var ] ) return string else return false	1
Q_25	position of substring in string	C_25_1	def get_substring_idxs ( substr , string ) string string string return [ var . start ( ) for var in re . finditer ( substr , string ) ]	1
Q_25	position of substring in string	C_25_2	def find_all_substrings ( string , substring ) string string string	1
Q_25	position of substring in string	C_25_3	def _string_substr ( self , start , length = none ) string string string op = ops . substring ( self , start , length ) return op . to_expr ( )	1
Q_25	position of substring in string	C_25_4	def get_substring_idxs ( substr , string ) string string string return [ var . start ( ) for var in re . finditer ( substr , string ) ]	1
Q_25	position of substring in string	C_25_5	def find_all_substrings ( string , substring ) string string string	1
Q_25	position of substring in string	C_25_6	def find_all_substrings ( string , substring ) string string string	1
Q_25	position of substring in string	C_25_7	def _call_ ( self , value ) for var in self . substrings if value . startswith ( var ) return value [ len ( var ) ] return value	1
Q_25	position of substring in string	C_25_8	def build_operation_stack ( string ) stack = [ ] start = number for var , var in enumerate ( string ) if var = = string substring = string [ start var ] start = var + number stack . append ( substring ) elif var = = string if var = start substring = string [ start var ] stack . append ( substring ) start = var + number elif var = = string if var = start substring = string [ start var ] stack . append ( substring ) start = var + number return stack	1
Q_25	position of substring in string	C_25_9	def _call_ ( self , value ) for var in self . substrings if value . startswith ( var ) return value [ len ( var ) ] return value	1
Q_25	position of substring in string	C_25_10	def search_nodenames ( self , * substrings str , name str = string ) _ > string string string test string dill string lahn_1 string nodenames string dill string lahn_1 string dill string lahn_1 string dill string lahn_1 string in < string > string dill string lahn_1 string test string dill string lahn_1 string land_dill string land_lahn_1 string land_lahn_2 string land_lahn_3 string stream_dill_lahn_2 string stream_lahn_1_lahn_2 string stream_lahn_2_lahn_3 string dill string lahn_1 string complete string lahn_2 string lahn_3 string land_dill string land_lahn_1 string land_lahn_2 string land_lahn_3 string stream_dill_lahn_2 string stream_lahn_1_lahn_2 string stream_lahn_2_lahn_3 string string try selection = selection ( name ) for var in self . nodes for substring in substrings if substring in var . name selection . nodes + = var break return selection except base_exception values = objecttools . enumeration ( substrings ) objecttools . augment_excmessage ( f string f string f string )	1
Q_25	position of substring in string	C_25_11	def deduplicate ( s , ch ) string string this is an irritating string with random spacing . string this is an irritating string with random spacing . string string return ch . join ( [ var for var in s . strip ( ) . split ( ch ) if var ] )	1
Q_25	position of substring in string	C_25_12	def _string_substr ( self , start , length = none ) string string string op = ops . substring ( self , start , length ) return op . to_expr ( )	1
Q_25	position of substring in string	C_25_13	def _call_ ( self , value ) for var in self . substrings if value . endswith ( var ) return value [ _ len ( var ) ] return value	1
Q_25	position of substring in string	C_25_14	def substitute_globals ( string , globs = none ) sub = set ( re . findall ( string , string ) ) globs = globs or inspect . currentframe ( ) . f_back . f_globals if sub for var in map ( str , sub ) string = string . replace ( string var , globs [ var ] ) return string else return false	0
Q_25	position of substring in string	C_25_15	def search_nodenames ( self , * substrings str , name str = string ) _ > string string string test string dill string lahn_1 string nodenames string dill string lahn_1 string dill string lahn_1 string dill string lahn_1 string in < string > string dill string lahn_1 string test string dill string lahn_1 string land_dill string land_lahn_1 string land_lahn_2 string land_lahn_3 string stream_dill_lahn_2 string stream_lahn_1_lahn_2 string stream_lahn_2_lahn_3 string dill string lahn_1 string complete string lahn_2 string lahn_3 string land_dill string land_lahn_1 string land_lahn_2 string land_lahn_3 string stream_dill_lahn_2 string stream_lahn_1_lahn_2 string stream_lahn_2_lahn_3 string string try selection = selection ( name ) for var in self . nodes for substring in substrings if substring in var . name selection . nodes + = var break return selection except base_exception values = objecttools . enumeration ( substrings ) objecttools . augment_excmessage ( f string f string f string )	0
Q_25	position of substring in string	C_25_16	def deduplicate ( s , ch ) string string this is an irritating string with random spacing . string this is an irritating string with random spacing . string string return ch . join ( [ var for var in s . strip ( ) . split ( ch ) if var ] )	0
Q_25	position of substring in string	C_25_17	def _call_ ( self , value ) for var in self . substrings if value . endswith ( var ) return value [ _ len ( var ) ] return value	0
Q_25	position of substring in string	C_25_18	def substitute_globals ( string , globs = none ) sub = set ( re . findall ( string , string ) ) globs = globs or inspect . currentframe ( ) . f_back . f_globals if sub for var in map ( str , sub ) string = string . replace ( string var , globs [ var ] ) return string else return false	0
Q_26	parse query string in url	C_26_0	def strip_url_params3 ( url , strip = none ) if not strip strip = [ ] parse = urllib . parse . urlparse ( url ) query = urllib . parse . parse_qs ( parse . query ) query = { var var [ number ] for var , var in query . items ( ) if var not in strip } query = urllib . parse . urlencode ( query ) new = parse . _replace ( query = query ) return new . geturl ( )	1
Q_26	parse query string in url	C_26_1	def _parse_url ( url ) p = urlsplit ( url ) query = { var var [ number ] for var , var in parse_qs ( p . query ) . items ( ) if len ( var ) = = number } return string . join ( [ p . netloc , p . path ] ) , query	1
Q_26	parse query string in url	C_26_2	def strip_url_params3 ( url , strip = none ) if not strip strip = [ ] parse = urllib . parse . urlparse ( url ) query = urllib . parse . parse_qs ( parse . query ) query = { var var [ number ] for var , var in query . items ( ) if var not in strip } query = urllib . parse . urlencode ( query ) new = parse . _replace ( query = query ) return new . geturl ( )	1
Q_26	parse query string in url	C_26_3	def url ( self ) _ > str string string string url_str = self . parse_url . path or string if self . parse_url . querystring is not none url_str + = string + self . parse_url . querystring return url_str	1
Q_26	parse query string in url	C_26_4	def _urlparse_qs ( url ) string string string	1
Q_26	parse query string in url	C_26_5	def _urlparse_qs ( url ) string string string	1
Q_26	parse query string in url	C_26_6	"def update_query ( url , params , remove = none ) string string s query parameters . replaces any current values if they are already present in the url . args url ( str ) the url to update . params ( mapping [ str , str ] ) a mapping of query parameter keys to values . remove ( sequence [ str ] ) parameters to remove from the query string . returns str the url with updated query parameters . examples url = string update_query ( url , { string string } ) http / / example . com ? a = number update_query ( url , { string string } ) http / / example . com ? a = number b = number update_query ( url , { string string } , remove = [ string ] ) http / / example . com ? b = number string "" if remove is none remove = [ ]"	1
Q_26	parse query string in url	C_26_7	def parse_query ( query , ilogger ) string string string	1
Q_26	parse query string in url	C_26_8	def _parse_url ( url_string ) u = urlparse ( url_string ) url = u . path query = parse_qs ( u . query ) return { string url_string . strip ( ) , string url . strip ( ) , string query }	1
Q_26	parse query string in url	C_26_9	def parse ( args , data ) url = urlparse ( data ) query = url . query if not args . no_query_params query = parse_qsl ( url . query ) return url , query	1
Q_26	parse query string in url	C_26_10	def url_parse_query ( query , encoding = none ) string string string if isinstance ( query , unicode ) if encoding is none encoding = url_encoding query = query . encode ( encoding , string )	1
Q_26	parse query string in url	C_26_11	def url_parse_query ( query , encoding = none ) string string string if isinstance ( query , unicode ) if encoding is none encoding = url_encoding query = query . encode ( encoding , string )	1
Q_26	parse query string in url	C_26_12	"def update_query ( url , params , remove = none ) string string s query parameters . replaces any current values if they are already present in the url . args url ( str ) the url to update . params ( mapping [ str , str ] ) a mapping of query parameter keys to values . remove ( sequence [ str ] ) parameters to remove from the query string . returns str the url with updated query parameters . examples url = string update_query ( url , { string string } ) http / / example . com ? a = number update_query ( url , { string string } ) http / / example . com ? a = number b = number update_query ( url , { string string } , remove = [ string ] ) http / / example . com ? b = number string "" if remove is none remove = [ ]"	1
Q_26	parse query string in url	C_26_13	def parse_query ( query , ilogger ) string string string	1
Q_26	parse query string in url	C_26_14	def url_parse_query ( query , encoding = none ) string string string if isinstance ( query , unicode ) if encoding is none encoding = url_encoding query = query . encode ( encoding , string )	1
Q_26	parse query string in url	C_26_15	"def update_query ( url , params , remove = none ) string string s query parameters . replaces any current values if they are already present in the url . args url ( str ) the url to update . params ( mapping [ str , str ] ) a mapping of query parameter keys to values . remove ( sequence [ str ] ) parameters to remove from the query string . returns str the url with updated query parameters . examples url = string update_query ( url , { string string } ) http / / example . com ? a = number update_query ( url , { string string } ) http / / example . com ? a = number b = number update_query ( url , { string string } , remove = [ string ] ) http / / example . com ? b = number string "" if remove is none remove = [ ]"	1
Q_26	parse query string in url	C_26_16	def _parse_url ( url ) p = urlsplit ( url ) query = { var var [ number ] for var , var in parse_qs ( p . query ) . items ( ) if len ( var ) = = number } return string . join ( [ p . netloc , p . path ] ) , query	1
Q_26	parse query string in url	C_26_17	def parse_url ( url )	1
Q_26	parse query string in url	C_26_18	def parse ( args , data ) url = urlparse ( data ) query = url . query if not args . no_query_params query = parse_qsl ( url . query ) return url , query	1
Q_26	parse query string in url	C_26_19	"def update_query ( url , params , remove = none ) string string s query parameters . replaces any current values if they are already present in the url . args url ( str ) the url to update . params ( mapping [ str , str ] ) a mapping of query parameter keys to values . remove ( sequence [ str ] ) parameters to remove from the query string . returns str the url with updated query parameters . examples url = string update_query ( url , { string string } ) http / / example . com ? a = number update_query ( url , { string string } ) http / / example . com ? a = number b = number update_query ( url , { string string } , remove = [ string ] ) http / / example . com ? b = number string "" if remove is none remove = [ ]"	1
Q_26	parse query string in url	C_26_20	def parse_url ( url )	1
Q_26	parse query string in url	C_26_21	def parse_query ( query , ilogger ) string string string	1
Q_26	parse query string in url	C_26_22	def url ( self ) _ > str string string string url_str = self . parse_url . path or string if self . parse_url . querystring is not none url_str + = string + self . parse_url . querystring return url_str	0
Q_27	parse json file	C_27_0	def _read_json_file ( path ) try with open ( path ) as f return json . load ( f ) except print ( string + path ) return none	1
Q_27	parse json file	C_27_1	def _parse_json_file ( self , file_path ) string string string if file_path = = string or os . path . splitext ( file_path ) [ number ] = string raise io_error ( string ) with open ( file_path ) as json_file self . _raw_data = json . load ( json_file ) self . _json_data = copy . deepcopy ( self . _raw_data )	1
Q_27	parse json file	C_27_2	def _read_json_file ( path ) try with open ( path ) as f return json . load ( f ) except print ( string + path ) return none	1
Q_27	parse json file	C_27_3	def _parse_json_file ( self , file_path ) string string string if file_path = = string or os . path . splitext ( file_path ) [ number ] = string raise io_error ( string ) with open ( file_path ) as json_file self . _raw_data = json . load ( json_file ) self . _json_data = copy . deepcopy ( self . _raw_data )	1
Q_27	parse json file	C_27_4	def parse_file_as_json ( self , myfile ) try content = json . loads ( myfile [ string ] ) except value_error log . warn ( string . format ( myfile [ string ] ) ) return run_id = content [ string ] if run_id not in self . bcl2fastq_data self . bcl2fastq_data [ run_id ] = dict ( ) run_data = self . bcl2fastq_data [ run_id ] for var in content . get ( string , [ ] ) l = var [ string ] lane = string . format ( var [ string ] ) if lane in run_data log . debug ( string . format ( self . prepend_runid ( run_id , lane ) ) ) run_data [ lane ] = { string number , string number , string number , string dict ( ) , string number , string number }	1
Q_27	parse json file	C_27_5	def parse_file ( self , file_content ) try return json . loads ( file_content ) except value_error as e raise i18n_file_load_error ( string . format ( e . strerror ) )	1
Q_27	parse json file	C_27_6	def parse ( json_text ) try j = json_parser . parse ( json_text ) except unexpected_input as u exc_class = u . match_examples ( json_parser . parse , { json_missing_opening [ string foo string , string foor string , string foo string ] , json_missing_closing [ string foo string , string , string a string , string ] , json_missing_comma [ string , string , string b string , string a string , string a string , string a string b string ] , json_trailing_comma [ string , string , string , string foo string , string foo string bar string ] } ) if not exc_class raise raise exc_class ( u . get_context ( json_text ) , u . line , u . column )	1
Q_27	parse json file	C_27_7	def parse ( json_text ) try j = json_parser . parse ( json_text ) except unexpected_input as u exc_class = u . match_examples ( json_parser . parse , { json_missing_opening [ string foo string , string foor string , string foo string ] , json_missing_closing [ string foo string , string , string a string , string ] , json_missing_comma [ string , string , string b string , string a string , string a string , string a string b string ] , json_trailing_comma [ string , string , string , string foo string , string foo string bar string ] } ) if not exc_class raise raise exc_class ( u . get_context ( json_text ) , u . line , u . column )	1
Q_27	parse json file	C_27_8	def parse_multiple_json ( json_file , offset = none ) string string string json_info_list = [ ] if not os . path . exists ( json_file ) return json_info_list try with open ( json_file , string ) as f if offset f . seek ( offset ) for var in f if var [ _ number ] = string	1
Q_27	parse json file	C_27_9	def parse_file ( self , f )	1
Q_27	parse json file	C_27_10	def parse_rc_json ( ) string string string fname = string path = os . path . expanduser ( string + fname ) if os . path . exists ( fname ) path = os . path . abspath ( fname ) elif not os . path . exists ( path ) path = string content = string if path with open ( path ) as f content = f . read ( ) ret = { } if content ret = json . loads ( content ) return collections . defaultdict ( dict , ret )	1
Q_27	parse json file	C_27_11	def parse_multiple_json ( json_file , offset = none ) string string string json_info_list = [ ] if not os . path . exists ( json_file ) return json_info_list try with open ( json_file , string ) as f if offset f . seek ( offset ) for var in f if var [ _ number ] = string	1
Q_27	parse json file	C_27_12	def parse_file ( self , f )	1
Q_27	parse json file	C_27_13	def parse_rc_json ( ) string string string fname = string path = os . path . expanduser ( string + fname ) if os . path . exists ( fname ) path = os . path . abspath ( fname ) elif not os . path . exists ( path ) path = string content = string if path with open ( path ) as f content = f . read ( ) ret = { } if content ret = json . loads ( content ) return collections . defaultdict ( dict , ret )	1
Q_27	parse json file	C_27_14	def parse_file_as_json ( self , myfile ) try content = json . loads ( myfile [ string ] ) except value_error log . warn ( string . format ( myfile [ string ] ) ) return run_id = content [ string ] if run_id not in self . bcl2fastq_data self . bcl2fastq_data [ run_id ] = dict ( ) run_data = self . bcl2fastq_data [ run_id ] for var in content . get ( string , [ ] ) l = var [ string ] lane = string . format ( var [ string ] ) if lane in run_data log . debug ( string . format ( self . prepend_runid ( run_id , lane ) ) ) run_data [ lane ] = { string number , string number , string number , string dict ( ) , string number , string number }	1
Q_27	parse json file	C_27_15	def parse_file ( self , f )	1
Q_27	parse json file	C_27_16	def parse_file ( self , file_content ) try return json . loads ( file_content ) except value_error as e raise i18n_file_load_error ( string . format ( e . strerror ) )	1
Q_27	parse json file	C_27_17	def post ( self , data = none , function = none , idempotent_key = none , * * kwargs )	0
Q_27	parse json file	C_27_18	def post ( self , data = none , function = none , idempotent_key = none , * * kwargs )	0
Q_28	parse command line argument	C_28_0	def parse_command_line_arguments ( ) parser = argparse . argument_parser ( description = string ) parser . add_argument ( string , help = string ) parser . add_argument ( string , string , nargs = number , type = float , help = string , required = true ) parser . add_argument ( string , string , type = int , help = string , required = true ) args = parser . parse_args ( ) return ( args )	1
Q_28	parse command line argument	C_28_1	def parse_command_line_arguments ( ) parser = argparse . argument_parser ( description = string ) parser . add_argument ( string , help = string , nargs = string , default = string ) parser . add_argument ( string , help = string , nargs = string , default = string ) parser . add_argument ( string , string , help = string , choices = potcar_sets ) return parser . parse_args ( )	1
Q_28	parse command line argument	C_28_2	def parse_commandline ( ) parser = argparse . argument_parser ( description = string ) parser . add_argument ( string , string , action = string , version = string . format ( _version_ , _licence_ ) , help = string ) parser . add_argument ( string , string , action = string , help = string ) parser . add_argument ( string , string , action = string , help = string ) parser . add_argument ( string , string , action = string , default = string , help = string ) parser . add_argument ( string , string , action = string , default = string , help = string ) args = parser . parse_args ( )	1
Q_28	parse command line argument	C_28_3	def parse_commandline ( ) parser = argparse . argument_parser ( description = string ) parser . add_argument ( string , string , action = string , version = string . format ( _version_ , _licence_ ) , help = string ) parser . add_argument ( string , string , action = string , help = string ) parser . add_argument ( string , string , action = string , help = string ) parser . add_argument ( string , string , action = string , default = string , help = string ) parser . add_argument ( string , string , action = string , default = string , help = string ) args = parser . parse_args ( )	1
Q_28	parse command line argument	C_28_4	def parse_command_line_arguments ( )	1
Q_28	parse command line argument	C_28_5	def parse_command_line_arguments ( )	1
Q_28	parse command line argument	C_28_6	def parse_command_line_arguments ( )	1
Q_28	parse command line argument	C_28_7	def parse_command_line_arguments ( ) parser = argparse . argument_parser ( description = string ) parser . add_argument ( string , help = string ) parser . add_argument ( string , string , nargs = number , type = float , help = string , required = true ) parser . add_argument ( string , string , type = int , help = string , required = true ) args = parser . parse_args ( ) return ( args )	1
Q_28	parse command line argument	C_28_8	def parse_command_line_arguments ( ) parser = argparse . argument_parser ( description = string ) parser . add_argument ( string , help = string ) parser . add_argument ( string , string , nargs = number , type = float , help = string , required = true ) parser . add_argument ( string , string , type = int , help = string , required = true ) args = parser . parse_args ( ) return ( args )	1
Q_28	parse command line argument	C_28_9	def parse_cmdln_args ( ) parser = argparse . argument_parser ( description = string ) parser . add_argument ( string , help = string , default = string ) parser . add_argument ( string , help = string ) parser . add_argument ( string , help = string ) args = parser . parse_args ( ) return ( args . log . upper ( ) , args . tc , args . ts )	1
Q_28	parse command line argument	C_28_10	def parse_command_line_arguments ( )	1
Q_28	parse command line argument	C_28_11	def parse_cmdln_args ( ) parser = argparse . argument_parser ( description = string ) parser . add_argument ( string , help = string , default = string ) parser . add_argument ( string , help = string ) parser . add_argument ( string , help = string ) args = parser . parse_args ( ) return ( args . log . upper ( ) , args . tc , args . ts )	1
Q_28	parse command line argument	C_28_12	def parse_command_line_arguments ( ) parser = argparse . argument_parser ( description = string ) parser . add_argument ( string , help = string ) parser . add_argument ( string , string , nargs = number , type = float , help = string , required = true ) parser . add_argument ( string , string , type = int , help = string , required = true ) args = parser . parse_args ( ) return ( args )	1
Q_28	parse command line argument	C_28_13	def parse_command_line_arguments ( )	1
Q_28	parse command line argument	C_28_14	def parse_cmdln_args ( ) parser = argparse . argument_parser ( description = string ) parser . add_argument ( string , help = string , default = string ) parser . add_argument ( string , help = string ) parser . add_argument ( string , help = string ) args = parser . parse_args ( ) return ( args . log . upper ( ) , args . tc , args . ts )	1
Q_28	parse command line argument	C_28_15	def main ( ) parser = argparse . argument_parser ( description = string ) parser . add_argument ( string , type = str , help = string , choices = commands . keys ( ) ) parser . add_argument ( string , metavar = string , type = str , nargs = string , help = string ) parser . add_argument ( string , action = string , default = false , dest = string , help = string ) args = parser . parse_args ( ) client = marketplace . client ( domain = config . marketplace_domain , protocol = config . marketplace_protocol , port = config . marketplace_port , consumer_key = config . consumer_key , consumer_secret = config . consumer_secret ) if args . verbose logger . set_level ( logging . debug ) if args . attrs result = commands [ args . method ] ( client , * args . attrs ) else result = commands [ args . method ] ( client ) if result [ string ] sys . stdout . write ( string result [ string ] ) else sys . stderr . write ( string result [ string ] ) sys . exit ( number )	1
Q_28	parse command line argument	C_28_16	def parse_command_line_arguments ( )	1
Q_28	parse command line argument	C_28_17	def main ( ) parser = argparse . argument_parser ( description = string ) parser . add_argument ( string , type = str , help = string , choices = commands . keys ( ) ) parser . add_argument ( string , metavar = string , type = str , nargs = string , help = string ) parser . add_argument ( string , action = string , default = false , dest = string , help = string ) args = parser . parse_args ( ) client = marketplace . client ( domain = config . marketplace_domain , protocol = config . marketplace_protocol , port = config . marketplace_port , consumer_key = config . consumer_key , consumer_secret = config . consumer_secret ) if args . verbose logger . set_level ( logging . debug ) if args . attrs result = commands [ args . method ] ( client , * args . attrs ) else result = commands [ args . method ] ( client ) if result [ string ] sys . stdout . write ( string result [ string ] ) else sys . stderr . write ( string result [ string ] ) sys . exit ( number )	1
Q_28	parse command line argument	C_28_18	def parse_command_line_arguments ( ) parser = argparse . argument_parser ( description = string ) parser . add_argument ( string , help = string , nargs = string , default = string ) parser . add_argument ( string , help = string , nargs = string , default = string ) parser . add_argument ( string , string , help = string , choices = potcar_sets ) return parser . parse_args ( )	1
Q_28	parse command line argument	C_28_19	def parseline ( self , line ) cmd , arg , line = cmd . parseline ( self , line ) if cmd and cmd . strip ( ) = string dof = getattr ( self , string + cmd , none ) argf = getattr ( self , string + cmd , none ) else argf = none if argf parser = argparse . argument_parser ( prog = cmd , description = getattr ( dof , string , none ) ) argf ( parser ) try arg = parser . parse_args ( shlex . split ( arg ) ) except system_exit , e return string , string , string return cmd , arg , line	1
Q_28	parse command line argument	C_28_20	def parseline ( self , line ) cmd , arg , line = cmd . parseline ( self , line ) if cmd and cmd . strip ( ) = string dof = getattr ( self , string + cmd , none ) argf = getattr ( self , string + cmd , none ) else argf = none if argf parser = argparse . argument_parser ( prog = cmd , description = getattr ( dof , string , none ) ) argf ( parser ) try arg = parser . parse_args ( shlex . split ( arg ) ) except system_exit , e return string , string , string return cmd , arg , line	1
Q_28	parse command line argument	C_28_21	def parseline ( self , line ) cmd , arg , line = cmd . parseline ( self , line ) if cmd and cmd . strip ( ) = string dof = getattr ( self , string + cmd , none ) argf = getattr ( self , string + cmd , none ) else argf = none if argf parser = argparse . argument_parser ( prog = cmd , description = getattr ( dof , string , none ) ) argf ( parser ) try arg = parser . parse_args ( shlex . split ( arg ) ) except system_exit , e return string , string , string return cmd , arg , line	1
Q_28	parse command line argument	C_28_22	def parse_command_line_arguments ( )	1
Q_28	parse command line argument	C_28_23	def get_complete ( command ) string string string assert isinstance ( command , click . command ) def complete_ ( self , text , line , begidx , endidx )	0
Q_28	parse command line argument	C_28_24	def get_complete ( command ) string string string assert isinstance ( command , click . command ) def complete_ ( self , text , line , begidx , endidx )	0
Q_29	parse binary file to custom class	C_29_0	def parse_bin ( path ) f = open ( path , string ) s = { }	1
Q_29	parse binary file to custom class	C_29_1	def parse_binary ( self , data , display ) class_type , length = struct . unpack ( string , data [ number ] ) class_struct = info_classes . get ( class_type , any_info ) class_data , _ = class_struct . parse_binary ( data , display ) data = data [ length * number ] return class_data , data	1
Q_29	parse binary file to custom class	C_29_2	def binary_file ( self , file = none ) string string string if file is none file = bytes_io ( ) self . _binary_file ( file ) return file	1
Q_29	parse binary file to custom class	C_29_3	def parse_binary ( self , data , display , rawdict = number ) string string string ret = { } val = struct . unpack ( self . static_codes , data [ self . static_size ] ) lengths = { } formats = { } vno = number for var in self . static_fields	1
Q_29	parse binary file to custom class	C_29_4	def _from_binary_reparse ( cls , binary_stream ) string string string string string string	1
Q_29	parse binary file to custom class	C_29_5	def parse_file_object ( self , parser_mediator , file_object ) string string string file_entry = parser_mediator . get_file_entry ( ) display_name = parser_mediator . get_display_name ( ) file_header_map = self . _get_data_type_map ( string ) try file_header , file_offset = self . _read_structure_from_file_object ( file_object , number , file_header_map ) except ( value_error , errors . parse_error ) as exception raise errors . unable_to_parse_file ( ( string string ) . format ( display_name , exception ) ) if file_header . unknown1 = number raise errors . unable_to_parse_file ( ( string string ) . format ( display_name , file_header . unknown1 ) ) if file_header . header_values_type > number raise errors . unable_to_parse_file ( ( string string ) . format ( display_name , file_header . header_values_type ) ) if file_header . header_values_type = = number data_map_name = string else data_map_name = string file_header_value_map = self . _get_data_type_map ( data_map_name ) try _ , value_data_size = self . _read_structure_from_file_object ( file_object , file_offset , file_header_value_map ) except ( value_error , errors . parse_error ) as exception raise errors . unable_to_parse_file ( ( string string ) . format ( display_name , exception ) ) file_offset + = value_data_size file_size = file_object . get_size ( ) remaining_file_size = file_size _ file_offset entry_header_map = self . _get_data_type_map ( string ) file_footer_map = self . _get_data_type_map ( string )	1
Q_29	parse binary file to custom class	C_29_6	def from_header ( self , binary ) string string string	1
Q_29	parse binary file to custom class	C_29_7	def parse_binary ( self , data , display , rawdict = number ) string string string ret = { } val = struct . unpack ( self . static_codes , data [ self . static_size ] ) lengths = { } formats = { } vno = number for var in self . static_fields	1
Q_29	parse binary file to custom class	C_29_8	def _from_binary_reparse ( cls , binary_stream ) string string string string string string	1
Q_29	parse binary file to custom class	C_29_9	def parse_file_object ( self , parser_mediator , file_object ) string string string file_entry = parser_mediator . get_file_entry ( ) display_name = parser_mediator . get_display_name ( ) file_header_map = self . _get_data_type_map ( string ) try file_header , file_offset = self . _read_structure_from_file_object ( file_object , number , file_header_map ) except ( value_error , errors . parse_error ) as exception raise errors . unable_to_parse_file ( ( string string ) . format ( display_name , exception ) ) if file_header . unknown1 = number raise errors . unable_to_parse_file ( ( string string ) . format ( display_name , file_header . unknown1 ) ) if file_header . header_values_type > number raise errors . unable_to_parse_file ( ( string string ) . format ( display_name , file_header . header_values_type ) ) if file_header . header_values_type = = number data_map_name = string else data_map_name = string file_header_value_map = self . _get_data_type_map ( data_map_name ) try _ , value_data_size = self . _read_structure_from_file_object ( file_object , file_offset , file_header_value_map ) except ( value_error , errors . parse_error ) as exception raise errors . unable_to_parse_file ( ( string string ) . format ( display_name , exception ) ) file_offset + = value_data_size file_size = file_object . get_size ( ) remaining_file_size = file_size _ file_offset entry_header_map = self . _get_data_type_map ( string ) file_footer_map = self . _get_data_type_map ( string )	1
Q_29	parse binary file to custom class	C_29_10	def parse_bin ( path ) f = open ( path , string ) s = { }	1
Q_29	parse binary file to custom class	C_29_11	def parse_bin ( path ) f = open ( path , string ) s = { }	1
Q_29	parse binary file to custom class	C_29_12	def from_header ( self , binary ) string string string	1
Q_29	parse binary file to custom class	C_29_13	def binary_file ( self , file = none ) string string string if file is none file = bytes_io ( ) self . _binary_file ( file ) return file	1
Q_29	parse binary file to custom class	C_29_14	def _run ( ) string string string args = parse_args ( )	0
Q_29	parse binary file to custom class	C_29_15	def _run ( ) string string string args = parse_args ( )	0
Q_29	parse binary file to custom class	C_29_16	def _init_ ( self , value ) string string string super ( binary_parser_exception , self ) . _init_ ( ) self . _value = value	0
Q_29	parse binary file to custom class	C_29_17	def console_type ( t = gtk . text_view ) class console_type ( t , _console ) _gsignals_ = { string ( gobject . signal_run_last , gobject . type_none , ( object , ) ) , string string } def _init_ ( self , * args , * * kwargs ) if gtk . pygtk_version [ number ] < number gobject . g_object . _init_ ( self ) else t . _init_ ( self ) _console . _init_ ( self , * args , * * kwargs ) def do_command ( self , code ) return _console . do_command ( self , code ) def do_key_press_event ( self , event ) return _console . do_key_press_event ( self , event , t ) if gtk . pygtk_version [ number ] < number gobject . type_register ( console_type ) return console_type	0
Q_29	parse binary file to custom class	C_29_18	def console_type ( t = gtk . text_view ) class console_type ( t , _console ) _gsignals_ = { string ( gobject . signal_run_last , gobject . type_none , ( object , ) ) , string string } def _init_ ( self , * args , * * kwargs ) if gtk . pygtk_version [ number ] < number gobject . g_object . _init_ ( self ) else t . _init_ ( self ) _console . _init_ ( self , * args , * * kwargs ) def do_command ( self , code ) return _console . do_command ( self , code ) def do_key_press_event ( self , event ) return _console . do_key_press_event ( self , event , t ) if gtk . pygtk_version [ number ] < number gobject . type_register ( console_type ) return console_type	0
Q_30	output to html file	C_30_0	def to_file ( self , outputfile = default_outputfile ) string string string if outputfile = no_outputfile if outputfile = = default_outputfile outputfile = string + str ( hash ( self ) ) + string	1
Q_30	output to html file	C_30_1	def generate_html ( ) string string string html_file = open ( html_filename , string ) html_file . write ( string ) html_file . write ( string ) for var in [ lines_filename , bars_filename , histogram_filename ] html_file . write ( string { number } string . format ( var ) ) html_file . write ( string ) html_file . close ( )	1
Q_30	output to html file	C_30_2	def html_index ( self , launch = true ) html = string html_files = [ var for var in self . files2 if var . endswith ( string ) ] for html_file in cm . abf_sort ( html_files ) if not html_file . endswith ( string ) continue name = html_file . split ( string ) [ number ] if name in self . groups . keys ( ) html + = string s string content string ( html_file , name ) html + = string color	1
Q_30	output to html file	C_30_3	def to_file ( self , outputfile = default_outputfile ) string string string if outputfile = no_outputfile if outputfile = = default_outputfile outputfile = string + str ( hash ( self ) ) + string	1
Q_30	output to html file	C_30_4	def generate_html ( ) string string string html_file = open ( html_filename , string ) html_file . write ( string ) html_file . write ( string ) for var in [ lines_filename , bars_filename , histogram_filename ] html_file . write ( string { number } string . format ( var ) ) html_file . write ( string ) html_file . close ( )	1
Q_30	output to html file	C_30_5	def to_html ( doc , output = string , style = string ) string string string	1
Q_30	output to html file	C_30_6	def to_html ( doc , output = string , style = string ) string string string	1
Q_30	output to html file	C_30_7	def _tmp_html_file ( self , content ) string string string self . log . debug ( string ) content = string string text _ align center string string locals ( ) now = datetime . now ( ) now = now . strftime ( string ) path_to_write_file = string locals ( ) try self . log . debug ( string ( path_to_write_file , ) ) write_file = codecs . open ( path_to_write_file , encoding = string , mode = string ) except io_error , e message = string ( path_to_write_file , ) self . log . critical ( message ) raise io_error ( message ) write_file . write ( content ) write_file . close ( ) self . log . debug ( string ) return path_to_write_file	1
Q_30	output to html file	C_30_8	def to_html_file ( self , path = string ) with open ( string . format ( path ) , string ) as file tpl = self . to_html ( ) file . write ( tpl )	1
Q_30	output to html file	C_30_9	def output_html ( self , root = false ) resources_dir = os . path . join ( os . path . dirname ( os . path . abspath ( _file_ ) ) , string ) with open ( os . path . join ( resources_dir , string ) ) as f css = f . read ( ) with open ( os . path . join ( resources_dir , string ) ) as f js = f . read ( ) with open ( os . path . join ( resources_dir , string ) ) as f jquery_js = f . read ( ) body = self . starting_frame ( root ) . as_html ( ) page = string string string . format ( css = css , js = js , jquery_js = jquery_js , body = body ) return page	1
Q_30	output to html file	C_30_10	def to_html_file ( self , path = string ) with open ( string . format ( path ) , string ) as file tpl = self . to_html ( ) file . write ( tpl )	1
Q_30	output to html file	C_30_11	def output_html_for_tuning ( self , audio_file_path , output_file_path , parameters = none ) string string string if not gf . file_can_be_written ( output_file_path ) self . log_exc ( u string s string ( output_file_path ) , none , true , os_error ) if parameters is none parameters = { } audio_file_path_absolute = gf . fix_slash ( os . path . abspath ( audio_file_path ) ) template_path_absolute = gf . absolute_path ( self . finetuneas_path , _file_ ) with io . open ( template_path_absolute , string , encoding = string ) as file_obj template = file_obj . read ( ) for var in self . finetuneas_replacements template = template . replace ( var [ number ] , var [ number ] ) template = template . replace ( self . finetuneas_replace_audiofilepath , u string file / / s string audio_file_path_absolute ) template = template . replace ( self . finetuneas_replace_fragments , u string self . json_string ) if gc . ppn_task_os_file_format in parameters output_format = parameters [ gc . ppn_task_os_file_format ] if output_format in self . finetuneas_allowed_formats template = template . replace ( self . finetuneas_replace_output_format , u string s string output_format ) if output_format = = string for key , placeholder , replacement in [ ( gc . ppn_task_os_file_smil_audio_ref , self . finetuneas_replace_smil_audioref , string s string ) , ( gc . ppn_task_os_file_smil_page_ref , self . finetuneas_replace_smil_pageref , string s string ) , ] if key in parameters template = template . replace ( placeholder , replacement parameters [ key ] ) with io . open ( output_file_path , string , encoding = string ) as file_obj file_obj . write ( template )	1
Q_30	output to html file	C_30_12	def output_html_for_tuning ( self , audio_file_path , output_file_path , parameters = none ) string string string if not gf . file_can_be_written ( output_file_path ) self . log_exc ( u string s string ( output_file_path ) , none , true , os_error ) if parameters is none parameters = { } audio_file_path_absolute = gf . fix_slash ( os . path . abspath ( audio_file_path ) ) template_path_absolute = gf . absolute_path ( self . finetuneas_path , _file_ ) with io . open ( template_path_absolute , string , encoding = string ) as file_obj template = file_obj . read ( ) for var in self . finetuneas_replacements template = template . replace ( var [ number ] , var [ number ] ) template = template . replace ( self . finetuneas_replace_audiofilepath , u string file / / s string audio_file_path_absolute ) template = template . replace ( self . finetuneas_replace_fragments , u string self . json_string ) if gc . ppn_task_os_file_format in parameters output_format = parameters [ gc . ppn_task_os_file_format ] if output_format in self . finetuneas_allowed_formats template = template . replace ( self . finetuneas_replace_output_format , u string s string output_format ) if output_format = = string for key , placeholder , replacement in [ ( gc . ppn_task_os_file_smil_audio_ref , self . finetuneas_replace_smil_audioref , string s string ) , ( gc . ppn_task_os_file_smil_page_ref , self . finetuneas_replace_smil_pageref , string s string ) , ] if key in parameters template = template . replace ( placeholder , replacement parameters [ key ] ) with io . open ( output_file_path , string , encoding = string ) as file_obj file_obj . write ( template )	1
Q_30	output to html file	C_30_13	def output_html_for_tuning ( self , audio_file_path , output_file_path , parameters = none ) string string string if not gf . file_can_be_written ( output_file_path ) self . log_exc ( u string s string ( output_file_path ) , none , true , os_error ) if parameters is none parameters = { } audio_file_path_absolute = gf . fix_slash ( os . path . abspath ( audio_file_path ) ) template_path_absolute = gf . absolute_path ( self . finetuneas_path , _file_ ) with io . open ( template_path_absolute , string , encoding = string ) as file_obj template = file_obj . read ( ) for var in self . finetuneas_replacements template = template . replace ( var [ number ] , var [ number ] ) template = template . replace ( self . finetuneas_replace_audiofilepath , u string file / / s string audio_file_path_absolute ) template = template . replace ( self . finetuneas_replace_fragments , u string self . json_string ) if gc . ppn_task_os_file_format in parameters output_format = parameters [ gc . ppn_task_os_file_format ] if output_format in self . finetuneas_allowed_formats template = template . replace ( self . finetuneas_replace_output_format , u string s string output_format ) if output_format = = string for key , placeholder , replacement in [ ( gc . ppn_task_os_file_smil_audio_ref , self . finetuneas_replace_smil_audioref , string s string ) , ( gc . ppn_task_os_file_smil_page_ref , self . finetuneas_replace_smil_pageref , string s string ) , ] if key in parameters template = template . replace ( placeholder , replacement parameters [ key ] ) with io . open ( output_file_path , string , encoding = string ) as file_obj file_obj . write ( template )	1
Q_30	output to html file	C_30_14	def output_html ( self , root = false ) resources_dir = os . path . join ( os . path . dirname ( os . path . abspath ( _file_ ) ) , string ) with open ( os . path . join ( resources_dir , string ) ) as f css = f . read ( ) with open ( os . path . join ( resources_dir , string ) ) as f js = f . read ( ) with open ( os . path . join ( resources_dir , string ) ) as f jquery_js = f . read ( ) body = self . starting_frame ( root ) . as_html ( ) page = string string string . format ( css = css , js = js , jquery_js = jquery_js , body = body ) return page	1
Q_30	output to html file	C_30_15	def html_index ( self , launch = true ) html = string html_files = [ var for var in self . files2 if var . endswith ( string ) ] for html_file in cm . abf_sort ( html_files ) if not html_file . endswith ( string ) continue name = html_file . split ( string ) [ number ] if name in self . groups . keys ( ) html + = string s string content string ( html_file , name ) html + = string color	0
Q_30	output to html file	C_30_16	def add_output_args ( arg_parser ) output_group = arg_parser . add_argument_group ( title = string , description = string ) output_group . add_argument ( string , default = none , help = string ) output_group . add_argument ( string , default = none , help = string ) output_group . add_argument ( string , default = string , help = string ) output_group . add_argument ( string , nargs = string ) output_group . add_argument ( string , nargs = number , action = string , help = ( string string ) ) output_group . add_argument ( string , default = false , action = string , help = string ) return output_group	0
Q_30	output to html file	C_30_17	def add_output_args ( arg_parser ) output_group = arg_parser . add_argument_group ( title = string , description = string ) output_group . add_argument ( string , default = none , help = string ) output_group . add_argument ( string , default = none , help = string ) output_group . add_argument ( string , default = string , help = string ) output_group . add_argument ( string , nargs = string ) output_group . add_argument ( string , nargs = number , action = string , help = ( string string ) ) output_group . add_argument ( string , default = false , action = string , help = string ) return output_group	0
Q_31	normal distribution	C_31_0	"def normal_distribution ( self , pos , sample ) string string s sample and target position parameters _ pos int the epoch number of the position you want to predict sample list sample is a ( number * num_of_functions ) matrix , representing { w1 , w2 , . wk } returns _ float the value of normal distribution string "" curr_sigma_sq = self . sigma_sq ( sample ) delta = self . trial_history [ pos _ number ] _ self . f_comb ( pos , sample ) return np . exp ( np . square ( delta ) / ( _ number . number * curr_sigma_sq ) ) / np . sqrt ( number * np . pi * np . sqrt ( curr_sigma_sq ) )"	1
Q_31	normal distribution	C_31_1	"def normal_distribution ( self , pos , sample ) string string s sample and target position parameters _ pos int the epoch number of the position you want to predict sample list sample is a ( number * num_of_functions ) matrix , representing { w1 , w2 , . wk } returns _ float the value of normal distribution string "" curr_sigma_sq = self . sigma_sq ( sample ) delta = self . trial_history [ pos _ number ] _ self . f_comb ( pos , sample ) return np . exp ( np . square ( delta ) / ( _ number . number * curr_sigma_sq ) ) / np . sqrt ( number * np . pi * np . sqrt ( curr_sigma_sq ) )"	1
Q_31	normal distribution	C_31_2	def normal_h1 ( size int = number , mean float = number , sigma float = number ) _ > histogram1_d string string string data = np . random . normal ( mean , sigma , ( size , ) ) return h1 ( data , name = string , axis_name = string , title = string )	1
Q_31	normal distribution	C_31_3	def normal_distribution ( mean , variance , minimum = none , maximum = none , weight_count = number ) string string string	1
Q_31	normal distribution	C_31_4	def normal_h1 ( size int = number , mean float = number , sigma float = number ) _ > histogram1_d string string string data = np . random . normal ( mean , sigma , ( size , ) ) return h1 ( data , name = string , axis_name = string , title = string )	1
Q_31	normal distribution	C_31_5	def normal_distribution ( mean , variance , minimum = none , maximum = none , weight_count = number ) string string string	1
Q_31	normal distribution	C_31_6	def _kl_normal_normal ( n_a , n_b , name = none ) string string kl_normal_normal string string with tf . name_scope ( name or string ) one = tf . constant ( number , dtype = n_a . dtype ) two = tf . constant ( number , dtype = n_a . dtype ) half = tf . constant ( number . number , dtype = n_a . dtype ) s_a_squared = tf . square ( n_a . scale ) s_b_squared = tf . square ( n_b . scale ) ratio = s_a_squared / s_b_squared return ( tf . square ( n_a . loc _ n_b . loc ) / ( two * s_b_squared ) + half * ( ratio _ one _ tf . math . log ( ratio ) ) )	1
Q_31	normal distribution	C_31_7	def tf_sample ( self , distr_params , deterministic ) mean , stddev , _ = distr_params	1
Q_31	normal distribution	C_31_8	def normal_h1 ( size int = number , mean float = number , sigma float = number ) _ > histogram1_d string string string data = np . random . normal ( mean , sigma , ( size , ) ) return h1 ( data , name = string , axis_name = string , title = string )	1
Q_31	normal distribution	C_31_9	def normal_distribution ( mean , variance , minimum = none , maximum = none , weight_count = number ) string string string	1
Q_31	normal distribution	C_31_10	def run_all ( logdir , verbose = false , num_summaries = number ) string string string del verbose tf . compat . v1 . set_random_seed ( number ) k = tf . compat . v1 . placeholder ( tf . float32 )	1
Q_31	normal distribution	C_31_11	def tf_sample ( self , distr_params , deterministic ) mean , stddev , _ = distr_params	1
Q_31	normal distribution	C_31_12	def _set_normal ( self , normal ) string string string for var , var in enumerate ( self . electrodes ) var . normal = normal / np . linalg . norm ( normal )	1
Q_31	normal distribution	C_31_13	def kl_divergence ( mu , log_var , mu_p = number . number , log_var_p = number . number ) string string string batch_size = shape_list ( mu ) [ number ] prior_distribution = tfp . distributions . normal ( mu_p , tf . exp ( tf . multiply ( number . number , log_var_p ) ) ) posterior_distribution = tfp . distributions . normal ( mu , tf . exp ( tf . multiply ( number . number , log_var ) ) ) kld = tfp . distributions . kl_divergence ( posterior_distribution , prior_distribution ) return tf . reduce_sum ( kld ) / to_float ( batch_size )	1
Q_31	normal distribution	C_31_14	def _call_ ( self , distribution_a )	1
Q_31	normal distribution	C_31_15	def _set_normal ( self , normal ) string string string for var , var in enumerate ( self . electrodes ) var . normal = normal / np . linalg . norm ( normal )	0
Q_31	normal distribution	C_31_16	def run_all ( logdir , verbose = false , num_summaries = number ) string string string del verbose tf . compat . v1 . set_random_seed ( number ) k = tf . compat . v1 . placeholder ( tf . float32 )	0
Q_31	normal distribution	C_31_17	def _call_ ( self , distribution_a )	0
Q_31	normal distribution	C_31_18	def _normalized_distro_name ( distro ) distro = distro . lower ( ) if distro . startswith ( ( string , string ) ) return string elif distro . startswith ( ( string , string ) ) return string elif distro . startswith ( string ) return string elif distro . startswith ( ( string , string , string ) ) return string elif distro . startswith ( string ) return string elif distro . startswith ( string ) return string elif distro . startswith ( string ) return string elif distro . startswith ( string ) return string elif distro . startswith ( ( string , string , string , string ) ) return string return distro	0
Q_31	normal distribution	C_31_19	def _normalized_distro_name ( distro ) distro = distro . lower ( ) if distro . startswith ( ( string , string ) ) return string elif distro . startswith ( ( string , string ) ) return string elif distro . startswith ( string ) return string elif distro . startswith ( ( string , string , string ) ) return string elif distro . startswith ( string ) return string elif distro . startswith ( string ) return string elif distro . startswith ( string ) return string elif distro . startswith ( string ) return string elif distro . startswith ( ( string , string , string , string ) ) return string return distro	0
Q_31	normal distribution	C_31_20	def kl_divergence ( mu , log_var , mu_p = number . number , log_var_p = number . number ) string string string batch_size = shape_list ( mu ) [ number ] prior_distribution = tfp . distributions . normal ( mu_p , tf . exp ( tf . multiply ( number . number , log_var_p ) ) ) posterior_distribution = tfp . distributions . normal ( mu , tf . exp ( tf . multiply ( number . number , log_var ) ) ) kld = tfp . distributions . kl_divergence ( posterior_distribution , prior_distribution ) return tf . reduce_sum ( kld ) / to_float ( batch_size )	0
Q_31	normal distribution	C_31_21	def _kl_normal_normal ( n_a , n_b , name = none ) string string kl_normal_normal string string with tf . name_scope ( name or string ) one = tf . constant ( number , dtype = n_a . dtype ) two = tf . constant ( number , dtype = n_a . dtype ) half = tf . constant ( number . number , dtype = n_a . dtype ) s_a_squared = tf . square ( n_a . scale ) s_b_squared = tf . square ( n_b . scale ) ratio = s_a_squared / s_b_squared return ( tf . square ( n_a . loc _ n_b . loc ) / ( two * s_b_squared ) + half * ( ratio _ one _ tf . math . log ( ratio ) ) )	0
Q_31	normal distribution	C_31_22	def _set_normal ( self , normal ) string string string for var , var in enumerate ( self . electrodes ) var . normal = normal / np . linalg . norm ( normal )	0
Q_31	normal distribution	C_31_23	def _set_normal ( self , normal ) string string string for var , var in enumerate ( self . electrodes ) var . normal = normal / np . linalg . norm ( normal )	0
Q_32	nelder mead optimize	C_32_0	def fit ( self , initial_parameters ) import sys import logging import warnings try from scipy . optimize import leastsq import scipy except import_error print ( string ) sys . exit ( number ) warnings . filterwarnings ( string ) def residuals ( p , eos , v , e ) return eos ( v , * p ) _ e try result = leastsq ( residuals , initial_parameters , args = ( self . _eos , self . _volume , self . _energy ) , full_output = number ) except runtime_error logging . exception ( string ) raise except ( runtime_warning , scipy . optimize . optimize . optimize_warning ) logging . exception ( string ) raise else self . parameters = result [ number ]	1
Q_32	nelder mead optimize	C_32_1	def optimize ( self , x0 , f = none , df = none , f_df = none ) string string string import scipy . optimize if f_df is none and df is not none f_df = lambda x float ( f ( x ) ) , df ( x ) if f_df is not none def _f_df ( x ) return f ( x ) , f_df ( x ) [ number ] [ number ] if f_df is none and df is none res = scipy . optimize . fmin_l_bfgs_b ( f , x0 = x0 , bounds = self . bounds , approx_grad = true , maxiter = self . maxiter ) else res = scipy . optimize . fmin_l_bfgs_b ( _f_df , x0 = x0 , bounds = self . bounds , maxiter = self . maxiter )	1
Q_32	nelder mead optimize	C_32_2	def scg ( f , gradf , x , optargs = ( ) , maxiters = number , max_f_eval = np . inf , xtol = none , ftol = none , gtol = none ) string string string if xtol is none xtol = number e _ number if ftol is none ftol = number e _ number if gtol is none gtol = number e _ number sigma0 = number . number e _ number fold = f ( x , * optargs )	1
Q_32	nelder mead optimize	C_32_3	def optimize ( self , duplicate_manager = none ) string string string if not self . analytical_gradient_acq out = self . optimizer . optimize ( f = self . acquisition_function , duplicate_manager = duplicate_manager ) else out = self . optimizer . optimize ( f = self . acquisition_function , f_df = self . acquisition_function_with_gradients , duplicate_manager = duplicate_manager ) return out	1
Q_32	nelder mead optimize	C_32_4	def scg ( f , gradf , x , optargs = ( ) , maxiters = number , max_f_eval = np . inf , xtol = none , ftol = none , gtol = none ) string string string if xtol is none xtol = number e _ number if ftol is none ftol = number e _ number if gtol is none gtol = number e _ number sigma0 = number . number e _ number fold = f ( x , * optargs )	1
Q_32	nelder mead optimize	C_32_5	def min_faktor ( mu , sigma , k , gamma = number ) d = mu . shape [ number ] log_s = np . zeros ( ( d _ number , ) )	1
Q_32	nelder mead optimize	C_32_6	def optimize ( self , x0 , f = none , df = none , f_df = none ) string string string import scipy . optimize if f_df is none and df is not none f_df = lambda x float ( f ( x ) ) , df ( x ) if f_df is not none def _f_df ( x ) return f ( x ) , f_df ( x ) [ number ] [ number ] if f_df is none and df is none res = scipy . optimize . fmin_l_bfgs_b ( f , x0 = x0 , bounds = self . bounds , approx_grad = true , maxiter = self . maxiter ) else res = scipy . optimize . fmin_l_bfgs_b ( _f_df , x0 = x0 , bounds = self . bounds , maxiter = self . maxiter )	1
Q_32	nelder mead optimize	C_32_7	def optimize ( self , duplicate_manager = none ) string string string if not self . analytical_gradient_acq out = self . optimizer . optimize ( f = self . acquisition_function , duplicate_manager = duplicate_manager ) else out = self . optimizer . optimize ( f = self . acquisition_function , f_df = self . acquisition_function_with_gradients , duplicate_manager = duplicate_manager ) return out	1
Q_32	nelder mead optimize	C_32_8	def min_faktor ( mu , sigma , k , gamma = number ) d = mu . shape [ number ] log_s = np . zeros ( ( d _ number , ) )	1
Q_32	nelder mead optimize	C_32_9	def optimize ( self , duplicate_manager = none ) string string string if not self . analytical_gradient_acq out = self . optimizer . optimize ( f = self . acquisition_function , duplicate_manager = duplicate_manager ) else out = self . optimizer . optimize ( f = self . acquisition_function , f_df = self . acquisition_function_with_gradients , duplicate_manager = duplicate_manager ) return out	1
Q_32	nelder mead optimize	C_32_10	def get_feature ( internel_layer , layers , filters , batch_norm = false , * * kwargs ) for var , var in enumerate ( layers ) for j in range ( var ) internel_layer = mx . sym . convolution ( data = internel_layer , kernel = ( number , number ) , pad = ( number , number ) , num_filter = filters [ var ] , name = string ( var + number , j + number ) ) if batch_norm internel_layer = mx . symbol . batch_norm ( data = internel_layer , name = string ( var + number , j + number ) ) internel_layer = mx . sym . activation ( data = internel_layer , act_type = string , name = string ( var + number , j + number ) ) internel_layer = mx . sym . pooling ( data = internel_layer , pool_type = string , kernel = ( number , number ) , stride = ( number , number ) , name = string ( var + number ) ) return internel_layer	0
Q_32	nelder mead optimize	C_32_11	def optimize_tc ( self ) string string string from scipy . optimize import minimize_scalar initial_tc = self . tc def cost ( tc ) self . set_tc ( tc ) return _ self . total_lh ( ) sol = minimize_scalar ( cost , bounds = [ ttconf . tiny_number , number . number ] ) if string in sol and sol [ string ] self . set_tc ( sol [ string ] ) else self . logger ( string + str ( sol ) , number , warn = true ) self . set_tc ( initial_tc . y , t = initial_tc . x )	0
Q_32	nelder mead optimize	C_32_12	def fit ( self , initial_parameters ) import sys import logging import warnings try from scipy . optimize import leastsq import scipy except import_error print ( string ) sys . exit ( number ) warnings . filterwarnings ( string ) def residuals ( p , eos , v , e ) return eos ( v , * p ) _ e try result = leastsq ( residuals , initial_parameters , args = ( self . _eos , self . _volume , self . _energy ) , full_output = number ) except runtime_error logging . exception ( string ) raise except ( runtime_warning , scipy . optimize . optimize . optimize_warning ) logging . exception ( string ) raise else self . parameters = result [ number ]	0
Q_32	nelder mead optimize	C_32_13	def get_feature ( internel_layer , layers , filters , batch_norm = false , * * kwargs ) for var , var in enumerate ( layers ) for j in range ( var ) internel_layer = mx . sym . convolution ( data = internel_layer , kernel = ( number , number ) , pad = ( number , number ) , num_filter = filters [ var ] , name = string ( var + number , j + number ) ) if batch_norm internel_layer = mx . symbol . batch_norm ( data = internel_layer , name = string ( var + number , j + number ) ) internel_layer = mx . sym . activation ( data = internel_layer , act_type = string , name = string ( var + number , j + number ) ) internel_layer = mx . sym . pooling ( data = internel_layer , pool_type = string , kernel = ( number , number ) , stride = ( number , number ) , name = string ( var + number ) ) return internel_layer	0
Q_33	memoize to disk _ persistent memoization	C_33_0	def memoize ( obj ) cache = obj . cache = { } functools . wraps ( obj ) def memoizer ( * args , * * kwargs ) key = tuple ( list ( args ) + sorted ( kwargs . items ( ) ) ) if key not in cache cache [ key ] = obj ( * args , * * kwargs ) return cache [ key ] return memoizer	1
Q_33	memoize to disk _ persistent memoization	C_33_1	def memoize ( f ) string string string	1
Q_33	memoize to disk _ persistent memoization	C_33_2	def memoize ( f ) string string string	1
Q_33	memoize to disk _ persistent memoization	C_33_3	def memoize ( func ) string string a string b string c string d string a string b string c string d string call memoized version string a string b string c string d string a string b string c string d string counter should no longer increase string closure changes result without memoization string a string c string a string c string a string b string c string d string string cache = func . _util_decor_memoize_cache = { }	1
Q_33	memoize to disk _ persistent memoization	C_33_4	def memoize ( self , obj )	1
Q_33	memoize to disk _ persistent memoization	C_33_5	def _run_node ( self , node ) string string s calculation plan and caches the results in the calc_dict . this should only be called by calc_dict itself internally . string string node s string string memoize string memoize string retrieved string cache_directory string cache_directory string unit_registry string unit_registry string pimms string number string loaded cache string t memoize / cache ) h = none ho = none res = none else h = none ho = none	1
Q_33	memoize to disk _ persistent memoization	C_33_6	def memoize ( self , code ) pk = hash ( self . as_grammar ( ) ) return string string string . format ( pk , self . _indent ( code , number ) , self . id , repr ( self . rulename ) )	1
Q_33	memoize to disk _ persistent memoization	C_33_7	def memoize ( cache = none ) string string string if cache is none cache = { } def memoize_decorator ( object ) string string string functools . wraps ( object ) def memoize_wrapper ( * args , * * kwargs ) string string string if kwargs key = args , frozenset ( kwargs . iteritems ( ) ) else key = args if key not in cache cache [ key ] = object ( * args , * * kwargs ) return cache [ key ] return memoize_wrapper return memoize_decorator	1
Q_33	memoize to disk _ persistent memoization	C_33_8	def _run_node ( self , node ) string string s calculation plan and caches the results in the calc_dict . this should only be called by calc_dict itself internally . string string node s string string memoize string memoize string retrieved string cache_directory string cache_directory string unit_registry string unit_registry string pimms string number string loaded cache string t memoize / cache ) h = none ho = none res = none else h = none ho = none	1
Q_33	memoize to disk _ persistent memoization	C_33_9	def memoize ( self , code ) pk = hash ( self . as_grammar ( ) ) return string string string . format ( pk , self . _indent ( code , number ) , self . id , repr ( self . rulename ) )	1
Q_33	memoize to disk _ persistent memoization	C_33_10	def memoize ( self , obj )	1
Q_33	memoize to disk _ persistent memoization	C_33_11	def memoize ( obj ) cache = obj . cache = { } functools . wraps ( obj ) def memoizer ( * args , * * kwargs ) key = tuple ( list ( args ) + sorted ( kwargs . items ( ) ) ) if key not in cache cache [ key ] = obj ( * args , * * kwargs ) return cache [ key ] return memoizer	1
Q_33	memoize to disk _ persistent memoization	C_33_12	def memoize ( func ) string string a string b string c string d string a string b string c string d string call memoized version string a string b string c string d string a string b string c string d string counter should no longer increase string closure changes result without memoization string a string c string a string c string a string b string c string d string string cache = func . _util_decor_memoize_cache = { }	1
Q_33	memoize to disk _ persistent memoization	C_33_13	def memoize ( cache_max_size = number ) def memoize_inner ( obj ) cache_name = str ( obj ) functools . wraps ( obj ) def wrapper ( self , * args , * * kwargs )	1
Q_33	memoize to disk _ persistent memoization	C_33_14	def memoize ( cache = none ) string string string if cache is none cache = { } def memoize_decorator ( object ) string string string functools . wraps ( object ) def memoize_wrapper ( * args , * * kwargs ) string string string if kwargs key = args , frozenset ( kwargs . iteritems ( ) ) else key = args if key not in cache cache [ key ] = object ( * args , * * kwargs ) return cache [ key ] return memoize_wrapper return memoize_decorator	1
Q_33	memoize to disk _ persistent memoization	C_33_15	def memoize ( obj ) cache = obj . cache = { } functools . wraps ( obj ) def memoizer ( * args , * * kwargs ) key = tuple ( list ( args ) + sorted ( kwargs . items ( ) ) ) if key not in cache cache [ key ] = obj ( * args , * * kwargs ) return cache [ key ] return memoizer	1
Q_33	memoize to disk _ persistent memoization	C_33_16	def memoize_by_args ( func ) string string string memory = { } functools . wraps ( func ) def memoized ( * args ) if args not in memory . keys ( ) value = func ( * args ) memory [ args ] = value return memory [ args ] return memoized	1
Q_33	memoize to disk _ persistent memoization	C_33_17	def memoize ( obj ) cache = obj . cache = { } functools . wraps ( obj ) def memoizer ( * args , * * kwargs ) key = tuple ( list ( args ) + sorted ( kwargs . items ( ) ) ) if key not in cache cache [ key ] = obj ( * args , * * kwargs ) return cache [ key ] return memoizer	0
Q_33	memoize to disk _ persistent memoization	C_33_18	def virtual_memory ( ) total , free , buffers , shared , _ , _ = _psutil_linux . get_sysinfo ( ) cached = active = inactive = none f = open ( string , string ) try for var in f if var . startswith ( string ) cached = int ( var . split ( ) [ number ] ) * number elif var . startswith ( string ) active = int ( var . split ( ) [ number ] ) * number elif var . startswith ( string ) inactive = int ( var . split ( ) [ number ] ) * number if cached is not none and active is not none and inactive is not none break else raise runtime_error ( string ) finally f . close ( ) avail = free + buffers + cached used = total _ free percent = usage_percent ( ( total _ avail ) , total , _round = number ) return nt_virtmem_info ( total , avail , percent , used , free , active , inactive , buffers , cached )	0
Q_33	memoize to disk _ persistent memoization	C_33_19	def memoize_by_args ( func ) string string string memory = { } functools . wraps ( func ) def memoized ( * args ) if args not in memory . keys ( ) value = func ( * args ) memory [ args ] = value return memory [ args ] return memoized	0
Q_34	matrix multiply	C_34_0	def _mul_ ( self , other ) if isinstance ( other , matrix ) return matrix ( self . matrix . dot ( other . matrix ) ) else return matrix ( self . matrix * other )	1
Q_34	matrix multiply	C_34_1	def _mul_ ( self , other ) if isinstance ( other , matrix ) return matrix ( self . matrix . dot ( other . matrix ) ) else return matrix ( self . matrix * other )	1
Q_34	matrix multiply	C_34_2	def multiply ( self , matrix ) string string string if not isinstance ( matrix , dense_matrix ) raise value_error ( string string ) j_model = self . _java_matrix_wrapper . call ( string , matrix ) return row_matrix ( j_model )	1
Q_34	matrix multiply	C_34_3	def _mul_ ( self , other ) if self . finalized dmat = self . _class_ ( ) dmat . shape = self . shape if isinstance ( other , sparse3_d_matrix )	1
Q_34	matrix multiply	C_34_4	def _mul_ ( self , other ) if self . finalized dmat = self . _class_ ( ) dmat . shape = self . shape if isinstance ( other , sparse3_d_matrix )	1
Q_34	matrix multiply	C_34_5	def mxmg ( m1 , m2 , nrow1 , ncol1 , ncol2 ) string string string m1 = stypes . to_double_matrix ( m1 ) m2 = stypes . to_double_matrix ( m2 ) mout = stypes . empty_double_matrix ( x = ncol2 , y = nrow1 ) nrow1 = ctypes . c_int ( nrow1 ) ncol1 = ctypes . c_int ( ncol1 ) ncol2 = ctypes . c_int ( ncol2 ) libspice . mxmg_c ( m1 , m2 , nrow1 , ncol1 , ncol2 , mout ) return stypes . c_matrix_to_numpy ( mout )	1
Q_34	matrix multiply	C_34_6	def mxmg ( m1 , m2 , nrow1 , ncol1 , ncol2 ) string string string m1 = stypes . to_double_matrix ( m1 ) m2 = stypes . to_double_matrix ( m2 ) mout = stypes . empty_double_matrix ( x = ncol2 , y = nrow1 ) nrow1 = ctypes . c_int ( nrow1 ) ncol1 = ctypes . c_int ( ncol1 ) ncol2 = ctypes . c_int ( ncol2 ) libspice . mxmg_c ( m1 , m2 , nrow1 , ncol1 , ncol2 , mout ) return stypes . c_matrix_to_numpy ( mout )	1
Q_34	matrix multiply	C_34_7	def multiply ( self , matrix ) positions = [ matrix * var for var in self . positions ] normals = list ( self . normals ) uvs = list ( self . uvs ) return mesh ( positions , normals , uvs )	1
Q_34	matrix multiply	C_34_8	def _mul_ ( self , m ) if hasattr ( m , string ) return matrix ( self . a * m , self . b * m , self . c * m , self . d * m , self . e * m , self . f * m ) m1 = matrix ( number , number ) return m1 . concat ( self , m )	1
Q_34	matrix multiply	C_34_9	def _mul_ ( self , other ) if isinstance ( other , matrix4 )	1
Q_34	matrix multiply	C_34_10	def _mul_ ( self , other ) if isinstance ( other , matrix4 )	1
Q_34	matrix multiply	C_34_11	def multiply ( self , matrix ) string string string if not isinstance ( matrix , dense_matrix ) raise value_error ( string string ) return indexed_row_matrix ( self . _java_matrix_wrapper . call ( string , matrix ) )	1
Q_34	matrix multiply	C_34_12	def multiply ( self , matrix ) string string string if not isinstance ( matrix , dense_matrix ) raise value_error ( string string ) return indexed_row_matrix ( self . _java_matrix_wrapper . call ( string , matrix ) )	1
Q_34	matrix multiply	C_34_13	def _mul_ ( self , m ) if hasattr ( m , string ) return matrix ( self . a * m , self . b * m , self . c * m , self . d * m , self . e * m , self . f * m ) m1 = matrix ( number , number ) return m1 . concat ( self , m )	1
Q_34	matrix multiply	C_34_14	def matrix_for_open_vr_matrix ( mat ) if len ( mat . m ) = = number	1
Q_34	matrix multiply	C_34_15	def multiply ( self , matrix ) positions = [ matrix * var for var in self . positions ] normals = list ( self . normals ) uvs = list ( self . uvs ) return mesh ( positions , normals , uvs )	1
Q_34	matrix multiply	C_34_16	def matrix_for_open_vr_matrix ( mat ) if len ( mat . m ) = = number	1
Q_34	matrix multiply	C_34_17	def _add_ ( self , other ) if isinstance ( other , matrix ) return matrix ( self . matrix + other . matrix ) else return matrix ( self . matrix + other )	1
Q_34	matrix multiply	C_34_18	def multiply ( self , matrix ) string string string if not isinstance ( matrix , dense_matrix ) raise value_error ( string string ) j_model = self . _java_matrix_wrapper . call ( string , matrix ) return row_matrix ( j_model )	1
Q_34	matrix multiply	C_34_19	def _add_ ( self , other ) if isinstance ( other , matrix ) return matrix ( self . matrix + other . matrix ) else return matrix ( self . matrix + other )	0
Q_34	matrix multiply	C_34_20	def matrix_for_open_vr_matrix ( mat ) if len ( mat . m ) = = number	0
Q_35	map to json	C_35_0	def maps_json ( ) string string string map_sources = { id { string map_source . id , string map_source . name , string map_source . folder , string map_source . min_zoom , string map_source . max_zoom , string [ { string var . min_zoom , string var . max_zoom , string var . tile_url . replace ( string , string ) , } for var in map_source . layers ] } for id , map_source in app . config [ string ] . items ( ) } return jsonify ( map_sources )	1
Q_35	map to json	C_35_1	def maps ( map_id = none , lang = string ) string string string if map_id cache_name = string ( map_id , lang ) params = { string map_id , string lang } else cache_name = string lang params = { string lang } data = get_cached ( string , cache_name , params = params ) . get ( string ) return data . get ( str ( map_id ) ) if map_id else data	1
Q_35	map to json	C_35_2	def to_json ( self ) map = dict ( ) map [ string ] = self . peer_pubkey map [ string ] = self . max_authorize map [ string ] = self . old_peer_cost map [ string ] = self . new_peer_cost map [ string ] = self . set_cost_view map [ string ] = self . field1 map [ string ] = self . field2 map [ string ] = self . field3 map [ string ] = self . field4 return map	1
Q_35	map to json	C_35_3	"def parse_json ( self , values_json ) string string t exist . value_error if values_json cannot be parsed . string "" values_map = json . loads ( values_json ) return self . override_from_dict ( values_map )"	1
Q_35	map to json	C_35_4	def _json_ ( self ) json = { string self . name , string self . id , string self . console , string self . console_type , string self . project . id , string self . vmx_path , string self . headless , string self . acpi_shutdown , string self . _adapters , string self . adapter_type , string self . use_any_adapter , string self . status , string self . working_path , string self . linked_clone } return json	1
Q_35	map to json	C_35_5	def from_json ( self , json_value ) self . index_all = json_value . get ( string , true ) self . max_depth = json_value . get ( string , _ number ) self . alias = none self . json_keys = { } if string in json_value self . alias = json_value [ string ] if string in json_value self . json_keys = json_value [ string ]	1
Q_35	map to json	C_35_6	def get_bpftool_map_ids ( self , map_file ) out = [ ] try map_data = json . load ( open ( map_file ) ) except exception as e self . _log_info ( string e ) return out for var in range ( len ( map_data ) ) if string in map_data [ var ] out . append ( map_data [ var ] [ string ] ) return out	1
Q_35	map to json	C_35_7	def to_json ( self ) map = dict ( ) map [ string ] = self . peer_pubkey map [ string ] = self . max_authorize map [ string ] = self . old_peer_cost map [ string ] = self . new_peer_cost map [ string ] = self . set_cost_view map [ string ] = self . field1 map [ string ] = self . field2 map [ string ] = self . field3 map [ string ] = self . field4 return map	1
Q_35	map to json	C_35_8	def to_json ( self ) map = dict ( ) map [ string ] = self . peer_pubkey map [ string ] = self . max_authorize map [ string ] = self . old_peer_cost map [ string ] = self . new_peer_cost map [ string ] = self . set_cost_view map [ string ] = self . field1 map [ string ] = self . field2 map [ string ] = self . field3 map [ string ] = self . field4 return map	1
Q_35	map to json	C_35_9	"def set_map_source ( self , map_src , jsonp_map = false ) string string map collection https / / code . highcharts . com / mapdata / string string no map source input , please refer to https / / code . highcharts . com / mapdata / string geojson string geojson string = highcharts . geojson ( string ) string var string head string map_data "" map_object ( self . map ) } )"	1
Q_35	map to json	C_35_10	def maps ( map_id = none , lang = string ) string string string if map_id cache_name = string ( map_id , lang ) params = { string map_id , string lang } else cache_name = string lang params = { string lang } data = get_cached ( string , cache_name , params = params ) . get ( string ) return data . get ( str ( map_id ) ) if map_id else data	1
Q_35	map to json	C_35_11	def generate_vector_color_map ( self ) string string string vector_stops = [ ]	1
Q_35	map to json	C_35_12	"def parse_json ( self , values_json ) string string t exist . value_error if values_json cannot be parsed . string "" values_map = json . loads ( values_json ) return self . override_from_dict ( values_map )"	1
Q_35	map to json	C_35_13	def maps_json ( ) string string string map_sources = { id { string map_source . id , string map_source . name , string map_source . folder , string map_source . min_zoom , string map_source . max_zoom , string [ { string var . min_zoom , string var . max_zoom , string var . tile_url . replace ( string , string ) , } for var in map_source . layers ] } for id , map_source in app . config [ string ] . items ( ) } return jsonify ( map_sources )	1
Q_35	map to json	C_35_14	def start_cleaning ( self , mode = number , navigation_mode = number , category = none , boundary_id = none )	1
Q_35	map to json	C_35_15	def start_cleaning ( self , mode = number , navigation_mode = number , category = none , boundary_id = none )	0
Q_35	map to json	C_35_16	def generate_vector_color_map ( self ) string string string vector_stops = [ ]	0
Q_35	map to json	C_35_17	"def set_map_source ( self , map_src , jsonp_map = false ) string string map collection https / / code . highcharts . com / mapdata / string string no map source input , please refer to https / / code . highcharts . com / mapdata / string geojson string geojson string = highcharts . geojson ( string ) string var string head string map_data "" map_object ( self . map ) } )"	0
Q_35	map to json	C_35_18	def to_json ( self ) map = dict ( ) map [ string ] = self . peer_pubkey map [ string ] = self . max_authorize map [ string ] = self . old_peer_cost map [ string ] = self . new_peer_cost map [ string ] = self . set_cost_view map [ string ] = self . field1 map [ string ] = self . field2 map [ string ] = self . field3 map [ string ] = self . field4 return map	0
Q_35	map to json	C_35_19	def maps ( map_id = none , lang = string ) string string string if map_id cache_name = string ( map_id , lang ) params = { string map_id , string lang } else cache_name = string lang params = { string lang } data = get_cached ( string , cache_name , params = params ) . get ( string ) return data . get ( str ( map_id ) ) if map_id else data	0
Q_35	map to json	C_35_20	def from_json ( self , json_value ) self . index_all = json_value . get ( string , true ) self . max_depth = json_value . get ( string , _ number ) self . alias = none self . json_keys = { } if string in json_value self . alias = json_value [ string ] if string in json_value self . json_keys = json_value [ string ]	0
Q_35	map to json	C_35_21	"def set_map_source ( self , map_src , jsonp_map = false ) string string map collection https / / code . highcharts . com / mapdata / string string no map source input , please refer to https / / code . highcharts . com / mapdata / string geojson string geojson string = highcharts . geojson ( string ) string var string head string map_data "" map_object ( self . map ) } )"	0
Q_35	map to json	C_35_22	def to_json ( self ) map = dict ( ) map [ string ] = self . peer_pubkey map [ string ] = self . max_authorize map [ string ] = self . old_peer_cost map [ string ] = self . new_peer_cost map [ string ] = self . set_cost_view map [ string ] = self . field1 map [ string ] = self . field2 map [ string ] = self . field3 map [ string ] = self . field4 return map	0
Q_35	map to json	C_35_23	def generate_vector_color_map ( self ) string string string vector_stops = [ ]	0
Q_35	map to json	C_35_24	def get_bpftool_map_ids ( self , map_file ) out = [ ] try map_data = json . load ( open ( map_file ) ) except exception as e self . _log_info ( string e ) return out for var in range ( len ( map_data ) ) if string in map_data [ var ] out . append ( map_data [ var ] [ string ] ) return out	0
Q_35	map to json	C_35_25	def _json_ ( self ) json = { string self . name , string self . id , string self . console , string self . console_type , string self . project . id , string self . vmx_path , string self . headless , string self . acpi_shutdown , string self . _adapters , string self . adapter_type , string self . use_any_adapter , string self . status , string self . working_path , string self . linked_clone } return json	0
Q_36	linear regression	C_36_0	"def linear_regression ( self , target , regression_length , mask = not_specified ) string string s number _ day returns against the number _ day returns of all other assets , computing each regression over number days . this can be achieved by doing the following returns = returns ( window_length = number ) returns_slice = returns [ sid ( number ) ] aapl_regressions = returns . linear_regression ( target = returns_slice , regression_length = number , ) this is equivalent to doing aapl_regressions = rolling_linear_regression_of_returns ( target = sid ( number ) , returns_length = number , regression_length = number , ) see also _ func scipy . stats . linregress class zipline . pipeline . factors . rolling_linear_regression_of_returns string "" from . statistical import rolling_linear_regression return rolling_linear_regression ( dependent = self , independent = target , regression_length = regression_length , mask = mask , )"	1
Q_36	linear regression	C_36_1	def func ( x , y ) from sklearn . linear_model import linear_regression from sklearn . model_selection import cross_val_score model = linear_regression ( ) model . fit ( x , y ) return model . predict ( x )	1
Q_36	linear regression	C_36_2	def linreg ( self , rsq = false , conf_test = false ) model = string if not self . datestack self . compute_dt_stats ( ) if np . isnan ( self . min_dt_ptp )	1
Q_36	linear regression	C_36_3	def fit_model ( regressor_type , regressor_kwargs , tf_matrix , target_gene_expression , early_stop_window_length = early_stop_window_length , seed = demon_seed ) string string string regressor_type = regressor_type . upper ( ) assert tf_matrix . shape [ number ] = = len ( target_gene_expression ) def do_sklearn_regression ( ) regressor = sklearn_regressor_factory [ regressor_type ] ( random_state = seed , * * regressor_kwargs ) with_early_stopping = is_oob_heuristic_supported ( regressor_type , regressor_kwargs ) if with_early_stopping regressor . fit ( tf_matrix , target_gene_expression , monitor = early_stop_monitor ( early_stop_window_length ) ) else regressor . fit ( tf_matrix , target_gene_expression ) return regressor if is_sklearn_regressor ( regressor_type ) return do_sklearn_regression ( )	1
Q_36	linear regression	C_36_4	"def lreg ( self , xcol , ycol , name = string ) string string s linear regression for a column string string can not calculate linear regression "" )"	1
Q_36	linear regression	C_36_5	def linear_regression ( self ) string string string model = linear_regression ( ) scores = [ ] kfold = k_fold ( n_splits = self . cv , shuffle = true , random_state = number ) for i , ( train , test ) in enumerate ( kfold . split ( self . baseline_in , self . baseline_out ) ) model . fit ( self . baseline_in . iloc [ train ] , self . baseline_out . iloc [ train ] ) scores . append ( model . score ( self . baseline_in . iloc [ test ] , self . baseline_out . iloc [ test ] ) ) mean_score = sum ( scores ) / len ( scores ) self . models . append ( model ) self . model_names . append ( string ) self . max_scores . append ( mean_score ) self . metrics [ string ] = { } self . metrics [ string ] [ string ] = mean_score self . metrics [ string ] [ string ] = self . adj_r2 ( mean_score , self . baseline_in . shape [ number ] , self . baseline_in . shape [ number ] )	1
Q_36	linear regression	C_36_6	def linear_regression ( x , y , add_intercept = true , coef_only = false , alpha = number . number number , as_dataframe = true , remove_na = false ) string string names string coef string se string t string pval string r2 string adj_r2 string ci [ number . number ] string ci [ number . number ] string coef string x string y string z string x string z string y string coef string string	1
Q_36	linear regression	C_36_7	def linear_regression ( x , y , add_intercept = true , coef_only = false , alpha = number . number number , as_dataframe = true , remove_na = false ) string string names string coef string se string t string pval string r2 string adj_r2 string ci [ number . number ] string ci [ number . number ] string coef string x string y string z string x string z string y string coef string string	1
Q_36	linear regression	C_36_8	def linear_regression ( self ) string string string model = linear_regression ( ) scores = [ ] kfold = k_fold ( n_splits = self . cv , shuffle = true , random_state = number ) for i , ( train , test ) in enumerate ( kfold . split ( self . baseline_in , self . baseline_out ) ) model . fit ( self . baseline_in . iloc [ train ] , self . baseline_out . iloc [ train ] ) scores . append ( model . score ( self . baseline_in . iloc [ test ] , self . baseline_out . iloc [ test ] ) ) mean_score = sum ( scores ) / len ( scores ) self . models . append ( model ) self . model_names . append ( string ) self . max_scores . append ( mean_score ) self . metrics [ string ] = { } self . metrics [ string ] [ string ] = mean_score self . metrics [ string ] [ string ] = self . adj_r2 ( mean_score , self . baseline_in . shape [ number ] , self . baseline_in . shape [ number ] )	1
Q_36	linear regression	C_36_9	def func ( x , y ) from sklearn . linear_model import linear_regression from sklearn . model_selection import cross_val_score model = linear_regression ( ) model . fit ( x , y ) return model . predict ( x )	1
Q_36	linear regression	C_36_10	def fit_model ( regressor_type , regressor_kwargs , tf_matrix , target_gene_expression , early_stop_window_length = early_stop_window_length , seed = demon_seed ) string string string regressor_type = regressor_type . upper ( ) assert tf_matrix . shape [ number ] = = len ( target_gene_expression ) def do_sklearn_regression ( ) regressor = sklearn_regressor_factory [ regressor_type ] ( random_state = seed , * * regressor_kwargs ) with_early_stopping = is_oob_heuristic_supported ( regressor_type , regressor_kwargs ) if with_early_stopping regressor . fit ( tf_matrix , target_gene_expression , monitor = early_stop_monitor ( early_stop_window_length ) ) else regressor . fit ( tf_matrix , target_gene_expression ) return regressor if is_sklearn_regressor ( regressor_type ) return do_sklearn_regression ( )	1
Q_36	linear regression	C_36_11	"def linear_regression ( self , target , regression_length , mask = not_specified ) string string s number _ day returns against the number _ day returns of all other assets , computing each regression over number days . this can be achieved by doing the following returns = returns ( window_length = number ) returns_slice = returns [ sid ( number ) ] aapl_regressions = returns . linear_regression ( target = returns_slice , regression_length = number , ) this is equivalent to doing aapl_regressions = rolling_linear_regression_of_returns ( target = sid ( number ) , returns_length = number , regression_length = number , ) see also _ func scipy . stats . linregress class zipline . pipeline . factors . rolling_linear_regression_of_returns string "" from . statistical import rolling_linear_regression return rolling_linear_regression ( dependent = self , independent = target , regression_length = regression_length , mask = mask , )"	1
Q_36	linear regression	C_36_12	def linear_regression ( self ) string string string model = linear_regression ( ) scores = [ ] kfold = k_fold ( n_splits = self . cv , shuffle = true , random_state = number ) for i , ( train , test ) in enumerate ( kfold . split ( self . baseline_in , self . baseline_out ) ) model . fit ( self . baseline_in . iloc [ train ] , self . baseline_out . iloc [ train ] ) scores . append ( model . score ( self . baseline_in . iloc [ test ] , self . baseline_out . iloc [ test ] ) ) mean_score = sum ( scores ) / len ( scores ) self . models . append ( model ) self . model_names . append ( string ) self . max_scores . append ( mean_score ) self . metrics [ string ] = { } self . metrics [ string ] [ string ] = mean_score self . metrics [ string ] [ string ] = self . adj_r2 ( mean_score , self . baseline_in . shape [ number ] , self . baseline_in . shape [ number ] )	1
Q_36	linear regression	C_36_13	"def regression ( self , slope = none ) string string t optimized returns _ dict regression parameters string string r_val "" ] = self . explained_variance ( ) return clock_model"	1
Q_36	linear regression	C_36_14	"def lreg ( self , xcol , ycol , name = string ) string string s linear regression for a column string string can not calculate linear regression "" )"	1
Q_36	linear regression	C_36_15	"def regression ( self , slope = none ) string string t optimized returns _ dict regression parameters string string r_val "" ] = self . explained_variance ( ) return clock_model"	1
Q_36	linear regression	C_36_16	def linear_regression ( self ) string string string model = linear_regression ( ) scores = [ ] kfold = k_fold ( n_splits = self . cv , shuffle = true , random_state = number ) for i , ( train , test ) in enumerate ( kfold . split ( self . baseline_in , self . baseline_out ) ) model . fit ( self . baseline_in . iloc [ train ] , self . baseline_out . iloc [ train ] ) scores . append ( model . score ( self . baseline_in . iloc [ test ] , self . baseline_out . iloc [ test ] ) ) mean_score = sum ( scores ) / len ( scores ) self . models . append ( model ) self . model_names . append ( string ) self . max_scores . append ( mean_score ) self . metrics [ string ] = { } self . metrics [ string ] [ string ] = mean_score self . metrics [ string ] [ string ] = self . adj_r2 ( mean_score , self . baseline_in . shape [ number ] , self . baseline_in . shape [ number ] )	1
Q_36	linear regression	C_36_17	def linreg ( self , rsq = false , conf_test = false ) model = string if not self . datestack self . compute_dt_stats ( ) if np . isnan ( self . min_dt_ptp )	1
Q_36	linear regression	C_36_18	def _linreg_model ( fitmodel ) output = string for var , var in result_iterator ( fitmodel ) if var = = string output + = string output + = string . join ( map ( str , var ) ) + string return output	0
Q_36	linear regression	C_36_19	"def regression ( self , slope = none ) string string t optimized returns _ dict regression parameters string string r_val "" ] = self . explained_variance ( ) return clock_model"	0
Q_36	linear regression	C_36_20	"def regression ( self , slope = none ) string string t optimized returns _ dict regression parameters string string r_val "" ] = self . explained_variance ( ) return clock_model"	0
Q_36	linear regression	C_36_21	def _linreg_model ( fitmodel ) output = string for var , var in result_iterator ( fitmodel ) if var = = string output + = string output + = string . join ( map ( str , var ) ) + string return output	0
Q_37	k mean cluster	C_37_0	def cluster_kmeans ( data , n_clusters , * * kwargs ) string string string km = cl . k_means ( n_clusters , * * kwargs ) kmf = km . fit ( data ) labels = kmf . labels_ return labels , [ np . nan ]	1
Q_37	k mean cluster	C_37_1	def optimal_clustering ( df , patch , method = string , statistic = string , max_k = number ) if len ( patch ) = = number return [ patch ] if statistic = = string if method = = string if len ( patch ) < = number k_max = number else k_max = min ( len ( patch ) / number , max_k ) clustering = { } db_index = [ ] x = df . ix [ patch , ] for var in range ( number , k_max + number ) kmeans = cluster . k_means ( n_clusters = var ) . fit ( x ) clustering [ var ] = pd . data_frame ( kmeans . predict ( x ) , index = patch ) dist_mu = squareform ( pdist ( kmeans . cluster_centers_ ) ) sigma = [ ] for i in range ( var ) points_in_cluster = clustering [ var ] [ clustering [ var ] [ number ] = = i ] . index sigma . append ( sqrt ( x . ix [ points_in_cluster , ] . var ( axis = number ) . sum ( ) ) ) db_index . append ( davies_bouldin ( dist_mu , np . array ( sigma ) ) ) db_index = np . array ( db_index ) k_optimal = np . argmin ( db_index ) + number return [ list ( clustering [ k_optimal ] [ clustering [ k_optimal ] [ number ] = = i ] . index ) for i in range ( k_optimal ) ] elif method = = string if len ( patch ) < = number k_max = number else k_max = min ( len ( patch ) / number , max_k ) clustering = { } db_index = [ ] x = df . ix [ patch , ] for var in range ( number , k_max + number ) agglomerative = cluster . agglomerative_clustering ( n_clusters = var , linkage = string ) . fit ( x ) clustering [ var ] = pd . data_frame ( agglomerative . fit_predict ( x ) , index = patch ) tmp = [ list ( clustering [ var ] [ clustering [ var ] [ number ] = = i ] . index ) for i in range ( var ) ] centers = np . array ( [ np . mean ( x . ix [ c , ] , axis = number ) for c in tmp ] ) dist_mu = squareform ( pdist ( centers ) ) sigma = [ ] for i in range ( var ) points_in_cluster = clustering [ var ] [ clustering [ var ] [ number ] = = i ] . index sigma . append ( sqrt ( x . ix [ points_in_cluster , ] . var ( axis = number ) . sum ( ) ) ) db_index . append ( davies_bouldin ( dist_mu , np . array ( sigma ) ) ) db_index = np . array ( db_index ) k_optimal = np . argmin ( db_index ) + number return [ list ( clustering [ k_optimal ] [ clustering [ k_optimal ] [ number ] = = i ] . index ) for i in range ( k_optimal ) ] elif statistic = = string x = np . array ( df . ix [ patch , ] ) if method = = string f = cluster . k_means gaps = gap ( x , ks = range ( number , min ( max_k , len ( patch ) ) ) , method = f ) k_optimal = list ( gaps ) . index ( max ( gaps ) ) + number clustering = pd . data_frame ( f ( n_clusters = k_optimal ) . fit_predict ( x ) , index = patch ) return [ list ( clustering [ clustering [ number ] = = i ] . index ) for i in range ( k_optimal ) ] else raise string	1
Q_37	k mean cluster	C_37_2	def kmeans_clustering ( self , numc , x = none , npcs = number ) string string string from sklearn . cluster import k_means if x is none d_sub = self . adata . uns [ string ] x = ( d_sub _ d_sub . mean ( number ) ) . dot ( self . adata . uns [ string ] . components_ [ npcs , ] . t ) save = true else save = false cl = k_means ( n_clusters = numc ) . fit_predict ( normalizer ( ) . fit_transform ( x ) ) if save self . adata . obs [ string ] = pd . categorical ( cl ) else return cl	1
Q_37	k mean cluster	C_37_3	def cluster_kmeans ( data = none , k = none , max_iter = number , tolerance = number e _ number , stride = number , metric = string , init_strategy = string , fixed_seed = false , n_jobs = none , chunksize = none , skip = number , keep_data = false , clustercenters = none , * * kwargs ) r string string euclidean string min_rmsd string string from pyemma . coordinates . clustering . kmeans import kmeans_clustering res = kmeans_clustering ( n_clusters = k , max_iter = max_iter , metric = metric , tolerance = tolerance , init_strategy = init_strategy , fixed_seed = fixed_seed , n_jobs = n_jobs , skip = skip , keep_data = keep_data , clustercenters = clustercenters , stride = stride ) from pyemma . util . reflection import get_default_args cs = _check_old_chunksize_arg ( chunksize , get_default_args ( cluster_kmeans ) [ string ] , * * kwargs ) if data is not none res . estimate ( data , chunksize = cs ) else res . chunksize = cs return res	1
Q_37	k mean cluster	C_37_4	def cluster_mini_batch_kmeans ( data = none , k = number , max_iter = number , batch_size = number . number , metric = string , init_strategy = string , n_jobs = none , chunksize = none , skip = number , clustercenters = none , * * kwargs ) r string string string from pyemma . coordinates . clustering . kmeans import mini_batch_kmeans_clustering res = mini_batch_kmeans_clustering ( n_clusters = k , max_iter = max_iter , metric = metric , init_strategy = init_strategy , batch_size = batch_size , n_jobs = n_jobs , skip = skip , clustercenters = clustercenters ) from pyemma . util . reflection import get_default_args cs = _check_old_chunksize_arg ( chunksize , get_default_args ( cluster_mini_batch_kmeans ) [ string ] , * * kwargs ) if data is not none res . estimate ( data , chunksize = cs ) else res . chunksize = chunksize return res	1
Q_37	k mean cluster	C_37_5	def cluster_mini_batch_kmeans ( data = none , k = number , max_iter = number , batch_size = number . number , metric = string , init_strategy = string , n_jobs = none , chunksize = none , skip = number , clustercenters = none , * * kwargs ) r string string string from pyemma . coordinates . clustering . kmeans import mini_batch_kmeans_clustering res = mini_batch_kmeans_clustering ( n_clusters = k , max_iter = max_iter , metric = metric , init_strategy = init_strategy , batch_size = batch_size , n_jobs = n_jobs , skip = skip , clustercenters = clustercenters ) from pyemma . util . reflection import get_default_args cs = _check_old_chunksize_arg ( chunksize , get_default_args ( cluster_mini_batch_kmeans ) [ string ] , * * kwargs ) if data is not none res . estimate ( data , chunksize = cs ) else res . chunksize = chunksize return res	1
Q_37	k mean cluster	C_37_6	def kmeans_clustering ( self , numc , x = none , npcs = number ) string string string from sklearn . cluster import k_means if x is none d_sub = self . adata . uns [ string ] x = ( d_sub _ d_sub . mean ( number ) ) . dot ( self . adata . uns [ string ] . components_ [ npcs , ] . t ) save = true else save = false cl = k_means ( n_clusters = numc ) . fit_predict ( normalizer ( ) . fit_transform ( x ) ) if save self . adata . obs [ string ] = pd . categorical ( cl ) else return cl	1
Q_37	k mean cluster	C_37_7	def cluster_mini_batch_kmeans ( data = none , k = number , max_iter = number , batch_size = number . number , metric = string , init_strategy = string , n_jobs = none , chunksize = none , skip = number , clustercenters = none , * * kwargs ) r string string string from pyemma . coordinates . clustering . kmeans import mini_batch_kmeans_clustering res = mini_batch_kmeans_clustering ( n_clusters = k , max_iter = max_iter , metric = metric , init_strategy = init_strategy , batch_size = batch_size , n_jobs = n_jobs , skip = skip , clustercenters = clustercenters ) from pyemma . util . reflection import get_default_args cs = _check_old_chunksize_arg ( chunksize , get_default_args ( cluster_mini_batch_kmeans ) [ string ] , * * kwargs ) if data is not none res . estimate ( data , chunksize = cs ) else res . chunksize = chunksize return res	1
Q_37	k mean cluster	C_37_8	def optimal_clustering ( df , patch , method = string , statistic = string , max_k = number ) if len ( patch ) = = number return [ patch ] if statistic = = string if method = = string if len ( patch ) < = number k_max = number else k_max = min ( len ( patch ) / number , max_k ) clustering = { } db_index = [ ] x = df . ix [ patch , ] for var in range ( number , k_max + number ) kmeans = cluster . k_means ( n_clusters = var ) . fit ( x ) clustering [ var ] = pd . data_frame ( kmeans . predict ( x ) , index = patch ) dist_mu = squareform ( pdist ( kmeans . cluster_centers_ ) ) sigma = [ ] for i in range ( var ) points_in_cluster = clustering [ var ] [ clustering [ var ] [ number ] = = i ] . index sigma . append ( sqrt ( x . ix [ points_in_cluster , ] . var ( axis = number ) . sum ( ) ) ) db_index . append ( davies_bouldin ( dist_mu , np . array ( sigma ) ) ) db_index = np . array ( db_index ) k_optimal = np . argmin ( db_index ) + number return [ list ( clustering [ k_optimal ] [ clustering [ k_optimal ] [ number ] = = i ] . index ) for i in range ( k_optimal ) ] elif method = = string if len ( patch ) < = number k_max = number else k_max = min ( len ( patch ) / number , max_k ) clustering = { } db_index = [ ] x = df . ix [ patch , ] for var in range ( number , k_max + number ) agglomerative = cluster . agglomerative_clustering ( n_clusters = var , linkage = string ) . fit ( x ) clustering [ var ] = pd . data_frame ( agglomerative . fit_predict ( x ) , index = patch ) tmp = [ list ( clustering [ var ] [ clustering [ var ] [ number ] = = i ] . index ) for i in range ( var ) ] centers = np . array ( [ np . mean ( x . ix [ c , ] , axis = number ) for c in tmp ] ) dist_mu = squareform ( pdist ( centers ) ) sigma = [ ] for i in range ( var ) points_in_cluster = clustering [ var ] [ clustering [ var ] [ number ] = = i ] . index sigma . append ( sqrt ( x . ix [ points_in_cluster , ] . var ( axis = number ) . sum ( ) ) ) db_index . append ( davies_bouldin ( dist_mu , np . array ( sigma ) ) ) db_index = np . array ( db_index ) k_optimal = np . argmin ( db_index ) + number return [ list ( clustering [ k_optimal ] [ clustering [ k_optimal ] [ number ] = = i ] . index ) for i in range ( k_optimal ) ] elif statistic = = string x = np . array ( df . ix [ patch , ] ) if method = = string f = cluster . k_means gaps = gap ( x , ks = range ( number , min ( max_k , len ( patch ) ) ) , method = f ) k_optimal = list ( gaps ) . index ( max ( gaps ) ) + number clustering = pd . data_frame ( f ( n_clusters = k_optimal ) . fit_predict ( x ) , index = patch ) return [ list ( clustering [ clustering [ number ] = = i ] . index ) for i in range ( k_optimal ) ] else raise string	1
Q_37	k mean cluster	C_37_9	def _kmeans ( x , n_clusters , max_iter , n_trials , tol ) string string string n_samples , n_features = x . shape [ number ] , x . shape [ number ] centers_best = np . empty ( shape = ( n_clusters , n_features ) , dtype = float ) labels_best = np . empty ( shape = n_samples , dtype = int ) for var in range ( n_trials ) centers , labels , sse_tot , sse_arr , n_iter = _kmeans_run ( x , n_clusters , max_iter , tol ) if var = = number sse_tot_best = sse_tot sse_arr_best = sse_arr n_iter_best = n_iter centers_best = centers . copy ( ) labels_best = labels . copy ( ) if sse_tot < sse_tot_best sse_tot_best = sse_tot sse_arr_best = sse_arr n_iter_best = n_iter centers_best = centers . copy ( ) labels_best = labels . copy ( ) return ( centers_best , labels_best , sse_arr_best , n_iter_best )	1
Q_37	k mean cluster	C_37_10	def eeg_microstates_clustering ( data , n_microstates = number , clustering_method = string , n_jobs = number , n_init = number , occurence_rejection_treshold = number . number number , max_refitting = number , verbose = true ) string string string	1
Q_37	k mean cluster	C_37_11	def eeg_microstates_clustering ( data , n_microstates = number , clustering_method = string , n_jobs = number , n_init = number , occurence_rejection_treshold = number . number number , max_refitting = number , verbose = true ) string string string	1
Q_37	k mean cluster	C_37_12	def cluster ( self , x ) x = super ( ) . cluster ( x ) self . _distances = linkage ( x , method = self . linkage ) if self . mode = = string return fcluster ( self . _distances , self . n_clusters , criterion = string ) elif self . mode = = string return fcluster ( self . _distances , self . max_distance , criterion = string ) else raise parameter_error ( f string { self . mode } string )	1
Q_37	k mean cluster	C_37_13	def elbow_method ( data , k_min , k_max , distance = string ) string string euclidean string string	1
Q_37	k mean cluster	C_37_14	def cluster ( self , x ) x = super ( ) . cluster ( x ) self . _distances = linkage ( x , method = self . linkage ) if self . mode = = string return fcluster ( self . _distances , self . n_clusters , criterion = string ) elif self . mode = = string return fcluster ( self . _distances , self . max_distance , criterion = string ) else raise parameter_error ( f string { self . mode } string )	1
Q_37	k mean cluster	C_37_15	def elbow_method ( data , k_min , k_max , distance = string ) string string euclidean string string	1
Q_37	k mean cluster	C_37_16	def eeg_microstates_clustering ( data , n_microstates = number , clustering_method = string , n_jobs = number , n_init = number , occurence_rejection_treshold = number . number number , max_refitting = number , verbose = true ) string string string	1
Q_37	k mean cluster	C_37_17	def _kmeans ( x , n_clusters , max_iter , n_trials , tol ) string string string n_samples , n_features = x . shape [ number ] , x . shape [ number ] centers_best = np . empty ( shape = ( n_clusters , n_features ) , dtype = float ) labels_best = np . empty ( shape = n_samples , dtype = int ) for var in range ( n_trials ) centers , labels , sse_tot , sse_arr , n_iter = _kmeans_run ( x , n_clusters , max_iter , tol ) if var = = number sse_tot_best = sse_tot sse_arr_best = sse_arr n_iter_best = n_iter centers_best = centers . copy ( ) labels_best = labels . copy ( ) if sse_tot < sse_tot_best sse_tot_best = sse_tot sse_arr_best = sse_arr n_iter_best = n_iter centers_best = centers . copy ( ) labels_best = labels . copy ( ) return ( centers_best , labels_best , sse_arr_best , n_iter_best )	1
Q_38	json to xml conversion	C_38_0	def convert ( self , content , conversion ) string string string if not conversion data = content elif self . format = = string data = json . loads ( content ) elif self . format = = string content = xml ( content ) first = list ( content . keys ( ) ) [ number ] data = content [ first ] else data = content return data	1
Q_38	json to xml conversion	C_38_1	def xml_to_json ( root ) string string string j = { } if len ( root ) = = number	1
Q_38	json to xml conversion	C_38_2	def to_xml ( self ) s = string number . number string utf _ number string s + = string http / / cloudfront . amazonaws . com / doc / number _ number number _ number number / string s + = string self . caller_reference if self . comment s + = string self . comment s + = string return s	1
Q_38	json to xml conversion	C_38_3	def convert ( self , content , conversion ) string string string if not conversion data = content elif self . format = = string data = json . loads ( content ) elif self . format = = string content = xml ( content ) first = list ( content . keys ( ) ) [ number ] data = content [ first ] else data = content return data	1
Q_38	json to xml conversion	C_38_4	def tmdd_to_json ( doc ) converters = tmdd_event_converter . list_from_document ( doc ) events = [ var . to_json ( ) for var in converters ] return { string dict ( version = string ) , string events }	1
Q_38	json to xml conversion	C_38_5	def json ( self , conversion _text = string ) _ > mapping string string string if not self . _json if conversion is string from xmljson import badgerfish as serializer elif conversion is string from xmljson import abdera as serializer elif conversion is string from xmljson import cobra as serializer elif conversion is string from xmljson import gdata as serializer elif conversion is string from xmljson import parker as serializer elif conversion is string from xmljson import yahoo as serializer self . _json = json . dumps ( serializer . data ( etree . fromstring ( self . xml ) ) ) return self . _json	1
Q_38	json to xml conversion	C_38_6	def keywords_json ( soup , html_flag = true )	1
Q_38	json to xml conversion	C_38_7	def _xml_to_json_places ( tree , is_reverse = false ) string string string select_multi = ( string if not is_reverse else string ) adresses = tree . findall ( string + select_multi ) places = [ ] sel_pl = string { } string for var in adresses el = { } el [ string ] = var . find ( string ) el [ string ] = var . find ( string ) el [ string ] = var . find ( string ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( string ) el [ string ] = var . find ( string ) place = { } def test_content_attrib ( selector , key ) string string string return selector . attrib . get ( key , none ) if selector is not none else none place [ string ] = test_content_attrib ( var . find ( string ) , string ) place [ string ] = test_content_attrib ( var . find ( string ) , string ) place [ string ] = test_content_attrib ( var . find ( string ) , string ) place [ string ] = test_content_attrib ( var . find ( string ) , string ) for key , value in iteritems ( el ) if value is not none place [ key ] = value . text if value . text is none place [ key ] = none else place [ key ] = none	1
Q_38	json to xml conversion	C_38_8	def xml_to_root ( xml union [ str , io ] ) _ > element_tree . element string string string if isinstance ( xml , str ) if string in xml return element_tree . fromstring ( xml ) else with open ( xml ) as fh xml_to_root ( fh ) tree = element_tree . parse ( xml ) return tree . getroot ( )	0
Q_38	json to xml conversion	C_38_9	def xml_to_json ( root ) string string string j = { } if len ( root ) = = number	0
Q_38	json to xml conversion	C_38_10	def to_xml ( self ) s = string number . number string utf _ number string s + = string http / / cloudfront . amazonaws . com / doc / number _ number number _ number number / string s + = string self . caller_reference if self . comment s + = string self . comment s + = string return s	0
Q_38	json to xml conversion	C_38_11	def to_xml ( self ) s = string number . number string utf _ number string s + = string http / / cloudfront . amazonaws . com / doc / number _ number number _ number number / string s + = string self . caller_reference if self . comment s + = string self . comment s + = string return s	0
Q_38	json to xml conversion	C_38_12	def _xml_to_json_places ( tree , is_reverse = false ) string string string select_multi = ( string if not is_reverse else string ) adresses = tree . findall ( string + select_multi ) places = [ ] sel_pl = string { } string for var in adresses el = { } el [ string ] = var . find ( string ) el [ string ] = var . find ( string ) el [ string ] = var . find ( string ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( sel_pl . format ( string ) ) el [ string ] = var . find ( string ) el [ string ] = var . find ( string ) place = { } def test_content_attrib ( selector , key ) string string string return selector . attrib . get ( key , none ) if selector is not none else none place [ string ] = test_content_attrib ( var . find ( string ) , string ) place [ string ] = test_content_attrib ( var . find ( string ) , string ) place [ string ] = test_content_attrib ( var . find ( string ) , string ) place [ string ] = test_content_attrib ( var . find ( string ) , string ) for key , value in iteritems ( el ) if value is not none place [ key ] = value . text if value . text is none place [ key ] = none else place [ key ] = none	0
Q_38	json to xml conversion	C_38_13	def to_xml ( self ) s = string number . number string utf _ number string s + = string http / / cloudfront . amazonaws . com / doc / number _ number number _ number number / string s + = string self . caller_reference if self . comment s + = string self . comment s + = string return s	0
Q_39	initialize array	C_39_0	def zeros ( stype , shape , ctx = none , dtype = none , * * kwargs ) string string row_sparse string csr string csr string row_sparse string float16 string string	1
Q_39	initialize array	C_39_1	def _get_real_imag_array ( array ) string string string imag_array = _np . array ( [ var . imag for var in array ] ) real_array = _np . array ( [ var . real for var in array ] ) return real_array , imag_array	1
Q_39	initialize array	C_39_2	def initialize ( self ) for var in self . lslist var . initialize ( )	1
Q_39	initialize array	C_39_3	def _init_arrays ( self , size = number ) if self . initialized self . _cluster_hits = np . zeros ( shape = ( size , ) , dtype = np . dtype ( self . _cluster_hits_descr ) ) self . _clusters = np . zeros ( shape = ( size , ) , dtype = np . dtype ( self . _cluster_descr ) ) self . _assigned_hit_array = np . zeros ( shape = ( size , ) , dtype = np . bool ) self . _cluster_hit_indices = np . empty ( shape = ( size , ) , dtype = np_int_type_chooser ( size ) ) self . _cluster_hit_indices . fill ( _ number )	1
Q_39	initialize array	C_39_4	def zeros ( stype , shape , ctx = none , dtype = none , * * kwargs ) string string row_sparse string csr string csr string row_sparse string float16 string string	1
Q_39	initialize array	C_39_5	def _get_real_imag_array ( array ) string string string imag_array = _np . array ( [ var . imag for var in array ] ) real_array = _np . array ( [ var . real for var in array ] ) return real_array , imag_array	1
Q_39	initialize array	C_39_6	def initialize ( self ) line_sink_string_base . initialize ( self ) self . aq . add_element ( self )	1
Q_39	initialize array	C_39_7	def initialize ( self ) self . state = self . init_func ( ) if isinstance ( self . state , xr . data_array ) self . shape_info = { string self . state . dims , string self . state . coords }	1
Q_39	initialize array	C_39_8	def initialize ( self ) string string string self . initialize_virtual_params ( ) self . initialize_callbacks ( ) self . initialize_criterion ( ) self . initialize_module ( ) self . initialize_optimizer ( ) self . initialize_history ( ) self . initialized_ = true return self	1
Q_39	initialize array	C_39_9	def _get_real_imag_array ( array ) string string string imag_array = _np . array ( [ var . imag for var in array ] ) real_array = _np . array ( [ var . real for var in array ] ) return real_array , imag_array	1
Q_39	initialize array	C_39_10	def initialize ( self ) string string string self . initialize_virtual_params ( ) self . initialize_callbacks ( ) self . initialize_criterion ( ) self . initialize_module ( ) self . initialize_optimizer ( ) self . initialize_history ( ) self . initialized_ = true return self	1
Q_39	initialize array	C_39_11	def _get_real_imag_array ( array ) string string string imag_array = _np . array ( [ var . imag for var in array ] ) real_array = _np . array ( [ var . real for var in array ] ) return real_array , imag_array	1
Q_39	initialize array	C_39_12	def _init ( init , x , n , rank , dtype ) string string string uinit = [ none for var in range ( n ) ] if isinstance ( init , list ) uinit = init elif init = = string for n in range ( number , n ) uinit [ n ] = array ( rand ( x . shape [ n ] , rank ) , dtype = dtype ) elif init = = string for n in range ( number , n ) uinit [ n ] = array ( nvecs ( x , n , rank ) , dtype = dtype ) else raise string str ( init ) return uinit	0
Q_39	initialize array	C_39_13	def initialize ( self ) self . state = self . init_func ( ) if isinstance ( self . state , xr . data_array ) self . shape_info = { string self . state . dims , string self . state . coords }	0
Q_39	initialize array	C_39_14	def initialize ( self ) line_sink_string_base . initialize ( self ) self . aq . add_element ( self )	0
Q_39	initialize array	C_39_15	def initializing ( self , initializing ) validate_attribute ( initializing , string , expected_type = initialize , required = false ) self . _initializing = initializing	0
Q_39	initialize array	C_39_16	def _init_arrays ( self , size = number ) if self . initialized self . _cluster_hits = np . zeros ( shape = ( size , ) , dtype = np . dtype ( self . _cluster_hits_descr ) ) self . _clusters = np . zeros ( shape = ( size , ) , dtype = np . dtype ( self . _cluster_descr ) ) self . _assigned_hit_array = np . zeros ( shape = ( size , ) , dtype = np . bool ) self . _cluster_hit_indices = np . empty ( shape = ( size , ) , dtype = np_int_type_chooser ( size ) ) self . _cluster_hit_indices . fill ( _ number )	0
Q_39	initialize array	C_39_17	def _plot_by_priority ( self , priority , fmtos , initializing = false ) def update ( var ) other_fmto = self . _shared . get ( var . key ) if other_fmto self . logger . debug ( string , var . key , other_fmto . plotter . logger . name ) other_fmto . share ( var , initializing = initializing )	0
Q_39	initialize array	C_39_18	def _plot_by_priority ( self , priority , fmtos , initializing = false ) def update ( var ) other_fmto = self . _shared . get ( var . key ) if other_fmto self . logger . debug ( string , var . key , other_fmto . plotter . logger . name ) other_fmto . share ( var , initializing = initializing )	0
Q_39	initialize array	C_39_19	def initializing ( self , initializing ) validate_attribute ( initializing , string , expected_type = initialize , required = false ) self . _initializing = initializing	0
Q_39	initialize array	C_39_20	def _init ( init , x , n , rank , dtype ) string string string uinit = [ none for var in range ( n ) ] if isinstance ( init , list ) uinit = init elif init = = string for n in range ( number , n ) uinit [ n ] = array ( rand ( x . shape [ n ] , rank ) , dtype = dtype ) elif init = = string for n in range ( number , n ) uinit [ n ] = array ( nvecs ( x , n , rank ) , dtype = dtype ) else raise string str ( init ) return uinit	0
Q_39	initialize array	C_39_21	def _get_real_imag_array ( array ) string string string imag_array = _np . array ( [ var . imag for var in array ] ) real_array = _np . array ( [ var . real for var in array ] ) return real_array , imag_array	0
Q_40	httpclient post json	C_40_0	async def _http_post ( self , url , data ) data = json . dumps ( data ) headers = { string string . format ( self . token ) , string string } res = await self . session . request ( string , full_sj_url + url , data = data , headers = headers , params = { string string , string string , string number , string string } ) ret = await res . json ( ) return ret	1
Q_40	httpclient post json	C_40_1	def post ( self , json = none ) string string string return self . _call ( string , url = self . endpoint , json = json )	1
Q_40	httpclient post json	C_40_2	def request ( self , url , json = string , data = string , username = string , password = string , headers = none , timout = number ) string string string raise not_implemented_error ( string string string string )	1
Q_40	httpclient post json	C_40_3	def make_jsonrpc_call ( self , url , method , params ) client = http_client ( ) body = json . dumps ( { string string , string method , string params , string string . join ( [ random . choice ( string . ascii_letters ) for var in range ( number ) ] ) } ) request = http_request ( url , method = string , headers = { string string } , body = body ) result = client . fetch ( request ) return result	1
Q_40	httpclient post json	C_40_4	def post ( self , json = none ) response = self . _http ( requests . post , json = json ) if response . status_code = = number return response . json ( )	1
Q_40	httpclient post json	C_40_5	def _post_json ( self , url , data , * * kwargs )	1
Q_40	httpclient post json	C_40_6	def post_json ( session , url , json ) string string string res = session . post ( url , json = json ) if res . status_code > = number raise parse_error ( res ) return res	1
Q_40	httpclient post json	C_40_7	def request ( self , url , json = string , data = string , username = string , password = string , headers = none , timout = number ) string string string raise not_implemented_error ( string string string string )	1
Q_40	httpclient post json	C_40_8	def postjson ( request , url , data ) if isinstance ( data , dict ) or isinstance ( data , list ) or isinstance ( data , tuple ) data = json . dumps ( data ) if url and url [ number ] = = string url = url [ number ] docservereq = request ( string + settings . foliadocserve_host + string + str ( settings . foliadocserve_port ) + string + url + string + sid )	1
Q_40	httpclient post json	C_40_9	def post ( self , json = none ) response = self . _http ( requests . post , json = json ) if response . status_code = = number return response . json ( )	1
Q_40	httpclient post json	C_40_10	def _post_json ( self , url , data , * * kwargs )	1
Q_40	httpclient post json	C_40_11	def post_json ( session , url , json ) string string string res = session . post ( url , json = json ) if res . status_code > = number raise parse_error ( res ) return res	1
Q_40	httpclient post json	C_40_12	def post ( self , json = none ) string string string return self . _call ( string , url = self . endpoint , json = json )	0
Q_40	httpclient post json	C_40_13	def request ( self , url , json = string , data = string , username = string , password = string , headers = none , timout = number ) string string string raise not_implemented_error ( string string string string )	0
Q_40	httpclient post json	C_40_14	def postjson ( request , url , data ) if isinstance ( data , dict ) or isinstance ( data , list ) or isinstance ( data , tuple ) data = json . dumps ( data ) if url and url [ number ] = = string url = url [ number ] docservereq = request ( string + settings . foliadocserve_host + string + str ( settings . foliadocserve_port ) + string + url + string + sid )	0
Q_41	html entity replace	C_41_0	def replace ( html , replacements = none ) string string string if not replacements return html	1
Q_41	html entity replace	C_41_1	def replace_entities ( self , html ) string string string def fixup ( text ) string string string text = text . group ( number ) if text [ number ] = = string	1
Q_41	html entity replace	C_41_2	def escape ( t ) string string string return ( t	1
Q_41	html entity replace	C_41_3	def htmlentityreplace_errors ( ex ) string string the cost was u20ac12 . string latin1 string htmlentityreplace string the cost was euro number . string string if isinstance ( ex , unicode_encode_error )	1
Q_41	html entity replace	C_41_4	def escape ( self , string ) string string < string > string string string html_entities = { string string , string string , string string } return html ( string . join ( html_entities . get ( var , var ) for var in string ) )	1
Q_41	html entity replace	C_41_5	def apply_entities_as_html ( text , entities ) string string string escapes = { string string , string string , string string , } formatters = { string lambda s , e string + s + string , string lambda s , e string + s + string , string lambda s , e string string url string string + s + string , string lambda s , e string tg / / user ? id = string user string id string string + s + string , string lambda s , e string + s + string , string lambda s , e string + s + string } return _apply_entities ( text , entities , escapes , formatters )	1
Q_41	html entity replace	C_41_6	def htmlentityreplace_errors ( ex ) string string the cost was u20ac12 . string latin1 string htmlentityreplace string the cost was euro number . string string if isinstance ( ex , unicode_encode_error )	1
Q_41	html entity replace	C_41_7	def prepare ( self , html )	1
Q_41	html entity replace	C_41_8	def make_entities_code ( entities ) entities_text = string . join ( string s string s string ( var , entities [ var ] . encode ( string ) . replace ( string string string ) ) for var in sorted ( entities . keys ( ) ) ) return string string string entities_text	1
Q_41	html entity replace	C_41_9	def escape ( t ) string string string return ( t	1
Q_41	html entity replace	C_41_10	def escape ( self , string ) string string < string > string string string html_entities = { string string , string string , string string } return html ( string . join ( html_entities . get ( var , var ) for var in string ) )	1
Q_41	html entity replace	C_41_11	def decode_html_entities ( html ) string string string if not html return html for var , var in six . iteritems ( html_entity_map ) html = html . replace ( var , var ) return html	1
Q_41	html entity replace	C_41_12	def decode_html_entities ( html ) string string string if not html return html for var , var in six . iteritems ( html_entity_map ) html = html . replace ( var , var ) return html	1
Q_41	html entity replace	C_41_13	def replace ( html , replacements = none ) string string string if not replacements return html	1
Q_41	html entity replace	C_41_14	def _partition_keys_for_xml ( self , o ) string string string string string ak = { } tk = none ck = { } mc = { }	0
Q_41	html entity replace	C_41_15	def apply_entities_as_html ( text , entities ) string string string escapes = { string string , string string , string string , } formatters = { string lambda s , e string + s + string , string lambda s , e string + s + string , string lambda s , e string string url string string + s + string , string lambda s , e string tg / / user ? id = string user string id string string + s + string , string lambda s , e string + s + string , string lambda s , e string + s + string } return _apply_entities ( text , entities , escapes , formatters )	0
Q_41	html entity replace	C_41_16	def _partition_keys_for_xml ( self , o ) string string string string string ak = { } tk = none ck = { } mc = { }	0
Q_41	html entity replace	C_41_17	def make_entities_code ( entities ) entities_text = string . join ( string s string s string ( var , entities [ var ] . encode ( string ) . replace ( string string string ) ) for var in sorted ( entities . keys ( ) ) ) return string string string entities_text	0
Q_42	html encode string	C_42_0	def _code_no_lexer ( self , text )	1
Q_42	html encode string	C_42_1	def _encode_str ( self , obj , escape_quotes = true ) string string string def replace ( match ) s = match . group ( number ) try if escape_quotes return escape_dct [ s ] else return base_escape_dct [ s ] except key_error n = ord ( s ) if n < number return string . format ( n ) else	1
Q_42	html encode string	C_42_2	def _code_no_lexer ( self , text )	1
Q_42	html encode string	C_42_3	def dumps ( value , escape = false , * * kwargs )	1
Q_42	html encode string	C_42_4	def modify_html ( content , prop = string ) html_string = getattr ( content , prop ) html_tree = html . fromstring ( html_string ) yield html_tree html_string = html . tostring ( html_tree , encoding = string ) html_string = re . sub ( r string , r string , html_string ) html_string = re . sub ( r string , r string , html_string ) setattr ( content , prop , html_string )	1
Q_42	html encode string	C_42_5	def dumps ( value , escape = false , * * kwargs )	1
Q_42	html encode string	C_42_6	"def encode ( self , str ) data = self . u2ent ( str ) data = data . replace ( string , string ) data = data . replace ( string , string ) data = data . replace ( string string quot string > string gt "" ) return data"	1
Q_42	html encode string	C_42_7	def to_pdf ( self ) html = safe_unicode ( self . template ( ) ) . encode ( string ) pdf_data = create_pdf ( html ) return pdf_data	1
Q_42	html encode string	C_42_8	def _html_escape ( string ) string string < > string string string string , string string , string string , }	1
Q_42	html encode string	C_42_9	"def encode ( self , str ) data = self . u2ent ( str ) data = data . replace ( string , string ) data = data . replace ( string , string ) data = data . replace ( string string quot string > string gt "" ) return data"	1
Q_42	html encode string	C_42_10	def encode ( self ) if self . html return self . html elif self . fig return self . encode2 ( ) else return self . encode1 ( )	1
Q_42	html encode string	C_42_11	def test_lower ( self ) encoder = encoder ( ) self . assert_equal ( string , encoder . encode ( string string ) , string ) self . assert_equal ( string , encoder . encode ( string string , string ) , string ) self . assert_equal ( string , encoder . encode ( string , string ) , string ) self . assert_equal ( string , encoder . encode ( string , number ) , string ) self . assert_equal ( string , encoder . encode ( string , string ) , string ) self . assert_equal ( string , encoder . encode ( string ) , string ) self . assert_equal ( string , encoder . encode ( string , string ) , string ) deadbeef = chr ( number ) + chr ( number ) + chr ( number ) + chr ( number ) self . assert_equal ( string , encoder . encode ( deadbeef , deadbeef ) , string ) self . assert_equal ( string , encoder . encode ( deadbeef ) , string ) self . assert_equal ( string , encoder . encode ( deadbeef , string ) , string )	1
Q_42	html encode string	C_42_12	def to_pdf ( self ) html = safe_unicode ( self . template ( ) ) . encode ( string ) pdf_data = create_pdf ( html ) return pdf_data	0
Q_42	html encode string	C_42_13	def _encode_str ( self , obj , escape_quotes = true ) string string string def replace ( match ) s = match . group ( number ) try if escape_quotes return escape_dct [ s ] else return base_escape_dct [ s ] except key_error n = ord ( s ) if n < number return string . format ( n ) else	0
Q_42	html encode string	C_42_14	def test_lower ( self ) encoder = encoder ( ) self . assert_equal ( string , encoder . encode ( string string ) , string ) self . assert_equal ( string , encoder . encode ( string string , string ) , string ) self . assert_equal ( string , encoder . encode ( string , string ) , string ) self . assert_equal ( string , encoder . encode ( string , number ) , string ) self . assert_equal ( string , encoder . encode ( string , string ) , string ) self . assert_equal ( string , encoder . encode ( string ) , string ) self . assert_equal ( string , encoder . encode ( string , string ) , string ) deadbeef = chr ( number ) + chr ( number ) + chr ( number ) + chr ( number ) self . assert_equal ( string , encoder . encode ( deadbeef , deadbeef ) , string ) self . assert_equal ( string , encoder . encode ( deadbeef ) , string ) self . assert_equal ( string , encoder . encode ( deadbeef , string ) , string )	0
Q_42	html encode string	C_42_15	def modify_html ( content , prop = string ) html_string = getattr ( content , prop ) html_tree = html . fromstring ( html_string ) yield html_tree html_string = html . tostring ( html_tree , encoding = string ) html_string = re . sub ( r string , r string , html_string ) html_string = re . sub ( r string , r string , html_string ) setattr ( content , prop , html_string )	0
Q_43	how to reverse a string	C_43_0	def convert_mac_to_int ( addr ) reverse_bytes_str = addr . split ( string ) reverse_bytes_str . reverse ( ) addr_str = string . join ( reverse_bytes_str ) return int ( addr_str , number )	1
Q_43	how to reverse a string	C_43_1	def reverse ( self ) string string in place string string def reverse_trans ( pipe ) if self . writeback self . _sync_helper ( pipe ) n = self . _len_ ( pipe ) for var in range ( n / / number ) left = pipe . lindex ( self . key , var ) right = pipe . lindex ( self . key , n _ var _ number ) pipe . lset ( self . key , var , right ) pipe . lset ( self . key , n _ var _ number , left ) self . _transaction ( reverse_trans )	1
Q_43	how to reverse a string	C_43_2	def reverse_words ( string ) arr = string . strip ( ) . split ( )	1
Q_43	how to reverse a string	C_43_3	def convert_mac_to_int ( addr ) reverse_bytes_str = addr . split ( string ) reverse_bytes_str . reverse ( ) addr_str = string . join ( reverse_bytes_str ) return int ( addr_str , number )	1
Q_43	how to reverse a string	C_43_4	def reverse_words ( string ) arr = string . strip ( ) . split ( )	1
Q_43	how to reverse a string	C_43_5	def convert_mac_to_int ( addr ) reverse_bytes_str = addr . split ( string ) reverse_bytes_str . reverse ( ) addr_str = string . join ( reverse_bytes_str ) return int ( addr_str , number )	1
Q_43	how to reverse a string	C_43_6	def _trim ( cls , s ) string string number number string number number string number number number number number number string number number number number number number string string reverse = s [ _ number ] idx = number for var in range ( number , len ( reverse ) ) if reverse [ var ] = = string idx + = number else break	1
Q_43	how to reverse a string	C_43_7	def reverse_words ( string ) arr = string . strip ( ) . split ( )	1
Q_43	how to reverse a string	C_43_8	def reverse_shuffle_string ( string ) if len ( string ) < number return string new_string = string odd = ( len ( string ) number = = number ) part1 = string [ int ( len ( string ) / number ) number ] part2 = string [ int ( len ( string ) / number ) number ] for var in range ( len ( part1 ) ) new_string + = part2 [ var ] new_string + = part1 [ var ] if odd new_string + = part2 [ _ number ] return new_string	1
Q_43	how to reverse a string	C_43_9	def to_reverse ( self ) string string number . number . number . number string string if self . v = = number return string . join ( list ( self . dq . split ( string ) [ _ number ] ) + [ string , string ] ) else return string . join ( list ( self . hex ( ) ) [ _ number ] + [ string , string ] )	1
Q_43	how to reverse a string	C_43_10	def reverse_url ( self , name str , * args any ) _ > str string string string reversed_url = self . default_router . reverse_url ( name , * args ) if reversed_url is not none return reversed_url raise key_error ( string name )	1
Q_43	how to reverse a string	C_43_11	def to_reverse ( self ) string string number . number . number . number string string if self . v = = number return string . join ( list ( self . dq . split ( string ) [ _ number ] ) + [ string , string ] ) else return string . join ( list ( self . hex ( ) ) [ _ number ] + [ string , string ] )	1
Q_43	how to reverse a string	C_43_12	def reverse ( self ) string string in place string string def reverse_trans ( pipe ) if self . writeback self . _sync_helper ( pipe ) n = self . _len_ ( pipe ) for var in range ( n / / number ) left = pipe . lindex ( self . key , var ) right = pipe . lindex ( self . key , n _ var _ number ) pipe . lset ( self . key , var , right ) pipe . lset ( self . key , n _ var _ number , left ) self . _transaction ( reverse_trans )	1
Q_43	how to reverse a string	C_43_13	def reverse_gate ( wordlen , input = string , output = string ) circ = identity_gate ( wordlen , input , output ) output_map = frozenset ( ( var , tuple ( reversed ( var ) ) ) for var , var in circ . output_map ) return attr . evolve ( circ , output_map = output_map )	1
Q_43	how to reverse a string	C_43_14	def to_reverse ( self ) string string number . number . number . number string string if self . v = = number return string . join ( list ( self . dq . split ( string ) [ _ number ] ) + [ string , string ] ) else return string . join ( list ( self . hex ( ) ) [ _ number ] + [ string , string ] )	1
Q_43	how to reverse a string	C_43_15	def _build_url_silent ( self , _name , * * kwargs ) subreverse = self used_args = set ( ) for var in _name . split ( string ) if not subreverse . _ready and subreverse . _need_arguments used_args = subreverse . url_arguments subreverse = subreverse ( * * kwargs ) subreverse = getattr ( subreverse , var ) if not subreverse . _ready and subreverse . _is_endpoint used_args = subreverse . url_arguments subreverse = subreverse ( * * kwargs ) return used_args , subreverse	0
Q_43	how to reverse a string	C_43_16	def to_reverse ( self ) string string number . number . number . number string string if self . v = = number return string . join ( list ( self . dq . split ( string ) [ _ number ] ) + [ string , string ] ) else return string . join ( list ( self . hex ( ) ) [ _ number ] + [ string , string ] )	0
Q_43	how to reverse a string	C_43_17	def compute_bridge_similarity ( self , vec1 , vec2 ) ewp = number _ np . multiply ( vec1 , vec2 )	0
Q_43	how to reverse a string	C_43_18	def compute_bridge_similarity ( self , vec1 , vec2 ) ewp = number _ np . multiply ( vec1 , vec2 )	0
Q_43	how to reverse a string	C_43_19	def compute_bridge_similarity ( self , vec1 , vec2 ) ewp = number _ np . multiply ( vec1 , vec2 )	0
Q_43	how to reverse a string	C_43_20	def _build_url_silent ( self , _name , * * kwargs ) subreverse = self used_args = set ( ) for var in _name . split ( string ) if not subreverse . _ready and subreverse . _need_arguments used_args = subreverse . url_arguments subreverse = subreverse ( * * kwargs ) subreverse = getattr ( subreverse , var ) if not subreverse . _ready and subreverse . _is_endpoint used_args = subreverse . url_arguments subreverse = subreverse ( * * kwargs ) return used_args , subreverse	0
Q_43	how to reverse a string	C_43_21	def reverse_shuffle_string ( string ) if len ( string ) < number return string new_string = string odd = ( len ( string ) number = = number ) part1 = string [ int ( len ( string ) / number ) number ] part2 = string [ int ( len ( string ) / number ) number ] for var in range ( len ( part1 ) ) new_string + = part2 [ var ] new_string + = part1 [ var ] if odd new_string + = part2 [ _ number ] return new_string	0
Q_43	how to reverse a string	C_43_22	def _trim ( cls , s ) string string number number string number number string number number number number number number string number number number number number number string string reverse = s [ _ number ] idx = number for var in range ( number , len ( reverse ) ) if reverse [ var ] = = string idx + = number else break	0
Q_43	how to reverse a string	C_43_23	def reverse_url ( self , name str , * args any ) _ > str string string string reversed_url = self . default_router . reverse_url ( name , * args ) if reversed_url is not none return reversed_url raise key_error ( string name )	0
Q_43	how to reverse a string	C_43_24	def reverse_gate ( wordlen , input = string , output = string ) circ = identity_gate ( wordlen , input , output ) output_map = frozenset ( ( var , tuple ( reversed ( var ) ) ) for var , var in circ . output_map ) return attr . evolve ( circ , output_map = output_map )	0
Q_43	how to reverse a string	C_43_25	def convert_mac_to_int ( addr ) reverse_bytes_str = addr . split ( string ) reverse_bytes_str . reverse ( ) addr_str = string . join ( reverse_bytes_str ) return int ( addr_str , number )	0
Q_43	how to reverse a string	C_43_26	def compute_bridge_similarity ( self , vec1 , vec2 ) ewp = number _ np . multiply ( vec1 , vec2 )	0
Q_43	how to reverse a string	C_43_27	def compute_bridge_similarity ( self , vec1 , vec2 ) ewp = number _ np . multiply ( vec1 , vec2 )	0
Q_44	how to read the content of a gz compress file	C_44_0	def read ( self ) with gzip . gzip_file ( self . path , compresslevel = self . compresslevel ) as gz_file gz_file . read1 = gz_file . read with io . text_io_wrapper ( gz_file , encoding = self . encoding , errors = self . errors , newline = self . newline ) as file_content return file_content . read ( )	1
Q_44	how to read the content of a gz compress file	C_44_1	def read_output ( filename ) if os . path . isfile ( filename ) with open ( filename , string ) as f return f . read ( ) . decode ( string ) elif os . path . isfile ( string . format ( filename ) ) with gzip . open ( string . format ( filename ) , string ) as f return f . read ( ) . decode ( string ) elif has_lzma and os . path . isfile ( string . format ( filename ) ) with open ( string . format ( filename ) , string ) as f return lzma . lzma_decompressor ( ) . decompress ( f . read ( ) ) . decode ( string ) else return none	1
Q_44	how to read the content of a gz compress file	C_44_2	def read ( self ) with gzip . gzip_file ( self . path , compresslevel = self . compresslevel ) as gz_file gz_file . read1 = gz_file . read with io . text_io_wrapper ( gz_file , encoding = self . encoding , errors = self . errors , newline = self . newline ) as file_content return file_content . read ( )	1
Q_44	how to read the content of a gz compress file	C_44_3	def _file_size ( file_path , uncompressed = false ) string string string _ , ext = os . path . splitext ( file_path ) if uncompressed if ext in { string , string } with gzip . gzip_file ( file_path , mode = string ) as fp try fp . seek ( number , os . seek_end ) return fp . tell ( ) except value_error	1
Q_44	how to read the content of a gz compress file	C_44_4	def read_output ( filename ) if os . path . isfile ( filename ) with open ( filename , string ) as f return f . read ( ) . decode ( string ) elif os . path . isfile ( string . format ( filename ) ) with gzip . open ( string . format ( filename ) , string ) as f return f . read ( ) . decode ( string ) elif has_lzma and os . path . isfile ( string . format ( filename ) ) with open ( string . format ( filename ) , string ) as f return lzma . lzma_decompressor ( ) . decompress ( f . read ( ) ) . decode ( string ) else return none	1
Q_44	how to read the content of a gz compress file	C_44_5	def _file_size ( file_path , uncompressed = false ) string string string _ , ext = os . path . splitext ( file_path ) if uncompressed if ext in { string , string } with gzip . gzip_file ( file_path , mode = string ) as fp try fp . seek ( number , os . seek_end ) return fp . tell ( ) except value_error	1
Q_44	how to read the content of a gz compress file	C_44_6	def compress_file ( fh_ , compresslevel = number , chunk_size = number ) string string string try bytes_read = int ( chunk_size ) if bytes_read = chunk_size raise value_error except value_error raise value_error ( string ) try while bytes_read = = chunk_size buf = bytes_io ( ) with open_fileobj ( buf , string , compresslevel ) as ogz try bytes_read = ogz . write ( fh_ . read ( chunk_size ) ) except attribute_error	1
Q_44	how to read the content of a gz compress file	C_44_7	def prep ( self ) while true sample = self . queue . get ( )	1
Q_44	how to read the content of a gz compress file	C_44_8	def compress ( s ) zbuf = c_string_io . string_io ( ) zfile = gzip . gzip_file ( mode = string , compresslevel = number , fileobj = zbuf ) zfile . write ( s ) zfile . close ( ) return zbuf . getvalue ( )	1
Q_44	how to read the content of a gz compress file	C_44_9	def _iter_ ( self ) if string in self . mode with gzip . gzip_file ( self . path , compresslevel = self . compresslevel ) as gz_file gz_file . read1 = gz_file . read with io . text_io_wrapper ( gz_file , encoding = self . encoding , errors = self . errors , newline = self . newline ) as file_content for var in file_content yield var else with gzip . open ( self . path , mode = self . mode , compresslevel = self . compresslevel ) as file_content for var in file_content yield var	1
Q_44	how to read the content of a gz compress file	C_44_10	def open_fileobj ( fileobj , mode = string , compresslevel = number ) if hasattr ( gzip . gzip_file , string ) return gzip . gzip_file ( filename = string , mode = mode , fileobj = fileobj , compresslevel = compresslevel ) return gzip_file ( filename = string , mode = mode , fileobj = fileobj , compresslevel = compresslevel )	1
Q_44	how to read the content of a gz compress file	C_44_11	def compress ( s ) zbuf = c_string_io . string_io ( ) zfile = gzip . gzip_file ( mode = string , compresslevel = number , fileobj = zbuf ) zfile . write ( s ) zfile . close ( ) return zbuf . getvalue ( )	1
Q_44	how to read the content of a gz compress file	C_44_12	def compress ( s ) zbuf = c_string_io . string_io ( ) zfile = gzip . gzip_file ( mode = string , compresslevel = number , fileobj = zbuf ) zfile . write ( s ) zfile . close ( ) return zbuf . getvalue ( )	1
Q_44	how to read the content of a gz compress file	C_44_13	def open_fileobj ( fileobj , mode = string , compresslevel = number ) if hasattr ( gzip . gzip_file , string ) return gzip . gzip_file ( filename = string , mode = mode , fileobj = fileobj , compresslevel = compresslevel ) return gzip_file ( filename = string , mode = mode , fileobj = fileobj , compresslevel = compresslevel )	1
Q_44	how to read the content of a gz compress file	C_44_14	def _compress_content ( self , content ) string string string zbuf = string_io ( ) zfile = gzip_file ( mode = string , compresslevel = number , fileobj = zbuf ) zfile . write ( content . read ( ) ) zfile . close ( ) content . file = zbuf return content	1
Q_44	how to read the content of a gz compress file	C_44_15	def compress_file ( fh_ , compresslevel = number , chunk_size = number ) string string string try bytes_read = int ( chunk_size ) if bytes_read = chunk_size raise value_error except value_error raise value_error ( string ) try while bytes_read = = chunk_size buf = bytes_io ( ) with open_fileobj ( buf , string , compresslevel ) as ogz try bytes_read = ogz . write ( fh_ . read ( chunk_size ) ) except attribute_error	1
Q_44	how to read the content of a gz compress file	C_44_16	def add_log_file_options ( self , argument_group ) string string string argument_group . add_argument ( string , string , string , action = string , metavar = string , dest = string , type = str , default = string , help = ( string string { number s } _ yyyymmdd_thhmmss . log . gz string string string . gz string ) . format ( self . name ) )	0
Q_44	how to read the content of a gz compress file	C_44_17	def _compress_content ( self , content ) string string string zbuf = string_io ( ) zfile = gzip_file ( mode = string , compresslevel = number , fileobj = zbuf ) zfile . write ( content . read ( ) ) zfile . close ( ) content . file = zbuf return content	0
Q_44	how to read the content of a gz compress file	C_44_18	def prep ( self ) while true sample = self . queue . get ( )	0
Q_44	how to read the content of a gz compress file	C_44_19	def add_log_file_options ( self , argument_group ) string string string argument_group . add_argument ( string , string , string , action = string , metavar = string , dest = string , type = str , default = string , help = ( string string { number s } _ yyyymmdd_thhmmss . log . gz string string string . gz string ) . format ( self . name ) )	0
Q_44	how to read the content of a gz compress file	C_44_20	def add_log_file_options ( self , argument_group ) string string string argument_group . add_argument ( string , string , string , action = string , metavar = string , dest = string , type = str , default = string , help = ( string string { number s } _ yyyymmdd_thhmmss . log . gz string string string . gz string ) . format ( self . name ) )	0
Q_45	how to read csv file in an efficient way	C_45_0	"def read_csv ( self , file_path , use_whole_file = false , names = none , skiprows = number , * args , * * kwargs ) string string names string file / / / my / path / in / local / file / system string hdfs / user / juliet / string t be an issue for small values of skiprows . no other value of header is supported . all additional parameters available in pandas . read_csv ( ) are usable here . returns _ a sparkling_pandas data_frame that contains the data from the specified file . string string "" . join ( rows ) if partition_number = = number return iter ( [ pandas . read_csv ( sio ( in_str ) , * args , header = none , names = mynames , skiprows = _skiprows , * * kwargs ) ] ) else"	1
Q_45	how to read csv file in an efficient way	C_45_1	def read_csv ( filename , has_header = true ) with open ( filename ) as fh csv_reader = csv . reader ( fh ) header = none if has_header header = csv_reader . next ( ) rows = [ var for var in csv_reader ] return header , rows	1
Q_45	how to read csv file in an efficient way	C_45_2	def read_csv ( csv_name , usecols = none ) string string string csv_path = os . path . join ( data_folder , csv_name ) csv = pd . read_csv ( csv_path , low_memory = false , usecols = usecols , encoding = string ) return csv	1
Q_45	how to read csv file in an efficient way	C_45_3	def read_csv ( csv_name , usecols = none ) string string string csv_path = os . path . join ( data_folder , csv_name ) csv = pd . read_csv ( csv_path , low_memory = false , usecols = usecols , encoding = string ) return csv	1
Q_45	how to read csv file in an efficient way	C_45_4	def _read_csv ( self , filename str ) _ > pd . data_frame path = self . _pathmap . get ( filename ) columns = self . _config . nodes . get ( filename , { } ) . get ( string , [ ] ) if path is none or os . path . getsize ( path ) = = number	1
Q_45	how to read csv file in an efficient way	C_45_5	def _read_csv ( self , filename str ) _ > pd . data_frame path = self . _pathmap . get ( filename ) columns = self . _config . nodes . get ( filename , { } ) . get ( string , [ ] ) if path is none or os . path . getsize ( path ) = = number	1
Q_45	how to read csv file in an efficient way	C_45_6	def read_csv ( csv_path , delimiter = string , header = false ) csv_data = [ ] with open ( csv_path , string ) as csvfile csvreader = csv . reader ( csvfile , delimiter = delimiter ) if header next ( csvreader , none ) csv_data = zip ( * csvreader ) return csv_data	1
Q_45	how to read csv file in an efficient way	C_45_7	def read_csv ( filename , has_header = true ) with open ( filename ) as fh csv_reader = csv . reader ( fh ) header = none if has_header header = csv_reader . next ( ) rows = [ var for var in csv_reader ] return header , rows	1
Q_45	how to read csv file in an efficient way	C_45_8	def read_csv ( csv_path , delimiter = string , header = false ) csv_data = [ ] with open ( csv_path , string ) as csvfile csvreader = csv . reader ( csvfile , delimiter = delimiter ) if header next ( csvreader , none ) csv_data = zip ( * csvreader ) return csv_data	1
Q_45	how to read csv file in an efficient way	C_45_9	def _read_csv ( self , csv_path ) logger . info ( string , csv_path ) df = pd . read_csv ( csv_path ) if string in df	1
Q_45	how to read csv file in an efficient way	C_45_10	def readcsv ( fn ) string string string import csv	1
Q_45	how to read csv file in an efficient way	C_45_11	def _create_dictionary_of_ned_d ( self ) string string string self . log . debug ( string ) count = number with open ( self . path_to_data_file , string ) as csv_file csv_reader = csv . reader ( csv_file , dialect = string , delimiter = string , quotechar = string string rb string excel string , string string ) these_keys = [ ] dict_list = [ ] for var in csv_reader if len ( these_keys ) = = number total_rows _ = number if string in var and string in var for i in var if i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) else these_keys . append ( i ) continue if len ( these_keys ) count + = number if count > number	1
Q_45	how to read csv file in an efficient way	C_45_12	def _read_csv ( self , csv_path ) logger . info ( string , csv_path ) df = pd . read_csv ( csv_path ) if string in df	1
Q_45	how to read csv file in an efficient way	C_45_13	def _create_dictionary_of_ned_d ( self ) string string string self . log . debug ( string ) count = number with open ( self . path_to_data_file , string ) as csv_file csv_reader = csv . reader ( csv_file , dialect = string , delimiter = string , quotechar = string string rb string excel string , string string ) these_keys = [ ] dict_list = [ ] for var in csv_reader if len ( these_keys ) = = number total_rows _ = number if string in var and string in var for i in var if i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) elif i = = string these_keys . append ( string ) else these_keys . append ( i ) continue if len ( these_keys ) count + = number if count > number	1
Q_45	how to read csv file in an efficient way	C_45_14	"def read_csv ( self , file_path , use_whole_file = false , names = none , skiprows = number , * args , * * kwargs ) string string names string file / / / my / path / in / local / file / system string hdfs / user / juliet / string t be an issue for small values of skiprows . no other value of header is supported . all additional parameters available in pandas . read_csv ( ) are usable here . returns _ a sparkling_pandas data_frame that contains the data from the specified file . string string "" . join ( rows ) if partition_number = = number return iter ( [ pandas . read_csv ( sio ( in_str ) , * args , header = none , names = mynames , skiprows = _skiprows , * * kwargs ) ] ) else"	1
Q_45	how to read csv file in an efficient way	C_45_15	def serialize ( self ) from itertools import chain result = stream ( ) result < < self . version . to_bytes ( number , string ) if self . network . tx_timestamp result < < self . timestamp . to_bytes ( number , string ) result < < parser . to_varint ( len ( self . ins ) )	1
Q_45	how to read csv file in an efficient way	C_45_16	def _read_csv ( self , csv_path ) logger . info ( string , csv_path ) df = pd . read_csv ( csv_path ) if string in df	0
Q_45	how to read csv file in an efficient way	C_45_17	def serialize ( self ) from itertools import chain result = stream ( ) result < < self . version . to_bytes ( number , string ) if self . network . tx_timestamp result < < self . timestamp . to_bytes ( number , string ) result < < parser . to_varint ( len ( self . ins ) )	0
Q_45	how to read csv file in an efficient way	C_45_18	def send_data ( self , callback ) string string string	0
Q_45	how to read csv file in an efficient way	C_45_19	def send_data ( self , callback ) string string string	0
Q_46	how to randomly pick a number	C_46_0	def randbelow ( num int ) _ > int string string s not an integer . randbelow ( number )	1
Q_46	how to randomly pick a number	C_46_1	def randbelow ( num int ) _ > int string string s not an integer . randbelow ( number )	1
Q_46	how to randomly pick a number	C_46_2	def pick ( self ) while true idx = random . randint ( number , len ( self . values ) _ number ) v , p = self . values [ idx ] if p > = random . uniform ( number , number ) return v	1
Q_46	how to randomly pick a number	C_46_3	def pick ( self ) string string string v = random . uniform ( number , self . ub ) d = self . dist c = self . vc _ number s = self . vc while true s = s / number if s = = number break if v < = d [ c ] [ number ] c _ = s else c + = s	1
Q_46	how to randomly pick a number	C_46_4	def get_random_int ( min_v = number , max_v = number , number = number , seed = none ) string string string rnd = random . random ( ) if seed rnd = random . random ( seed )	1
Q_46	how to randomly pick a number	C_46_5	def sphere_pick_polar ( d , n = number , rng = none ) string string string if rng is none rng = np . random a = np . empty ( [ n , d ] ) if d = = number a [ , number ] = rng . randint ( number , size = n ) * number _ number elif d = = number a [ , number ] = number . number a [ , number ] = rng . uniform ( _ np . pi , + np . pi , n ) elif d = = number u , v = rng . uniform ( number . number , number . number , ( number , n ) ) a [ , number ] = number . number a [ , number ] = np . arccos ( number . number * v _ number . number ) a [ , number ] = number . number * np . pi * u else raise exception ( string ) return a	1
Q_46	how to randomly pick a number	C_46_6	def pick ( self ) while true idx = random . randint ( number , len ( self . values ) _ number ) v , p = self . values [ idx ] if p > = random . uniform ( number , number ) return v	1
Q_46	how to randomly pick a number	C_46_7	def get_random_int ( min_v = number , max_v = number , number = number , seed = none ) string string string rnd = random . random ( ) if seed rnd = random . random ( seed )	1
Q_46	how to randomly pick a number	C_46_8	def pick_led ( self , inc )	1
Q_46	how to randomly pick a number	C_46_9	def randnum_min ( self , randnum int ) _ > none if not isinstance ( randnum , int ) raise type_error ( string ) if randnum < number raise value_error ( string ) self . _randnum_min = randnum	1
Q_46	how to randomly pick a number	C_46_10	def sphere_pick_polar ( d , n = number , rng = none ) string string string if rng is none rng = np . random a = np . empty ( [ n , d ] ) if d = = number a [ , number ] = rng . randint ( number , size = n ) * number _ number elif d = = number a [ , number ] = number . number a [ , number ] = rng . uniform ( _ np . pi , + np . pi , n ) elif d = = number u , v = rng . uniform ( number . number , number . number , ( number , n ) ) a [ , number ] = number . number a [ , number ] = np . arccos ( number . number * v _ number . number ) a [ , number ] = number . number * np . pi * u else raise exception ( string ) return a	1
Q_46	how to randomly pick a number	C_46_11	def pick ( self ) string string string v = random . uniform ( number , self . ub ) d = self . dist c = self . vc _ number s = self . vc while true s = s / number if s = = number break if v < = d [ c ] [ number ] c _ = s else c + = s	1
Q_46	how to randomly pick a number	C_46_12	def pick_led ( self , inc )	1
Q_46	how to randomly pick a number	C_46_13	def tempo_adjust2 ( self , tempo_factor ) string string string late_votes = ( len ( self . adtm . get_next_basal_predicted_cells ( ) ) _ len ( self . apical_intersect ) ) * _ number early_votes = len ( self . apical_intersect ) votes = late_votes + early_votes print ( string , votes ) if votes > number tempo_factor = tempo_factor * number . number print string elif votes < number tempo_factor = tempo_factor * number print string elif votes = = number print string if random . random ( ) > number . number tempo_factor = tempo_factor * number . number print string else tempo_factor = tempo_factor * number print string return tempo_factor	1
Q_46	how to randomly pick a number	C_46_14	def tempo_adjust2 ( self , tempo_factor ) string string string late_votes = ( len ( self . adtm . get_next_basal_predicted_cells ( ) ) _ len ( self . apical_intersect ) ) * _ number early_votes = len ( self . apical_intersect ) votes = late_votes + early_votes print ( string , votes ) if votes > number tempo_factor = tempo_factor * number . number print string elif votes < number tempo_factor = tempo_factor * number print string elif votes = = number print string if random . random ( ) > number . number tempo_factor = tempo_factor * number . number print string else tempo_factor = tempo_factor * number print string return tempo_factor	0
Q_46	how to randomly pick a number	C_46_15	def get_help ( event ) args = [ string , string , string ] description = ( string string string string ) return command_usage_message . get_usage_message ( event . command , args , description )	0
Q_46	how to randomly pick a number	C_46_16	def get_help ( event ) args = [ string , string , string ] description = ( string string string string ) return command_usage_message . get_usage_message ( event . command , args , description )	0
Q_47	how to make the checkbox check	C_47_0	def check_checkbox ( self , value ) string string string check_box = find_field ( world . browser , string , value ) assert check_box , string { } string . format ( value ) if not check_box . is_selected ( ) check_box . click ( )	1
Q_47	how to make the checkbox check	C_47_1	def checkbox_check ( self , force_check = false ) string string string if not self . get_attribute ( string ) self . click ( force_click = force_check )	1
Q_47	how to make the checkbox check	C_47_2	def _call_ ( self , * arg ) if self . status	1
Q_47	how to make the checkbox check	C_47_3	def _call_ ( self , * arg ) if self . status	1
Q_47	how to make the checkbox check	C_47_4	def add_check_box ( self , * args , * * kwargs ) checkbox = beakerx_checkbox ( description = self . get_description ( args , kwargs ) ) checkbox . value = get_value ( kwargs , string , false ) self . children + = ( checkbox , ) self . components [ checkbox . description ] = checkbox return checkbox	1
Q_47	how to make the checkbox check	C_47_5	def assert_checked_checkbox ( self , value ) string string string check_box = find_field ( world . browser , string , value ) assert check_box , string { } string . format ( value ) assert check_box . is_selected ( ) , string	1
Q_47	how to make the checkbox check	C_47_6	def checkbox_uncheck ( self , force_check = false ) string string string if self . get_attribute ( string ) self . click ( force_click = force_check )	1
Q_47	how to make the checkbox check	C_47_7	def check_checkbox ( step , value ) with assert_context_manager ( step ) check_box = find_field ( world . browser , string , value ) if not check_box . is_selected ( ) check_box . click ( )	1
Q_47	how to make the checkbox check	C_47_8	def checkbox_uncheck ( self , force_check = false ) string string string if self . get_attribute ( string ) self . click ( force_click = force_check )	1
Q_47	how to make the checkbox check	C_47_9	def check_checkbox ( self , value ) string string string check_box = find_field ( world . browser , string , value ) assert check_box , string { } string . format ( value ) if not check_box . is_selected ( ) check_box . click ( )	1
Q_47	how to make the checkbox check	C_47_10	def check_checkbox ( step , value ) with assert_context_manager ( step ) check_box = find_field ( world . browser , string , value ) if not check_box . is_selected ( ) check_box . click ( )	1
Q_47	how to make the checkbox check	C_47_11	def create_check_box_widget ( self , text = none ) check_box_widget = check_box_widget ( self . _ui ) check_box_widget . text = text return check_box_widget	1
Q_47	how to make the checkbox check	C_47_12	def assert_checked_checkbox ( self , value ) string string string check_box = find_field ( world . browser , string , value ) assert check_box , string { } string . format ( value ) assert check_box . is_selected ( ) , string	1
Q_47	how to make the checkbox check	C_47_13	def check_checkbox ( step , value ) with assert_context_manager ( step ) check_box = find_field ( world . browser , string , value ) if not check_box . is_selected ( ) check_box . click ( )	1
Q_47	how to make the checkbox check	C_47_14	def checkbox_handler ( self ) if self . key is not none self . parent_form . last_button_clicked = self . key else self . parent_form . last_button_clicked = string self . parent_form . form_remained_open = true if self . parent_form . currently_running_mainloop self . parent_form . t_kroot . quit ( )	1
Q_47	how to make the checkbox check	C_47_15	def assert_checked_checkbox ( self , value ) string string string check_box = find_field ( world . browser , string , value ) assert check_box , string { } string . format ( value ) assert check_box . is_selected ( ) , string	1
Q_47	how to make the checkbox check	C_47_16	def checkbox_handler ( self ) if self . key is not none self . parent_form . last_button_clicked = self . key else self . parent_form . last_button_clicked = string self . parent_form . form_remained_open = true if self . parent_form . currently_running_mainloop self . parent_form . t_kroot . quit ( )	0
Q_47	how to make the checkbox check	C_47_17	def assert_checked_checkbox ( self , value ) string string string check_box = find_field ( world . browser , string , value ) assert check_box , string { } string . format ( value ) assert check_box . is_selected ( ) , string	0
Q_47	how to make the checkbox check	C_47_18	def assert_checked_checkbox ( self , value ) string string string check_box = find_field ( world . browser , string , value ) assert check_box , string { } string . format ( value ) assert check_box . is_selected ( ) , string	0
Q_48	how to get html of website	C_48_0	def get_html ( self ) r = requests . get ( self . url ) if r . status_code = = number raise player_not_found_error else soup = beautiful_soup ( r . text , string ) return soup . find ( string , class_ = string )	1
Q_48	how to get html of website	C_48_1	def get_html_source ( self ) string string string req = urllib . request . request ( self . url ) req . add_header ( string , random . choice ( user_agents ) ) req_text = urllib . request . urlopen ( req ) . read ( ) self . source = str ( req_text ) self . soup = beautiful_soup ( self . source , string ) return self . source	1
Q_48	how to get html of website	C_48_2	def get_html_source ( self ) string string string req = urllib . request . request ( self . url ) req . add_header ( string , random . choice ( user_agents ) ) req_text = urllib . request . urlopen ( req ) . read ( ) self . source = str ( req_text ) self . soup = beautiful_soup ( self . source , string ) return self . source	1
Q_48	how to get html of website	C_48_3	def get_html ( self ) r = requests . get ( self . url ) if r . status_code = = number raise player_not_found_error else soup = beautiful_soup ( r . text , string ) return soup . find ( string , class_ = string )	1
Q_48	how to get html of website	C_48_4	def update_website ( self , website ) self . connect ( ) website = self . server . update_website ( self . session_id , website [ string ] , website [ string ] , website [ string ] , website [ string ] , website [ string ] , * website [ string ] ) return website	1
Q_48	how to get html of website	C_48_5	def get_website ( bucket_name , * * conn ) try result = get_bucket_website ( bucket = bucket_name , * * conn ) except client_error as e if string not in str ( e ) raise e return none website = { } if result . get ( string ) website [ string ] = result [ string ] if result . get ( string ) website [ string ] = result [ string ] if result . get ( string ) website [ string ] = result [ string ] if result . get ( string ) website [ string ] = result [ string ] return website	1
Q_48	how to get html of website	C_48_6	def get_website ( bucket_name , * * conn ) try result = get_bucket_website ( bucket = bucket_name , * * conn ) except client_error as e if string not in str ( e ) raise e return none website = { } if result . get ( string ) website [ string ] = result [ string ] if result . get ( string ) website [ string ] = result [ string ] if result . get ( string ) website [ string ] = result [ string ] if result . get ( string ) website [ string ] = result [ string ] return website	1
Q_48	how to get html of website	C_48_7	def _repr_html_ ( self ) url = self . get_app_root_url ( ) da_id = self . session_id ( ) comm = locate_jpd_comm ( da_id , self , url [ number _ number ] ) external = self . add_external_link and string { url } string _new string . format ( url = url ) or string fb = string i string ( self . frame and number or number ) iframe = string string ( url ) s string string { string url ,	1
Q_48	how to get html of website	C_48_8	def get_site ( self , webspace_name , website_name ) string string string return self . _perform_get ( self . _get_sites_details_path ( webspace_name , website_name ) , site )	1
Q_48	how to get html of website	C_48_9	def _repr_html_ ( self ) url = self . get_app_root_url ( ) da_id = self . session_id ( ) comm = locate_jpd_comm ( da_id , self , url [ number _ number ] ) external = self . add_external_link and string { url } string _new string . format ( url = url ) or string fb = string i string ( self . frame and number or number ) iframe = string string ( url ) s string string { string url ,	1
Q_48	how to get html of website	C_48_10	def _repr_html_ ( self ) url = self . get_app_root_url ( ) da_id = self . session_id ( ) comm = locate_jpd_comm ( da_id , self , url [ number _ number ] ) external = self . add_external_link and string { url } string _new string . format ( url = url ) or string fb = string i string ( self . frame and number or number ) iframe = string string ( url ) s string string { string url ,	1
Q_48	how to get html of website	C_48_11	def update_website ( self , website ) self . connect ( ) website = self . server . update_website ( self . session_id , website [ string ] , website [ string ] , website [ string ] , website [ string ] , website [ string ] , * website [ string ] ) return website	0
Q_48	how to get html of website	C_48_12	def answer ( client , inline_query ) inline_query . answer ( results = [ inline_query_result_article ( id = uuid4 ( ) , title = string , input_message_content = input_text_message_content ( string s how to install * * pyrogram * * string https / / docs . pyrogram . ml / start / installation string how to install pyrogram string https / / i . imgur . com / jyxr_st_e . png string open website string https / / docs . pyrogram . ml / start / installation string usage string here string ) , url = string , description = string , thumb_url = string , reply_markup = inline_keyboard_markup ( [ [ inline_keyboard_button ( string , url = string ) ] ] ) ) ] , cache_time = number )	0
Q_48	how to get html of website	C_48_13	def html ( self ) string string string page = self . get_html_head ( ) page + = string page + = self . toc ( ) for var in self . suites page + = var . html ( ) page + = string return page	0
Q_48	how to get html of website	C_48_14	def get_website ( bucket_name , * * conn ) try result = get_bucket_website ( bucket = bucket_name , * * conn ) except client_error as e if string not in str ( e ) raise e return none website = { } if result . get ( string ) website [ string ] = result [ string ] if result . get ( string ) website [ string ] = result [ string ] if result . get ( string ) website [ string ] = result [ string ] if result . get ( string ) website [ string ] = result [ string ] return website	0
Q_48	how to get html of website	C_48_15	def answer ( client , inline_query ) inline_query . answer ( results = [ inline_query_result_article ( id = uuid4 ( ) , title = string , input_message_content = input_text_message_content ( string s how to install * * pyrogram * * string https / / docs . pyrogram . ml / start / installation string how to install pyrogram string https / / i . imgur . com / jyxr_st_e . png string open website string https / / docs . pyrogram . ml / start / installation string usage string here string ) , url = string , description = string , thumb_url = string , reply_markup = inline_keyboard_markup ( [ [ inline_keyboard_button ( string , url = string ) ] ] ) ) ] , cache_time = number )	0
Q_48	how to get html of website	C_48_16	def main ( ) string string string	0
Q_48	how to get html of website	C_48_17	def website ( app = none , mode = string , subcontext = string ) string string string base_url = websites . get ( mode , string ) if app and base_url opts = { string app , string base_url } base_url = subcontext_map . get ( ( mode , subcontext ) , base_url ) base_url = opts return base_url	0
Q_48	how to get html of website	C_48_18	def get_site ( self , webspace_name , website_name ) string string string return self . _perform_get ( self . _get_sites_details_path ( webspace_name , website_name ) , site )	0
Q_48	how to get html of website	C_48_19	def _repr_html_ ( self ) url = self . get_app_root_url ( ) da_id = self . session_id ( ) comm = locate_jpd_comm ( da_id , self , url [ number _ number ] ) external = self . add_external_link and string { url } string _new string . format ( url = url ) or string fb = string i string ( self . frame and number or number ) iframe = string string ( url ) s string string { string url ,	0
Q_48	how to get html of website	C_48_20	def html ( self ) string string string page = self . get_html_head ( ) page + = string page + = self . toc ( ) for var in self . suites page + = var . html ( ) page + = string return page	0
Q_48	how to get html of website	C_48_21	def get_website ( bucket_name , * * conn ) try result = get_bucket_website ( bucket = bucket_name , * * conn ) except client_error as e if string not in str ( e ) raise e return none website = { } if result . get ( string ) website [ string ] = result [ string ] if result . get ( string ) website [ string ] = result [ string ] if result . get ( string ) website [ string ] = result [ string ] if result . get ( string ) website [ string ] = result [ string ] return website	0
Q_48	how to get html of website	C_48_22	def website ( app = none , mode = string , subcontext = string ) string string string base_url = websites . get ( mode , string ) if app and base_url opts = { string app , string base_url } base_url = subcontext_map . get ( ( mode , subcontext ) , base_url ) base_url = opts return base_url	0
Q_48	how to get html of website	C_48_23	def website ( app = none , mode = string , subcontext = string ) string string string base_url = websites . get ( mode , string ) if app and base_url opts = { string app , string base_url } base_url = subcontext_map . get ( ( mode , subcontext ) , base_url ) base_url = opts return base_url	0
Q_49	how to get database table name	C_49_0	def get_table ( self , database_name , table_name ) database = self . get_database ( database_name ) try return database . tables [ table_name ] except key_error raise table_not_found_exception ( table_name )	1
Q_49	how to get database table name	C_49_1	def get_table ( self , table_name , db = string ) string string airflow string static_babynames string static_babynames string state string year string name string gender string num string string if db = = string and string in table_name db , table_name = table_name . split ( string ) [ number ] with self . metastore as client return client . get_table ( dbname = db , tbl_name = table_name )	1
Q_49	how to get database table name	C_49_2	def get_table_location ( self , database_name , table_name ) string string string table = self . get_table ( database_name , table_name ) return table [ string ] [ string ]	1
Q_49	how to get database table name	C_49_3	def get_table ( self ) database_name = self . parameters . get ( string ) table_name = self . parameters . get ( string ) table = self . glue_backend . get_table ( database_name , table_name ) return json . dumps ( { string table . as_dict ( ) } )	1
Q_49	how to get database table name	C_49_4	def get_table ( self , database_name , table_name ) database = self . get_database ( database_name ) try return database . tables [ table_name ] except key_error raise table_not_found_exception ( table_name )	1
Q_49	how to get database table name	C_49_5	def table_metadata ( self , database , table ) string return ( self . metadata ( string ) or { } ) . get ( database , { } ) . get ( string , { } ) . get ( table , { } )	1
Q_49	how to get database table name	C_49_6	def get_table ( self , table_name , db = string ) string string airflow string static_babynames string static_babynames string state string year string name string gender string num string string if db = = string and string in table_name db , table_name = table_name . split ( string ) [ number ] with self . metastore as client return client . get_table ( dbname = db , tbl_name = table_name )	1
Q_49	how to get database table name	C_49_7	def get_table ( self , database_name , table_name ) string string db string table_foo string name string table_foo string string result = self . get_conn ( ) . get_table ( database_name = database_name , name = table_name ) return result [ string ]	1
Q_49	how to get database table name	C_49_8	def table_metadata ( self , database , table ) string return ( self . metadata ( string ) or { } ) . get ( database , { } ) . get ( string , { } ) . get ( table , { } )	1
Q_49	how to get database table name	C_49_9	def get_table ( self , database_name , table_name ) string string db string table_foo string name string table_foo string string result = self . get_conn ( ) . get_table ( database_name = database_name , name = table_name ) return result [ string ]	1
Q_49	how to get database table name	C_49_10	def table_metadata ( self , database , table ) string return ( self . metadata ( string ) or { } ) . get ( database , { } ) . get ( string , { } ) . get ( table , { } )	1
Q_49	how to get database table name	C_49_11	def main ( options ) filename_database = options [ string ] name_table = options [ string ] print ( string ) if os . path . exists ( filename_database ) print ( string . format ( database = filename_database ) ) create_database ( filename = string ) print ( string . format ( filename = filename_database ) ) database = dataset . connect ( string . format ( filename_database = filename_database ) ) table = database [ name_table ] print ( string ) table . insert ( dict ( name = string , age = number , country = string , uuid4 = str ( uuid . uuid4 ( ) ) ) ) table . insert ( dict ( name = string , age = number , country = string , activity = string , uuid4 = str ( uuid . uuid4 ( ) ) ) ) print ( string string string . format ( tables = database . tables , table = name_table , columns = database [ name_table ] . columns , row = [ var for var in table . find ( id = string ) ] ) ) print ( string . format ( table = name_table ) ) print ( pyprel . table ( contents = pyprel . table_dataset_database_table ( table = database [ name_table ] ) ) )	0
Q_49	how to get database table name	C_49_12	def get_table_location ( self , database_name , table_name ) string string string table = self . get_table ( database_name , table_name ) return table [ string ] [ string ]	0
Q_49	how to get database table name	C_49_13	def table ( self , name str ) string string mytable string string if self . _check_db ( ) = = false return try res = self . getall ( name ) except exception as e self . err ( e , self . table , string ) return if res is none self . warning ( string , name , string ) return num = len ( res ) self . info ( num , string ) self . info ( string , string . join ( list ( res ) ) )	0
Q_50	how to get current date	C_50_0	def date_0utc ( date ) string string string return ee . date . from_ymd ( date . get ( string ) , date . get ( string ) , date . get ( string ) )	1
Q_50	how to get current date	C_50_1	def date ( self ) string string string if self . _date return self . _date return datetime . datetime . now ( ) . strftime ( string )	1
Q_50	how to get current date	C_50_2	def get_current_date_time ( i ) string string string import datetime a = { } now1 = datetime . datetime . now ( ) now = now1 . timetuple ( ) a [ string ] = now [ number ] a [ string ] = now [ number ] a [ string ] = now [ number ] a [ string ] = now [ number ] a [ string ] = now [ number ] a [ string ] = now [ number ] return { string number , string a , string now1 . isoformat ( ) }	1
Q_50	how to get current date	C_50_3	def date ( self ) string string string if self . _date return self . _date return datetime . datetime . now ( ) . strftime ( string )	1
Q_50	how to get current date	C_50_4	def get_current_date_time ( i ) string string string import datetime a = { } now1 = datetime . datetime . now ( ) now = now1 . timetuple ( ) a [ string ] = now [ number ] a [ string ] = now [ number ] a [ string ] = now [ number ] a [ string ] = now [ number ] a [ string ] = now [ number ] a [ string ] = now [ number ] return { string number , string a , string now1 . isoformat ( ) }	1
Q_50	how to get current date	C_50_5	def is_effective ( self ) string string string now = date_time . utcnow ( ) return self . get_start_date ( ) < = now and self . get_end_date ( ) > = now	1
Q_50	how to get current date	C_50_6	def is_effective ( self ) string string string now = date_time . utcnow ( ) return self . get_start_date ( ) < = now and self . get_end_date ( ) > = now	1
Q_50	how to get current date	C_50_7	def _get_current_datetime ( self ) string string string self . wql_time = string self . current_time = self . query ( self . wql_time )	1
Q_50	how to get current date	C_50_8	def get_dates ( self ) today = datetime . date . today ( ) day = today if string in self . request . get param = self . request . get . get ( string ) try day = datetime . datetime . strptime ( param , string ) . date ( ) except pass week_start = utils . get_week_start ( day ) week_end = week_start + relativedelta ( days = number ) return today , week_start , week_end	1
Q_50	how to get current date	C_50_9	def get_dates ( self ) today = datetime . date . today ( ) day = today if string in self . request . get param = self . request . get . get ( string ) try day = datetime . datetime . strptime ( param , string ) . date ( ) except pass week_start = utils . get_week_start ( day ) week_end = week_start + relativedelta ( days = number ) return today , week_start , week_end	1
Q_50	how to get current date	C_50_10	def parse_date ( self , item , field_name , source_name ) string string string	1
Q_50	how to get current date	C_50_11	def is_effective ( self ) string string string now = date_time . utcnow ( ) return self . get_start_date ( ) < = now and self . get_end_date ( ) > = now	1
Q_50	how to get current date	C_50_12	def get_date ( self ) string string string year = self . get_year ( ) month = self . get_month ( ) day = self . get_day ( ) return _date_from_string ( year , self . get_year_format ( ) , month , self . get_month_format ( ) , day , self . get_day_format ( ) )	1
Q_50	how to get current date	C_50_13	def parse_date ( self , item , field_name , source_name ) string string string	1
Q_50	how to get current date	C_50_14	def get_dates ( self ) today = datetime . date . today ( ) day = today if string in self . request . get param = self . request . get . get ( string ) try day = datetime . datetime . strptime ( param , string ) . date ( ) except pass week_start = utils . get_week_start ( day ) week_end = week_start + relativedelta ( days = number ) return today , week_start , week_end	1
Q_50	how to get current date	C_50_15	def date_0utc ( date ) string string string return ee . date . from_ymd ( date . get ( string ) , date . get ( string ) , date . get ( string ) )	0
Q_50	how to get current date	C_50_16	def _get_current_datetime ( self ) string string string self . wql_time = string self . current_time = self . query ( self . wql_time )	0
Q_50	how to get current date	C_50_17	def get_date ( self ) string string string year = self . get_year ( ) month = self . get_month ( ) day = self . get_day ( ) return _date_from_string ( year , self . get_year_format ( ) , month , self . get_month_format ( ) , day , self . get_day_format ( ) )	0
Q_50	how to get current date	C_50_18	def _repr_ ( self ) if self . get_start_date ( ) . year = self . get_end_date ( ) . year if self . week = = number return string self . get_end_date ( ) . year elif self . week > number return string ( self . get_start_date ( ) . year , self . get_start_date ( ) . isocalendar ( ) [ number ] ) return string ( self . get_start_date ( ) . year , self . get_start_date ( ) . isocalendar ( ) [ number ] )	0
Q_50	how to get current date	C_50_19	def get_date ( self ) string string string year = self . get_year ( ) month = self . get_month ( ) day = self . get_day ( ) return _date_from_string ( year , self . get_year_format ( ) , month , self . get_month_format ( ) , day , self . get_day_format ( ) )	0
Q_51	how to extract zip file recursively	C_51_0	def extract_zip ( zip_name , exclude_term = none ) string string string zip_dir = os . path . dirname ( os . path . abspath ( zip_name ) ) try with zipfile . zip_file ( zip_name ) as z	1
Q_51	how to extract zip file recursively	C_51_1	def extract_zip ( archive_path , dest ) with zipfile . zip_file ( archive_path ) as z validate_filenames ( z . namelist ( ) ) z . extractall ( dest )	1
Q_51	how to extract zip file recursively	C_51_2	def extract_zipdir ( zip_file ) string string string if not os . path . exists ( zip_file ) raise value_error ( string . format ( zip_file ) ) directory = os . path . dirname ( zip_file ) filename = os . path . basename ( zip_file ) dirpath = os . path . join ( directory , filename . replace ( string , string ) ) with zipfile . zip_file ( zip_file , string , zipfile . zip_deflated ) as zipf zipf . extractall ( dirpath ) return dirpath	1
Q_51	how to extract zip file recursively	C_51_3	def extract_zipdir ( zip_file ) string string string if not os . path . exists ( zip_file ) raise value_error ( string . format ( zip_file ) ) directory = os . path . dirname ( zip_file ) filename = os . path . basename ( zip_file ) dirpath = os . path . join ( directory , filename . replace ( string , string ) ) with zipfile . zip_file ( zip_file , string , zipfile . zip_deflated ) as zipf zipf . extractall ( dirpath ) return dirpath	1
Q_51	how to extract zip file recursively	C_51_4	def _extract_zip ( self , url , content , value ) zipinmemory = io ( content ) zcopied = number with zipfile . zip_file ( zipinmemory ) as zipf progress_logger . debug ( string , len ( zipf . namelist ( ) ) ) for var in zipf . namelist ( ) if var . endswith ( string ) continue regex_pattern , targets = none , none for r , t in value . items ( ) if re . match ( r , var ) regex_pattern , targets = r , t break if regex_pattern is none progress_logger . debug ( string s string , var ) elif targets is none progress_logger . debug ( string s string s string , var , regex_pattern ) else if isinstance ( targets , str ) targets = [ targets ] for target in targets new_path = self . _file_path ( var , target , regex = regex_pattern ) progress_logger . debug ( string s string s string s string , var , new_path . relative_to ( self . download_root ) , regex_pattern ) self . _write ( new_path , zipf . read ( var ) , url ) zcopied + = number return zcopied	1
Q_51	how to extract zip file recursively	C_51_5	def extract_zip ( self ) assert self . file_count > number try with zipfile . zip_file ( self . archive_path , string ) as zip namelist = zip . namelist ( ) print ( string , namelist ) if len ( namelist ) = self . file_count msg = ( string string string ) ( len ( namelist ) , self . file_count , namelist ) log . error ( msg ) raise runtime_error ( msg ) for var in namelist content = zip . read ( var ) dst = self . file_rename ( var ) out_filename = os . path . join ( self . rom_path , dst ) with open ( out_filename , string ) as f f . write ( content ) if dst = = var print ( string out_filename ) else print ( string ( var , out_filename ) ) self . post_processing ( out_filename ) except bad_zip_file as err msg = string ( self . archive_path , err ) log . error ( msg ) raise bad_zip_file ( msg )	1
Q_51	how to extract zip file recursively	C_51_6	def extract_zip ( self ) assert self . file_count > number try with zipfile . zip_file ( self . archive_path , string ) as zip namelist = zip . namelist ( ) print ( string , namelist ) if namelist = self . archive_names msg = ( string string ) self . archive_names log . error ( msg ) raise runtime_error ( msg ) zip . extractall ( path = self . rom_path ) except bad_zip_file as err msg = string ( self . archive_path , err ) log . error ( msg ) raise bad_zip_file ( msg ) hex2bin ( src = os . path . join ( self . rom_path , string ) , dst = self . rom_path , verbose = false )	1
Q_51	how to extract zip file recursively	C_51_7	def extract_zip ( zip_file_path ) string string string dfs = { } with zipfile . zip_file ( zip_file_path , mode = string ) as z_file names = z_file . namelist ( ) for var in names content = z_file . read ( var ) _ , tmp_file_path = tempfile . mkstemp ( ) try with open ( tmp_file_path , string ) as tmp_file tmp_file . write ( content ) dfs [ var ] = joblib . load ( tmp_file_path ) finally shutil . rmtree ( tmp_file_path , ignore_errors = true ) return dfs	1
Q_51	how to extract zip file recursively	C_51_8	def extract_zip ( self ) assert self . file_count > number try with zipfile . zip_file ( self . archive_path , string ) as zip namelist = zip . namelist ( ) print ( string , namelist ) if len ( namelist ) = self . file_count msg = ( string string string ) ( len ( namelist ) , self . file_count , namelist ) log . error ( msg ) raise runtime_error ( msg ) for var in namelist content = zip . read ( var ) dst = self . file_rename ( var ) out_filename = os . path . join ( self . rom_path , dst ) with open ( out_filename , string ) as f f . write ( content ) if dst = = var print ( string out_filename ) else print ( string ( var , out_filename ) ) self . post_processing ( out_filename ) except bad_zip_file as err msg = string ( self . archive_path , err ) log . error ( msg ) raise bad_zip_file ( msg )	1
Q_51	how to extract zip file recursively	C_51_9	def unpack_zipfile ( filename ) string string string with open ( filename , string ) as fzip z = zipfile . zip_file ( fzip ) for var in z . namelist ( ) print ( ( string . format ( var ) ) ) ensure_dirs ( var ) z . extract ( var )	1
Q_51	how to extract zip file recursively	C_51_10	def unpack_zipfile ( filename ) string string string with open ( filename , string ) as fzip z = zipfile . zip_file ( fzip ) for var in z . namelist ( ) print ( ( string . format ( var ) ) ) ensure_dirs ( var ) z . extract ( var )	1
Q_51	how to extract zip file recursively	C_51_11	def extract_zip ( archive_path , dest ) with zipfile . zip_file ( archive_path ) as z validate_filenames ( z . namelist ( ) ) z . extractall ( dest )	1
Q_51	how to extract zip file recursively	C_51_12	def extract_zip ( zip_file_path ) string string string dfs = { } with zipfile . zip_file ( zip_file_path , mode = string ) as z_file names = z_file . namelist ( ) for var in names content = z_file . read ( var ) _ , tmp_file_path = tempfile . mkstemp ( ) try with open ( tmp_file_path , string ) as tmp_file tmp_file . write ( content ) dfs [ var ] = joblib . load ( tmp_file_path ) finally shutil . rmtree ( tmp_file_path , ignore_errors = true ) return dfs	1
Q_51	how to extract zip file recursively	C_51_13	def extract_zip ( self ) assert self . file_count > number try with zipfile . zip_file ( self . archive_path , string ) as zip namelist = zip . namelist ( ) print ( string , namelist ) if namelist = self . archive_names msg = ( string string ) self . archive_names log . error ( msg ) raise runtime_error ( msg ) zip . extractall ( path = self . rom_path ) except bad_zip_file as err msg = string ( self . archive_path , err ) log . error ( msg ) raise bad_zip_file ( msg ) hex2bin ( src = os . path . join ( self . rom_path , string ) , dst = self . rom_path , verbose = false )	1
Q_51	how to extract zip file recursively	C_51_14	def extract_zip ( self ) assert self . file_count > number try with zipfile . zip_file ( self . archive_path , string ) as zip namelist = zip . namelist ( ) print ( string , namelist ) if len ( namelist ) = self . file_count msg = ( string string string ) ( len ( namelist ) , self . file_count , namelist ) log . error ( msg ) raise runtime_error ( msg ) for var in namelist content = zip . read ( var ) dst = self . file_rename ( var ) out_filename = os . path . join ( self . rom_path , dst ) with open ( out_filename , string ) as f f . write ( content ) if dst = = var print ( string out_filename ) else print ( string ( var , out_filename ) ) self . post_processing ( out_filename ) except bad_zip_file as err msg = string ( self . archive_path , err ) log . error ( msg ) raise bad_zip_file ( msg )	1
Q_51	how to extract zip file recursively	C_51_15	def extract_zip ( self ) assert self . file_count > number try with zipfile . zip_file ( self . archive_path , string ) as zip content = zip . read ( string ) out_filename = os . path . join ( self . rom_path , string ) with open ( out_filename , string ) as f f . write ( content ) print ( string out_filename ) self . post_processing ( out_filename ) except bad_zip_file as err msg = string ( self . archive_path , err ) log . error ( msg ) raise bad_zip_file ( msg )	1
Q_51	how to extract zip file recursively	C_51_16	def _chmod ( self , info , path )	0
Q_51	how to extract zip file recursively	C_51_17	def _chmod ( self , info , path )	0
Q_51	how to extract zip file recursively	C_51_18	def extract_zip ( self ) assert self . file_count > number try with zipfile . zip_file ( self . archive_path , string ) as zip content = zip . read ( string ) out_filename = os . path . join ( self . rom_path , string ) with open ( out_filename , string ) as f f . write ( content ) print ( string out_filename ) self . post_processing ( out_filename ) except bad_zip_file as err msg = string ( self . archive_path , err ) log . error ( msg ) raise bad_zip_file ( msg )	0
Q_52	how to empty array	C_52_0	def empty ( shape , dtype = none , * * kwargs ) string string string data = np . empty ( shape , dtype ) return dc . array ( data , * * kwargs )	1
Q_52	how to empty array	C_52_1	def default_array ( self , array_size ) array = np . empty ( array_size , dtype = self . dtype ) if self . value_type = = enum array . fill ( self . default_value . index ) return enum_array ( array , self . possible_values ) array . fill ( self . default_value ) return array	1
Q_52	how to empty array	C_52_2	def default_array ( self , array_size ) array = np . empty ( array_size , dtype = self . dtype ) if self . value_type = = enum array . fill ( self . default_value . index ) return enum_array ( array , self . possible_values ) array . fill ( self . default_value ) return array	1
Q_52	how to empty array	C_52_3	def no_data ( self ) try empty = self . dfdata . empty except attribute_error empty = true return empty	1
Q_52	how to empty array	C_52_4	def empty ( shape , dtype = none , * * kwargs ) string string string data = np . empty ( shape , dtype ) return dc . array ( data , * * kwargs )	1
Q_52	how to empty array	C_52_5	def empty_like ( array , dtype = none ) string string string array = numpy . asarray ( array ) if dtype is none dtype = array . dtype return anonymousmemmap ( array . shape , dtype )	1
Q_52	how to empty array	C_52_6	def no_data ( self ) try empty = self . dfdata . empty except attribute_error empty = true return empty	1
Q_52	how to empty array	C_52_7	def empty ( self ) string string a string a string string return any ( len ( self . _get_axis ( var ) ) = = number for var in self . _axis_orders )	1
Q_52	how to empty array	C_52_8	def empty_like ( self , * * overrides ) if isinstance ( self . array , self . numpy . ndarray ) return self . numpy . empty_like ( array ) else return self . array . empty_like ( * * overrides )	0
Q_52	how to empty array	C_52_9	def empty_like ( array , dtype = none ) string string string array = numpy . asarray ( array ) if dtype is none dtype = array . dtype return anonymousmemmap ( array . shape , dtype )	0
Q_52	how to empty array	C_52_10	def empty ( self ) string string a string a string string return any ( len ( self . _get_axis ( var ) ) = = number for var in self . _axis_orders )	0
Q_52	how to empty array	C_52_11	def _write_header ( self , output ) header_lines = [ ] header_lines . append ( string . format ( len ( self . data_block ) ) ) variables = self . _get_df_header_row ( string ) variables = convert_magicc7_to_openscm_variables ( variables , inverse = true ) variables = [ var . replace ( string , string ) for var in variables ] regions = self . _get_df_header_row ( string ) regions = convert_magicc_to_openscm_regions ( regions , inverse = true ) special_scen_code = get_special_scen_code ( regions = regions , emissions = variables ) header_lines . append ( string . format ( special_scen_code ) )	0
Q_52	how to empty array	C_52_12	def _write_header ( self , output ) header_lines = [ ] header_lines . append ( string . format ( len ( self . data_block ) ) ) variables = self . _get_df_header_row ( string ) variables = convert_magicc7_to_openscm_variables ( variables , inverse = true ) variables = [ var . replace ( string , string ) for var in variables ] regions = self . _get_df_header_row ( string ) regions = convert_magicc_to_openscm_regions ( regions , inverse = true ) special_scen_code = get_special_scen_code ( regions = regions , emissions = variables ) header_lines . append ( string . format ( special_scen_code ) )	0
Q_52	how to empty array	C_52_13	def empty_like ( self , * * overrides ) if isinstance ( self . array , self . numpy . ndarray ) return self . numpy . empty_like ( array ) else return self . array . empty_like ( * * overrides )	0
Q_53	how to determine a string be a valid word	C_53_0	def is_word ( self , word , ret_ref_trie = false )	1
Q_53	how to determine a string be a valid word	C_53_1	def is_http_word ( self , word ) if ( len ( word ) < number ) return false else if ( word [ number ] = = ord ( string ) and word [ number ] = = ord ( string ) and word [ number ] = = ord ( string ) and word [ number ] = = ord ( string ) ) return true else return false	1
Q_53	how to determine a string be a valid word	C_53_2	def find_word_prob ( word_string , word_total = sum ( word_distribution . values ( ) ) ) string string string if word_string is none return number elif isinstance ( word_string , str ) return word_distribution [ word_string ] / word_total else raise input_error ( string )	1
Q_53	how to determine a string be a valid word	C_53_3	def correct_word ( word_string ) string string string if word_string is none return string elif isinstance ( word_string , str ) return max ( find_candidates ( word_string ) , key = find_word_prob ) else raise input_error ( string )	1
Q_53	how to determine a string be a valid word	C_53_4	def is_word ( self , word , ret_ref_trie = false )	1
Q_53	how to determine a string be a valid word	C_53_5	def _parse_filter_word ( self , word ) string string string if isinstance ( word , str ) word = string { } string . format ( word ) elif isinstance ( word , dt . date ) if isinstance ( word , dt . datetime ) if word . tzinfo is none	1
Q_53	how to determine a string be a valid word	C_53_6	def is_http_word ( self , word ) if ( len ( word ) < number ) return false else if ( word [ number ] = = ord ( string ) and word [ number ] = = ord ( string ) and word [ number ] = = ord ( string ) and word [ number ] = = ord ( string ) ) return true else return false	1
Q_53	how to determine a string be a valid word	C_53_7	def _camel_case ( var ) string string string var = var . lower ( ) if string in var split_word = var . split ( string ) else split_word = var . split ( ) if len ( split_word ) > number for var , var in enumerate ( split_word ) if var > number split_word [ var ] = var . title ( ) strings = string . join ( split_word ) return strings	1
Q_53	how to determine a string be a valid word	C_53_8	def pad_word ( word , length = number ) if len ( word ) > length return word [ length ] if len ( word ) < length return word + string * ( length _ len ( word ) ) return word	1
Q_53	how to determine a string be a valid word	C_53_9	def valid_scrabble_word ( word ) string string string letters_in_bag = { string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , } for var in word if var = = string continue try letters_in_bag [ var ] _ = number except key_error return false if letters_in_bag [ var ] < number letters_in_bag [ string ] _ = number if letters_in_bag [ string ] < number return false return true	1
Q_53	how to determine a string be a valid word	C_53_10	def valid_scrabble_word ( word ) string string string letters_in_bag = { string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , } for var in word if var = = string continue try letters_in_bag [ var ] _ = number except key_error return false if letters_in_bag [ var ] < number letters_in_bag [ string ] _ = number if letters_in_bag [ string ] < number return false return true	0
Q_53	how to determine a string be a valid word	C_53_11	def is_word ( self , word , ret_ref_trie = false )	0
Q_53	how to determine a string be a valid word	C_53_12	def process_word ( word str , to_lower bool = false , append_case optional [ str ] = none ) _ > tuple [ str ] string string < first_upper > string < all_upper > string string if all ( var . isupper ( ) for var in word ) and len ( word ) > number uppercase = string elif word [ number ] . isupper ( ) uppercase = string else uppercase = none if to_lower word = word . lower ( ) if word . isdigit ( ) answer = [ string ] elif word . startswith ( string ) or word . startswith ( string ) answer = [ string ] else answer = list ( word ) if to_lower and uppercase is not none if append_case = = string answer = [ uppercase ] + answer elif append_case = = string answer = answer + [ uppercase ] return tuple ( answer )	0
Q_53	how to determine a string be a valid word	C_53_13	def _parse_filter_word ( self , word ) string string string if isinstance ( word , str ) word = string { } string . format ( word ) elif isinstance ( word , dt . date ) if isinstance ( word , dt . datetime ) if word . tzinfo is none	0
Q_53	how to determine a string be a valid word	C_53_14	def process_word ( word str , to_lower bool = false , append_case optional [ str ] = none ) _ > tuple [ str ] string string < first_upper > string < all_upper > string string if all ( var . isupper ( ) for var in word ) and len ( word ) > number uppercase = string elif word [ number ] . isupper ( ) uppercase = string else uppercase = none if to_lower word = word . lower ( ) if word . isdigit ( ) answer = [ string ] elif word . startswith ( string ) or word . startswith ( string ) answer = [ string ] else answer = list ( word ) if to_lower and uppercase is not none if append_case = = string answer = [ uppercase ] + answer elif append_case = = string answer = answer + [ uppercase ] return tuple ( answer )	0
Q_53	how to determine a string be a valid word	C_53_15	def correct_word ( word_string ) string string string if word_string is none return string elif isinstance ( word_string , str ) return max ( find_candidates ( word_string ) , key = find_word_prob ) else raise input_error ( string )	0
Q_53	how to determine a string be a valid word	C_53_16	def _camel_case ( var ) string string string var = var . lower ( ) if string in var split_word = var . split ( string ) else split_word = var . split ( ) if len ( split_word ) > number for var , var in enumerate ( split_word ) if var > number split_word [ var ] = var . title ( ) strings = string . join ( split_word ) return strings	0
Q_53	how to determine a string be a valid word	C_53_17	def pad_word ( word , length = number ) if len ( word ) > length return word [ length ] if len ( word ) < length return word + string * ( length _ len ( word ) ) return word	0
Q_53	how to determine a string be a valid word	C_53_18	def process_word ( word str , to_lower bool = false , append_case optional [ str ] = none ) _ > tuple [ str ] string string < first_upper > string < all_upper > string string if all ( var . isupper ( ) for var in word ) and len ( word ) > number uppercase = string elif word [ number ] . isupper ( ) uppercase = string else uppercase = none if to_lower word = word . lower ( ) if word . isdigit ( ) answer = [ string ] elif word . startswith ( string ) or word . startswith ( string ) answer = [ string ] else answer = list ( word ) if to_lower and uppercase is not none if append_case = = string answer = [ uppercase ] + answer elif append_case = = string answer = answer + [ uppercase ] return tuple ( answer )	0
Q_54	how to check if a checkbox be check	C_54_0	def checkbox_check ( self , force_check = false ) string string string if not self . get_attribute ( string ) self . click ( force_click = force_check )	1
Q_54	how to check if a checkbox be check	C_54_1	def assert_checked_checkbox ( self , value ) string string string check_box = find_field ( world . browser , string , value ) assert check_box , string { } string . format ( value ) assert check_box . is_selected ( ) , string	1
Q_54	how to check if a checkbox be check	C_54_2	def assert_checked_checkbox ( self , value ) string string string check_box = find_field ( world . browser , string , value ) assert check_box , string { } string . format ( value ) assert check_box . is_selected ( ) , string	1
Q_54	how to check if a checkbox be check	C_54_3	def _call_ ( self , * arg ) if self . status	1
Q_54	how to check if a checkbox be check	C_54_4	def check_checkbox ( self , value ) string string string check_box = find_field ( world . browser , string , value ) assert check_box , string { } string . format ( value ) if not check_box . is_selected ( ) check_box . click ( )	1
Q_54	how to check if a checkbox be check	C_54_5	def check_checkbox ( step , value ) with assert_context_manager ( step ) check_box = find_field ( world . browser , string , value ) if not check_box . is_selected ( ) check_box . click ( )	1
Q_54	how to check if a checkbox be check	C_54_6	def _call_ ( self , * arg ) if self . status	1
Q_54	how to check if a checkbox be check	C_54_7	def checkbox_check ( self , force_check = false ) string string string if not self . get_attribute ( string ) self . click ( force_click = force_check )	1
Q_54	how to check if a checkbox be check	C_54_8	def set_checkbox ( self , data , uncheck_other_boxes = true ) string string checkbox string string for ( name , value ) in data . items ( )	1
Q_54	how to check if a checkbox be check	C_54_9	def check_checkbox ( self , value ) string string string check_box = find_field ( world . browser , string , value ) assert check_box , string { } string . format ( value ) if not check_box . is_selected ( ) check_box . click ( )	1
Q_54	how to check if a checkbox be check	C_54_10	def check_checkbox ( step , value ) with assert_context_manager ( step ) check_box = find_field ( world . browser , string , value ) if not check_box . is_selected ( ) check_box . click ( )	1
Q_54	how to check if a checkbox be check	C_54_11	def checkbox_handler ( self ) if self . key is not none self . parent_form . last_button_clicked = self . key else self . parent_form . last_button_clicked = string self . parent_form . form_remained_open = true if self . parent_form . currently_running_mainloop self . parent_form . t_kroot . quit ( )	1
Q_54	how to check if a checkbox be check	C_54_12	def check ( self , item_id ) string string string try return self . jbx . info ( item_id ) . get ( string ) . lower ( ) = = string except jbxapi . joe_exception return false return false	1
Q_54	how to check if a checkbox be check	C_54_13	def check ( self , item_id ) string string string try return self . jbx . info ( item_id ) . get ( string ) . lower ( ) = = string except jbxapi . joe_exception return false return false	0
Q_54	how to check if a checkbox be check	C_54_14	def check ( self , item_id ) string string string try return self . jbx . info ( item_id ) . get ( string ) . lower ( ) = = string except jbxapi . joe_exception return false return false	0
Q_55	heatmap from tagint d coordinate	C_55_0	def heatmap ( z , x = none , y = none , colorscale = string ) string string string z = np . atleast_1d ( z ) data = [ go . heatmap ( z = z , x = x , y = y , colorscale = colorscale ) ] return chart ( data = data )	1
Q_55	heatmap from tagint d coordinate	C_55_1	def colorize ( img , heatmap ) string string string heatmap = viz . intensity_to_rgb ( heatmap , cmap = string ) [ , , _ number ] return img * number . number + heatmap * number . number	1
Q_55	heatmap from tagint d coordinate	C_55_2	def get_figure ( self , heatmap_kw = none , * * kwargs ) string string string if heatmap_kw is not none assert isinstance ( heatmap_kw , dict ) if heatmap_kw is none heatmap_kw = { } return self . get_heatmap ( * * heatmap_kw ) . get_figure ( * * kwargs )	1
Q_55	heatmap from tagint d coordinate	C_55_3	def draw ( self , size = none , cmap = string ) string string string heatmaps_uint8 = self . to_uint8 ( ) heatmaps_drawn = [ ] for var in sm . xrange ( heatmaps_uint8 . shape [ number ] )	1
Q_55	heatmap from tagint d coordinate	C_55_4	def heatmap ( self , partition = none , cmap = cm . blues ) string string string if isinstance ( self . dm , distance_matrix ) length = self . dm . values . shape [ number ] else length = self . dm . shape [ number ] datamax = float ( np . abs ( self . dm ) . max ( ) ) fig = plt . figure ( ) ax = fig . add_subplot ( number ) ticks_at = [ number , number . number * datamax , datamax ] if partition sorting = flatten_list ( partition . get_membership ( ) ) self . dm = self . dm . reorder ( sorting ) cax = ax . imshow ( self . dm . values , interpolation = string , origin = string , extent = [ number . , length , number . , length ] , vmin = number , vmax = datamax , cmap = cmap , ) cbar = fig . colorbar ( cax , ticks = ticks_at , format = string ) cbar . set_label ( string ) return fig	1
Q_55	heatmap from tagint d coordinate	C_55_5	def heatmap ( z , x = none , y = none , colorscale = string ) string string string z = np . atleast_1d ( z ) data = [ go . heatmap ( z = z , x = x , y = y , colorscale = colorscale ) ] return chart ( data = data )	1
Q_55	heatmap from tagint d coordinate	C_55_6	def get_mpl_heatmap_axes ( dfr , fig , heatmap_gs ) string string string	1
Q_55	heatmap from tagint d coordinate	C_55_7	def draw ( self , size = none , cmap = string ) string string string heatmaps_uint8 = self . to_uint8 ( ) heatmaps_drawn = [ ] for var in sm . xrange ( heatmaps_uint8 . shape [ number ] )	1
Q_55	heatmap from tagint d coordinate	C_55_8	def heatmap ( x , y , step = none , min_pt = none , max_pt = none , colormap = string , alpha = number , grid = false , colorbar = true , scale = string , vmax = string , vmin = string , crop = true ) string string string ( x_vec , y_vec , hist_matrix ) = calc_2d_hist ( x , y , step , min_pt , max_pt )	1
Q_55	heatmap from tagint d coordinate	C_55_9	def heatmap ( dm , partition = none , cmap = cm . blues , fontsize = number ) string string string assert isinstance ( dm , distance_matrix ) datamax = float ( np . abs ( dm . values ) . max ( ) ) length = dm . shape [ number ] if partition sorting = np . array ( flatten_list ( partition . get_membership ( ) ) ) new_dm = dm . reorder ( dm . df . columns [ sorting ] ) else new_dm = dm fig = plt . figure ( ) ax = fig . add_subplot ( number ) ax . xaxis . tick_top ( ) ax . grid ( false ) tick_positions = np . array ( list ( range ( length ) ) ) + number . number if fontsize is not none ax . set_yticks ( tick_positions ) ax . set_xticks ( tick_positions ) ax . set_xticklabels ( new_dm . df . columns , rotation = number , fontsize = fontsize , ha = string ) ax . set_yticklabels ( new_dm . df . index , fontsize = fontsize , va = string ) cbar_ticks_at = [ number , number . number * datamax , datamax ] cax = ax . imshow ( new_dm . values , interpolation = string , extent = [ number . , length , length , number . ] , vmin = number , vmax = datamax , cmap = cmap , ) cbar = fig . colorbar ( cax , ticks = cbar_ticks_at , format = string ) cbar . set_label ( string ) return fig	1
Q_55	heatmap from tagint d coordinate	C_55_10	def heatmap ( x , y , step = none , min_pt = none , max_pt = none , colormap = string , alpha = number , grid = false , colorbar = true , scale = string , vmax = string , vmin = string , crop = true ) string string string ( x_vec , y_vec , hist_matrix ) = calc_2d_hist ( x , y , step , min_pt , max_pt )	1
Q_55	heatmap from tagint d coordinate	C_55_11	def _get_projection_matrix ( self )	1
Q_55	heatmap from tagint d coordinate	C_55_12	def get_figure ( self , heatmap_kw = none , * * kwargs ) string string string if heatmap_kw is not none assert isinstance ( heatmap_kw , dict ) if heatmap_kw is none heatmap_kw = { } return self . get_heatmap ( * * heatmap_kw ) . get_figure ( * * kwargs )	1
Q_55	heatmap from tagint d coordinate	C_55_13	def get_mpl_heatmap_axes ( dfr , fig , heatmap_gs ) string string string	0
Q_55	heatmap from tagint d coordinate	C_55_14	def heatmap ( dm , partition = none , cmap = cm . blues , fontsize = number ) string string string assert isinstance ( dm , distance_matrix ) datamax = float ( np . abs ( dm . values ) . max ( ) ) length = dm . shape [ number ] if partition sorting = np . array ( flatten_list ( partition . get_membership ( ) ) ) new_dm = dm . reorder ( dm . df . columns [ sorting ] ) else new_dm = dm fig = plt . figure ( ) ax = fig . add_subplot ( number ) ax . xaxis . tick_top ( ) ax . grid ( false ) tick_positions = np . array ( list ( range ( length ) ) ) + number . number if fontsize is not none ax . set_yticks ( tick_positions ) ax . set_xticks ( tick_positions ) ax . set_xticklabels ( new_dm . df . columns , rotation = number , fontsize = fontsize , ha = string ) ax . set_yticklabels ( new_dm . df . index , fontsize = fontsize , va = string ) cbar_ticks_at = [ number , number . number * datamax , datamax ] cax = ax . imshow ( new_dm . values , interpolation = string , extent = [ number . , length , length , number . ] , vmin = number , vmax = datamax , cmap = cmap , ) cbar = fig . colorbar ( cax , ticks = cbar_ticks_at , format = string ) cbar . set_label ( string ) return fig	0
Q_55	heatmap from tagint d coordinate	C_55_15	def colorize ( img , heatmap ) string string string heatmap = viz . intensity_to_rgb ( heatmap , cmap = string ) [ , , _ number ] return img * number . number + heatmap * number . number	0
Q_56	hash set for count distinct element	C_56_0	def init_unique_hash ( self ) while self . next_regular ( ) hash = hashlib . sha1 ( self . seq . upper ( ) . encode ( string ) ) . hexdigest ( ) if hash in self . unique_hash_dict self . unique_hash_dict [ hash ] [ string ] . append ( self . id ) self . unique_hash_dict [ hash ] [ string ] + = number else self . unique_hash_dict [ hash ] = { string self . id , string [ self . id ] , string self . seq , string number } self . unique_hash_list = [ var [ number ] for var in sorted ( [ ( self . unique_hash_dict [ hash ] [ string ] , hash ) for hash in self . unique_hash_dict ] , reverse = true ) ] self . total_unique = len ( self . unique_hash_dict ) self . reset ( )	1
Q_56	hash set for count distinct element	C_56_1	def distinct_counts ( self ) string string string	1
Q_56	hash set for count distinct element	C_56_2	def distinct_counts ( self ) string string string	1
Q_56	hash set for count distinct element	C_56_3	def _set_count ( self , elem , count ) if count < number raise value_error self . _size + = count _ self . count ( elem ) if count = = number self . _dict . pop ( elem , none ) else self . _dict [ elem ] = count	1
Q_56	hash set for count distinct element	C_56_4	def distinct ( self ) string string string new_query_set = self . clone ( ) new_query_set . query . distinct = true return new_query_set	1
Q_56	hash set for count distinct element	C_56_5	def init_unique_hash ( self ) while self . next_regular ( ) hash = hashlib . sha1 ( self . seq . upper ( ) . encode ( string ) ) . hexdigest ( ) if hash in self . unique_hash_dict self . unique_hash_dict [ hash ] [ string ] . append ( self . id ) self . unique_hash_dict [ hash ] [ string ] + = number else self . unique_hash_dict [ hash ] = { string self . id , string [ self . id ] , string self . seq , string number } self . unique_hash_list = [ var [ number ] for var in sorted ( [ ( self . unique_hash_dict [ hash ] [ string ] , hash ) for hash in self . unique_hash_dict ] , reverse = true ) ] self . total_unique = len ( self . unique_hash_dict ) self . reset ( )	1
Q_56	hash set for count distinct element	C_56_6	def distinct ( self ) string string string	1
Q_56	hash set for count distinct element	C_56_7	def distinct ( self ) string string string	1
Q_56	hash set for count distinct element	C_56_8	def distinct ( self ) string string string	1
Q_56	hash set for count distinct element	C_56_9	def _set_count ( self , elem , count ) if count < number raise value_error self . _size + = count _ self . count ( elem ) if count = = number self . _dict . pop ( elem , none ) else self . _dict [ elem ] = count	1
Q_56	hash set for count distinct element	C_56_10	def _set_count ( self , elem , count ) if count < number raise value_error self . _size + = count _ self . count ( elem ) if count = = number self . _dict . pop ( elem , none ) else self . _dict [ elem ] = count	1
Q_56	hash set for count distinct element	C_56_11	def clone_with_new_elements ( self , new_elements , drop_keywords = set ( [ ] ) , rename_dict = { } , extra_kwargs = { } ) string string string kwargs = dict ( elements = new_elements , distinct = self . distinct , sort_key = self . sort_key , sources = self . sources ) for var in drop_keywords kwargs . pop ( var ) for old_name , new_name in rename_dict . items ( ) kwargs [ new_name ] = kwargs . pop ( old_name ) kwargs . update ( extra_kwargs ) return self . _class_ ( * * kwargs )	0
Q_56	hash set for count distinct element	C_56_12	def distinct ( self ) string string string new_query_set = self . clone ( ) new_query_set . query . distinct = true return new_query_set	0
Q_56	hash set for count distinct element	C_56_13	def same_disks ( self , count = number ) string string string ret = self if len ( self ) > number type_counter = counter ( self . drive_type ) drive_type , counts = type_counter . most_common ( ) [ number ] self . set_drive_type ( drive_type ) if len ( self ) > number size_counter = counter ( self . capacity ) size , counts = size_counter . most_common ( ) [ number ] self . set_capacity ( size ) if len ( self ) > = count indices = self . index [ count ] self . set_indices ( indices ) else self . set_indices ( string ) return ret	0
Q_56	hash set for count distinct element	C_56_14	def distinct ( self ) string string string	0
Q_56	hash set for count distinct element	C_56_15	def _table_union ( left , right , distinct = false ) string string string op = ops . union ( left , right , distinct = distinct ) return op . to_expr ( )	0
Q_56	hash set for count distinct element	C_56_16	def same_disks ( self , count = number ) string string string ret = self if len ( self ) > number type_counter = counter ( self . drive_type ) drive_type , counts = type_counter . most_common ( ) [ number ] self . set_drive_type ( drive_type ) if len ( self ) > number size_counter = counter ( self . capacity ) size , counts = size_counter . most_common ( ) [ number ] self . set_capacity ( size ) if len ( self ) > = count indices = self . index [ count ] self . set_indices ( indices ) else self . set_indices ( string ) return ret	0
Q_56	hash set for count distinct element	C_56_17	def _table_union ( left , right , distinct = false ) string string string op = ops . union ( left , right , distinct = distinct ) return op . to_expr ( )	0
Q_57	group by count	C_57_0	def groupby_count ( i , key = none , force_keys = none ) string string string counter = defaultdict ( lambda number ) if not key key = lambda o o for var in i counter [ key ( var ) ] + = number if force_keys for var in force_keys counter [ var ] + = number return counter . items ( )	1
Q_57	group by count	C_57_1	def get_top_entries ( self ) query = string try db = self . get_db ( ) results = db . execute ( query ) return [ var for var in results ] finally db . close ( )	1
Q_57	group by count	C_57_2	def group_by_count ( self ) d = ordered_dict ( ) for var , var in self . most_common ( ) if var not in d d [ var ] = [ ] d [ var ] . append ( var ) return d . items ( )	1
Q_57	group by count	C_57_3	def groupby_count ( i , key = none , force_keys = none ) string string string counter = defaultdict ( lambda number ) if not key key = lambda o o for var in i counter [ key ( var ) ] + = number if force_keys for var in force_keys counter [ var ] + = number return counter . items ( )	1
Q_57	group by count	C_57_4	def group ( self ) string string string if hasattr ( self , string ) group_by = self . group_by else group_by = self . default_group_by if self . args [ string ] is not none group_by = self . args [ string ] self . groups = grouping ( self . logevents , group_by ) self . groups . move_items ( none , string ) self . groups . sort_by_size ( group_limit = self . args [ string ] , discard_others = self . args [ string ] )	1
Q_57	group by count	C_57_5	def get_top_entries ( self ) query = string try db = self . get_db ( ) results = db . execute ( query ) return [ var for var in results ] finally db . close ( )	1
Q_57	group by count	C_57_6	def groups_count ( self ) string string string if self . _keyboard_description . contents . ctrls is not none return self . _keyboard_description . contents . ctrls . contents . num_groups else groups_source = self . _groups_source groups_count = number while ( groups_count < xkb_num_kbd_groups and groups_source [ groups_count ] = none_ ) groups_count + = number return groups_count	1
Q_57	group by count	C_57_7	def vk_cmd_dispatch ( command_buffer , group_count_x , group_count_y , group_count_z , ) result = _call_api ( lib . vk_cmd_dispatch , command_buffer , group_count_x , group_count_y , group_count_z )	1
Q_57	group by count	C_57_8	def groups_count ( self ) string string string if self . _keyboard_description . contents . ctrls is not none return self . _keyboard_description . contents . ctrls . contents . num_groups else groups_source = self . _groups_source groups_count = number while ( groups_count < xkb_num_kbd_groups and groups_source [ groups_count ] = none_ ) groups_count + = number return groups_count	0
Q_57	group by count	C_57_9	def count ( self ) string string string ids , _ , ngroups = self . grouper . group_info val = self . obj . get_values ( ) mask = ( ids = _ number ) isna ( val ) ids = ensure_platform_int ( ids ) minlength = ngroups or number out = np . bincount ( ids [ mask ] , minlength = minlength ) return series ( out , index = self . grouper . result_index , name = self . _selection_name , dtype = string )	0
Q_57	group by count	C_57_10	def get_group_count ( group_id , failures = false ) if failures return failure . objects . filter ( group = group_id ) . count ( ) return task . objects . filter ( group = group_id ) . count ( )	0
Q_57	group by count	C_57_11	def group ( self , group ) if group self . group_id = group . id self . _group = group	0
Q_57	group by count	C_57_12	def vk_cmd_dispatch ( command_buffer , group_count_x , group_count_y , group_count_z , ) result = _call_api ( lib . vk_cmd_dispatch , command_buffer , group_count_x , group_count_y , group_count_z )	0
Q_57	group by count	C_57_13	def count ( self ) string string string ids , _ , ngroups = self . grouper . group_info val = self . obj . get_values ( ) mask = ( ids = _ number ) isna ( val ) ids = ensure_platform_int ( ids ) minlength = ngroups or number out = np . bincount ( ids [ mask ] , minlength = minlength ) return series ( out , index = self . grouper . result_index , name = self . _selection_name , dtype = string )	0
Q_57	group by count	C_57_14	def group ( self , group ) if group self . group_id = group . id self . _group = group	0
Q_57	group by count	C_57_15	def group ( self ) string string string if hasattr ( self , string ) group_by = self . group_by else group_by = self . default_group_by if self . args [ string ] is not none group_by = self . args [ string ] self . groups = grouping ( self . logevents , group_by ) self . groups . move_items ( none , string ) self . groups . sort_by_size ( group_limit = self . args [ string ] , discard_others = self . args [ string ] )	0
Q_58	get the description of a http status code	C_58_0	def error_code_to_str ( code ) string string string try name = errno . errorcode [ code ] except key_error name = string try description = os . strerror ( code ) except value_error description = string return string . format ( name , code , description )	1
Q_58	get the description of a http status code	C_58_1	def get_description ( status_code ) string string string description = _descriptions . get ( status_code ) if description is none description = string str ( status_code ) return description	1
Q_58	get the description of a http status code	C_58_2	def get ( self ) string string string if py_funceble . http_code [ string ]	1
Q_58	get the description of a http status code	C_58_3	def get_http_status_string ( v ) string string number no content string string code = get_http_status_code ( v ) try return error_descriptions [ code ] except key_error return string . format ( code )	1
Q_58	get the description of a http status code	C_58_4	def get ( cls )	1
Q_58	get the description of a http status code	C_58_5	def _catch_errors ( self , json_response ) status = json_response . get ( string ) if status and status . get ( string ) = number self . status_code = status . get ( string ) self . error = status . get ( string ) return self . error	1
Q_58	get the description of a http status code	C_58_6	def _catch_errors ( self , json_response ) status = json_response . get ( string ) if status and status . get ( string ) = number self . status_code = status . get ( string ) self . error = status . get ( string ) return self . error	1
Q_58	get the description of a http status code	C_58_7	def get ( cls )	1
Q_58	get the description of a http status code	C_58_8	def get_reason_for_status ( status_code ) string string string if status_code in requests . status_codes . codes return requests . status_codes . _codes [ status_code ] [ number ] . replace ( string , string ) else return string . format ( status_code )	1
Q_58	get the description of a http status code	C_58_9	def _get_status_code ( self , http_status ) string string string try return int ( http_status . split ( string , number ) [ number ] ) except type_error _logger . warning ( string , http_status ) return number	1
Q_58	get the description of a http status code	C_58_10	def get_reason_for_status ( status_code ) string string string if status_code in requests . status_codes . codes return requests . status_codes . _codes [ status_code ] [ number ] . replace ( string , string ) else return string . format ( status_code )	1
Q_58	get the description of a http status code	C_58_11	def get_description ( self , view , status_code ) if status_code in ( status . http_401_unauthorized , status . http_403_forbidden ) return string return view . get_view_description ( html = true )	1
Q_58	get the description of a http status code	C_58_12	def get_http_status_string ( v ) string string number no content string string code = get_http_status_code ( v ) try return error_descriptions [ code ] except key_error return string . format ( code )	1
Q_58	get the description of a http status code	C_58_13	def compute_status ( ) status_codes = [ ] for var , var in dependencies . items ( ) status_codes . append ( get_status ( var ) [ number ] ) if max ( status_codes ) = = number return ( string , max ( status_codes ) ) return ( string , max ( status_codes ) )	1
Q_58	get the description of a http status code	C_58_14	def _get_status_code ( self , http_status ) string string string try return int ( http_status . split ( string , number ) [ number ] ) except type_error _logger . warning ( string , http_status ) return number	1
Q_58	get the description of a http status code	C_58_15	def compute_status ( ) status_codes = [ ] for var , var in dependencies . items ( ) status_codes . append ( get_status ( var ) [ number ] ) if max ( status_codes ) = = number return ( string , max ( status_codes ) ) return ( string , max ( status_codes ) )	1
Q_58	get the description of a http status code	C_58_16	def get_description ( status_code ) string string string description = _descriptions . get ( status_code ) if description is none description = string str ( status_code ) return description	1
Q_58	get the description of a http status code	C_58_17	def error_code_to_str ( code ) string string string try name = errno . errorcode [ code ] except key_error name = string try description = os . strerror ( code ) except value_error description = string return string . format ( name , code , description )	0
Q_58	get the description of a http status code	C_58_18	def get_description ( self , view , status_code ) if status_code in ( status . http_401_unauthorized , status . http_403_forbidden ) return string return view . get_view_description ( html = true )	0
Q_58	get the description of a http status code	C_58_19	def get ( self ) string string string if py_funceble . http_code [ string ]	0
Q_59	get name of enumerate value	C_59_0	def _to_string ( self ) enum_name = none value = self . _get_calculated_value ( self . value ) for var , var in vars ( self . enum_type ) . items ( ) if value = = var enum_name = var break if enum_name is none return string value else return string ( value , enum_name )	1
Q_59	get name of enumerate value	C_59_1	"def enum_value_name ( self , enum , value ) string string t exist or the value is not a valid value for the enum . string "" return self . enum_types_by_name [ enum ] . values_by_number [ value ] . name"	1
Q_59	get name of enumerate value	C_59_2	def _parse_enumerated_value ( self , enumerated_value_node ) return svd_enumerated_value ( name = _get_text ( enumerated_value_node , string ) , description = _get_text ( enumerated_value_node , string ) , value = _get_int ( enumerated_value_node , string ) , is_default = _get_int ( enumerated_value_node , string ) )	1
Q_59	get name of enumerate value	C_59_3	def _get_enum_values ( self , data ) string string string enumstr = data . attrib . get ( string ) if not enumstr return none if string in enumstr return { self . _cast ( var ) var for var , var in [ kv . split ( string ) for kv in enumstr . split ( string ) ] } return enumstr . split ( string )	1
Q_59	get name of enumerate value	C_59_4	def _to_string ( self ) enum_name = none value = self . _get_calculated_value ( self . value ) for var , var in vars ( self . enum_type ) . items ( ) if value = = var enum_name = var break if enum_name is none return string value else return string ( value , enum_name )	1
Q_59	get name of enumerate value	C_59_5	def enum ( name , * fields ) obj = type_object ( ) obj . is_enum = true obj . _name_ = name obj . _enum_ = { } for var , var in fields obj . _enum_ [ var ] = type_object ( ) obj . _enum_ [ var ] . name = var return obj	1
Q_59	get name of enumerate value	C_59_6	def _to_string ( self ) enum_name = none value = self . _get_calculated_value ( self . value ) for var , var in vars ( self . enum_type ) . items ( ) if value = = var enum_name = var break if enum_name is none return string value else return string ( value , enum_name )	1
Q_59	get name of enumerate value	C_59_7	def get_enum_from_name ( self , enum_name ) string string string return next ( ( var for var in self . enums if var . name = = enum_name ) , none )	1
Q_59	get name of enumerate value	C_59_8	def _parse_enumerated_value ( self , enumerated_value_node ) return svd_enumerated_value ( name = _get_text ( enumerated_value_node , string ) , description = _get_text ( enumerated_value_node , string ) , value = _get_int ( enumerated_value_node , string ) , is_default = _get_int ( enumerated_value_node , string ) )	1
Q_59	get name of enumerate value	C_59_9	"def enum_value_name ( self , enum , value ) string string t exist or the value is not a valid value for the enum . string "" return self . enum_types_by_name [ enum ] . values_by_number [ value ] . name"	1
Q_59	get name of enumerate value	C_59_10	def validate_default_element ( self , value ) string string string if isinstance ( value , ( six . string_types , six . integer_types ) )	1
Q_59	get name of enumerate value	C_59_11	def get_enum_from_name ( self , enum_name ) string string string return next ( ( var for var in self . enums if var . name = = enum_name ) , none )	1
Q_59	get name of enumerate value	C_59_12	def validate_default_element ( self , value ) string string string if isinstance ( value , ( six . string_types , six . integer_types ) )	1
Q_59	get name of enumerate value	C_59_13	def get_enum_from_name ( self , enum_name ) string string string return next ( ( var for var in self . enums if var . name = = enum_name ) , none )	1
Q_59	get name of enumerate value	C_59_14	def enum_value ( self ) string string string try return self . properties . units_state [ int ( self . last_value ) _ number ] except index_error value = string except value_error value = string return value	1
Q_59	get name of enumerate value	C_59_15	def sanitize_enum ( self , enum ) for var , var in enum . children ( ) for var , enumerator in var . children ( ) enumerator . value = c_ast . constant ( string , string ) return enum	0
Q_59	get name of enumerate value	C_59_16	def sanitize_enum ( self , enum ) for var , var in enum . children ( ) for var , enumerator in var . children ( ) enumerator . value = c_ast . constant ( string , string ) return enum	0
Q_59	get name of enumerate value	C_59_17	"def verify ( self , obj ) string string s schema . args obj ( object ) a python object to verify raises validation_error if there is a problem verifying the object , a validation_error is thrown with at least the reason key set indicating the reason for the lack of validation . string string object is not in list of enumerated options string not in list of enumerated options "" , object = obj , options = self . options ) return obj"	0
Q_59	get name of enumerate value	C_59_18	def enum_value ( self ) string string string try return self . properties . units_state [ int ( self . last_value ) _ number ] except index_error value = string except value_error value = string return value	0
Q_59	get name of enumerate value	C_59_19	def enum_value ( self ) string string string try return self . properties . units_state [ int ( self . last_value ) _ number ] except index_error value = string except value_error value = string return value	0
Q_60	get inner html	C_60_0	def inner_html ( self , html str ) _ > none	1
Q_60	get inner html	C_60_1	def inner_html ( self ) _ > str string string string if self . _inner_element return self . _inner_element . inner_html return super ( ) . inner_html	1
Q_60	get inner html	C_60_2	def html ( self ) _ > str string string string if self . _inner_element return self . start_tag + self . _inner_element . html + self . end_tag return super ( ) . html	1
Q_60	get inner html	C_60_3	def inner_html ( self ) _ > str string string string if self . _inner_element return self . _inner_element . inner_html return super ( ) . inner_html	1
Q_60	get inner html	C_60_4	def inner_html ( self , html str ) _ > none	1
Q_60	get inner html	C_60_5	def _set_html ( self , html = none ) string string string self . _html = self . _get_html ( html ) self . _view . set_html ( self . _html )	1
Q_60	get inner html	C_60_6	def html ( self ) _ > str string string string if self . _inner_element return self . start_tag + self . _inner_element . html + self . end_tag return super ( ) . html	1
Q_60	get inner html	C_60_7	def render ( self ) indent = self . doc . indent inner = self . content or string if not self . safe inner = escape ( inner , quote = false ) inner + = string . join ( [ var . render ( ) for var in self . child_nodes ] ) html = self . doc . render_tag ( self . tag_name , inner , self . attrs ) if indent pretty_html = string + ( indent * self . level ) + html if self . _is_last ( ) pretty_html + = string + indent * ( self . level _ number ) html = pretty_html return html	1
Q_60	get inner html	C_60_8	def _get_html ( self , html_filename ) path , fn = os . path . split ( _file_ ) with open ( os . path . join ( path , html_filename ) ) as f html = f . read ( ) to_replace = [ ( var . groupdict ( ) [ string ] , html [ var . start ( ) var . end ( ) ] ) for var in self . script_tag . finditer ( html ) ] for filename , tag in to_replace with open ( os . path . join ( path , filename ) ) as scriptfile html = html . replace ( tag , string . format ( scriptfile . read ( ) ) ) return html	1
Q_60	get inner html	C_60_9	def svelte_component ( name , path ) string string string if path [ _ number ] = = string js_path = path elif path [ _ number ] = = string print ( string ) js_path = build_svelte ( path ) js_content = read ( js_path , mode = string ) def inner ( data ) id_str = js_id ( name ) html = _template . replace ( string , js_content ) . replace ( string , name ) . replace ( string , json . dumps ( data ) ) . replace ( string , id_str ) _display_html ( html ) return inner	1
Q_60	get inner html	C_60_10	def get_png_img_html ( blob union [ bytes , memoryview ] , extra_html_class str = none ) _ > str string string string return string string { } string string . format ( string { } string . format ( extra_html_class ) if extra_html_class else string , get_png_data_url ( blob ) )	1
Q_60	get inner html	C_60_11	def _set_html ( self , html = none ) string string string self . _html = self . _get_html ( html ) self . _view . set_html ( self . _html )	1
Q_60	get inner html	C_60_12	def get_png_img_html ( blob union [ bytes , memoryview ] , extra_html_class str = none ) _ > str string string string return string string { } string string . format ( string { } string . format ( extra_html_class ) if extra_html_class else string , get_png_data_url ( blob ) )	0
Q_60	get inner html	C_60_13	def svelte_component ( name , path ) string string string if path [ _ number ] = = string js_path = path elif path [ _ number ] = = string print ( string ) js_path = build_svelte ( path ) js_content = read ( js_path , mode = string ) def inner ( data ) id_str = js_id ( name ) html = _template . replace ( string , js_content ) . replace ( string , name ) . replace ( string , json . dumps ( data ) ) . replace ( string , id_str ) _display_html ( html ) return inner	0
Q_60	get inner html	C_60_14	def _get_html ( self , html_filename ) path , fn = os . path . split ( _file_ ) with open ( os . path . join ( path , html_filename ) ) as f html = f . read ( ) to_replace = [ ( var . groupdict ( ) [ string ] , html [ var . start ( ) var . end ( ) ] ) for var in self . script_tag . finditer ( html ) ] for filename , tag in to_replace with open ( os . path . join ( path , filename ) ) as scriptfile html = html . replace ( tag , string . format ( scriptfile . read ( ) ) ) return html	0
Q_60	get inner html	C_60_15	def render ( self ) indent = self . doc . indent inner = self . content or string if not self . safe inner = escape ( inner , quote = false ) inner + = string . join ( [ var . render ( ) for var in self . child_nodes ] ) html = self . doc . render_tag ( self . tag_name , inner , self . attrs ) if indent pretty_html = string + ( indent * self . level ) + html if self . _is_last ( ) pretty_html + = string + indent * ( self . level _ number ) html = pretty_html return html	0
Q_60	get inner html	C_60_16	def _set_html ( self , html = none ) string string string self . _html = self . _get_html ( html ) self . _view . set_html ( self . _html )	0
Q_61	get executable path	C_61_0	def which ( name ) for var in os . environ [ string ] . split ( os . pathsep ) exe = os . path . join ( var , name ) if is_executable ( exe ) return os . path . abspath ( exe ) for ext in [ string ] + os . environ . get ( string , string ) . split ( os . pathsep ) exe = string . format ( exe , ext . lower ( ) ) if is_executable ( exe ) return os . path . abspath ( exe )	1
Q_61	get executable path	C_61_1	def get_compiler_path ( ) string string string	1
Q_61	get executable path	C_61_2	def get_binary_path ( executable , logging_level = string ) string string string if sys . platform = = string if executable = = string return executable executable = executable + string if executable in os . listdir ( string ) binary = os . var . join ( os . getcwd ( ) , executable ) else binary = next ( ( os . var . join ( var , executable ) for var in os . environ [ string ] . split ( os . pathsep ) if os . var . isfile ( os . var . join ( var , executable ) ) ) , none ) else venv_parent = get_venv_parent_path ( ) venv_bin_path = os . var . join ( venv_parent , string , string ) if not venv_bin_path in os . environ . get ( string ) if logging_level = = string print ( f string ) os . environ [ string ] = os . pathsep . join ( [ os . environ [ string ] , venv_bin_path ] ) binary = shutil . which ( executable ) return binary if binary else none	1
Q_61	get executable path	C_61_3	def find_windows_executable ( bin_path , exe_name ) string string string requested_path = get_windows_path ( bin_path , exe_name ) if os . path . isfile ( requested_path ) return requested_path try pathext = os . environ [ string ] except key_error pass else for var in pathext . split ( os . pathsep ) path = get_windows_path ( bin_path , exe_name + var . strip ( ) . lower ( ) ) if os . path . isfile ( path ) return path return find_executable ( exe_name )	1
Q_61	get executable path	C_61_4	def find_executable ( executable , path = none ) string string executable string path string os . pathsep string path string string if path is none path = os . environ [ string ] paths = path . split ( os . pathsep ) base , ext = os . path . splitext ( executable ) if ( sys . platform = = string or os . name = = string ) and ( ext = string ) executable = executable + string if not os . path . isfile ( executable ) for var in paths f = os . path . join ( var , executable ) if os . path . isfile ( f )	1
Q_61	get executable path	C_61_5	def get_exe_path ( cls ) string string string return os . path . abspath ( os . path . join ( root , cls . bmds_version_dir , cls . exe + string ) )	1
Q_61	get executable path	C_61_6	def get_exe_path ( cls ) string string string return os . path . abspath ( os . path . join ( root , cls . bmds_version_dir , cls . exe + string ) )	1
Q_61	get executable path	C_61_7	def get_binary_path ( executable , logging_level = string ) string string string if sys . platform = = string if executable = = string return executable executable = executable + string if executable in os . listdir ( string ) binary = os . var . join ( os . getcwd ( ) , executable ) else binary = next ( ( os . var . join ( var , executable ) for var in os . environ [ string ] . split ( os . pathsep ) if os . var . isfile ( os . var . join ( var , executable ) ) ) , none ) else venv_parent = get_venv_parent_path ( ) venv_bin_path = os . var . join ( venv_parent , string , string ) if not venv_bin_path in os . environ . get ( string ) if logging_level = = string print ( f string ) os . environ [ string ] = os . pathsep . join ( [ os . environ [ string ] , venv_bin_path ] ) binary = shutil . which ( executable ) return binary if binary else none	1
Q_61	get executable path	C_61_8	def find_executable ( executable , path = none ) string string executable string path string os . pathsep string path string string if path is none path = os . environ [ string ] paths = path . split ( os . pathsep ) base , ext = os . path . splitext ( executable ) if ( sys . platform = = string or os . name = = string ) and ( ext = string ) executable = executable + string if not os . path . isfile ( executable ) for var in paths f = os . path . join ( var , executable ) if os . path . isfile ( f )	1
Q_61	get executable path	C_61_9	"def _search_for_executable ( self , executable ) string string executable string t be found . string string path "" ) if envpath is none return for var in envpath . split ( os . pathsep ) exe = os . var . join ( var , executable ) if os . var . isfile ( exe ) return os . var . abspath ( exe )"	1
Q_61	get executable path	C_61_10	def find_executable ( executable str , * paths str ) _ > typing . optional [ path ] string string path string os . pathsep string path string string if not executable . endswith ( string ) executable = f string if executable in _known_executables return _known_executables [ executable ] output = f string if not paths path = os . environ [ string ] paths = tuple ( [ str ( path ( sys . exec_prefix , string ) . absolute ( ) ) ] + path . split ( os . pathsep ) ) executable_path = path ( executable ) . absolute ( ) if not executable_path . is_file ( ) for path_ in paths executable_path = path ( path_ , executable ) . absolute ( ) if executable_path . is_file ( ) break else _logger . error ( string , output ) return none _known_executables [ executable ] = executable_path _logger . info ( string , output , str ( executable_path ) ) return executable_path	1
Q_61	get executable path	C_61_11	def get_path_of_executable ( executable ) string string string exe_paths = os . environ [ string ] . split ( string ) for var in exe_paths exe_file = os . path . join ( var , executable ) if os . path . isfile ( exe_file ) and os . access ( exe_file , os . x_ok ) return exe_file return none	1
Q_61	get executable path	C_61_12	def which ( name ) for var in os . environ [ string ] . split ( os . pathsep ) exe = os . path . join ( var , name ) if is_executable ( exe ) return os . path . abspath ( exe ) for ext in [ string ] + os . environ . get ( string , string ) . split ( os . pathsep ) exe = string . format ( exe , ext . lower ( ) ) if is_executable ( exe ) return os . path . abspath ( exe )	1
Q_61	get executable path	C_61_13	"def _search_for_executable ( self , executable ) string string executable string t be found . string string path "" ) if envpath is none return for var in envpath . split ( os . pathsep ) exe = os . var . join ( var , executable ) if os . var . isfile ( exe ) return os . var . abspath ( exe )"	1
Q_61	get executable path	C_61_14	def find_executable ( executable str , * paths str ) _ > typing . optional [ path ] string string path string os . pathsep string path string string if not executable . endswith ( string ) executable = f string if executable in _known_executables return _known_executables [ executable ] output = f string if not paths path = os . environ [ string ] paths = tuple ( [ str ( path ( sys . exec_prefix , string ) . absolute ( ) ) ] + path . split ( os . pathsep ) ) executable_path = path ( executable ) . absolute ( ) if not executable_path . is_file ( ) for path_ in paths executable_path = path ( path_ , executable ) . absolute ( ) if executable_path . is_file ( ) break else _logger . error ( string , output ) return none _known_executables [ executable ] = executable_path _logger . info ( string , output , str ( executable_path ) ) return executable_path	1
Q_61	get executable path	C_61_15	def get_path_of_executable ( executable ) string string string exe_paths = os . environ [ string ] . split ( string ) for var in exe_paths exe_file = os . path . join ( var , executable ) if os . path . isfile ( exe_file ) and os . access ( exe_file , os . x_ok ) return exe_file return none	1
Q_61	get executable path	C_61_16	def which ( cmd , mode = os . f_ok os . x_ok , path = none ) string string string if os . path . dirname ( cmd ) if os . path . isfile ( cmd ) and os . access ( cmd , mode ) return cmd if path is none path = os . environ . get ( string , defpath ) if not path return none paths = path . split ( pathsep ) if sys . platform = = string	1
Q_61	get executable path	C_61_17	def find_windows_executable ( bin_path , exe_name ) string string string requested_path = get_windows_path ( bin_path , exe_name ) if os . path . isfile ( requested_path ) return requested_path try pathext = os . environ [ string ] except key_error pass else for var in pathext . split ( os . pathsep ) path = get_windows_path ( bin_path , exe_name + var . strip ( ) . lower ( ) ) if os . path . isfile ( path ) return path return find_executable ( exe_name )	1
Q_62	get current process id	C_62_0	def ps ( self ) string string string	1
Q_62	get current process id	C_62_1	def ps ( self ) string string string	1
Q_62	get current process id	C_62_2	def get_pid ( procname ) for var in psutil . process_iter ( ) if var . name = = procname return var . pid	1
Q_62	get current process id	C_62_3	def get_pid ( self , id ) f = open ( self . config [ id ] [ string ] ) try pid = int ( f . read ( ) . strip ( ) ) except value_error print string self . config [ id ] [ string ] sys . exit ( number ) f . close ( ) return pid	1
Q_62	get current process id	C_62_4	def process_id ( self ) ret = string if thread f = getattr ( os , string , none ) if f ret = str ( f ( ) ) return ret	1
Q_62	get current process id	C_62_5	"def get_pid ( self ) string string t be found . string "" if self . dw_process_id is none if self . _process is not none"	1
Q_62	get current process id	C_62_6	def process_id ( self ) ret = string if thread f = getattr ( os , string , none ) if f ret = str ( f ( ) ) return ret	1
Q_62	get current process id	C_62_7	def get_pid ( procname ) for var in psutil . process_iter ( ) if var . name = = procname return var . pid	1
Q_62	get current process id	C_62_8	"def get_pid ( self ) string string t be found . string "" if self . dw_process_id is none if self . _process is not none"	1
Q_62	get current process id	C_62_9	def _create_variable ( orig_v , step , variables ) string string string	1
Q_62	get current process id	C_62_10	def get_procid ( self , record ) procid = getattr ( record , string , self . procid ) if procid is none or procid = = string procid = getattr ( record , string , nilvalue ) return self . filter_printusascii ( str ( procid ) )	1
Q_62	get current process id	C_62_11	def get_procid ( self , record ) procid = getattr ( record , string , self . procid ) if procid is none or procid = = string procid = getattr ( record , string , nilvalue ) return self . filter_printusascii ( str ( procid ) )	1
Q_62	get current process id	C_62_12	def get_process_id_from_prefix ( self ) if self . cmdprefix pid = self . input_process ( self . cmdprefix ) else if self . last_event is none raise cmd_error ( string ) pid = self . last_event . get_pid ( ) return pid	0
Q_62	get current process id	C_62_13	def get_id ( self )	0
Q_62	get current process id	C_62_14	def get_id ( self )	0
Q_62	get current process id	C_62_15	def get_process_id_from_prefix ( self ) if self . cmdprefix pid = self . input_process ( self . cmdprefix ) else if self . last_event is none raise cmd_error ( string ) pid = self . last_event . get_pid ( ) return pid	0
Q_63	get current observable value	C_63_0	def _set_observable ( self , var , new_value )	1
Q_63	get current observable value	C_63_1	def make_dict_observable ( matrix_observable ) string string string dict_observable = { } observable = np . array ( matrix_observable ) observable_size = len ( observable ) observable_bits = int ( np . ceil ( np . log2 ( observable_size ) ) ) binary_formater = string . format ( observable_bits ) if observable . ndim = = number observable = observable . diagonal ( ) for var in range ( observable_size ) state_str = format ( var , binary_formater ) dict_observable [ state_str ] = observable [ var ] return dict_observable	1
Q_63	get current observable value	C_63_2	def add ( self , observable_element ) string string string if observable_element not in self . _observables self . _observables . append ( observable_element ) else raise runtime_error ( string . format ( observable_element ) )	1
Q_63	get current observable value	C_63_3	def _trigger_event ( self , holder t . any , alt_name str , action str , * event_args t . any ) _ > none string string string if isinstance ( self . observable , observable ) observable = self . observable elif isinstance ( self . observable , str ) observable = getattr ( holder , self . observable ) elif isinstance ( holder , observable ) observable = holder else raise type_error ( string string string string ) name = alt_name if self . event is none else self . event event = string . format ( action , name ) observable . trigger ( event , * event_args )	1
Q_63	get current observable value	C_63_4	def _sma_observable ( observable_name , expected , function = none , param = none , value = none ) param = param or os . environ . get ( observable_name ) if not param return groups = parse_param ( param ) if not isinstance ( param , list ) else param function = function or globals ( ) [ string + observable_name ] value = value or function ( * groups ) name = function . _name_ . replace ( string , string ) . replace ( string , string ) . capitalize ( ) print ( string { } { } string . format ( observable_name , name , groups [ number ] ) ) print ( string . format ( observable_name , value ) ) print ( string . format ( observable_name , expected ) )	1
Q_63	get current observable value	C_63_5	def get_monitor_observables ( self , name ) try lines = self . items ( name ) except no_section_error return [ ] lines = [ item_line ( var , var ) for var , var in lines ] return get_observables_from_lines ( lines )	1
Q_63	get current observable value	C_63_6	def value ( self ) if not self . partial self . full . wait ( ) try return self . average ( self . queue ) except ( zero_division_error , value_error )	1
Q_63	get current observable value	C_63_7	def _call_ ( self , field ) acquire = getattr ( field , string , true ) if acquire fieldname = getattr ( field , string , field . get_name ( ) ) current = self . context while hasattr ( current , string ) current = current . aq_parent if i_plone_site_root . provided_by ( current ) break if fieldname in current . schema ( ) . _names value = current . schema ( ) [ fieldname ] . get ( current ) if value is not none return value	1
Q_63	get current observable value	C_63_8	def get_monitor_observables ( self , name ) try lines = self . items ( name ) except no_section_error return [ ] lines = [ item_line ( var , var ) for var , var in lines ] return get_observables_from_lines ( lines )	1
Q_63	get current observable value	C_63_9	def create_with ( cls , event str = none , observable t . union [ str , observable ] = none ) _ > t . callable [ . , string ] string string string return functools . partial ( cls , event = event , observable = observable )	1
Q_63	get current observable value	C_63_10	def _main ( ) api = connect_api ( )	1
Q_63	get current observable value	C_63_11	def make_dict_observable ( matrix_observable ) string string string dict_observable = { } observable = np . array ( matrix_observable ) observable_size = len ( observable ) observable_bits = int ( np . ceil ( np . log2 ( observable_size ) ) ) binary_formater = string . format ( observable_bits ) if observable . ndim = = number observable = observable . diagonal ( ) for var in range ( observable_size ) state_str = format ( var , binary_formater ) dict_observable [ state_str ] = observable [ var ] return dict_observable	0
Q_63	get current observable value	C_63_12	def create_with ( cls , event str = none , observable t . union [ str , observable ] = none ) _ > t . callable [ . , string ] string string string return functools . partial ( cls , event = event , observable = observable )	0
Q_63	get current observable value	C_63_13	def _trigger_event ( self , holder t . any , alt_name str , action str , * event_args t . any ) _ > none string string string if isinstance ( self . observable , observable ) observable = self . observable elif isinstance ( self . observable , str ) observable = getattr ( holder , self . observable ) elif isinstance ( holder , observable ) observable = holder else raise type_error ( string string string string ) name = alt_name if self . event is none else self . event event = string . format ( action , name ) observable . trigger ( event , * event_args )	0
Q_63	get current observable value	C_63_14	def _call_ ( self , field ) acquire = getattr ( field , string , true ) if acquire fieldname = getattr ( field , string , field . get_name ( ) ) current = self . context while hasattr ( current , string ) current = current . aq_parent if i_plone_site_root . provided_by ( current ) break if fieldname in current . schema ( ) . _names value = current . schema ( ) [ fieldname ] . get ( current ) if value is not none return value	0
Q_63	get current observable value	C_63_15	def add ( self , observable_element ) string string string if observable_element not in self . _observables self . _observables . append ( observable_element ) else raise runtime_error ( string . format ( observable_element ) )	0
Q_63	get current observable value	C_63_16	def _sma_observable ( observable_name , expected , function = none , param = none , value = none ) param = param or os . environ . get ( observable_name ) if not param return groups = parse_param ( param ) if not isinstance ( param , list ) else param function = function or globals ( ) [ string + observable_name ] value = value or function ( * groups ) name = function . _name_ . replace ( string , string ) . replace ( string , string ) . capitalize ( ) print ( string { } { } string . format ( observable_name , name , groups [ number ] ) ) print ( string . format ( observable_name , value ) ) print ( string . format ( observable_name , expected ) )	0
Q_63	get current observable value	C_63_17	def _main ( ) api = connect_api ( )	0
Q_63	get current observable value	C_63_18	def value ( self ) if not self . partial self . full . wait ( ) try return self . average ( self . queue ) except ( zero_division_error , value_error )	0
Q_63	get current observable value	C_63_19	def _set_observable ( self , var , new_value )	0
Q_64	get current ip address	C_64_0	def get_ip ( self , address ) string string number . number . number . number string string res = self . get_request ( string + address ) return ip_address ( cloud_manager = self , * * res [ string ] )	1
Q_64	get current ip address	C_64_1	def get_ip ( request ) string string string if config . behind_reverse_proxy ip_address = request . meta . get ( config . reverse_proxy_header , string ) ip_address = ip_address . split ( string , number ) [ number ] . strip ( ) if ip_address = = string ip_address = get_ip_address_from_request ( request ) else ip_address = get_ip_address_from_request ( request ) return ip_address	1
Q_64	get current ip address	C_64_2	def get_ip ( self ) if self . _ip is not none ret = self . _ip else ret = self . ip_addr return ret	1
Q_64	get current ip address	C_64_3	def get_ip ( self ) if self . _ip is none self . _ip = self . fetch_ip ( ) return self . _ip	1
Q_64	get current ip address	C_64_4	def get_ip ( self ) if self . _ip is none self . _ip = self . fetch_ip ( ) return self . _ip	1
Q_64	get current ip address	C_64_5	def get_user_ip ( request ) string string string ip = get_real_ip ( request ) if ip is none ip = get_ip ( request ) if ip is none ip = string return ip	1
Q_64	get current ip address	C_64_6	def get_ip ( self ) if self . _ip is not none ret = self . _ip else ret = self . ip_addr return ret	1
Q_64	get current ip address	C_64_7	def get_ip ( request ) string string string if config . behind_reverse_proxy ip_address = request . meta . get ( config . reverse_proxy_header , string ) ip_address = ip_address . split ( string , number ) [ number ] . strip ( ) if ip_address = = string ip_address = get_ip_address_from_request ( request ) else ip_address = get_ip_address_from_request ( request ) return ip_address	1
Q_64	get current ip address	C_64_8	async def get_ip ( self ) _ > union [ i_pv4_address , i_pv6_address ] string string string xff = await self . get_x_forwarded_for ( ) if xff return xff [ number ] ip_addr = self . _request . transport . get_extra_info ( string ) [ number ] return ip_address ( ip_addr )	1
Q_64	get current ip address	C_64_9	async def get_ip ( self ) _ > union [ i_pv4_address , i_pv6_address ] string string string xff = await self . get_x_forwarded_for ( ) if xff return xff [ number ] ip_addr = self . _request . transport . get_extra_info ( string ) [ number ] return ip_address ( ip_addr )	1
Q_64	get current ip address	C_64_10	def _get_address_translations_table ( address_translations ) string string string table = formatting . table ( [ string , string , string , string , string , string ] ) for var in address_translations table . add_row ( [ var . get ( string , string ) , var . get ( string , { } ) . get ( string , string ) , var . get ( string , string ) , var . get ( string , { } ) . get ( string , string ) , var . get ( string , string ) , var . get ( string , string ) ] ) return table	1
Q_64	get current ip address	C_64_11	def get_user_ip ( request ) string string string ip = get_real_ip ( request ) if ip is none ip = get_ip ( request ) if ip is none ip = string return ip	1
Q_64	get current ip address	C_64_12	def update_ipaddress ( self ) string string string	1
Q_64	get current ip address	C_64_13	def get_user_ip ( request ) string string string ip = get_real_ip ( request ) if ip is none ip = get_ip ( request ) if ip is none ip = string return ip	1
Q_64	get current ip address	C_64_14	def ip ( ip_address , return_format = none ) string string string response = _get ( string . format ( address = ip_address ) , return_format ) if string in str ( response ) raise error ( string . format ( address = ip_address ) ) else return response	0
Q_64	get current ip address	C_64_15	def on_new_master_detected_message ( self , data ) master = none try if isinstance ( data , six . binary_type ) data = data . decode ( string ) parsed = json . loads ( data ) if parsed and string in parsed ip = parsed [ string ] . get ( string ) port = parsed [ string ] . get ( string ) if ip and port master = string ( ip , port ) except exception logger . exception ( string string ) if master self . change_master ( master )	0
Q_64	get current ip address	C_64_16	def update_ipaddress ( self ) string string string	0
Q_64	get current ip address	C_64_17	def on_new_master_detected_message ( self , data ) master = none try if isinstance ( data , six . binary_type ) data = data . decode ( string ) parsed = json . loads ( data ) if parsed and string in parsed ip = parsed [ string ] . get ( string ) port = parsed [ string ] . get ( string ) if ip and port master = string ( ip , port ) except exception logger . exception ( string string ) if master self . change_master ( master )	0
Q_64	get current ip address	C_64_18	def _get_address_translations_table ( address_translations ) string string string table = formatting . table ( [ string , string , string , string , string , string ] ) for var in address_translations table . add_row ( [ var . get ( string , string ) , var . get ( string , { } ) . get ( string , string ) , var . get ( string , string ) , var . get ( string , { } ) . get ( string , string ) , var . get ( string , string ) , var . get ( string , string ) ] ) return table	0
Q_64	get current ip address	C_64_19	def get_ip ( self ) if self . _ip is not none ret = self . _ip else ret = self . ip_addr return ret	0
Q_64	get current ip address	C_64_20	def on_new_master_detected_message ( self , data ) master = none try if isinstance ( data , six . binary_type ) data = data . decode ( string ) parsed = json . loads ( data ) if parsed and string in parsed ip = parsed [ string ] . get ( string ) port = parsed [ string ] . get ( string ) if ip and port master = string ( ip , port ) except exception logger . exception ( string string ) if master self . change_master ( master )	0
Q_64	get current ip address	C_64_21	async def get_ip ( self ) _ > union [ i_pv4_address , i_pv6_address ] string string string xff = await self . get_x_forwarded_for ( ) if xff return xff [ number ] ip_addr = self . _request . transport . get_extra_info ( string ) [ number ] return ip_address ( ip_addr )	0
Q_64	get current ip address	C_64_22	def get_ip ( self ) if self . _ip is none self . _ip = self . fetch_ip ( ) return self . _ip	0
Q_64	get current ip address	C_64_23	def get_ip ( self ) if self . _ip is not none ret = self . _ip else ret = self . ip_addr return ret	0
Q_65	get all parent of xml node	C_65_0	def get_edges ( self , node ) return [ ( node , var ) for var in self . get_children ( node ) ] + [ ( parent , node ) for parent in self . get_parents ( node ) ]	1
Q_65	get all parent of xml node	C_65_1	def get_ancestor_ephemeral_nodes ( self , selected_nodes ) node_names = { } for var in selected_nodes if var not in self . manifest . nodes continue node = self . manifest . nodes [ var ]	1
Q_65	get all parent of xml node	C_65_2	def get_xml_node ( self ) xb = xmlapi . xml_builder ( ) ret = [ ] if self . access_hosts is not none ret . append ( xb . list_elements ( string , self . access_hosts ) ) if self . rw_hosts is not none ret . append ( xb . list_elements ( string , self . rw_hosts ) ) if self . ro_hosts is not none ret . append ( xb . list_elements ( string , self . ro_hosts ) ) if self . root_hosts is not none ret . append ( xb . list_elements ( string , self . root_hosts ) ) return ret	1
Q_65	get all parent of xml node	C_65_3	def _import_parents_from_xml ( self , xml ) parents = xml . iterfind ( string ) for var in parents for o in var	1
Q_65	get all parent of xml node	C_65_4	def _find ( self , node ) root = node while root in self . parents root = self . parents [ root ] while node in self . parents prev_node = node node = self . parents [ node ] self . parents [ prev_node ] = root return root	1
Q_65	get all parent of xml node	C_65_5	def get_xml_node ( self ) xb = xmlapi . xml_builder ( ) ret = [ ] if self . access_hosts is not none ret . append ( xb . list_elements ( string , self . access_hosts ) ) if self . rw_hosts is not none ret . append ( xb . list_elements ( string , self . rw_hosts ) ) if self . ro_hosts is not none ret . append ( xb . list_elements ( string , self . ro_hosts ) ) if self . root_hosts is not none ret . append ( xb . list_elements ( string , self . root_hosts ) ) return ret	1
Q_65	get all parent of xml node	C_65_6	def get_parents ( self , node ) parent = self . parents . get ( node ) if parent = = none return set ( ) else return { parent }	1
Q_65	get all parent of xml node	C_65_7	def get_nidm_parent ( self , term )	1
Q_65	get all parent of xml node	C_65_8	def get_parents ( self , node ) parent = self . parents . get ( node ) if parent = = none return set ( ) else return { parent }	1
Q_65	get all parent of xml node	C_65_9	def dominator_tree ( graph ) string string roots string loops string string todo = queue ( ) done = set ( ) dominator = tree ( none ) nodes = list ( graph . nodes ) while true	1
Q_65	get all parent of xml node	C_65_10	def get_all_parents ( self ) string string string all_parents = set ( ) for var in self . parents all_parents . add ( var . item_id ) all_parents = var . get_all_parents ( ) return all_parents	1
Q_65	get all parent of xml node	C_65_11	def get_xml_node ( self ) xb = xmlapi . xml_builder ( ) ret = [ ] if self . access_hosts is not none ret . append ( xb . list_elements ( string , self . access_hosts ) ) if self . rw_hosts is not none ret . append ( xb . list_elements ( string , self . rw_hosts ) ) if self . ro_hosts is not none ret . append ( xb . list_elements ( string , self . ro_hosts ) ) if self . root_hosts is not none ret . append ( xb . list_elements ( string , self . root_hosts ) ) return ret	1
Q_65	get all parent of xml node	C_65_12	def get_edges ( self , node ) return [ ( node , var ) for var in self . get_children ( node ) ] + [ ( parent , node ) for parent in self . get_parents ( node ) ]	1
Q_65	get all parent of xml node	C_65_13	def get_all_parents ( self ) string string string all_parents = set ( ) for var in self . parents all_parents . add ( var . item_id ) all_parents = var . get_all_parents ( ) return all_parents	1
Q_65	get all parent of xml node	C_65_14	def get_ancestor_ephemeral_nodes ( self , selected_nodes ) node_names = { } for var in selected_nodes if var not in self . manifest . nodes continue node = self . manifest . nodes [ var ]	0
Q_65	get all parent of xml node	C_65_15	def estimate_cpd ( self , node ) string string a string b string c string a string c string b string c string a string c string string state_counts = self . state_counts ( node )	0
Q_65	get all parent of xml node	C_65_16	def get_parents ( self , node ) parent = self . parents . get ( node ) if parent = = none return set ( ) else return { parent }	0
Q_65	get all parent of xml node	C_65_17	def get_nidm_parent ( self , term )	0
Q_65	get all parent of xml node	C_65_18	def _find ( self , node ) root = node while root in self . parents root = self . parents [ root ] while node in self . parents prev_node = node node = self . parents [ node ] self . parents [ prev_node ] = root return root	0
Q_65	get all parent of xml node	C_65_19	def get_parents ( self , node ) parent = self . parents . get ( node ) if parent = = none return set ( ) else return { parent }	0
Q_65	get all parent of xml node	C_65_20	def dominator_tree ( graph ) string string roots string loops string string todo = queue ( ) done = set ( ) dominator = tree ( none ) nodes = list ( graph . nodes ) while true	0
Q_65	get all parent of xml node	C_65_21	def estimate_cpd ( self , node ) string string a string b string c string a string c string b string c string a string c string string state_counts = self . state_counts ( node )	0
Q_66	fuzzy match ranking	C_66_0	def fuzzmatch ( self , fuzzkey , multi = false ) string string fuzzy string string keys , ratios = np . array ( [ ( var , seqm ( none , fuzzkey , var ) . ratio ( ) ) for var in self . components . keys ( ) ] ) . t mratio = max ( ratios ) if multi return keys [ ratios = = mratio ] else if sum ( ratios = = mratio ) = = number return keys [ ratios = = mratio ] [ number ] else raise value_error ( string { } string . format ( fuzzkey ) + string . join ( keys [ ratios = = mratio ] ) + string )	1
Q_66	fuzzy match ranking	C_66_1	def _fuzzy_match ( set_a , set_b ) seen = dict ( ) scores = list ( )	1
Q_66	fuzzy match ranking	C_66_2	def fuzzy_match ( name , strings ) global fuzzy_match_fun if fuzzy_match_fun is not none return fuzzy_match_fun ( name , strings ) try from fuzzywuzzy import process , fuzz fuzzy_match_fun = lambda name , strings process . extract_one ( name , strings , scorer = fuzz . partial_ratio ) [ number ] except import_error	1
Q_66	fuzzy match ranking	C_66_3	def _exact_match ( response , matches , insensitive , fuzzy ) string string string for var in matches if response = = var return var elif insensitive and response . lower ( ) = = var . lower ( ) return var elif fuzzy and _exact_fuzzy_match ( response , var , insensitive ) return var else return none	1
Q_66	fuzzy match ranking	C_66_4	def rank ( raw_match_info , * raw_weights )	1
Q_66	fuzzy match ranking	C_66_5	def _exact_match ( response , matches , insensitive , fuzzy ) string string string for var in matches if response = = var return var elif insensitive and response . lower ( ) = = var . lower ( ) return var elif fuzzy and _exact_fuzzy_match ( response , var , insensitive ) return var else return none	1
Q_66	fuzzy match ranking	C_66_6	def _exact_match ( response , matches , insensitive , fuzzy ) string string string for var in matches if response = = var return var elif insensitive and response . lower ( ) = = var . lower ( ) return var elif fuzzy and _exact_fuzzy_match ( response , var , insensitive ) return var else return none	1
Q_66	fuzzy match ranking	C_66_7	def best_item_from_list ( item , options , fuzzy = number , fname_match = true , fuzzy_fragment = none , guess = false ) string string string match = best_match_from_list ( item , options , fuzzy , fname_match , fuzzy_fragment , guess ) if match return match [ number ] return none	1
Q_66	fuzzy match ranking	C_66_8	def dictionarize ( rankings , m ) rankcnt = { }	1
Q_66	fuzzy match ranking	C_66_9	def fuzzmatch ( self , fuzzkey , multi = false ) string string fuzzy string string keys , ratios = np . array ( [ ( var , seqm ( none , fuzzkey , var ) . ratio ( ) ) for var in self . components . keys ( ) ] ) . t mratio = max ( ratios ) if multi return keys [ ratios = = mratio ] else if sum ( ratios = = mratio ) = = number return keys [ ratios = = mratio ] [ number ] else raise value_error ( string { } string . format ( fuzzkey ) + string . join ( keys [ ratios = = mratio ] ) + string )	0
Q_66	fuzzy match ranking	C_66_10	def zrank ( self , name , value ) zset = self . _get_zset ( name , string ) return zset . rank ( self . _encode ( value ) ) if zset else none	0
Q_66	fuzzy match ranking	C_66_11	def zrank ( self , name , value ) zset = self . _get_zset ( name , string ) return zset . rank ( self . _encode ( value ) ) if zset else none	0
Q_66	fuzzy match ranking	C_66_12	def best_item_from_list ( item , options , fuzzy = number , fname_match = true , fuzzy_fragment = none , guess = false ) string string string match = best_match_from_list ( item , options , fuzzy , fname_match , fuzzy_fragment , guess ) if match return match [ number ] return none	0
Q_66	fuzzy match ranking	C_66_13	def find_preset ( self , preset ) string string string	0
Q_66	fuzzy match ranking	C_66_14	def dictionarize ( rankings , m ) rankcnt = { }	0
Q_66	fuzzy match ranking	C_66_15	def find_preset ( self , preset ) string string string	0
Q_66	fuzzy match ranking	C_66_16	def rank ( raw_match_info , * raw_weights )	0
Q_67	format date	C_67_0	def format_grouped_date ( self , data , group ) date = self . get_grouped_date ( data , group ) if group = = string date = u string ( ( date _ datetime . timedelta ( days = number ) ) . strftime ( string ) , date . strftime ( string ) ) elif group = = string date = date . strftime ( string ) else date = formats . date_format ( date , string ) return date	1
Q_67	format date	C_67_1	def datetime_from_iso8601 ( date ) string string number _ number number _ number t12 number number string number _ number number _ number number t12 number number . number string string format = iso8610_format if date . endswith ( string ) date = date [ _ number ]	1
Q_67	format date	C_67_2	def format_date ( self , value , format_ ) string string string date_ = make_date ( value ) return dates . format_date ( date_ , format_ , locale = self . lang )	1
Q_67	format date	C_67_3	def format_date ( date , timestamp_format ) try date = date_add . format ( int ( date ) ) except value_error date = timestamp_format . format ( date ) return date	1
Q_67	format date	C_67_4	def format_date_for_input ( date ) date_fmt = get_locale ( ) . date_formats [ string ] . pattern	1
Q_67	format date	C_67_5	def format_date_for_input ( date ) date_fmt = get_locale ( ) . date_formats [ string ] . pattern	1
Q_67	format date	C_67_6	def format_date ( date , timestamp_format ) try date = date_add . format ( int ( date ) ) except value_error date = timestamp_format . format ( date ) return date	1
Q_67	format date	C_67_7	def format_date ( date , gmt_offset = number , relative = true , shorter = false , full_format = false ) string string number minutes ago string july number , number string string if not date return string if isinstance ( date , float ) or isinstance ( date , int ) date = datetime . datetime . utcfromtimestamp ( date ) now = datetime . datetime . utcnow ( ) if date > now if relative and ( date _ now ) . seconds < number	1
Q_67	format date	C_67_8	def std_tsymbol ( tsymbol ) s , date = tsymbol if date = = number return string . format ( s ) elif date < = number return string . format ( s , str ( _ date ) ) elif date > = number return string . format ( s , str ( date ) )	1
Q_67	format date	C_67_9	def std_tsymbol ( tsymbol ) s , date = tsymbol if date = = number return string . format ( s ) elif date < = number return string . format ( s , str ( _ date ) ) elif date > = number return string . format ( s , str ( date ) )	1
Q_67	format date	C_67_10	def format_dateformat ( dates ) format = dateformat . date_format ( string ) for var in dates assert isinstance ( format . format ( var ) , str )	1
Q_67	format date	C_67_11	def format_date_for_input ( date ) date_fmt = get_locale ( ) . date_formats [ string ] . pattern	1
Q_67	format date	C_67_12	def format_grouped_date ( self , data , group ) date = self . get_grouped_date ( data , group ) if group = = string date = u string ( ( date _ datetime . timedelta ( days = number ) ) . strftime ( string ) , date . strftime ( string ) ) elif group = = string date = date . strftime ( string ) else date = formats . date_format ( date , string ) return date	1
Q_67	format date	C_67_13	def format_date ( date , gmt_offset = number , relative = true , shorter = false , full_format = false ) string string number minutes ago string july number , number string string if not date return string if isinstance ( date , float ) or isinstance ( date , int ) date = datetime . datetime . utcfromtimestamp ( date ) now = datetime . datetime . utcnow ( ) if date > now if relative and ( date _ now ) . seconds < number	1
Q_67	format date	C_67_14	def format_date ( date , gmt_offset = number , relative = true , shorter = false , full_format = false ) string string number minutes ago string july number , number string string if not date return string if isinstance ( date , float ) or isinstance ( date , int ) date = datetime . datetime . utcfromtimestamp ( date ) now = datetime . datetime . utcnow ( ) if date > now if relative and ( date _ now ) . seconds < number	1
Q_67	format date	C_67_15	def format_date ( date , timestamp_format ) try date = date_add . format ( int ( date ) ) except value_error date = timestamp_format . format ( date ) return date	1
Q_67	format date	C_67_16	def format_dateformat ( dates ) format = dateformat . date_format ( string ) for var in dates assert isinstance ( format . format ( var ) , str )	1
Q_67	format date	C_67_17	def datetime_from_iso8601 ( date ) string string number _ number number _ number t12 number number string number _ number number _ number number t12 number number . number string string format = iso8610_format if date . endswith ( string ) date = date [ _ number ]	0
Q_68	finding time elapse use a timer	C_68_0	def timer ( name ) start_time = time . time ( ) yield elapsed_time = time . time ( ) _ start_time print ( string . format ( name , int ( elapsed_time * number ) ) )	1
Q_68	finding time elapse use a timer	C_68_1	def timer ( description = string , log = none ) string string sleeping string doing string string start = time ( ) yield elapsed = time ( ) _ start message = string ( description , elapsed ) ( print if log is none else log . info ) ( message )	1
Q_68	finding time elapse use a timer	C_68_2	def timer ( name ) start_time = time . time ( ) yield elapsed_time = time . time ( ) _ start_time print ( string . format ( name , int ( elapsed_time * number ) ) )	1
Q_68	finding time elapse use a timer	C_68_3	def timer ( description = string , log = none ) string string sleeping string doing string string start = time ( ) yield elapsed = time ( ) _ start message = string ( description , elapsed ) ( print if log is none else log . info ) ( message )	1
Q_68	finding time elapse use a timer	C_68_4	def timed ( func ) functools . wraps ( func ) def timer ( * args , * * kwargs ) start_time = time ( ) result = func ( * args , * * kwargs ) elapsed_time = str ( timedelta ( seconds = int ( time ( ) _ start_time ) ) ) print ( string . format ( elapsed_time ) ) return result return timer	1
Q_68	finding time elapse use a timer	C_68_5	def timed ( func ) functools . wraps ( func ) def timer ( * args , * * kwargs ) start_time = time ( ) result = func ( * args , * * kwargs ) elapsed_time = str ( timedelta ( seconds = int ( time ( ) _ start_time ) ) ) print ( string . format ( elapsed_time ) ) return result return timer	1
Q_68	finding time elapse use a timer	C_68_6	def _calc_benchmark_stat ( self , f ) timer = timer ( ) i = number while true f ( ) i + = number if i > = self . min_run _ , elapsed = timer . lap ( ) if elapsed > self . min_time break return benchmark_stat ( elapsed / i , i )	1
Q_68	finding time elapse use a timer	C_68_7	def elapsed_time ( self ) string string string	1
Q_68	finding time elapse use a timer	C_68_8	def timeout_counter ( sec_timeout ) start_time = time . time ( ) elapsed_time = time . time ( ) _ start_time time_left = sec_timeout _ int ( elapsed_time ) printed_time = time_left while elapsed_time < sec_timeout time_left = sec_timeout _ int ( elapsed_time ) if time_left < printed_time printed_time = time_left print ( string printed_time ) elapsed_time = time . time ( ) _ start_time	1
Q_68	finding time elapse use a timer	C_68_9	def cumulative_elapsed_time_example ( ) print ( string ) timer = stopwatch ( string ) with timer sleep ( number ) sleep ( number ) with timer sleep ( number ) timer . log_elapsed_time ( prefix = string )	1
Q_68	finding time elapse use a timer	C_68_10	def update ( self )	1
Q_68	finding time elapse use a timer	C_68_11	def _calc_benchmark_stat ( self , f ) timer = timer ( ) i = number while true f ( ) i + = number if i > = self . min_run _ , elapsed = timer . lap ( ) if elapsed > self . min_time break return benchmark_stat ( elapsed / i , i )	1
Q_68	finding time elapse use a timer	C_68_12	def elapsed_time ( self ) string string string	1
Q_68	finding time elapse use a timer	C_68_13	def timer ( fn , miniter = number , minwall = number . number ) string string string results = [ ] count = number	1
Q_68	finding time elapse use a timer	C_68_14	def update ( self )	1
Q_68	finding time elapse use a timer	C_68_15	def timeout_counter ( sec_timeout ) start_time = time . time ( ) elapsed_time = time . time ( ) _ start_time time_left = sec_timeout _ int ( elapsed_time ) printed_time = time_left while elapsed_time < sec_timeout time_left = sec_timeout _ int ( elapsed_time ) if time_left < printed_time printed_time = time_left print ( string printed_time ) elapsed_time = time . time ( ) _ start_time	1
Q_68	finding time elapse use a timer	C_68_16	def timer ( fn , miniter = number , minwall = number . number ) string string string results = [ ] count = number	1
Q_68	finding time elapse use a timer	C_68_17	def cumulative_elapsed_time_example ( ) print ( string ) timer = stopwatch ( string ) with timer sleep ( number ) sleep ( number ) with timer sleep ( number ) timer . log_elapsed_time ( prefix = string )	1
Q_68	finding time elapse use a timer	C_68_18	def update ( self )	0
Q_68	finding time elapse use a timer	C_68_19	def timeout_counter ( sec_timeout ) start_time = time . time ( ) elapsed_time = time . time ( ) _ start_time time_left = sec_timeout _ int ( elapsed_time ) printed_time = time_left while elapsed_time < sec_timeout time_left = sec_timeout _ int ( elapsed_time ) if time_left < printed_time printed_time = time_left print ( string printed_time ) elapsed_time = time . time ( ) _ start_time	0
Q_69	find int in string	C_69_0	def find_number ( regex , s ) string string string result = find_string ( regex , s ) if result is none return none return int ( result )	1
Q_69	find int in string	C_69_1	def find_number ( regex , s ) string string string result = find_string ( regex , s ) if result is none return none return int ( result )	1
Q_69	find int in string	C_69_2	def find ( self , txt ) result = [ ] for var in self . table print ( string , var ) if txt in str ( var ) result . append ( var )	1
Q_69	find int in string	C_69_3	def find_challenge_goal ( self , id , raw = false ) start = number matching_strings = [ ] def try_find ( ) nonlocal start index = self . js_strings . index ( id , start ) for var in range ( find_goal_search_distance ) next_str = self . js_strings [ index + var + number ] if re . search ( r string , next_str , re . i ) matching_strings . append ( ( var , index , next_str ) ) start = index + find_goal_search_distance + number try while true try_find ( ) except ( value_error , index_error ) pass try goal = min ( matching_strings ) [ number ] except value_error return none , none raw = goal plain = raw . replace ( string , string ) . replace ( string , string ) return raw , plain	1
Q_69	find int in string	C_69_4	def find_first ( value , find_arr , start = number ) i = len ( value ) for var in find_arr temp = value . find ( var , start ) if temp = = _ number continue i = min ( i , temp ) if i = = len ( value ) return _ number return i	1
Q_69	find int in string	C_69_5	def find ( value , find , start = number ) string string string l = len ( value ) if is_list ( find ) m = l for var in find i = value . find ( var , start ) if i = = _ number continue m = min ( m , i ) return m else i = value . find ( find , start ) if i = = _ number return l return i	1
Q_69	find int in string	C_69_6	def find ( value , find , start = number ) string string string l = len ( value ) if is_list ( find ) m = l for var in find i = value . find ( var , start ) if i = = _ number continue m = min ( m , i ) return m else i = value . find ( find , start ) if i = = _ number return l return i	1
Q_69	find int in string	C_69_7	def find_challenge_goal ( self , id , raw = false ) start = number matching_strings = [ ] def try_find ( ) nonlocal start index = self . js_strings . index ( id , start ) for var in range ( find_goal_search_distance ) next_str = self . js_strings [ index + var + number ] if re . search ( r string , next_str , re . i ) matching_strings . append ( ( var , index , next_str ) ) start = index + find_goal_search_distance + number try while true try_find ( ) except ( value_error , index_error ) pass try goal = min ( matching_strings ) [ number ] except value_error return none , none raw = goal plain = raw . replace ( string , string ) . replace ( string , string ) return raw , plain	1
Q_69	find int in string	C_69_8	def _isavaliablevni ( vnirange , allocated , vni ) find = false for var , var in vnirange if var < = int ( vni ) < = var find = true break if find if str ( vni ) not in allocated find = true else find = false else find = false return find	1
Q_69	find int in string	C_69_9	def _break ( s , find ) string string string i = s . find ( find ) return s [ i ] , s [ i ]	0
Q_69	find int in string	C_69_10	def get ( self , find_id ) find_id = int ( find_id ) for var in self if id ( var ) = = find_id return var	0
Q_69	find int in string	C_69_11	def is_substr ( find , strlist ) if len ( strlist ) < number and len ( find ) < number return false for var in range ( len ( strlist ) ) if find not in strlist [ var ] return false return true	0
Q_69	find int in string	C_69_12	def find_first ( value , find_arr , start = number ) i = len ( value ) for var in find_arr temp = value . find ( var , start ) if temp = = _ number continue i = min ( i , temp ) if i = = len ( value ) return _ number return i	0
Q_69	find int in string	C_69_13	def _parse_xml ( self , xml_file )	0
Q_69	find int in string	C_69_14	def _parse_xml ( self , xml_file )	0
Q_69	find int in string	C_69_15	def is_substr ( find , strlist ) if len ( strlist ) < number and len ( find ) < number return false for var in range ( len ( strlist ) ) if find not in strlist [ var ] return false return true	0
Q_69	find int in string	C_69_16	def _isavaliablevni ( vnirange , allocated , vni ) find = false for var , var in vnirange if var < = int ( vni ) < = var find = true break if find if str ( vni ) not in allocated find = true else find = false else find = false return find	0
Q_69	find int in string	C_69_17	def find ( self , txt ) result = [ ] for var in self . table print ( string , var ) if txt in str ( var ) result . append ( var )	0
Q_69	find int in string	C_69_18	def get ( self , find_id ) find_id = int ( find_id ) for var in self if id ( var ) = = find_id return var	0
Q_69	find int in string	C_69_19	def _break ( s , find ) string string string i = s . find ( find ) return s [ i ] , s [ i ]	0
Q_70	filter array	C_70_0	def params ( self ) if not any ( var . params for var in self ) return none else return array ( var . params or null ( ) for var in self )	1
Q_70	filter array	C_70_1	def filter ( this , args ) array = to_object ( this , args . space ) callbackfn = get_arg ( args , number ) arr_len = js_arr_length ( array ) if not is_callable ( callbackfn ) raise make_error ( string , string ) _this = get_arg ( args , number ) k = number res = [ ] while k < arr_len if array . has_property ( unicode ( k ) ) k_value = array . get ( unicode ( k ) ) if to_boolean ( callbackfn . call ( _this , ( k_value , float ( k ) , array ) ) ) res . append ( k_value ) k + = number return args . space . construct_array ( res )	1
Q_70	filter array	C_70_2	def get_json_filters ( args ) jsonfilters = [ ] if hasattr ( args , string ) splitnames = args . include_names_json . split ( string ) for var in splitnames splitnameeq = var . split ( string )	1
Q_70	filter array	C_70_3	def params ( self ) if not any ( var . params for var in self ) return none else return array ( var . params or null ( ) for var in self )	1
Q_70	filter array	C_70_4	def apply_filter ( x , filter = none , axis = number ) string string string x = _as_array ( x ) if x . shape [ axis ] = = number return x b , a = filter return signal . filtfilt ( b , a , x , axis = axis )	1
Q_70	filter array	C_70_5	def apply_filter ( x , filter = none , axis = number ) string string string x = _as_array ( x ) if x . shape [ axis ] = = number return x b , a = filter return signal . filtfilt ( b , a , x , axis = axis )	1
Q_70	filter array	C_70_6	def _device_proxy_get_property_list ( self , filter , array = none ) string string * string string if array is none new_array = std_string_vector ( ) self . _get_property_list ( filter , new_array ) return new_array if isinstance ( array , std_string_vector ) self . _get_property_list ( filter , array ) return array elif isinstance ( array , collections_abc . sequence ) new_array = std_string_vector ( ) self . _get_property_list ( filter , new_array ) std_string_vector_2_seq ( new_array , array ) return array raise type_error ( string )	1
Q_70	filter array	C_70_7	def params ( self ) if not any ( var . params for var in self ) return none else return array ( var . params or null ( ) for var in self )	1
Q_70	filter array	C_70_8	def _build_filtered_query ( self , f , operator ) string string string self . _filtered = true if isinstance ( f , filter ) filter_object = f else filter_object = filter ( operator ) . filter ( f ) self . _filter_dsl = filter_object	0
Q_70	filter array	C_70_9	def fbp_filter_op ( ray_trafo , padding = true , filter_type = string , frequency_scaling = number . number ) string string ram _ lak string shepp _ logan string cosine string hamming string hann string string impl = string if pyfftw_available else string alen = ray_trafo . geometry . motion_params . length if ray_trafo . domain . ndim = = number	0
Q_70	filter array	C_70_10	def _build_filtered_query ( self , f , operator ) string string string self . _filtered = true if isinstance ( f , filter ) filter_object = f else filter_object = filter ( operator ) . filter ( f ) self . _filter_dsl = filter_object	0
Q_70	filter array	C_70_11	def get_filter ( self ) new_filter = self . input_buffer [ string ] . peek ( ) if not new_filter return false if new_filter = = self . filter_frame return true self . send ( string , new_filter ) filter_coefs = new_filter . as_numpy ( dtype = numpy . float32 ) if filter_coefs . ndim = number self . logger . warning ( string ) return false ylen , xlen = filter_coefs . shape [ number ] if ( xlen number ) = number or ( ylen number ) = number self . logger . warning ( string ) return false self . filter_frame = new_filter self . filter_coefs = filter_coefs self . fil_count = none return true	0
Q_70	filter array	C_70_12	def get_filter ( self ) new_filter = self . input_buffer [ string ] . peek ( ) if not new_filter return false if new_filter = = self . filter_frame return true self . send ( string , new_filter ) filter_coefs = new_filter . as_numpy ( dtype = numpy . float32 ) if filter_coefs . ndim = number self . logger . warning ( string ) return false ylen , xlen = filter_coefs . shape [ number ] if ( xlen number ) = number or ( ylen number ) = number self . logger . warning ( string ) return false self . filter_frame = new_filter self . filter_coefs = filter_coefs self . fil_count = none return true	0
Q_70	filter array	C_70_13	def _device_proxy_get_property_list ( self , filter , array = none ) string string * string string if array is none new_array = std_string_vector ( ) self . _get_property_list ( filter , new_array ) return new_array if isinstance ( array , std_string_vector ) self . _get_property_list ( filter , array ) return array elif isinstance ( array , collections_abc . sequence ) new_array = std_string_vector ( ) self . _get_property_list ( filter , new_array ) std_string_vector_2_seq ( new_array , array ) return array raise type_error ( string )	0
Q_70	filter array	C_70_14	def _build_filtered_query ( self , f , operator ) string string string self . _filtered = true if isinstance ( f , filter ) filter_object = f else filter_object = filter ( operator ) . filter ( f ) self . _filter_dsl = filter_object	0
Q_70	filter array	C_70_15	def filter ( this , args ) array = to_object ( this , args . space ) callbackfn = get_arg ( args , number ) arr_len = js_arr_length ( array ) if not is_callable ( callbackfn ) raise make_error ( string , string ) _this = get_arg ( args , number ) k = number res = [ ] while k < arr_len if array . has_property ( unicode ( k ) ) k_value = array . get ( unicode ( k ) ) if to_boolean ( callbackfn . call ( _this , ( k_value , float ( k ) , array ) ) ) res . append ( k_value ) k + = number return args . space . construct_array ( res )	0
Q_70	filter array	C_70_16	def _build_filtered_query ( self , f , operator ) string string string self . _filtered = true if isinstance ( f , filter ) filter_object = f else filter_object = filter ( operator ) . filter ( f ) self . _filter_dsl = filter_object	0
Q_70	filter array	C_70_17	def apply_filter ( x , filter = none , axis = number ) string string string x = _as_array ( x ) if x . shape [ axis ] = = number return x b , a = filter return signal . filtfilt ( b , a , x , axis = axis )	0
Q_71	extract data from a text file	C_71_0	def extractdata ( pattern , text = none , filepath = none ) string string string y = [ ] if text is none textsource = open ( filepath , string ) else textsource = text . splitlines ( ) for var in textsource match = scanf ( pattern , var ) if match if len ( y ) = = number y = [ [ s ] for s in match ] else for i , ydata in enumerate ( y ) ydata . append ( match [ i ] ) if text is none textsource . close ( ) return y	1
Q_71	extract data from a text file	C_71_1	def from_text_file ( file_path ) string string string results = [ ] with io . open ( file_path , string , encoding = string ) as f data_strs = f . read ( ) . split ( monsoon_data . delimiter ) for var in data_strs results . append ( monsoon_data . from_string ( var ) ) return results	1
Q_71	extract data from a text file	C_71_2	def _extract_metadata_from_file_entry ( self , mediator , file_entry , data_stream ) string string string	1
Q_71	extract data from a text file	C_71_3	def extractdata ( pattern , text = none , filepath = none ) string string string y = [ ] if text is none textsource = open ( filepath , string ) else textsource = text . splitlines ( ) for var in textsource match = scanf ( pattern , var ) if match if len ( y ) = = number y = [ [ s ] for s in match ] else for i , ydata in enumerate ( y ) ydata . append ( match [ i ] ) if text is none textsource . close ( ) return y	1
Q_71	extract data from a text file	C_71_4	def extract_impression_from_file ( file_path )	1
Q_71	extract data from a text file	C_71_5	def _read_inputs ( loc , msg ) if loc = = string msg . info ( string ) file_ = sys . stdin file_ = ( var . encode ( string ) for var in file_ ) else input_path = path ( loc ) if not input_path . exists ( ) or not input_path . is_file ( ) msg . fail ( string , loc , exits = number ) msg . info ( string . format ( input_path . parts [ _ number ] ) ) file_ = input_path . open ( ) for var in file_ data = srsly . json_loads ( var ) text = data [ string ] yield text	1
Q_71	extract data from a text file	C_71_6	def no_error_extract_data_from_file ( self , file_path str ) _ > iterable [ data_source_type ] string string string try return self . extract_data_from_file ( file_path ) except exception as e logging . warning ( e ) return [ ]	1
Q_71	extract data from a text file	C_71_7	def no_error_extract_data_from_file ( self , file_path str ) _ > iterable [ data_source_type ] string string string try return self . extract_data_from_file ( file_path ) except exception as e logging . warning ( e ) return [ ]	1
Q_71	extract data from a text file	C_71_8	def from_text_file ( file_path ) string string string results = [ ] with io . open ( file_path , string , encoding = string ) as f data_strs = f . read ( ) . split ( monsoon_data . delimiter ) for var in data_strs results . append ( monsoon_data . from_string ( var ) ) return results	1
Q_71	extract data from a text file	C_71_9	def load_text ( fname ) with codecs . open ( fname , string , string ) as f data = f . read ( ) return normalize ( data ) . split ( )	1
Q_71	extract data from a text file	C_71_10	def read_field_report ( path , data_flag = string , meta_data_flag = string ) string string string text = open ( path ) . read ( ) mdpos = text . find ( meta_data_flag ) dpos = text . find ( data_flag ) mdata = io . string_io ( string . join ( text [ mdpos dpos ] . split ( string ) [ number ] ) ) data = io . string_io ( string . join ( text [ dpos ] . split ( string ) [ number ] ) ) data = pd . read_csv ( data , index_col = number ) data = data . groupby ( data . index ) . mean ( ) mdata = pd . read_csv ( mdata , sep = string , header = none , index_col = number ) [ number ] mdata = mdata . to_dict ( ) out = { } out [ string ] = int ( mdata [ string ] ) out [ string ] = mdata [ string ] out [ string ] = int ( mdata [ string ] ) out [ string ] = float ( mdata [ string ] ) out [ string ] = mdata [ string ] position_map = { string string , string string , string string } out [ string ] = position_map [ mdata [ string ] ] out [ string ] = mdata [ string ] out [ string ] = data field_class = getattr ( argiope . mesh , mdata [ string ] ) return field_class ( * * out )	1
Q_71	extract data from a text file	C_71_11	def extractidddata ( fname , debug = false ) string string string try if isinstance ( fname , ( file , string_io ) ) astr = fname . read ( ) try astr = astr . decode ( string ) except attribute_error pass else astr = mylib2 . readfile ( fname )	1
Q_71	extract data from a text file	C_71_12	def load_text ( fname ) with codecs . open ( fname , string , string ) as f data = f . read ( ) return normalize ( data ) . split ( )	1
Q_71	extract data from a text file	C_71_13	def read_field_report ( path , data_flag = string , meta_data_flag = string ) string string string text = open ( path ) . read ( ) mdpos = text . find ( meta_data_flag ) dpos = text . find ( data_flag ) mdata = io . string_io ( string . join ( text [ mdpos dpos ] . split ( string ) [ number ] ) ) data = io . string_io ( string . join ( text [ dpos ] . split ( string ) [ number ] ) ) data = pd . read_csv ( data , index_col = number ) data = data . groupby ( data . index ) . mean ( ) mdata = pd . read_csv ( mdata , sep = string , header = none , index_col = number ) [ number ] mdata = mdata . to_dict ( ) out = { } out [ string ] = int ( mdata [ string ] ) out [ string ] = mdata [ string ] out [ string ] = int ( mdata [ string ] ) out [ string ] = float ( mdata [ string ] ) out [ string ] = mdata [ string ] position_map = { string string , string string , string string } out [ string ] = position_map [ mdata [ string ] ] out [ string ] = mdata [ string ] out [ string ] = data field_class = getattr ( argiope . mesh , mdata [ string ] ) return field_class ( * * out )	1
Q_71	extract data from a text file	C_71_14	def extractidddata ( fname , debug = false ) string string string try if isinstance ( fname , ( file , string_io ) ) astr = fname . read ( ) try astr = astr . decode ( string ) except attribute_error pass else astr = mylib2 . readfile ( fname )	1
Q_71	extract data from a text file	C_71_15	def extract_impression_from_file ( file_path )	1
Q_71	extract data from a text file	C_71_16	def extract_context_data ( self ) string string string data = { } for var , var in {	0
Q_71	extract data from a text file	C_71_17	def _extract_metadata_from_file_entry ( self , mediator , file_entry , data_stream ) string string string	0
Q_71	extract data from a text file	C_71_18	def extract_context_data ( self ) string string string data = { } for var , var in {	0
Q_72	extract latitude and longitude from give input	C_72_0	def decode_longitude ( self , longitude ) match = re_longitude . match ( longitude ) if not match raise parser_error ( string ) longitude = int ( match . group ( number ) ) + float ( match . group ( number ) ) / number . if not ( number < = longitude < = number ) raise parser_error ( string ) if match . group ( number ) . upper ( ) = = string longitude = _ longitude return longitude	1
Q_72	extract latitude and longitude from give input	C_72_1	def from_latitude_longitude ( cls , latitude = number . number , longitude = number . number ) string string string assert _ number . number < = longitude < = number . number , string assert _ number . number < = latitude < = number . number , string return cls ( latitude = latitude , longitude = longitude )	1
Q_72	extract latitude and longitude from give input	C_72_2	def decode_longitude ( self , longitude ) match = re_longitude . match ( longitude ) if not match raise parser_error ( string ) longitude = int ( match . group ( number ) ) + float ( match . group ( number ) ) / number . if not ( number < = longitude < = number ) raise parser_error ( string ) if match . group ( number ) . upper ( ) = = string longitude = _ longitude return longitude	1
Q_72	extract latitude and longitude from give input	C_72_3	def from_latlon ( latitude , longitude , force_zone_number = none , force_zone_letter = none ) string string string if not in_bounds ( latitude , _ number . number , number . number ) raise out_of_range_error ( string ) if not in_bounds ( longitude , _ number . number , number . number ) raise out_of_range_error ( string ) if force_zone_number is not none check_valid_zone ( force_zone_number , force_zone_letter ) lat_rad = mathlib . radians ( latitude ) lat_sin = mathlib . sin ( lat_rad ) lat_cos = mathlib . cos ( lat_rad ) lat_tan = lat_sin / lat_cos lat_tan2 = lat_tan * lat_tan lat_tan4 = lat_tan2 * lat_tan2 if force_zone_number is none zone_number = latlon_to_zone_number ( latitude , longitude ) else zone_number = force_zone_number if force_zone_letter is none zone_letter = latitude_to_zone_letter ( latitude ) else zone_letter = force_zone_letter lon_rad = mathlib . radians ( longitude ) central_lon = zone_number_to_central_longitude ( zone_number ) central_lon_rad = mathlib . radians ( central_lon ) n = r / mathlib . sqrt ( number _ e * lat_sin * * number ) c = e_p2 * lat_cos * * number a = lat_cos * ( lon_rad _ central_lon_rad ) a2 = a * a a3 = a2 * a a4 = a3 * a a5 = a4 * a a6 = a5 * a m = r * ( m1 * lat_rad _ m2 * mathlib . sin ( number * lat_rad ) + m3 * mathlib . sin ( number * lat_rad ) _ m4 * mathlib . sin ( number * lat_rad ) ) easting = k0 * n * ( a + a3 / number * ( number _ lat_tan2 + c ) + a5 / number * ( number _ number * lat_tan2 + lat_tan4 + number * c _ number * e_p2 ) ) + number northing = k0 * ( m + n * lat_tan * ( a2 / number + a4 / number * ( number _ lat_tan2 + number * c + number * c * * number ) + a6 / number * ( number _ number * lat_tan2 + lat_tan4 + number * c _ number * e_p2 ) ) ) if mixed_signs ( latitude ) raise value_error ( string ) elif negative ( latitude ) northing + = number return easting , northing , zone_number , zone_letter	1
Q_72	extract latitude and longitude from give input	C_72_4	def from_latlon ( latitude , longitude , force_zone_number = none , force_zone_letter = none ) string string string if not in_bounds ( latitude , _ number . number , number . number ) raise out_of_range_error ( string ) if not in_bounds ( longitude , _ number . number , number . number ) raise out_of_range_error ( string ) if force_zone_number is not none check_valid_zone ( force_zone_number , force_zone_letter ) lat_rad = mathlib . radians ( latitude ) lat_sin = mathlib . sin ( lat_rad ) lat_cos = mathlib . cos ( lat_rad ) lat_tan = lat_sin / lat_cos lat_tan2 = lat_tan * lat_tan lat_tan4 = lat_tan2 * lat_tan2 if force_zone_number is none zone_number = latlon_to_zone_number ( latitude , longitude ) else zone_number = force_zone_number if force_zone_letter is none zone_letter = latitude_to_zone_letter ( latitude ) else zone_letter = force_zone_letter lon_rad = mathlib . radians ( longitude ) central_lon = zone_number_to_central_longitude ( zone_number ) central_lon_rad = mathlib . radians ( central_lon ) n = r / mathlib . sqrt ( number _ e * lat_sin * * number ) c = e_p2 * lat_cos * * number a = lat_cos * ( lon_rad _ central_lon_rad ) a2 = a * a a3 = a2 * a a4 = a3 * a a5 = a4 * a a6 = a5 * a m = r * ( m1 * lat_rad _ m2 * mathlib . sin ( number * lat_rad ) + m3 * mathlib . sin ( number * lat_rad ) _ m4 * mathlib . sin ( number * lat_rad ) ) easting = k0 * n * ( a + a3 / number * ( number _ lat_tan2 + c ) + a5 / number * ( number _ number * lat_tan2 + lat_tan4 + number * c _ number * e_p2 ) ) + number northing = k0 * ( m + n * lat_tan * ( a2 / number + a4 / number * ( number _ lat_tan2 + number * c + number * c * * number ) + a6 / number * ( number _ number * lat_tan2 + lat_tan4 + number * c _ number * e_p2 ) ) ) if mixed_signs ( latitude ) raise value_error ( string ) elif negative ( latitude ) northing + = number return easting , northing , zone_number , zone_letter	1
Q_72	extract latitude and longitude from give input	C_72_5	def compile_geometry ( lat , lon , elev ) string string string logger_excel . info ( string ) lat = _remove_geo_placeholders ( lat ) lon = _remove_geo_placeholders ( lon )	1
Q_72	extract latitude and longitude from give input	C_72_6	def compile_geometry ( lat , lon , elev ) string string string logger_excel . info ( string ) lat = _remove_geo_placeholders ( lat ) lon = _remove_geo_placeholders ( lon )	1
Q_72	extract latitude and longitude from give input	C_72_7	def parse_lat_lon ( query_params ) lat = query_params . get ( string , none ) lon = query_params . get ( string , none ) if not lat and not lon return none if not lat or not lon raise parse_error ( string lat string lon string ) try lat = float ( lat ) lon = float ( lon ) except value_error raise parse_error ( string lat string lon string ) point = point ( lon , lat , srid = default_srid ) if default_srid = database_srid ct = coord_transform ( spatial_reference ( default_srid ) , spatial_reference ( database_srid ) ) point . transform ( ct ) return point	1
Q_72	extract latitude and longitude from give input	C_72_8	def lat_lon_grid_deltas ( longitude , latitude , * * kwargs ) r string string string from pyproj import geod	1
Q_72	extract latitude and longitude from give input	C_72_9	def lon_lat ( value ) string string number number string string lon , lat = value . split ( ) return longitude ( lon ) , latitude ( lat )	1
Q_72	extract latitude and longitude from give input	C_72_10	def get_nearest_indices ( self , latitude , longitude ) string string string	1
Q_72	extract latitude and longitude from give input	C_72_11	def from_latitude_longitude ( cls , latitude = number . number , longitude = number . number ) string string string assert _ number . number < = longitude < = number . number , string assert _ number . number < = latitude < = number . number , string return cls ( latitude = latitude , longitude = longitude )	1
Q_72	extract latitude and longitude from give input	C_72_12	def lat_lon_grid_deltas ( longitude , latitude , * * kwargs ) r string string string from pyproj import geod	1
Q_72	extract latitude and longitude from give input	C_72_13	def parse_lat_lon ( query_params ) lat = query_params . get ( string , none ) lon = query_params . get ( string , none ) if not lat and not lon return none if not lat or not lon raise parse_error ( string lat string lon string ) try lat = float ( lat ) lon = float ( lon ) except value_error raise parse_error ( string lat string lon string ) point = point ( lon , lat , srid = default_srid ) if default_srid = database_srid ct = coord_transform ( spatial_reference ( default_srid ) , spatial_reference ( database_srid ) ) point . transform ( ct ) return point	1
Q_72	extract latitude and longitude from give input	C_72_14	def compile_geometry ( lat , lon , elev ) string string string logger_excel . info ( string ) lat = _remove_geo_placeholders ( lat ) lon = _remove_geo_placeholders ( lon )	1
Q_72	extract latitude and longitude from give input	C_72_15	def latlon_to_zone_number ( latitude , longitude )	1
Q_72	extract latitude and longitude from give input	C_72_16	def from_latitude_longitude ( cls , latitude = number . number , longitude = number . number ) string string string assert _ number . number < = longitude < = number . number , string assert _ number . number < = latitude < = number . number , string return cls ( latitude = latitude , longitude = longitude )	1
Q_72	extract latitude and longitude from give input	C_72_17	def compile_geometry ( lat , lon , elev ) string string string logger_excel . info ( string ) lat = _remove_geo_placeholders ( lat ) lon = _remove_geo_placeholders ( lon )	1
Q_72	extract latitude and longitude from give input	C_72_18	def compile_geometry ( lat , lon , elev ) string string string logger_excel . info ( string ) lat = _remove_geo_placeholders ( lat ) lon = _remove_geo_placeholders ( lon )	1
Q_72	extract latitude and longitude from give input	C_72_19	def lat_lon_grid_deltas ( longitude , latitude , * * kwargs ) r string string string from pyproj import geod	0
Q_72	extract latitude and longitude from give input	C_72_20	def lat_lon_grid_deltas ( longitude , latitude , * * kwargs ) r string string string from pyproj import geod	0
Q_72	extract latitude and longitude from give input	C_72_21	def get_nearest_indices ( self , latitude , longitude ) string string string	0
Q_72	extract latitude and longitude from give input	C_72_22	def lon_lat ( value ) string string number number string string lon , lat = value . split ( ) return longitude ( lon ) , latitude ( lat )	0
Q_72	extract latitude and longitude from give input	C_72_23	def latlon_to_zone_number ( latitude , longitude )	0
Q_73	extract data from html content	C_73_0	def _extract_data_from_show_html ( self , html ) string string string html_lines = html . splitlines ( ) for var , var in enumerate ( html_lines ) if var . strip ( ) = = r string start_line = var + number if var . strip ( ) = = r string end_line = var try data_list = html_lines [ start_line end_line ] data_string = string . join ( data_list ) return data_string . strip ( ) except raise exception ( string )	1
Q_73	extract data from html content	C_73_1	def extract ( self , html_text str , extract_title bool = false , extract_meta bool = false , extract_microdata bool = false , microdata_base_url str = string , extract_json_ld bool = false , extract_rdfa bool = false , rdfa_base_url str = string ) _ > list [ extraction ] string string title string title string . string meta string meta string author string . string microdata string json _ ld string rdfa string string res = list ( ) soup = beautiful_soup ( html_text , string ) if soup . title and extract_title title = self . _wrap_data ( string , soup . title . string . encode ( string ) . decode ( string ) ) res . append ( title ) if soup . title and extract_meta meta_content = self . _wrap_meta_content ( soup . find_all ( string ) ) meta_data = self . _wrap_data ( string , meta_content ) res . append ( meta_data ) if extract_microdata mde = microdata_extractor ( ) mde_data = self . _wrap_data ( string , mde . extract ( html_text , microdata_base_url ) ) res . append ( mde_data ) if extract_json_ld jslde = json_ld_extractor ( ) jslde_data = self . _wrap_data ( string , jslde . extract ( html_text ) ) res . append ( jslde_data ) if extract_rdfa rdfae = rd_fa_extractor ( ) rdfae_data = self . _wrap_data ( string , rdfae . extract ( html_text , rdfa_base_url ) ) res . append ( rdfae_data ) return res	1
Q_73	extract data from html content	C_73_2	def run ( args ) string string string html_content_extractor = html_content_extractor ( ) with warnings . catch_warnings ( ) warnings . simplefilter ( string ) extractions = html_content_extractor . extract ( html_text = args . input_file ) for var in extractions print ( var . value )	1
Q_73	extract data from html content	C_73_3	def text_filter ( html ) if isinstance ( html , list ) html = string . join ( html ) ok , content = soup_ops . extract_text ( html ) if ok return content else raise runtime_error ( string )	1
Q_73	extract data from html content	C_73_4	def extract_content ( html , encoding = none , as_blocks = false ) if string not in _loaded_models _loaded_models [ string ] = load_pickled_model ( string ) return _loaded_models [ string ] . extract ( html , encoding = encoding , as_blocks = as_blocks )	1
Q_73	extract data from html content	C_73_5	def text_filter ( html ) if isinstance ( html , list ) html = string . join ( html ) ok , content = soup_ops . extract_text ( html ) if ok return content else raise runtime_error ( string )	1
Q_73	extract data from html content	C_73_6	def parse_item ( self , response ) key = none if re . search ( r string , response . url ) and response . css ( string string ) . extract ( ) is not none and len ( response . css ( string string ) . extract ( ) ) > number key = response . css ( string string ) . extract ( ) [ number ] elif ( re . search ( r string , response . url ) or re . search ( r string , response . url ) ) and response . css ( string string ) . extract ( ) is not none and len ( response . css ( string string ) . extract ( ) ) > number key = response . css ( string string ) . extract ( ) [ number ] elif re . search ( r string , response . url ) and response . css ( string string ) . extract ( ) is not none and len ( response . css ( string string ) . extract ( ) ) > number key = response . css ( string string ) . extract ( ) [ number ] if key is not none yield { key response . url }	1
Q_73	extract data from html content	C_73_7	def run ( args ) string string string html_content_extractor = html_content_extractor ( ) with warnings . catch_warnings ( ) warnings . simplefilter ( string ) extractions = html_content_extractor . extract ( html_text = args . input_file ) for var in extractions print ( var . value )	1
Q_73	extract data from html content	C_73_8	def parse_content ( self , content ) self . data = [ ] self . environment = { } self . invalid_lines = [ ]	1
Q_73	extract data from html content	C_73_9	def extract ( self , html_text str , extract_title bool = false , extract_meta bool = false , extract_microdata bool = false , microdata_base_url str = string , extract_json_ld bool = false , extract_rdfa bool = false , rdfa_base_url str = string ) _ > list [ extraction ] string string title string title string . string meta string meta string author string . string microdata string json _ ld string rdfa string string res = list ( ) soup = beautiful_soup ( html_text , string ) if soup . title and extract_title title = self . _wrap_data ( string , soup . title . string . encode ( string ) . decode ( string ) ) res . append ( title ) if soup . title and extract_meta meta_content = self . _wrap_meta_content ( soup . find_all ( string ) ) meta_data = self . _wrap_data ( string , meta_content ) res . append ( meta_data ) if extract_microdata mde = microdata_extractor ( ) mde_data = self . _wrap_data ( string , mde . extract ( html_text , microdata_base_url ) ) res . append ( mde_data ) if extract_json_ld jslde = json_ld_extractor ( ) jslde_data = self . _wrap_data ( string , jslde . extract ( html_text ) ) res . append ( jslde_data ) if extract_rdfa rdfae = rd_fa_extractor ( ) rdfae_data = self . _wrap_data ( string , rdfae . extract ( html_text , rdfa_base_url ) ) res . append ( rdfae_data ) return res	1
Q_73	extract data from html content	C_73_10	def extract_from ( msg_body , content_type = string ) try if content_type = = string return extract_from_plain ( msg_body ) elif content_type = = string return extract_from_html ( msg_body ) except exception log . exception ( string ) return msg_body	1
Q_73	extract data from html content	C_73_11	def get_hardforks ( self ) rows = self . _parse_tbodies ( self . session . get ( string ) . text ) [ number ]	1
Q_73	extract data from html content	C_73_12	def extract_content ( html , encoding = none , as_blocks = false ) if string not in _loaded_models _loaded_models [ string ] = load_pickled_model ( string ) return _loaded_models [ string ] . extract ( html , encoding = encoding , as_blocks = as_blocks )	1
Q_73	extract data from html content	C_73_13	def get_hardforks ( self ) rows = self . _parse_tbodies ( self . session . get ( string ) . text ) [ number ]	1
Q_73	extract data from html content	C_73_14	def parse_item ( self , response ) key = none if re . search ( r string , response . url ) and response . css ( string string ) . extract ( ) is not none and len ( response . css ( string string ) . extract ( ) ) > number key = response . css ( string string ) . extract ( ) [ number ] elif ( re . search ( r string , response . url ) or re . search ( r string , response . url ) ) and response . css ( string string ) . extract ( ) is not none and len ( response . css ( string string ) . extract ( ) ) > number key = response . css ( string string ) . extract ( ) [ number ] elif re . search ( r string , response . url ) and response . css ( string string ) . extract ( ) is not none and len ( response . css ( string string ) . extract ( ) ) > number key = response . css ( string string ) . extract ( ) [ number ] if key is not none yield { key response . url }	1
Q_73	extract data from html content	C_73_15	def parse_content ( self , content ) self . data = [ ] self . environment = { } self . invalid_lines = [ ]	0
Q_73	extract data from html content	C_73_16	def _extract_data_from_show_html ( self , html ) string string string html_lines = html . splitlines ( ) for var , var in enumerate ( html_lines ) if var . strip ( ) = = r string start_line = var + number if var . strip ( ) = = r string end_line = var try data_list = html_lines [ start_line end_line ] data_string = string . join ( data_list ) return data_string . strip ( ) except raise exception ( string )	0
Q_73	extract data from html content	C_73_17	def extract ( self , html_contents , css_contents = none , base_url = none ) string string string	0
Q_73	extract data from html content	C_73_18	def extract_from ( msg_body , content_type = string ) try if content_type = = string return extract_from_plain ( msg_body ) elif content_type = = string return extract_from_html ( msg_body ) except exception log . exception ( string ) return msg_body	0
Q_73	extract data from html content	C_73_19	def extract_content ( html , encoding = none , as_blocks = false ) if string not in _loaded_models _loaded_models [ string ] = load_pickled_model ( string ) return _loaded_models [ string ] . extract ( html , encoding = encoding , as_blocks = as_blocks )	0
Q_73	extract data from html content	C_73_20	def parse_item ( self , response ) key = none if re . search ( r string , response . url ) and response . css ( string string ) . extract ( ) is not none and len ( response . css ( string string ) . extract ( ) ) > number key = response . css ( string string ) . extract ( ) [ number ] elif ( re . search ( r string , response . url ) or re . search ( r string , response . url ) ) and response . css ( string string ) . extract ( ) is not none and len ( response . css ( string string ) . extract ( ) ) > number key = response . css ( string string ) . extract ( ) [ number ] elif re . search ( r string , response . url ) and response . css ( string string ) . extract ( ) is not none and len ( response . css ( string string ) . extract ( ) ) > number key = response . css ( string string ) . extract ( ) [ number ] if key is not none yield { key response . url }	0
Q_74	export to excel	C_74_0	def to_excel ( self , * args ) string string string path = os . getcwd ( ) fname = self . fname . replace ( string , string ) + string if len ( args ) > number and args [ number ] = string path = args [ number ] if os . path . exists ( path ) = = false os . mkdir ( path ) xl_file = pd . excel_writer ( path + os . sep + fname ) for var in self . filter_data ( string ) self . extract ( var ) labels = list ( self . filter_data ( string ) . values ( ) ) for prof in self . data data_df = pd . data_frame ( ) data_df [ string ] = self . data [ prof ] [ number ] for timestep , data in zip ( self . time , self . data [ prof ] [ number ] ) data_df [ timestep ] = data myvar = labels [ prof _ number ] . split ( string ) [ number ] br_label = labels [ prof _ number ] . split ( string string string ) [ number ] . replace ( string , string ) mylabel = string . format ( myvar , br_label , unit ) data_df . to_excel ( xl_file , sheet_name = mylabel ) xl_file . save ( )	1
Q_74	export to excel	C_74_1	def export_to_xlsx ( table , filename_or_fobj = none , sheet_name = string , * args , * * kwargs ) string string string workbook = workbook ( ) sheet = workbook . active sheet . title = sheet_name prepared_table = prepare_to_export ( table , * args , * * kwargs )	1
Q_74	export to excel	C_74_2	def export_analytics_data_to_excel ( data , output_file_name , result_info_key , identifier_keys ) string string string workbook = create_excel_workbook ( data , result_info_key , identifier_keys ) workbook . save ( output_file_name ) print ( string . format ( output_file_name ) )	1
Q_74	export to excel	C_74_3	def to_excel ( self , excel_writer , sheet_name = string , iamc_index = false , * * kwargs ) string string data string model string scenario string region string variable string unit string string if not isinstance ( excel_writer , pd . excel_writer ) close = true excel_writer = pd . excel_writer ( excel_writer ) self . _to_file_format ( iamc_index ) . to_excel ( excel_writer , sheet_name = sheet_name , index = false , * * kwargs ) if close excel_writer . close ( )	1
Q_74	export to excel	C_74_4	def to_excel ( self , excel_writer , sheet_name = string , iamc_index = false , * * kwargs ) string string data string model string scenario string region string variable string unit string string if not isinstance ( excel_writer , pd . excel_writer ) close = true excel_writer = pd . excel_writer ( excel_writer ) self . _to_file_format ( iamc_index ) . to_excel ( excel_writer , sheet_name = sheet_name , index = false , * * kwargs ) if close excel_writer . close ( )	1
Q_74	export to excel	C_74_5	def on_excel ( self ) from pylon . io . excel import excel_writer filename = asksaveasfilename ( filetypes = [ ( string , string ) ] ) if filename excel_writer ( self . case ) . write ( filename )	1
Q_74	export to excel	C_74_6	def to_excel ( self , xl_app = none , resize_columns = true ) from win32com . client import dispatch , gencache if xl_app is none xl_app = dispatch ( string ) xl_app = gencache . ensure_dispatch ( xl_app )	1
Q_74	export to excel	C_74_7	def to_excel ( self , xl_app = none , resize_columns = true ) from win32com . client import dispatch , gencache if xl_app is none xl_app = dispatch ( string ) xl_app = gencache . ensure_dispatch ( xl_app )	1
Q_74	export to excel	C_74_8	def export_xlsx ( wb , output , fn ) string string string wb . close ( ) output . seek ( number ) response = http_response ( output . read ( ) , content_type = string ) cd = codecs . encode ( string fn , string ) response [ string ] = cd return response	1
Q_74	export to excel	C_74_9	def on_excel ( self ) from pylon . io . excel import excel_writer filename = asksaveasfilename ( filetypes = [ ( string , string ) ] ) if filename excel_writer ( self . case ) . write ( filename )	1
Q_74	export to excel	C_74_10	def export_translations ( tasks_ids ) qs = trans_task . objects . filter ( pk_in = tasks_ids ) export = export_queryset ( qs , trans_task , ( string , string , string , string , string , string , string , string , string ) ) excel = export . get_excel ( ) return excel	1
Q_74	export to excel	C_74_11	def export_analytics_data_to_excel ( data , output_file_name , result_info_key , identifier_keys ) string string string workbook = create_excel_workbook ( data , result_info_key , identifier_keys ) workbook . save ( output_file_name ) print ( string . format ( output_file_name ) )	1
Q_74	export to excel	C_74_12	def to_excel ( self , * args ) string string string path = os . getcwd ( ) fname = self . fname . replace ( string , string ) + string if len ( args ) > number and args [ number ] = string path = args [ number ] if os . path . exists ( path ) = = false os . mkdir ( path ) xl_file = pd . excel_writer ( path + os . sep + fname ) for var in self . filter_data ( string ) self . extract ( var ) labels = list ( self . filter_data ( string ) . values ( ) ) for prof in self . data data_df = pd . data_frame ( ) data_df [ string ] = self . data [ prof ] [ number ] for timestep , data in zip ( self . time , self . data [ prof ] [ number ] ) data_df [ timestep ] = data myvar = labels [ prof _ number ] . split ( string ) [ number ] br_label = labels [ prof _ number ] . split ( string string string ) [ number ] . replace ( string , string ) mylabel = string . format ( myvar , br_label , unit ) data_df . to_excel ( xl_file , sheet_name = mylabel ) xl_file . save ( )	1
Q_74	export to excel	C_74_13	def export_to_xlsx ( table , filename_or_fobj = none , sheet_name = string , * args , * * kwargs ) string string string workbook = workbook ( ) sheet = workbook . active sheet . title = sheet_name prepared_table = prepare_to_export ( table , * args , * * kwargs )	1
Q_74	export to excel	C_74_14	def export_translations ( tasks_ids ) qs = trans_task . objects . filter ( pk_in = tasks_ids ) export = export_queryset ( qs , trans_task , ( string , string , string , string , string , string , string , string , string ) ) excel = export . get_excel ( ) return excel	1
Q_74	export to excel	C_74_15	"def excel_to_sql ( excel_file_path , engine , read_excel_kwargs = none , to_generic_type_kwargs = none , to_sql_kwargs = none ) string string employee string skiprows string department string t have options to convert it to string . string string replace "" ) ) )"	1
Q_74	export to excel	C_74_16	def export_xlsx ( wb , output , fn ) string string string wb . close ( ) output . seek ( number ) response = http_response ( output . read ( ) , content_type = string ) cd = codecs . encode ( string fn , string ) response [ string ] = cd return response	1
Q_74	export to excel	C_74_17	"def excel_to_sql ( excel_file_path , engine , read_excel_kwargs = none , to_generic_type_kwargs = none , to_sql_kwargs = none ) string string employee string skiprows string department string t have options to convert it to string . string string replace "" ) ) )"	0
Q_75	encrypt aes ctr mode	C_75_0	def encrypt ( cls , data , key , iv_data ) validate_key_size ( key , cls . key_size , string ) iv , ctr = iv_data ciphertext = crypto_aes . new ( key , crypto_aes . mode_ctr , counter = ctr ) . encrypt ( data ) return iv + ciphertext	1
Q_75	encrypt aes ctr mode	C_75_1	def _encrypt ( data ) string string string bs = aes . block_size def pad ( s ) n = bs _ len ( s ) bs char = chr ( n ) . encode ( string ) return s + n * char password = settings . geckoboard_password salt = random . new ( ) . read ( bs _ len ( string ) ) key , iv = _derive_key_and_iv ( password , salt , number , bs ) cipher = aes . new ( key , aes . mode_cbc , iv ) encrypted = b string + salt + cipher . encrypt ( pad ( data ) ) return base64 . b64encode ( encrypted )	1
Q_75	encrypt aes ctr mode	C_75_2	def ctr_enc ( key , plaintext ) iv = os . urandom ( aes . block_size ) cipher = _cipher ( _aes ( key ) , _ctrmode ( iv ) , backend = _backend ) . encryptor ( ) return iv + cipher . update ( plaintext ) + cipher . finalize ( )	1
Q_75	encrypt aes ctr mode	C_75_3	def encrypt ( self , raw , mode = aes . mode_cbc ) raw = self . _pad ( raw , aes . block_size ) iv = random . new ( ) . read ( aes . block_size ) cipher = aes . new ( self . key , mode , iv ) return base64 . b64encode ( iv + cipher . encrypt ( raw ) ) . decode ( string )	1
Q_75	encrypt aes ctr mode	C_75_4	def aes_cbc_encrypt ( plain_text bytes , key bytes , iv bytes = b string ) if len ( iv ) = = number iv = aes_handler . generate_iv ( ) cipher = aes . new ( key = key , mode = aes . mode_cbc , iv = iv ) return cipher . iv , cipher . encrypt ( pad ( plain_text , aes . block_size ) )	1
Q_75	encrypt aes ctr mode	C_75_5	def aes_ctr_encrypt ( plain_text bytes , key bytes ) cipher = aes . new ( key = key , mode = aes . mode_ctr ) cipher_text = cipher . encrypt ( plain_text ) nonce = cipher . nonce return nonce , cipher_text	1
Q_75	encrypt aes ctr mode	C_75_6	def aes_encrypt ( key , data , mode = string , iv = none ) aes = aes ( ) aes . mode = mode aes . iv = iv aes . key = key return aes . encrypt ( data )	1
Q_75	encrypt aes ctr mode	C_75_7	def encrypt ( self , key ) string string string if ( self . encrypted ) return	1
Q_75	encrypt aes ctr mode	C_75_8	def aes_ctr_encrypt ( plain_text bytes , key bytes ) cipher = aes . new ( key = key , mode = aes . mode_ctr ) cipher_text = cipher . encrypt ( plain_text ) nonce = cipher . nonce return nonce , cipher_text	1
Q_75	encrypt aes ctr mode	C_75_9	def encrypt ( cls , data , key , iv_data ) validate_key_size ( key , cls . key_size , string ) iv , ctr = iv_data ciphertext = crypto_aes . new ( key , crypto_aes . mode_ctr , counter = ctr ) . encrypt ( data ) return iv + ciphertext	1
Q_75	encrypt aes ctr mode	C_75_10	def encrypt ( self , data ) if self . iv is none cipher = py_aes . new ( self . key , self . mode ) else cipher = py_aes . new ( self . key , self . mode , self . iv ) return cipher . encrypt ( pad_data ( aes . str_to_bytes ( data ) ) )	1
Q_75	encrypt aes ctr mode	C_75_11	def aes_cbc_encrypt ( plain_text bytes , key bytes , iv bytes = b string ) if len ( iv ) = = number iv = aes_handler . generate_iv ( ) cipher = aes . new ( key = key , mode = aes . mode_cbc , iv = iv ) return cipher . iv , cipher . encrypt ( pad ( plain_text , aes . block_size ) )	1
Q_75	encrypt aes ctr mode	C_75_12	def encrypt ( self , data ) if self . iv is none cipher = py_aes . new ( self . key , self . mode ) else cipher = py_aes . new ( self . key , self . mode , self . iv ) return cipher . encrypt ( pad_data ( aes . str_to_bytes ( data ) ) )	1
Q_75	encrypt aes ctr mode	C_75_13	def ctr_enc ( key , plaintext ) iv = os . urandom ( aes . block_size ) cipher = _cipher ( _aes ( key ) , _ctrmode ( iv ) , backend = _backend ) . encryptor ( ) return iv + cipher . update ( plaintext ) + cipher . finalize ( )	1
Q_75	encrypt aes ctr mode	C_75_14	def aes_encrypt ( key , data , mode = string , iv = none ) aes = aes ( ) aes . mode = mode aes . iv = iv aes . key = key return aes . encrypt ( data )	1
Q_75	encrypt aes ctr mode	C_75_15	def _encrypt ( data ) string string string bs = aes . block_size def pad ( s ) n = bs _ len ( s ) bs char = chr ( n ) . encode ( string ) return s + n * char password = settings . geckoboard_password salt = random . new ( ) . read ( bs _ len ( string ) ) key , iv = _derive_key_and_iv ( password , salt , number , bs ) cipher = aes . new ( key , aes . mode_cbc , iv ) encrypted = b string + salt + cipher . encrypt ( pad ( data ) ) return base64 . b64encode ( encrypted )	1
Q_75	encrypt aes ctr mode	C_75_16	def encrypt ( self , raw , mode = aes . mode_cbc ) raw = self . _pad ( raw , aes . block_size ) iv = random . new ( ) . read ( aes . block_size ) cipher = aes . new ( self . key , mode , iv ) return base64 . b64encode ( iv + cipher . encrypt ( raw ) ) . decode ( string )	1
Q_76	encode url	C_76_0	def _urlencode ( self , h ) rv = [ ] for var , var in h . iteritems ( ) rv . append ( string ( urllib . quote ( var . encode ( string ) ) , urllib . quote ( var . encode ( string ) ) ) ) return string . join ( rv )	1
Q_76	encode url	C_76_1	def url_encode ( url ) string string string if isinstance ( url , text_type ) url = url . encode ( string ) return quote ( url , string )	1
Q_76	encode url	C_76_2	def url_encode_and_join ( self , seq , sepr = string ) string string string try from urllib . parse import quote_plus as encode return sepr . join ( [ encode ( var , encoding = charset_utf8 ) for var in seq ] ) except import_error from urllib import quote as encode return sepr . join ( [ i for i in map ( lambda var encode ( var ) , seq ) ] )	1
Q_76	encode url	C_76_3	def trigger ( self , identifier , force = true ) string string string self . debug ( identifier ) url = string . format ( base = self . local_base_url , identifier = identifier ) param = { } if force param [ string ] = force encode = urllib . urlencode ( param ) if encode url + = string url + = encode return self . core . update ( url , { } )	1
Q_76	encode url	C_76_4	def _list ( self , domain = none )	1
Q_76	encode url	C_76_5	def urlencode ( params ) utf8_params = encode_params_utf8 ( params ) urlencoded = _urlencode ( utf8_params ) if isinstance ( urlencoded , unicode_type )	1
Q_76	encode url	C_76_6	def _urlencode ( self , url ) if is_python3 ( ) return urllib . parse . urlencode ( url ) else return urllib . urlencode ( url )	1
Q_76	encode url	C_76_7	def url_encode_and_join ( self , seq , sepr = string ) string string string try from urllib . parse import quote_plus as encode return sepr . join ( [ encode ( var , encoding = charset_utf8 ) for var in seq ] ) except import_error from urllib import quote as encode return sepr . join ( [ i for i in map ( lambda var encode ( var ) , seq ) ] )	1
Q_76	encode url	C_76_8	def _urlencode ( self , url ) if is_python3 ( ) return urllib . parse . urlencode ( url ) else return urllib . urlencode ( url )	1
Q_76	encode url	C_76_9	def encode ( self ) string string string opt_dict = { } for var , var in self . options . items ( ) opt_dict [ var ] = var [ number ] ss = string . format ( self . scheme , string . join ( self . hosts ) ) if self . bucket ss + = string + self . bucket	1
Q_76	encode url	C_76_10	def encode ( self ) string string string opt_dict = { } for var , var in self . options . items ( ) opt_dict [ var ] = var [ number ] ss = string . format ( self . scheme , string . join ( self . hosts ) ) if self . bucket ss + = string + self . bucket	1
Q_76	encode url	C_76_11	def encode ( self ) string string string opt_dict = { } for var , var in self . options . items ( ) opt_dict [ var ] = var [ number ] ss = string . format ( self . scheme , string . join ( self . hosts ) ) if self . bucket ss + = string + self . bucket	1
Q_76	encode url	C_76_12	def url_encode ( url ) string string string if isinstance ( url , text_type ) url = url . encode ( string ) return quote ( url , string )	1
Q_76	encode url	C_76_13	def url_encoder ( self ) encodedurl = [ ] encodedurl . append ( aios . int_byte ( string , self . power ) ) asisurl = string myurl = urlparse ( self . type_payload ) myhostname = myurl . hostname mypath = myurl . path if ( myurl . scheme , myhostname . startswith ( string ) ) in url_schemes encodedurl . append ( aios . int_byte ( string , url_schemes . index ( ( myurl . scheme , myhostname . startswith ( string ) ) ) ) ) if myhostname . startswith ( string ) myhostname = myhostname [ number ] extval = none if myhostname . split ( string ) [ _ number ] in url_domain extval = url_domain . index ( myhostname . split ( string ) [ _ number ] ) myhostname = string . join ( myhostname . split ( string ) [ _ number ] ) if extval is not none and not mypath . startswith ( string ) extval + = number else if myurl . port is none if extval is not none mypath = mypath [ number ] else extval + = number encodedurl . append ( aios . string ( string ) ) encodedurl [ _ number ] . val = myhostname if extval is not none encodedurl . append ( aios . int_byte ( string , extval ) ) if myurl . port asisurl + = string + str ( myurl . port ) + mypath asisurl + = mypath if myurl . params asisurl + = string + myurl . params if myurl . query asisurl + = string + myurl . query if myurl . fragment asisurl + = string + myurl . fragment encodedurl . append ( aios . string ( string ) ) encodedurl [ _ number ] . val = asisurl tlength = number for var in encodedurl	1
Q_76	encode url	C_76_14	def url_encoder ( self ) encodedurl = [ ] encodedurl . append ( aios . int_byte ( string , self . power ) ) asisurl = string myurl = urlparse ( self . type_payload ) myhostname = myurl . hostname mypath = myurl . path if ( myurl . scheme , myhostname . startswith ( string ) ) in url_schemes encodedurl . append ( aios . int_byte ( string , url_schemes . index ( ( myurl . scheme , myhostname . startswith ( string ) ) ) ) ) if myhostname . startswith ( string ) myhostname = myhostname [ number ] extval = none if myhostname . split ( string ) [ _ number ] in url_domain extval = url_domain . index ( myhostname . split ( string ) [ _ number ] ) myhostname = string . join ( myhostname . split ( string ) [ _ number ] ) if extval is not none and not mypath . startswith ( string ) extval + = number else if myurl . port is none if extval is not none mypath = mypath [ number ] else extval + = number encodedurl . append ( aios . string ( string ) ) encodedurl [ _ number ] . val = myhostname if extval is not none encodedurl . append ( aios . int_byte ( string , extval ) ) if myurl . port asisurl + = string + str ( myurl . port ) + mypath asisurl + = mypath if myurl . params asisurl + = string + myurl . params if myurl . query asisurl + = string + myurl . query if myurl . fragment asisurl + = string + myurl . fragment encodedurl . append ( aios . string ( string ) ) encodedurl [ _ number ] . val = asisurl tlength = number for var in encodedurl	1
Q_76	encode url	C_76_15	def _urlencode ( self , h ) rv = [ ] for var , var in h . iteritems ( ) rv . append ( string ( urllib . quote ( var . encode ( string ) ) , urllib . quote ( var . encode ( string ) ) ) ) return string . join ( rv )	1
Q_77	deserialize json	C_77_0	def json_loads ( payload ) string try return json . loads ( payload ) except value_error as e log . error ( string + payload + string ) raise e	1
Q_77	deserialize json	C_77_1	def json_loads ( payload ) string try return json . loads ( payload ) except value_error as e log . error ( string + payload + string ) raise e	1
Q_77	deserialize json	C_77_2	def deserialize ( json , cls = none ) string string string logger . debug ( string , json ) out = simplejson . loads ( json ) if isinstance ( out , dict ) and cls is not none return cls ( * * out ) return out	1
Q_77	deserialize json	C_77_3	def deserialize ( s ) if isinstance ( s , bytes ) return json . loads ( s . decode ( string ) ) return json . loads ( s )	1
Q_77	deserialize json	C_77_4	def deserialize ( s ) if isinstance ( s , bytes ) return json . loads ( s . decode ( string ) ) return json . loads ( s )	1
Q_77	deserialize json	C_77_5	def deserialize_json ( cls , serialized_json ) string string string serialized = json . loads ( serialized_json ) return macaroon . from_dict ( serialized )	1
Q_77	deserialize json	C_77_6	def deserialize ( self , deserializable primitive_json_type ) _ > optional [ serializable_type ] if not isinstance ( self . _decoder , parsed_json_decoder )	1
Q_77	deserialize json	C_77_7	def _deserialize ( kwargs ) def deserialize ( item ) if isinstance ( item [ number ] , str ) try data = json . loads ( item [ number ] )	1
Q_77	deserialize json	C_77_8	def deserialize ( self ) string string string super ( deserializer , self ) . deserialize ( ) try return json . loads ( self . req . get_body ( ) ) except type_error link = string self . fail ( string string string , link ) except unicode_decode_error link = string self . fail ( string string string , link ) except value_error as exc link = string self . fail ( string string string exc . message , link )	1
Q_77	deserialize json	C_77_9	def deserialize ( s ) s = s . strip ( ) try doc = etree . fromstring ( s ) if is_tmdd ( doc )	1
Q_77	deserialize json	C_77_10	def deserialize_json ( cls , serialized_json ) string string string serialized = json . loads ( serialized_json ) return macaroon . from_dict ( serialized )	1
Q_77	deserialize json	C_77_11	async def deserialize ( data dict ) string string proof name string name string age string restrictions string schema_id string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b number schema_name number . number . number string schema_name string faber student info string schema_version string number . number string schema_issuer_did string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b string issuer_did string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b string cred_def_id string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b number cl number string schema_id string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b number schema_name number . number . number string schema_name string byu student info string schema_version string number . number string schema_issuer_did string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b string issuer_did string number fh8y_bzrp_j_qm_ny_zzgo_tq_b string cred_def_id string number fh8y_bzrp_j_qm_ny_zzgo_tq_b number cl number string name string name string restrictions string schema_id string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b number schema_name number . number . number string schema_name string faber student info string schema_version string number . number string schema_issuer_did string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b string issuer_did string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b string cred_def_id string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b number cl number string schema_id string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b number schema_name number . number . number string schema_name string byu student info string schema_version string number . number string schema_issuer_did string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b string issuer_did string number fh8y_bzrp_j_qm_ny_zzgo_tq_b string cred_def_id string number fh8y_bzrp_j_qm_ny_zzgo_tq_b number cl number string string return await proof . _deserialize ( string , json . dumps ( data ) , data . get ( string ) . get ( string ) )	1
Q_77	deserialize json	C_77_12	def deserialize ( s ) s = s . strip ( ) try doc = etree . fromstring ( s ) if is_tmdd ( doc )	1
Q_77	deserialize json	C_77_13	def _deserialize ( kwargs ) def deserialize ( item ) if isinstance ( item [ number ] , str ) try data = json . loads ( item [ number ] )	1
Q_77	deserialize json	C_77_14	def deserialize ( s ) s = s . strip ( ) try doc = etree . fromstring ( s ) if is_tmdd ( doc )	1
Q_77	deserialize json	C_77_15	def deserialize_json ( cls , serialized_json ) string string string serialized = json . loads ( serialized_json ) return macaroon . from_dict ( serialized )	1
Q_77	deserialize json	C_77_16	async def deserialize ( data dict ) string string proof name string name string age string restrictions string schema_id string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b number schema_name number . number . number string schema_name string faber student info string schema_version string number . number string schema_issuer_did string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b string issuer_did string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b string cred_def_id string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b number cl number string schema_id string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b number schema_name number . number . number string schema_name string byu student info string schema_version string number . number string schema_issuer_did string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b string issuer_did string number fh8y_bzrp_j_qm_ny_zzgo_tq_b string cred_def_id string number fh8y_bzrp_j_qm_ny_zzgo_tq_b number cl number string name string name string restrictions string schema_id string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b number schema_name number . number . number string schema_name string faber student info string schema_version string number . number string schema_issuer_did string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b string issuer_did string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b string cred_def_id string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b number cl number string schema_id string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b number schema_name number . number . number string schema_name string byu student info string schema_version string number . number string schema_issuer_did string number x_fh8y_bzrp_j_qm_ny_zzgo_tq_b string issuer_did string number fh8y_bzrp_j_qm_ny_zzgo_tq_b string cred_def_id string number fh8y_bzrp_j_qm_ny_zzgo_tq_b number cl number string string return await proof . _deserialize ( string , json . dumps ( data ) , data . get ( string ) . get ( string ) )	0
Q_77	deserialize json	C_77_17	def deserialize ( self , deserializable primitive_json_type ) _ > optional [ serializable_type ] if not isinstance ( self . _decoder , parsed_json_decoder )	0
Q_78	deduct the median from each column	C_78_0	def median ( self , * * kwargs ) string string string if self . _is_transposed kwargs [ string ] = kwargs . get ( string , number ) ^ number return self . transpose ( ) . median ( * * kwargs )	1
Q_78	deduct the median from each column	C_78_1	def median_abs_dev ( values )	1
Q_78	deduct the median from each column	C_78_2	def median ( self , * * kwargs ) string string string if self . _is_transposed kwargs [ string ] = kwargs . get ( string , number ) ^ number return self . transpose ( ) . median ( * * kwargs )	1
Q_78	deduct the median from each column	C_78_3	def running_median ( seq , m ) string string center string string seq = iter ( seq ) s = [ ] m = m / / number	1
Q_78	deduct the median from each column	C_78_4	def median_abs_dev ( values )	1
Q_78	deduct the median from each column	C_78_5	def median ( self , values , axis = number , average = true ) string string string mid_2 = self . index . start + self . index . stop hi = ( mid_2 ) / / number lo = ( mid_2 _ number ) / / number	1
Q_78	deduct the median from each column	C_78_6	def mad ( data ) r string string string return np . median ( np . abs ( data _ np . median ( data ) ) )	1
Q_78	deduct the median from each column	C_78_7	def mad ( v ) string string string return np . median ( np . abs ( v _ np . median ( v ) ) )	1
Q_78	deduct the median from each column	C_78_8	def median ( self , values , axis = number , average = true ) string string string mid_2 = self . index . start + self . index . stop hi = ( mid_2 ) / / number lo = ( mid_2 _ number ) / / number	1
Q_78	deduct the median from each column	C_78_9	def median_interp ( interp_object ) string string string new_grid = np . sort ( np . concatenate ( [ interp_object . x [ _ number ] + number . number * var * np . diff ( interp_object . x ) for var in range ( number ) ] ) . flatten ( ) ) tmp_prop = np . exp ( _ ( interp_object ( new_grid ) _ interp_object . y . min ( ) ) ) tmp_cumsum = np . cumsum ( number . number * ( tmp_prop [ number ] + tmp_prop [ _ number ] ) * np . diff ( new_grid ) ) median_index = min ( len ( tmp_cumsum ) _ number , max ( number , np . searchsorted ( tmp_cumsum , tmp_cumsum [ _ number ] * number . number ) + number ) ) return new_grid [ median_index ]	1
Q_78	deduct the median from each column	C_78_10	def mad ( data ) r string string string return np . median ( np . abs ( data _ np . median ( data ) ) )	1
Q_78	deduct the median from each column	C_78_11	def median_abs_dev ( values )	1
Q_78	deduct the median from each column	C_78_12	def median_interp ( interp_object ) string string string new_grid = np . sort ( np . concatenate ( [ interp_object . x [ _ number ] + number . number * var * np . diff ( interp_object . x ) for var in range ( number ) ] ) . flatten ( ) ) tmp_prop = np . exp ( _ ( interp_object ( new_grid ) _ interp_object . y . min ( ) ) ) tmp_cumsum = np . cumsum ( number . number * ( tmp_prop [ number ] + tmp_prop [ _ number ] ) * np . diff ( new_grid ) ) median_index = min ( len ( tmp_cumsum ) _ number , max ( number , np . searchsorted ( tmp_cumsum , tmp_cumsum [ _ number ] * number . number ) + number ) ) return new_grid [ median_index ]	1
Q_78	deduct the median from each column	C_78_13	def running_median ( seq , m ) string string center string string seq = iter ( seq ) s = [ ] m = m / / number	1
Q_78	deduct the median from each column	C_78_14	def mad ( v ) string string string return np . median ( np . abs ( v _ np . median ( v ) ) )	1
Q_78	deduct the median from each column	C_78_15	def adjust_to_level ( self , level , x , op , median ) if x > median if level > number . number result = median + ( x _ median ) * ( ( level _ number . number ) / number . number ) else result = op + ( median _ op ) * ( level / number . number ) else if level > number . number result = x + ( median _ x ) * ( ( level _ number . number ) / number . number ) else result = median + ( op _ median ) * ( level / number . number ) return result	0
Q_78	deduct the median from each column	C_78_16	def adjust_to_level ( self , level , x , op , median ) if x > median if level > number . number result = median + ( x _ median ) * ( ( level _ number . number ) / number . number ) else result = op + ( median _ op ) * ( level / number . number ) else if level > number . number result = x + ( median _ x ) * ( ( level _ number . number ) / number . number ) else result = median + ( op _ median ) * ( level / number . number ) return result	0
Q_78	deduct the median from each column	C_78_17	def zoom_level_from_geometry ( geometry , splits = number ) string string string	0
Q_79	custom http error response	C_79_0	def handle_http_error ( self , response , custom_messages = none , raise_for_status = false ) string string string if not custom_messages custom_messages = { } if response . status_code in custom_messages . keys ( ) raise errors . http_error ( custom_messages [ response . status_code ] ) if raise_for_status response . raise_for_status ( )	1
Q_79	custom http error response	C_79_1	def handle_http_error ( self , response , custom_messages = none , raise_for_status = false ) string string string if not custom_messages custom_messages = { } if response . status_code in custom_messages . keys ( ) raise errors . http_error ( custom_messages [ response . status_code ] ) if raise_for_status response . raise_for_status ( )	1
Q_79	custom http error response	C_79_2	def handle_http_error ( self , response , custom_messages = none , raise_for_status = false ) if not custom_messages custom_messages = { } if response . status_code in custom_messages . keys ( ) raise requests . exceptions . http_error ( custom_messages [ response . status_code ] ) if raise_for_status response . raise_for_status ( )	1
Q_79	custom http error response	C_79_3	def raise_for_status ( self , response ) http_error_msg = string if number < = response . status_code < number try http_error_msg = response . json ( ) except http_error_msg = ( string . format ( code = response . status_code , reason = response . reason , url = response . url ) ) elif number < = response . status_code < number http_error_msg = ( string . format ( code = response . status_code , reason = response . reason , url = response . url ) ) if http_error_msg raise http_error ( http_error_msg , response = response )	1
Q_79	custom http error response	C_79_4	def _error_response ( e ) res = make_response ( e . urlencoded , e . status_code ) res . headers [ string ] = string return res	1
Q_79	custom http error response	C_79_5	def handle_http_error ( self , response , ignore = none , custom_messages = none , raise_for_status = true ) status = response . status_code ignore = ignore or [ ] custom_messages = custom_messages or { } if status in ignore or status in self . _ignore_codes return none elif response . status_code in custom_messages . keys ( ) raise requests . exceptions . http_error ( custom_messages [ response . status_code ] ) elif raise_for_status response . raise_for_status ( )	1
Q_79	custom http error response	C_79_6	def raise_for_status ( self , response ) http_error_msg = string if number < = response . status_code < number try http_error_msg = response . json ( ) except http_error_msg = ( string . format ( code = response . status_code , reason = response . reason , url = response . url ) ) elif number < = response . status_code < number http_error_msg = ( string . format ( code = response . status_code , reason = response . reason , url = response . url ) ) if http_error_msg raise http_error ( http_error_msg , response = response )	1
Q_79	custom http error response	C_79_7	def _error_response ( e ) res = make_response ( e . urlencoded , e . status_code ) res . headers [ string ] = string return res	1
Q_79	custom http error response	C_79_8	def _send_custom_response ( self , reply ) code , custom_response = reply if self . _is_multiline_reply ( custom_response ) self . multiline_reply ( code , custom_response ) else self . reply ( code , custom_response )	1
Q_79	custom http error response	C_79_9	def _do_put ( self , uri , * * kwargs ) string string string	1
Q_79	custom http error response	C_79_10	def status_code ( self ) http_error = self . _http_error if http_error is not none and hasattr ( http_error , string ) return http_error . response . status_code	1
Q_79	custom http error response	C_79_11	def _do_post ( self , url , * * kwargs ) string string string	1
Q_79	custom http error response	C_79_12	def handle_http_error ( self , response , ignore = none , custom_messages = none , raise_for_status = true ) status = response . status_code ignore = ignore or [ ] custom_messages = custom_messages or { } if status in ignore or status in self . _ignore_codes return none elif response . status_code in custom_messages . keys ( ) raise requests . exceptions . http_error ( custom_messages [ response . status_code ] ) elif raise_for_status response . raise_for_status ( )	1
Q_79	custom http error response	C_79_13	def _raise_from_invalid_response ( error ) string string string response = error . response error_message = str ( error ) message = u string . format ( method = response . request . method , url = response . request . url , error = error_message ) raise exceptions . from_http_status ( response . status_code , message , response = response )	1
Q_79	custom http error response	C_79_14	def _do_put ( self , uri , * * kwargs ) string string string	1
Q_79	custom http error response	C_79_15	def _raise_from_invalid_response ( error ) string string string response = error . response error_message = str ( error ) message = u string . format ( method = response . request . method , url = response . request . url , error = error_message ) raise exceptions . from_http_status ( response . status_code , message , response = response )	1
Q_79	custom http error response	C_79_16	def _do_post ( self , url , * * kwargs ) string string string	0
Q_79	custom http error response	C_79_17	def status_code ( self ) http_error = self . _http_error if http_error is not none and hasattr ( http_error , string ) return http_error . response . status_code	0
Q_79	custom http error response	C_79_18	def _send_custom_response ( self , reply ) code , custom_response = reply if self . _is_multiline_reply ( custom_response ) self . multiline_reply ( code , custom_response ) else self . reply ( code , custom_response )	0
Q_80	create cookie	C_80_0	def setcookie ( self , key , value , max_age = none , expires = none , path = string , domain = none , secure = none , httponly = false ) string string string newcookie = morsel ( ) newcookie . key = key newcookie . value = value newcookie . coded_value = value if max_age is not none newcookie [ string ] = max_age if expires is not none newcookie [ string ] = expires if path is not none newcookie [ string ] = path if domain is not none newcookie [ string ] = domain if secure newcookie [ string ] = secure if httponly newcookie [ string ] = httponly self . sent_cookies = [ var for var in self . sent_cookies if var . key = key ] self . sent_cookies . append ( newcookie )	1
Q_80	create cookie	C_80_1	def create_cookie ( key str , value str = string , max_age optional [ union [ int , timedelta ] ] = none , expires optional [ union [ int , float , datetime ] ] = none , path str = string , domain optional [ str ] = none , secure bool = false , httponly bool = false , ) _ > simple_cookie string string string cookie = simple_cookie ( ) cookie [ key ] = value cookie [ key ] [ string ] = path cookie [ key ] [ string ] = httponly	1
Q_80	create cookie	C_80_2	def create_cookie ( key str , value str = string , max_age optional [ union [ int , timedelta ] ] = none , expires optional [ union [ int , float , datetime ] ] = none , path str = string , domain optional [ str ] = none , secure bool = false , httponly bool = false , ) _ > simple_cookie string string string cookie = simple_cookie ( ) cookie [ key ] = value cookie [ key ] [ string ] = path cookie [ key ] [ string ] = httponly	1
Q_80	create cookie	C_80_3	def create_cookie ( self , value , typ , cookie_name = none , ttl = _ number , kill = false ) string string string if kill ttl = _ number elif ttl < number ttl = self . default_value [ string ] if cookie_name is none cookie_name = self . default_value [ string ] c_args = { } srvdomain = self . default_value [ string ] if srvdomain and srvdomain not in [ string , string , string ] c_args [ string ] = srvdomain srvpath = self . default_value [ string ] if srvpath c_args [ string ] = srvpath	1
Q_80	create cookie	C_80_4	def set_cookie ( self , name , value = string , expires = number , path = string , domain = string , secure = false , http_only = false ) cook = cookie . simple_cookie ( ) cook [ name ] = value cook [ name ] [ string ] = expires cook [ name ] [ string ] = path cook [ name ] [ string ] = domain cook [ name ] [ string ] = secure cook [ name ] [ string ] = http_only self . send_header ( string , cook . output ( header = string ) )	1
Q_80	create cookie	C_80_5	def create_cookie ( self , value , typ , cookie_name = none , ttl = _ number , kill = false ) string string string if kill ttl = _ number elif ttl < number ttl = self . default_value [ string ] if cookie_name is none cookie_name = self . default_value [ string ] c_args = { } srvdomain = self . default_value [ string ] if srvdomain and srvdomain not in [ string , string , string ] c_args [ string ] = srvdomain srvpath = self . default_value [ string ] if srvpath c_args [ string ] = srvpath	1
Q_80	create cookie	C_80_6	def create_cookie ( name , value , * * kwargs ) string string string supercookie string string result = { string number , string name , string value , string none , string string , string string , string false , string none , string true , string none , string none , string { string none } , string false , } badargs = set ( kwargs ) _ set ( result ) if badargs err = string raise type_error ( err list ( badargs ) ) result . update ( kwargs ) result [ string ] = bool ( result [ string ] ) result [ string ] = bool ( result [ string ] ) result [ string ] = result [ string ] . startswith ( string ) result [ string ] = bool ( result [ string ] ) return cookielib . cookie ( * * result )	1
Q_80	create cookie	C_80_7	def create_cookie ( name , value , * * kwargs ) string string string supercookie string string result = { string number , string name , string value , string none , string string , string string , string false , string none , string true , string none , string none , string { string none } , string false , } badargs = set ( kwargs ) _ set ( result ) if badargs err = string raise type_error ( err list ( badargs ) ) result . update ( kwargs ) result [ string ] = bool ( result [ string ] ) result [ string ] = bool ( result [ string ] ) result [ string ] = result [ string ] . startswith ( string ) result [ string ] = bool ( result [ string ] ) return cookielib . cookie ( * * result )	1
Q_80	create cookie	C_80_8	def _set_cookie ( self , name , value ) cookie_domain = self . _config . cookie_domain cookie_path = self . _config . cookie_path cookie_expires = self . _config . cookie_expires if self . _config . secure return self . handler . set_secure_cookie ( name , value , expires_days = cookie_expires / ( number * number ) , domain = cookie_domain , path = cookie_path ) else return self . handler . set_cookie ( name , value , expires = cookie_expires , domain = cookie_domain , path = cookie_path )	1
Q_80	create cookie	C_80_9	def _set_cookie ( self , name , value ) cookie_domain = self . _config . cookie_domain cookie_path = self . _config . cookie_path cookie_expires = self . _config . cookie_expires if self . _config . secure return self . handler . set_secure_cookie ( name , value , expires_days = cookie_expires / ( number * number ) , domain = cookie_domain , path = cookie_path ) else return self . handler . set_cookie ( name , value , expires = cookie_expires , domain = cookie_domain , path = cookie_path )	1
Q_80	create cookie	C_80_10	def _call_ ( self , req , res ) string string cookie string on_headerstrings string string	1
Q_80	create cookie	C_80_11	def setcookie ( self , key , value , max_age = none , expires = none , path = string , domain = none , secure = none , httponly = false ) string string string newcookie = morsel ( ) newcookie . key = key newcookie . value = value newcookie . coded_value = value if max_age is not none newcookie [ string ] = max_age if expires is not none newcookie [ string ] = expires if path is not none newcookie [ string ] = path if domain is not none newcookie [ string ] = domain if secure newcookie [ string ] = secure if httponly newcookie [ string ] = httponly self . sent_cookies = [ var for var in self . sent_cookies if var . key = key ] self . sent_cookies . append ( newcookie )	1
Q_80	create cookie	C_80_12	def create_cookie ( name , value , domain , httponly = none , * * kwargs ) string string string if domain = = string domain = string config = dict ( name = name , value = value , version = number , port = none , domain = domain , path = string , secure = false , expires = none , discard = true , comment = none , comment_url = none , rfc2109 = false , rest = { string httponly } , ) for var in kwargs if var not in config raise grab_misuse_error ( string string var ) config . update ( * * kwargs ) config [ string ] [ string ] = httponly config [ string ] = bool ( config [ string ] ) config [ string ] = bool ( config [ string ] ) config [ string ] = ( config [ string ] or string ) . startswith ( string ) config [ string ] = bool ( config [ string ] ) return cookie ( * * config )	1
Q_80	create cookie	C_80_13	def _call_ ( self , req , res ) string string cookie string on_headerstrings string string	1
Q_80	create cookie	C_80_14	def append_cookie ( self , cookie , var , payload , typ , domain = none , path = none , timestamp = string , max_age = number ) string string string timestamp = str ( int ( time . time ( ) ) )	1
Q_80	create cookie	C_80_15	def _set_cookie ( self , name , value ) cookie_domain = self . _config . cookie_domain cookie_path = self . _config . cookie_path cookie_expires = self . _config . cookie_expires if self . _config . secure return self . handler . set_secure_cookie ( name , value , expires_days = cookie_expires / ( number * number ) , domain = cookie_domain , path = cookie_path ) else return self . handler . set_cookie ( name , value , expires = cookie_expires , domain = cookie_domain , path = cookie_path )	1
Q_80	create cookie	C_80_16	def create_cookie ( name , value , domain , httponly = none , * * kwargs ) string string string if domain = = string domain = string config = dict ( name = name , value = value , version = number , port = none , domain = domain , path = string , secure = false , expires = none , discard = true , comment = none , comment_url = none , rfc2109 = false , rest = { string httponly } , ) for var in kwargs if var not in config raise grab_misuse_error ( string string var ) config . update ( * * kwargs ) config [ string ] [ string ] = httponly config [ string ] = bool ( config [ string ] ) config [ string ] = bool ( config [ string ] ) config [ string ] = ( config [ string ] or string ) . startswith ( string ) config [ string ] = bool ( config [ string ] ) return cookie ( * * config )	1
Q_80	create cookie	C_80_17	def append_cookie ( self , cookie , var , payload , typ , domain = none , path = none , timestamp = string , max_age = number ) string string string timestamp = str ( int ( time . time ( ) ) )	1
Q_80	create cookie	C_80_18	def _setcookie ( self , session_id , expires = string , * * kw ) cookie_name = self . _config . cookie_name cookie_domain = self . _config . cookie_domain cookie_path = self . _config . cookie_path httponly = self . _config . httponly secure = self . _config . secure web . setcookie ( cookie_name , session_id , expires = expires , domain = cookie_domain , httponly = httponly , secure = secure , path = cookie_path )	1
Q_80	create cookie	C_80_19	def set_cookie ( self , name , value = string , expires = number , path = string , domain = string , secure = false , http_only = false ) cook = cookie . simple_cookie ( ) cook [ name ] = value cook [ name ] [ string ] = expires cook [ name ] [ string ] = path cook [ name ] [ string ] = domain cook [ name ] [ string ] = secure cook [ name ] [ string ] = http_only self . send_header ( string , cook . output ( header = string ) )	1
Q_80	create cookie	C_80_20	def _call_ ( self , req , res ) string string cookie string on_headerstrings string string	1
Q_80	create cookie	C_80_21	def _setcookie ( self , session_id , expires = string , * * kw ) cookie_name = self . _config . cookie_name cookie_domain = self . _config . cookie_domain cookie_path = self . _config . cookie_path httponly = self . _config . httponly secure = self . _config . secure web . setcookie ( cookie_name , session_id , expires = expires , domain = cookie_domain , httponly = httponly , secure = secure , path = cookie_path )	0
Q_81	copy a file to a path	C_81_0	def _copy ( from_path , to_path ) message = string log . debug ( message , from_path , to_path ) copy ( from_path , to_path )	1
Q_81	copy a file to a path	C_81_1	def _copy_file ( self , file_obj , destination , suffix , overwrite ) if overwrite	1
Q_81	copy a file to a path	C_81_2	def write_file_to_output ( self , filename , path ) path = os . path . join ( self . out_path , path )	1
Q_81	copy a file to a path	C_81_3	def copy_file ( self , from_path , to_path ) string string string if not op . exists ( op . dirname ( to_path ) ) self . make_directory ( op . dirname ( to_path ) ) shutil . copy ( from_path , to_path ) logging . debug ( string . format ( to_path ) )	1
Q_81	copy a file to a path	C_81_4	def copy_file ( src , dst , ignore = none ) string string string	1
Q_81	copy a file to a path	C_81_5	def copy_file ( src , dst , ignore = none ) string string string	1
Q_81	copy a file to a path	C_81_6	def copy_file ( self , from_path , to_path ) string string string if not op . exists ( op . dirname ( to_path ) ) self . make_directory ( op . dirname ( to_path ) ) shutil . copy ( from_path , to_path ) logging . debug ( string . format ( to_path ) )	1
Q_81	copy a file to a path	C_81_7	def copy_dir ( self , path ) string string string for var in path if os . path . isdir ( path ) full_path = os . path . join ( self . archive_dir , var . lstrip ( string ) ) logger . debug ( string , var , full_path ) shutil . copytree ( var , full_path ) else logger . debug ( string , var ) return path	1
Q_81	copy a file to a path	C_81_8	def copy ( configfile = string , destpath = string , overwrite = false , sub_node = string ) string string string log . info ( string . format ( os . path . basename ( _file_ ) , whoami ( ) , locals ( ) ) ) assert ( os . path . isfile ( configfile ) ) if os . path . exists ( destpath ) if os . listdir ( destpath ) raise folder_already_exists ( string string . format ( destpath ) ) else log . info ( string . format ( destpath ) ) path ( destpath ) . makedirs_p ( ) from boyle . files . file_tree_map import file_tree_map file_map = file_tree_map ( ) try file_map . from_config_file ( configfile ) except exception as e raise file_tree_map_error ( str ( e ) ) if sub_node sub_map = file_map . get_node ( sub_node ) if not sub_map raise file_tree_map_error ( string string . format ( sub_node ) ) file_map . _filetree = { } file_map . _filetree [ sub_node ] = sub_map try file_map . copy_to ( destpath , overwrite = overwrite ) except exception as e raise file_tree_map_error ( str ( e ) )	1
Q_81	copy a file to a path	C_81_9	def _copy_file ( filepath , fulltime ) if filepath is none filepath_out = string else filename = _os . path . basename ( filepath ) root , ext = _os . path . splitext ( filename ) filepath_out = fulltime + ext copypath = _os . path . join ( basedir , filepath_out ) _shutil . copyfile ( filepath , copypath ) return filepath_out	1
Q_81	copy a file to a path	C_81_10	def _copy_file ( filepath , fulltime ) if filepath is none filepath_out = string else filename = _os . path . basename ( filepath ) root , ext = _os . path . splitext ( filename ) filepath_out = fulltime + ext copypath = _os . path . join ( basedir , filepath_out ) _shutil . copyfile ( filepath , copypath ) return filepath_out	1
Q_81	copy a file to a path	C_81_11	"def copy_file ( source_path , target_path , allow_undo = true , no_confirm = false , rename_on_collision = true , silent = false , extra_flags = number , h_wnd = none ) string string flying file string t automatically clobber on a name clash , automatically rename on collision and display the animation . string "" return _file_operation ( shellcon . fo_copy , source_path , target_path , allow_undo , no_confirm , rename_on_collision , silent , extra_flags , h_wnd )"	1
Q_81	copy a file to a path	C_81_12	def copy ( configfile = string , destpath = string , overwrite = false , sub_node = string ) string string string log . info ( string . format ( os . path . basename ( _file_ ) , whoami ( ) , locals ( ) ) ) assert ( os . path . isfile ( configfile ) ) if os . path . exists ( destpath ) if os . listdir ( destpath ) raise folder_already_exists ( string string . format ( destpath ) ) else log . info ( string . format ( destpath ) ) path ( destpath ) . makedirs_p ( ) from boyle . files . file_tree_map import file_tree_map file_map = file_tree_map ( ) try file_map . from_config_file ( configfile ) except exception as e raise file_tree_map_error ( str ( e ) ) if sub_node sub_map = file_map . get_node ( sub_node ) if not sub_map raise file_tree_map_error ( string string . format ( sub_node ) ) file_map . _filetree = { } file_map . _filetree [ sub_node ] = sub_map try file_map . copy_to ( destpath , overwrite = overwrite ) except exception as e raise file_tree_map_error ( str ( e ) )	1
Q_81	copy a file to a path	C_81_13	def write_file_to_output ( self , filename , path ) path = os . path . join ( self . out_path , path )	1
Q_81	copy a file to a path	C_81_14	def _copy ( from_path , to_path ) message = string log . debug ( message , from_path , to_path ) copy ( from_path , to_path )	1
Q_81	copy a file to a path	C_81_15	def copy_dir ( self , path ) string string string for var in path if os . path . isdir ( path ) full_path = os . path . join ( self . archive_dir , var . lstrip ( string ) ) logger . debug ( string , var , full_path ) shutil . copytree ( var , full_path ) else logger . debug ( string , var ) return path	1
Q_81	copy a file to a path	C_81_16	def _inject_files_to_staging ( self , rel_filepaths , temp_path ) patch_files = { } for var in rel_filepaths from_filepath = os . path . join ( self . _root_path , var ) to_filepath = os . path . join ( temp_path , var ) _logger . debug ( string , from_filepath , to_filepath ) to_path = os . path . dirname ( to_filepath ) if os . path . exists ( to_path ) is false os . makedirs ( to_path ) with open ( from_filepath , string ) as f with open ( to_filepath , string ) as g shutil . copyfileobj ( f , g ) s = os . stat ( from_filepath ) mtime_epoch = int ( s . st_mtime ) filesize_b = s . st_size	1
Q_81	copy a file to a path	C_81_17	"def copy_file ( source_path , target_path , allow_undo = true , no_confirm = false , rename_on_collision = true , silent = false , extra_flags = number , h_wnd = none ) string string flying file string t automatically clobber on a name clash , automatically rename on collision and display the animation . string "" return _file_operation ( shellcon . fo_copy , source_path , target_path , allow_undo , no_confirm , rename_on_collision , silent , extra_flags , h_wnd )"	1
Q_81	copy a file to a path	C_81_18	"def copy_file ( source_path , target_path , allow_undo = true , no_confirm = false , rename_on_collision = true , silent = false , extra_flags = number , h_wnd = none ) string string flying file string t automatically clobber on a name clash , automatically rename on collision and display the animation . string "" return _file_operation ( shellcon . fo_copy , source_path , target_path , allow_undo , no_confirm , rename_on_collision , silent , extra_flags , h_wnd )"	1
Q_81	copy a file to a path	C_81_19	"def copy_file ( source_path , target_path , allow_undo = true , no_confirm = false , rename_on_collision = true , silent = false , extra_flags = number , h_wnd = none ) string string flying file string t automatically clobber on a name clash , automatically rename on collision and display the animation . string "" return _file_operation ( shellcon . fo_copy , source_path , target_path , allow_undo , no_confirm , rename_on_collision , silent , extra_flags , h_wnd )"	1
Q_81	copy a file to a path	C_81_20	def _copy_file ( self , file_obj , destination , suffix , overwrite ) if overwrite	0
Q_81	copy a file to a path	C_81_21	def _inject_files_to_staging ( self , rel_filepaths , temp_path ) patch_files = { } for var in rel_filepaths from_filepath = os . path . join ( self . _root_path , var ) to_filepath = os . path . join ( temp_path , var ) _logger . debug ( string , from_filepath , to_filepath ) to_path = os . path . dirname ( to_filepath ) if os . path . exists ( to_path ) is false os . makedirs ( to_path ) with open ( from_filepath , string ) as f with open ( to_filepath , string ) as g shutil . copyfileobj ( f , g ) s = os . stat ( from_filepath ) mtime_epoch = int ( s . st_mtime ) filesize_b = s . st_size	0
Q_82	copy to clipboard	C_82_0	def copy_to_clipboard ( i )	1
Q_82	copy to clipboard	C_82_1	def copy_to_clipboard ( i )	1
Q_82	copy to clipboard	C_82_2	def copy_to_clipboard ( text )	1
Q_82	copy to clipboard	C_82_3	def paste ( self ) string string string clipboard = q_application . clipboard ( ) cliptext = string if clipboard . mime_data ( ) . has_text ( ) cliptext = to_text_string ( clipboard . text ( ) ) if cliptext . strip ( ) self . import_from_string ( cliptext , title = _ ( string ) ) else q_message_box . warning ( self , _ ( string ) , _ ( string ) )	1
Q_82	copy to clipboard	C_82_4	def copy_to_clipboard ( text )	1
Q_82	copy to clipboard	C_82_5	def copy_filepath ( self ) string string string clipboard = q_application . instance ( ) . clipboard ( ) clipboard . set_text ( self . filepath ( ) ) clipboard . set_text ( self . filepath ( ) , clipboard . selection )	1
Q_82	copy to clipboard	C_82_6	def copy_filepath ( self ) string string string clipboard = q_application . instance ( ) . clipboard ( ) clipboard . set_text ( self . filepath ( ) ) clipboard . set_text ( self . filepath ( ) , clipboard . selection )	1
Q_82	copy to clipboard	C_82_7	def copy_to_clipboard ( self , event ) log . critical ( string ) text = self . text . get ( string , tkinter . end ) print ( text ) self . root . clipboard_clear ( ) self . root . clipboard_append ( text )	1
Q_82	copy to clipboard	C_82_8	def paste ( self ) string string string clipboard = q_application . clipboard ( ) cliptext = string if clipboard . mime_data ( ) . has_text ( ) cliptext = to_text_string ( clipboard . text ( ) ) if cliptext . strip ( ) self . import_from_string ( cliptext , title = _ ( string ) ) else q_message_box . warning ( self , _ ( string ) , _ ( string ) )	1
Q_82	copy to clipboard	C_82_9	def copy_to_clipboard ( self , event ) log . critical ( string ) text = self . text . get ( string , tkinter . end ) print ( text ) self . root . clipboard_clear ( ) self . root . clipboard_append ( text )	1
Q_82	copy to clipboard	C_82_10	def copy_clipboard ( self ) if self . get_has_selection ( ) super ( guake_terminal , self ) . copy_clipboard ( ) elif self . matched_value guake_clipboard = gtk . clipboard . get_default ( self . guake . window . get_display ( ) ) guake_clipboard . set_text ( self . matched_value , len ( self . matched_value ) )	1
Q_82	copy to clipboard	C_82_11	def create_clipboard ( self , text , selection = gdk . selection_clipboard ) string string string clipboard = gtk . clipboard . get ( selection ) clipboard . set_text ( string . join ( text ) , _ number ) clipboard . store ( ) return clipboard	1
Q_82	copy to clipboard	C_82_12	def copy_request_to_clipboard ( self ) txt = string . join ( self . context_model . request ) clipboard = app . clipboard ( ) clipboard . set_text ( txt ) with app . status ( string ) pass	1
Q_82	copy to clipboard	C_82_13	def create_clipboard ( self , text , selection = gdk . selection_clipboard ) string string string clipboard = gtk . clipboard . get ( selection ) clipboard . set_text ( string . join ( text ) , _ number ) clipboard . store ( ) return clipboard	1
Q_82	copy to clipboard	C_82_14	def copy_clipboard ( self ) if self . get_has_selection ( ) super ( guake_terminal , self ) . copy_clipboard ( ) elif self . matched_value guake_clipboard = gtk . clipboard . get_default ( self . guake . window . get_display ( ) ) guake_clipboard . set_text ( self . matched_value , len ( self . matched_value ) )	1
Q_82	copy to clipboard	C_82_15	def paste ( self ) string string string clipboard = q_application . clipboard ( ) cliptext = string if clipboard . mime_data ( ) . has_text ( ) cliptext = to_text_string ( clipboard . text ( ) ) if cliptext . strip ( ) self . import_from_string ( cliptext , title = _ ( string ) ) else q_message_box . warning ( self , _ ( string ) , _ ( string ) )	1
Q_82	copy to clipboard	C_82_16	def create_clipboard ( self , text , selection = gdk . selection_clipboard ) string string string clipboard = gtk . clipboard . get ( selection ) clipboard . set_text ( string . join ( text ) , _ number ) clipboard . store ( ) return clipboard	1
Q_82	copy to clipboard	C_82_17	def copy ( self ) string string string cliptxt = self . _sel_to_text ( self . selected_indexes ( ) ) clipboard = q_application . clipboard ( ) clipboard . set_text ( cliptxt )	1
Q_83	convert uint8 array to image	C_83_0	def _convert_uint8 ( im ) if im . dtype = np . uint8 im = np . uint8 ( im * number ) return im	1
Q_83	convert uint8 array to image	C_83_1	def _convert_uint8 ( im ) if im . dtype = np . uint8 im = np . uint8 ( im * number ) return im	1
Q_83	convert uint8 array to image	C_83_2	def uint8_to_uint32 ( self , element ) img = np . dstack ( [ element . dimension_values ( var , flat = false ) for var in element . vdims ] ) if img . shape [ number ] = = number	1
Q_83	convert uint8 array to image	C_83_3	def to_u_int_array ( img , dtype = none , cut_negative = true , cut_high = true , range = none , copy = true ) string string string mn , mx = none , none if range is not none mn , mx = range if dtype is none if mx is none mx = np . nanmax ( img ) dtype = np . uint16 if mx > number else np . uint8 dtype = np . dtype ( dtype ) if dtype = = img . dtype return img	1
Q_83	convert uint8 array to image	C_83_4	def from_array ( x , frame = string ) string string string if not image . can_convert ( x ) raise value_error ( string ) dtype = x . dtype height = x . shape [ number ] width = x . shape [ number ] channels = number if len ( x . shape ) = = number channels = x . shape [ number ] if dtype = = np . uint8 if channels = = number if np . any ( ( x binary_im_max_val ) > number ) return grayscale_image ( x , frame ) return binary_image ( x , frame ) elif channels = = number return color_image ( x , frame ) else raise value_error ( string ) elif dtype = = np . uint16 if channels = number raise value_error ( string ) return grayscale_image ( x , frame ) elif dtype = = np . float32 or dtype = = np . float64 if channels = = number return depth_image ( x , frame ) elif channels = = number return gd_image ( x , frame ) elif channels = = number logging . warning ( string ) return color_image ( x . astype ( np . uint8 ) , frame ) return rgbd_image ( x , frame ) else raise value_error ( string ( str ( dtype ) ) )	1
Q_83	convert uint8 array to image	C_83_5	def to_u_int_array ( img , dtype = none , cut_negative = true , cut_high = true , range = none , copy = true ) string string string mn , mx = none , none if range is not none mn , mx = range if dtype is none if mx is none mx = np . nanmax ( img ) dtype = np . uint16 if mx > number else np . uint8 dtype = np . dtype ( dtype ) if dtype = = img . dtype return img	1
Q_83	convert uint8 array to image	C_83_6	def to_uint8 ( self ) string string string	1
Q_83	convert uint8 array to image	C_83_7	def from_array ( x , frame = string ) string string string if not image . can_convert ( x ) raise value_error ( string ) dtype = x . dtype height = x . shape [ number ] width = x . shape [ number ] channels = number if len ( x . shape ) = = number channels = x . shape [ number ] if dtype = = np . uint8 if channels = = number if np . any ( ( x binary_im_max_val ) > number ) return grayscale_image ( x , frame ) return binary_image ( x , frame ) elif channels = = number return color_image ( x , frame ) else raise value_error ( string ) elif dtype = = np . uint16 if channels = number raise value_error ( string ) return grayscale_image ( x , frame ) elif dtype = = np . float32 or dtype = = np . float64 if channels = = number return depth_image ( x , frame ) elif channels = = number return gd_image ( x , frame ) elif channels = = number logging . warning ( string ) return color_image ( x . astype ( np . uint8 ) , frame ) return rgbd_image ( x , frame ) else raise value_error ( string ( str ( dtype ) ) )	1
Q_83	convert uint8 array to image	C_83_8	def to_uint8 ( self , data ) string string string np = util . get_module ( string , required = string )	1
Q_83	convert uint8 array to image	C_83_9	def from_array ( x , frame = string ) string string string if not image . can_convert ( x ) raise value_error ( string ) dtype = x . dtype height = x . shape [ number ] width = x . shape [ number ] channels = number if len ( x . shape ) = = number channels = x . shape [ number ] if dtype = = np . uint8 if channels = = number if np . any ( ( x binary_im_max_val ) > number ) return grayscale_image ( x , frame ) return binary_image ( x , frame ) elif channels = = number return color_image ( x , frame ) else raise value_error ( string ) elif dtype = = np . uint16 if channels = number raise value_error ( string ) return grayscale_image ( x , frame ) elif dtype = = np . float32 or dtype = = np . float64 if channels = = number return depth_image ( x , frame ) elif channels = = number return gd_image ( x , frame ) elif channels = = number logging . warning ( string ) return color_image ( x . astype ( np . uint8 ) , frame ) return rgbd_image ( x , frame ) else raise value_error ( string ( str ( dtype ) ) )	1
Q_83	convert uint8 array to image	C_83_10	def imread ( img , color = none , dtype = none ) string string no_uint string float string string color2_cv = { string cv2 . imread_grayscale , string cv2 . imread_color , none cv2 . imread_anycolor } c = color2_cv [ color ] if callable ( img ) img = img ( ) elif isinstance ( img , string_types )	1
Q_83	convert uint8 array to image	C_83_11	def uint32_to_uint8 ( cls , img ) string string string return np . flipud ( img . view ( dtype = np . uint8 ) . reshape ( img . shape + ( number , ) ) )	1
Q_83	convert uint8 array to image	C_83_12	def to_uint8 ( self , data ) string string string np = util . get_module ( string , required = string )	1
Q_83	convert uint8 array to image	C_83_13	def upscale_float_image ( img , as_uint16 ) if as_uint16 return np . asarray ( ( img * number ) , np . uint16 ) return np . asarray ( ( img * number ) , np . uint8 )	1
Q_83	convert uint8 array to image	C_83_14	def _validate_image_datatype ( self , img_array ) string string string if img_array . dtype = np . uint8 and img_array . dtype = np . uint16 msg = ( string string ) raise runtime_error ( msg )	1
Q_83	convert uint8 array to image	C_83_15	def uint8_to_uint32 ( self , element ) img = np . dstack ( [ element . dimension_values ( var , flat = false ) for var in element . vdims ] ) if img . shape [ number ] = = number	1
Q_83	convert uint8 array to image	C_83_16	def to_uint8 ( self ) string string string	1
Q_83	convert uint8 array to image	C_83_17	def imread ( img , color = none , dtype = none ) string string no_uint string float string string color2_cv = { string cv2 . imread_grayscale , string cv2 . imread_color , none cv2 . imread_anycolor } c = color2_cv [ color ] if callable ( img ) img = img ( ) elif isinstance ( img , string_types )	1
Q_83	convert uint8 array to image	C_83_18	def to_u_int_array ( img , dtype = none , cut_negative = true , cut_high = true , range = none , copy = true ) string string string mn , mx = none , none if range is not none mn , mx = range if dtype is none if mx is none mx = np . nanmax ( img ) dtype = np . uint16 if mx > number else np . uint8 dtype = np . dtype ( dtype ) if dtype = = img . dtype return img	1
Q_83	convert uint8 array to image	C_83_19	def upscale_float_image ( img , as_uint16 ) if as_uint16 return np . asarray ( ( img * number ) , np . uint16 ) return np . asarray ( ( img * number ) , np . uint8 )	1
Q_83	convert uint8 array to image	C_83_20	def uint32_to_uint8 ( cls , img ) string string string return np . flipud ( img . view ( dtype = np . uint8 ) . reshape ( img . shape + ( number , ) ) )	1
Q_83	convert uint8 array to image	C_83_21	def _validate_image_datatype ( self , img_array ) string string string if img_array . dtype = np . uint8 and img_array . dtype = np . uint16 msg = ( string string ) raise runtime_error ( msg )	0
Q_83	convert uint8 array to image	C_83_22	def uint32_to_uint8 ( cls , img ) string string string return np . flipud ( img . view ( dtype = np . uint8 ) . reshape ( img . shape + ( number , ) ) )	0
Q_84	convert string to number	C_84_0	"def _convert_num ( number ) string string s an int or float , this attempts to convert it . param str number return float or str string string convert_num value_error { } "" . format ( e ) ) return number"	1
Q_84	convert string to number	C_84_1	def convert_string_to_number ( value ) string string string if value is none return number if isinstance ( value , int ) return value if value . isdigit ( ) return int ( value ) num_list = map ( lambda s numbers [ s ] , re . findall ( numbers + string , value . lower ( ) ) ) return sum ( num_list )	1
Q_84	convert string to number	C_84_2	def convert_string_to_number ( value ) string string string if value is none return number if isinstance ( value , int ) return value if value . isdigit ( ) return int ( value ) num_list = map ( lambda s numbers [ s ] , re . findall ( numbers + string , value . lower ( ) ) ) return sum ( num_list )	1
Q_84	convert string to number	C_84_3	def convert_string_to_number ( value ) string string string if value is none return number if isinstance ( value , int ) return value if value . isdigit ( ) return int ( value ) num_list = map ( lambda s numbers [ s ] , re . findall ( numbers + string , value . lower ( ) ) ) return sum ( num_list )	1
Q_84	convert string to number	C_84_4	def default_number_converter ( number_str ) string string string is_int = ( number_str . startswith ( string ) and number_str [ number ] . isdigit ( ) ) or number_str . isdigit ( )	1
Q_84	convert string to number	C_84_5	def default_number_converter ( number_str ) string string string is_int = ( number_str . startswith ( string ) and number_str [ number ] . isdigit ( ) ) or number_str . isdigit ( )	1
Q_84	convert string to number	C_84_6	"def _convert_num ( number ) string string s an int or float , this attempts to convert it . param str number return float or str string string convert_num value_error { } "" . format ( e ) ) return number"	1
Q_84	convert string to number	C_84_7	def nat_cmp ( a , b ) convert = lambda text int ( text ) if text . isdigit ( ) else text	1
Q_84	convert string to number	C_84_8	"def pack_unsigned_int ( number , size , le ) if not isinstance ( number , int ) raise struct_error ( string ) if number < number raise type_error ( string t convert negative long to unsigned string number i too large to convert "" number ) return pack_int ( number , size , le )"	1
Q_84	convert string to number	C_84_9	def to_str ( num ) if isinstance ( num , dict ) s = sorted ( num . items ( ) ) sp = num . get ( string , string ) return ( sp + string ) . join ( to_str ( var ) for var , var in s if var = string ) elif isinstance ( num , float ) num = ( string round ( num , number ) ) . rstrip ( string ) . rstrip ( string ) return num elif isinstance ( num , bool ) return string if num else string elif num is none return string return str ( num )	1
Q_84	convert string to number	C_84_10	def nat_cmp ( a , b ) convert = lambda text int ( text ) if text . isdigit ( ) else text	1
Q_84	convert string to number	C_84_11	def to_str ( n , base ) convert_string = string if n < base return convert_string [ n ] else return to_str ( n / / base , base ) + convert_string [ n base ]	1
Q_84	convert string to number	C_84_12	"def pack_unsigned_int ( number , size , le ) if not isinstance ( number , int ) raise struct_error ( string ) if number < number raise type_error ( string t convert negative long to unsigned string number i too large to convert "" number ) return pack_int ( number , size , le )"	0
Q_84	convert string to number	C_84_13	def to_str ( num ) if isinstance ( num , dict ) s = sorted ( num . items ( ) ) sp = num . get ( string , string ) return ( sp + string ) . join ( to_str ( var ) for var , var in s if var = string ) elif isinstance ( num , float ) num = ( string round ( num , number ) ) . rstrip ( string ) . rstrip ( string ) return num elif isinstance ( num , bool ) return string if num else string elif num is none return string return str ( num )	0
Q_84	convert string to number	C_84_14	def number_to_string ( value )	0
Q_84	convert string to number	C_84_15	def standardize_phone_number ( number ) number_str = str ( number ) if number_str . startswith ( string ) return string + number_str [ number ] elif number_str . startswith ( string ) return string + number_str [ number ]	0
Q_84	convert string to number	C_84_16	def to_str ( n , base ) convert_string = string if n < base return convert_string [ n ] else return to_str ( n / / base , base ) + convert_string [ n base ]	0
Q_84	convert string to number	C_84_17	def standardize_phone_number ( number ) number_str = str ( number ) if number_str . startswith ( string ) return string + number_str [ number ] elif number_str . startswith ( string ) return string + number_str [ number ]	0
Q_84	convert string to number	C_84_18	def number_to_string ( value )	0
Q_85	convert json to csv	C_85_0	def json_to_csv ( json_input ) string string string try json_input = json . loads ( json_input ) except pass	1
Q_85	convert json to csv	C_85_1	def json_to_csv ( json_input ) string string string try json_input = json . loads ( json_input ) except pass	1
Q_85	convert json to csv	C_85_2	def json_to_csv ( json_input ) string string string try json_input = json . loads ( json_input ) except pass	1
Q_85	convert json to csv	C_85_3	def _tsv2json ( in_tsv , out_json , index_column , additional_metadata = none , drop_columns = none , enforce_case = true ) string string string import pandas as pd	1
Q_85	convert json to csv	C_85_4	def get_csv_from_json ( d ) string string string logger_jsons . info ( string ) csv_data = ordered_dict ( ) if string in d csv_data = _get_csv_from_section ( d , string , csv_data ) if string in d csv_data = _get_csv_from_section ( d , string , csv_data ) logger_jsons . info ( string ) return csv_data	1
Q_85	convert json to csv	C_85_5	def _tsv2json ( in_tsv , out_json , index_column , additional_metadata = none , drop_columns = none , enforce_case = true ) string string string import pandas as pd	1
Q_85	convert json to csv	C_85_6	def csv_to_json ( csv_filepath , json_filepath , fieldnames , ignore_first_line = true ) string string string import csv import json csvfile = open ( csv_filepath , string ) jsonfile = open ( json_filepath , string ) reader = csv . dict_reader ( csvfile , fieldnames ) rows = [ ] if ignore_first_line next ( reader ) for var in reader rows . append ( var ) json . dump ( rows , jsonfile ) jsonfile . close ( ) csvfile . close ( )	1
Q_85	convert json to csv	C_85_7	def convert ( csv , json , * * kwargs ) string string _ string _ string string csv_local , json_local = none , none try if csv = = string or csv is none csv = sys . stdin elif isinstance ( csv , str ) csv = csv_local = open ( csv , string ) if json = = string or json is none json = sys . stdout elif isinstance ( json , str ) json = json_local = open ( json , string ) data = load_csv ( csv , * * kwargs ) save_json ( data , json , * * kwargs ) finally if csv_local is not none csv_local . close ( ) if json_local is not none json_local . close ( )	1
Q_85	convert json to csv	C_85_8	def convert ( csv , json , * * kwargs ) string string _ string _ string string csv_local , json_local = none , none try if csv = = string or csv is none csv = sys . stdin elif isinstance ( csv , str ) csv = csv_local = open ( csv , string ) if json = = string or json is none json = sys . stdout elif isinstance ( json , str ) json = json_local = open ( json , string ) data = load_csv ( csv , * * kwargs ) save_json ( data , json , * * kwargs ) finally if csv_local is not none csv_local . close ( ) if json_local is not none json_local . close ( )	1
Q_85	convert json to csv	C_85_9	def save_csv ( self , csv_location )	1
Q_85	convert json to csv	C_85_10	def convert ( csv , json , * * kwargs ) string string _ string _ string string csv_local , json_local = none , none try if csv = = string or csv is none csv = sys . stdin elif isinstance ( csv , str ) csv = csv_local = open ( csv , string ) if json = = string or json is none json = sys . stdout elif isinstance ( json , str ) json = json_local = open ( json , string ) data = load_csv ( csv , * * kwargs ) save_json ( data , json , * * kwargs ) finally if csv_local is not none csv_local . close ( ) if json_local is not none json_local . close ( )	1
Q_85	convert json to csv	C_85_11	def csv_to_json ( csv_filepath , json_filepath , fieldnames , ignore_first_line = true ) string string string import csv import json csvfile = open ( csv_filepath , string ) jsonfile = open ( json_filepath , string ) reader = csv . dict_reader ( csvfile , fieldnames ) rows = [ ] if ignore_first_line next ( reader ) for var in reader rows . append ( var ) json . dump ( rows , jsonfile ) jsonfile . close ( ) csvfile . close ( )	1
Q_85	convert json to csv	C_85_12	def serialize ( graph bel_graph , csv , sif , gsea , graphml , json , bel ) string string string if csv log . info ( string , csv ) to_csv ( graph , csv ) if sif log . info ( string , sif ) to_sif ( graph , sif ) if graphml log . info ( string , graphml ) to_graphml ( graph , graphml ) if gsea log . info ( string , gsea ) to_gsea ( graph , gsea ) if json log . info ( string , json ) to_json_file ( graph , json ) if bel log . info ( string , bel ) to_bel ( graph , bel )	0
Q_85	convert json to csv	C_85_13	def serialize ( graph bel_graph , csv , sif , gsea , graphml , json , bel ) string string string if csv log . info ( string , csv ) to_csv ( graph , csv ) if sif log . info ( string , sif ) to_sif ( graph , sif ) if graphml log . info ( string , graphml ) to_graphml ( graph , graphml ) if gsea log . info ( string , gsea ) to_gsea ( graph , gsea ) if json log . info ( string , json ) to_json_file ( graph , json ) if bel log . info ( string , bel ) to_bel ( graph , bel )	0
Q_85	convert json to csv	C_85_14	def read_csv ( csv_name ) string string string data = { } if not isinstance ( csv_name , ( str , unicode ) ) raise exceptions . invalid_data_format ( string ) with open ( csv_name , string ) as csv_data reader = csv . reader ( csv_data , delimiter = string , quotechar = string ) for var in reader try key = to_epoch ( var [ number ] ) value = float ( var [ number ] ) data [ key ] = value except value_error pass return data	0
Q_85	convert json to csv	C_85_15	def serialize ( graph bel_graph , csv , sif , gsea , graphml , json , bel ) string string string if csv log . info ( string , csv ) to_csv ( graph , csv ) if sif log . info ( string , sif ) to_sif ( graph , sif ) if graphml log . info ( string , graphml ) to_graphml ( graph , graphml ) if gsea log . info ( string , gsea ) to_gsea ( graph , gsea ) if json log . info ( string , json ) to_json_file ( graph , json ) if bel log . info ( string , bel ) to_bel ( graph , bel )	0
Q_85	convert json to csv	C_85_16	def save_csv ( self , csv_location )	0
Q_85	convert json to csv	C_85_17	def serialize ( graph bel_graph , csv , sif , gsea , graphml , json , bel ) string string string if csv log . info ( string , csv ) to_csv ( graph , csv ) if sif log . info ( string , sif ) to_sif ( graph , sif ) if graphml log . info ( string , graphml ) to_graphml ( graph , graphml ) if gsea log . info ( string , gsea ) to_gsea ( graph , gsea ) if json log . info ( string , json ) to_json_file ( graph , json ) if bel log . info ( string , bel ) to_bel ( graph , bel )	0
Q_85	convert json to csv	C_85_18	def _write_local_data_files ( self , cursor ) string string string schema = list ( map ( lambda schema_tuple schema_tuple [ number ] , cursor . description ) ) col_type_dict = self . _get_col_type_dict ( ) file_no = number tmp_file_handle = named_temporary_file ( delete = true ) if self . export_format = = string file_mime_type = string else file_mime_type = string files_to_upload = [ { string self . filename . format ( file_no ) , string tmp_file_handle , string file_mime_type } ] if self . export_format = = string csv_writer = self . _configure_csv_file ( tmp_file_handle , schema ) for var in cursor	0
Q_85	convert json to csv	C_85_19	def read_csv ( csv_name ) string string string data = { } if not isinstance ( csv_name , ( str , unicode ) ) raise exceptions . invalid_data_format ( string ) with open ( csv_name , string ) as csv_data reader = csv . reader ( csv_data , delimiter = string , quotechar = string ) for var in reader try key = to_epoch ( var [ number ] ) value = float ( var [ number ] ) data [ key ] = value except value_error pass return data	0
Q_85	convert json to csv	C_85_20	def csv_to_json ( csv_filepath , json_filepath , fieldnames , ignore_first_line = true ) string string string import csv import json csvfile = open ( csv_filepath , string ) jsonfile = open ( json_filepath , string ) reader = csv . dict_reader ( csvfile , fieldnames ) rows = [ ] if ignore_first_line next ( reader ) for var in reader rows . append ( var ) json . dump ( rows , jsonfile ) jsonfile . close ( ) csvfile . close ( )	0
Q_86	convert int to string	C_86_0	def string_to_int ( s ) string string string result = number for var in s if not isinstance ( var , int ) var = ord ( var ) result = number * result + var return result	1
Q_86	convert int to string	C_86_1	def string_to_int ( s ) string string string result = number for var in s if not isinstance ( var , int ) var = ord ( var ) result = number * result + var return result	1
Q_86	convert int to string	C_86_2	def convert_to_integer ( self , str ) if str . startswith ( string ) or str . startswith ( string ) return int ( str , number ) elif str . startswith ( string ) return int ( str [ number ] , number ) else return int ( str )	1
Q_86	convert int to string	C_86_3	def convert_to_integer ( self , str ) if str . startswith ( string ) or str . startswith ( string ) return int ( str , number ) elif str . startswith ( string ) return int ( str [ number ] , number ) else return int ( str )	1
Q_86	convert int to string	C_86_4	def _u_int ( s ) string string number a string string try v = int ( s , number ) except value_error v = _ number if len ( s ) < number or len ( s ) > number or v < number or v > _rune_max raise input_error ( string ( s , ) ) return v	1
Q_86	convert int to string	C_86_5	def to_match_packet_type ( value ) if isinstance ( value , ( list , tuple ) ) return str_to_int ( value [ number ] ) < < number str_to_int ( value [ number ] ) else return str_to_int ( value )	1
Q_86	convert int to string	C_86_6	def convert_str_to_int ( arg ) string string string for var , var in list ( arg . items ( ) )	1
Q_86	convert int to string	C_86_7	def _convert_value ( self , item ) string string string	1
Q_86	convert int to string	C_86_8	def to_match_masked_int ( value ) if isinstance ( value , str ) and string in value value = value . split ( string ) return str_to_int ( value [ number ] ) , str_to_int ( value [ number ] ) return str_to_int ( value )	1
Q_86	convert int to string	C_86_9	def int_to_decimal_str ( integer ) string string string int_string = str ( integer ) if len ( int_string ) < number return string + int_string . zfill ( number ) else return int_string [ _ number ] + string + int_string [ _ number ]	0
Q_86	convert int to string	C_86_10	def to_match_masked_int ( value ) if isinstance ( value , str ) and string in value value = value . split ( string ) return str_to_int ( value [ number ] ) , str_to_int ( value [ number ] ) return str_to_int ( value )	0
Q_86	convert int to string	C_86_11	def nat_cmp ( a , b ) convert = lambda text int ( text ) if text . isdigit ( ) else text	0
Q_86	convert int to string	C_86_12	def nat_cmp ( a , b ) convert = lambda text int ( text ) if text . isdigit ( ) else text	0
Q_86	convert int to string	C_86_13	def str2int ( self , s ) if self . is_binary ( s ) if s [ number _ number ] return int ( s [ number _ number ] , number ) else raise error . py_smi_semantic_error ( string ) elif self . is_hex ( s ) if s [ number _ number ] return int ( s [ number _ number ] , number ) else raise error . py_smi_semantic_error ( string ) else return int ( s )	0
Q_86	convert int to string	C_86_14	def _convert_value ( self , item ) string string string	0
Q_86	convert int to string	C_86_15	def convert_str_to_int ( arg ) string string string for var , var in list ( arg . items ( ) )	0
Q_86	convert int to string	C_86_16	def to_match_packet_type ( value ) if isinstance ( value , ( list , tuple ) ) return str_to_int ( value [ number ] ) < < number str_to_int ( value [ number ] ) else return str_to_int ( value )	0
Q_86	convert int to string	C_86_17	def _u_int ( s ) string string number a string string try v = int ( s , number ) except value_error v = _ number if len ( s ) < number or len ( s ) > number or v < number or v > _rune_max raise input_error ( string ( s , ) ) return v	0
Q_86	convert int to string	C_86_18	def _u_int ( s ) string string number a string string try v = int ( s , number ) except value_error v = _ number if len ( s ) < number or len ( s ) > number or v < number or v > _rune_max raise input_error ( string ( s , ) ) return v	0
Q_87	convert int to bool	C_87_0	def convert_to_bool ( x any , default bool = none ) _ > bool string string string if isinstance ( x , bool ) return x if not x	1
Q_87	convert int to bool	C_87_1	def _convert_to_bool ( argument ) lowered = argument . lower ( ) if lowered in ( string , string , string , string , string , string , string ) return true elif lowered in ( string , string , string , string , string , string , string ) return false else raise bad_argument ( lowered + string )	1
Q_87	convert int to bool	C_87_2	def convert ( self , value ) string string string if self . _type is str return str ( value ) elif self . _type is int try return int ( value ) except ( unicode_error , value_error ) raise workflow_argument_error ( string . format ( value ) ) elif self . _type is float try return float ( value ) except ( unicode_error , value_error ) raise workflow_argument_error ( string . format ( value ) ) elif self . _type is bool if isinstance ( value , bool ) return bool ( value ) value = value . lower ( ) if value in ( string , string , string , string ) return true elif value in ( string , string , string , string ) return false raise workflow_argument_error ( string . format ( value ) ) else return value	1
Q_87	convert int to bool	C_87_3	def _convert ( value , default = none , convert = none ) def convert_bool ( value ) if value . lower ( ) in ( string , string , string , string ) return true if value . lower ( ) in ( string , string , string , string ) return false raise value_error ( string . format ( value ) ) if value = = string value = none if convert is none if default is not none convert = type ( default ) else convert = str if convert = = bool convert = convert_bool if value is none return default else return convert ( value )	1
Q_87	convert int to bool	C_87_4	"def boolval ( v ) if isinstance ( v , bool ) return v if isinstance ( v , int ) return bool ( v ) if is_string ( v ) v = v . lower ( ) if v in { string , string , string , string , string , string } return true if v in { string , string , string , string , string } return false raise value_error ( string t know how to convert r to bool "" v )"	1
Q_87	convert int to bool	C_87_5	"def boolval ( v ) if isinstance ( v , bool ) return v if isinstance ( v , int ) return bool ( v ) if is_string ( v ) v = v . lower ( ) if v in { string , string , string , string , string , string } return true if v in { string , string , string , string , string } return false raise value_error ( string t know how to convert r to bool "" v )"	1
Q_87	convert int to bool	C_87_6	def to_bool ( self , value ) if value = = none return false elif isinstance ( value , bool ) return value else if str ( value ) . lower ( ) in [ string , string , string ] return true else return false	1
Q_87	convert int to bool	C_87_7	def _convert ( value , default = none , convert = none ) def convert_bool ( value ) if value . lower ( ) in ( string , string , string , string ) return true if value . lower ( ) in ( string , string , string , string ) return false raise value_error ( string . format ( value ) ) if value = = string value = none if convert is none if default is not none convert = type ( default ) else convert = str if convert = = bool convert = convert_bool if value is none return default else return convert ( value )	1
Q_87	convert int to bool	C_87_8	def str_to_bool ( s ) s = s . lower ( ) if s in ( string , string , string ) return true if s in ( string , string , string ) return false raise conversion_error ( string . format ( s ) )	1
Q_87	convert int to bool	C_87_9	def convert ( self , value ) string string string if self . _type is str return str ( value ) elif self . _type is int try return int ( value ) except ( unicode_error , value_error ) raise workflow_argument_error ( string . format ( value ) ) elif self . _type is float try return float ( value ) except ( unicode_error , value_error ) raise workflow_argument_error ( string . format ( value ) ) elif self . _type is bool if isinstance ( value , bool ) return bool ( value ) value = value . lower ( ) if value in ( string , string , string , string ) return true elif value in ( string , string , string , string ) return false raise workflow_argument_error ( string . format ( value ) ) else return value	1
Q_87	convert int to bool	C_87_10	def to_bool ( value ) try return bool ( int ( value ) ) except value_error return true if string = = value . lower ( ) else false	1
Q_87	convert int to bool	C_87_11	"def boolval ( v ) if isinstance ( v , bool ) return v if isinstance ( v , int ) return bool ( v ) if is_string ( v ) v = v . lower ( ) if v in { string , string , string , string , string , string } return true if v in { string , string , string , string , string } return false raise value_error ( string t know how to convert r to bool "" v )"	1
Q_87	convert int to bool	C_87_12	def _convert_to_bool ( argument ) lowered = argument . lower ( ) if lowered in ( string , string , string , string , string , string , string ) return true elif lowered in ( string , string , string , string , string , string , string ) return false else raise bad_argument ( lowered + string )	1
Q_87	convert int to bool	C_87_13	def str_to_bool ( s ) s = s . lower ( ) if s in ( string , string , string ) return true if s in ( string , string , string ) return false raise conversion_error ( string . format ( s ) )	1
Q_87	convert int to bool	C_87_14	def convert_to_bool ( ) string string string if not options . strict_bool . value return [ ] requires . add ( string ) result = [ ] result . append ( string ) result . append ( string ) result . append ( string ) return result	1
Q_87	convert int to bool	C_87_15	def convert_to_bool ( x any , default bool = none ) _ > bool string string string if isinstance ( x , bool ) return x if not x	1
Q_87	convert int to bool	C_87_16	def to_bool ( x ) if x . lower ( ) in ( string , string , string , string ) return true elif x . lower ( ) in ( string , string , string , string ) return false else raise value_error ( string x )	1
Q_87	convert int to bool	C_87_17	def to_bool ( self , value ) if value = = none return false elif isinstance ( value , bool ) return value else if str ( value ) . lower ( ) in [ string , string , string ] return true else return false	0
Q_87	convert int to bool	C_87_18	def convert_to_bool ( ) string string string if not options . strict_bool . value return [ ] requires . add ( string ) result = [ ] result . append ( string ) result . append ( string ) result . append ( string ) return result	0
Q_87	convert int to bool	C_87_19	def to_bool ( x ) if x . lower ( ) in ( string , string , string , string ) return true elif x . lower ( ) in ( string , string , string , string ) return false else raise value_error ( string x )	0
Q_88	convert html to pdf	C_88_0	def html_to_pdf ( tmp_filenames , output_directory , lang_options ) input_html = output_directory + string + tmp_filenames [ number ] wkthml_cmd = [ string ]	1
Q_88	convert html to pdf	C_88_1	def html_to_pdf ( content , encoding = string , link_callback = fetch_resources , * * kwargs ) string string string src = bytes_io ( content . encode ( encoding ) ) dest = bytes_io ( ) pdf = pisa . pisa_document ( src , dest , encoding = encoding , link_callback = link_callback , * * kwargs ) if pdf . err logger . error ( string ) for var in pdf . log if var [ number ] = = xhtml2pdf . default . pml_error logger_x2p . error ( string , var [ number ] , var [ number ] , var [ number ] ) raise pdf_rendering_error ( string , content = content , log = pdf . log ) if pdf . warn for var in pdf . log if var [ number ] = = xhtml2pdf . default . pml_warning logger_x2p . warning ( string , var [ number ] , var [ number ] , var [ number ] ) return dest . getvalue ( )	1
Q_88	convert html to pdf	C_88_2	def make_pdf_from_html (	1
Q_88	convert html to pdf	C_88_3	def html_to_pdf ( content , encoding = string , link_callback = fetch_resources , * * kwargs ) string string string src = bytes_io ( content . encode ( encoding ) ) dest = bytes_io ( ) pdf = pisa . pisa_document ( src , dest , encoding = encoding , link_callback = link_callback , * * kwargs ) if pdf . err logger . error ( string ) for var in pdf . log if var [ number ] = = xhtml2pdf . default . pml_error logger_x2p . error ( string , var [ number ] , var [ number ] , var [ number ] ) raise pdf_rendering_error ( string , content = content , log = pdf . log ) if pdf . warn for var in pdf . log if var [ number ] = = xhtml2pdf . default . pml_warning logger_x2p . warning ( string , var [ number ] , var [ number ] , var [ number ] ) return dest . getvalue ( )	1
Q_88	convert html to pdf	C_88_4	def to_pdf ( self ) html = safe_unicode ( self . template ( ) ) . encode ( string ) pdf_data = create_pdf ( html ) return pdf_data	1
Q_88	convert html to pdf	C_88_5	def pdf_from_post ( self ) string string string html = self . request . form . get ( string ) style = self . request . form . get ( string ) reporthtml = string reporthtml = reporthtml . format ( style , html ) reporthtml = safe_unicode ( reporthtml ) . encode ( string ) pdf_fn = tempfile . mktemp ( suffix = string ) pdf_file = create_pdf ( htmlreport = reporthtml , outfile = pdf_fn ) return pdf_file	1
Q_88	convert html to pdf	C_88_6	def html_to_pdf ( tmp_filenames , output_directory , lang_options ) input_html = output_directory + string + tmp_filenames [ number ] wkthml_cmd = [ string ]	1
Q_88	convert html to pdf	C_88_7	def pdf_from_post ( self ) string string string html = self . request . form . get ( string ) style = self . request . form . get ( string ) reporthtml = string reporthtml = reporthtml . format ( style , html ) reporthtml = safe_unicode ( reporthtml ) . encode ( string ) pdf_fn = tempfile . mktemp ( suffix = string ) pdf_file = create_pdf ( htmlreport = reporthtml , outfile = pdf_fn ) return pdf_file	1
Q_88	convert html to pdf	C_88_8	"def add_to_writer ( self , writer pdf_file_writer , start_recto bool = true ) _ > none string string string if self . is_html pdf = get_pdf_from_html ( html = self . html , header_html = self . header_html , footer_html = self . footer_html , wkhtmltopdf_filename = self . wkhtmltopdf_filename , wkhtmltopdf_options = self . wkhtmltopdf_options ) append_memory_pdf_to_writer ( pdf , writer , start_recto = start_recto ) elif self . is_filename if start_recto and writer . get_num_pages ( ) number = number writer . add_blank_page ( ) writer . append_pages_from_reader ( pdf_file_reader ( open ( self . filename , string ) ) ) else raise assertion_error ( string t get here "" )"	1
Q_88	convert html to pdf	C_88_9	def _single_page_pdf ( page ) string string string pdf = pdf . new ( ) pdf . pages . append ( page ) bio = bytes_io ( ) pdf . save ( bio ) bio . seek ( number ) return bio . read ( )	1
Q_88	convert html to pdf	C_88_10	def to_pdf ( self , out_file_name , image_file_name = none , show_boundingboxes = false , fontname = string , invisible_text = false , interword_spaces = false , ) string string string	1
Q_88	convert html to pdf	C_88_11	def make_pdf_from_html (	1
Q_88	convert html to pdf	C_88_12	def to_pdf ( self ) html = safe_unicode ( self . template ( ) ) . encode ( string ) pdf_data = create_pdf ( html ) return pdf_data	1
Q_88	convert html to pdf	C_88_13	def render_pdf ( self , * args , * * kwargs ) string string string html = self . render_html ( * args , * * kwargs ) options = self . get_pdfkit_options ( ) if string in self . request . get and settings . debug options [ string ] = number kwargs = { } wkhtmltopdf_bin = os . environ . get ( string ) if wkhtmltopdf_bin kwargs [ string ] = pdfkit . configuration ( wkhtmltopdf = wkhtmltopdf_bin ) pdf = pdfkit . from_string ( html , false , options , * * kwargs ) return pdf	1
Q_88	convert html to pdf	C_88_14	async def generate ( request ) start = time ( ) config = { } for var , var in request . headers . items ( ) if var . startswith ( string ) or var . startswith ( string ) config [ var [ number ] . lower ( ) ] = var . lower ( ) data = await request . read ( ) if not data logger . info ( string ) raise web . http_bad_request ( text = string ) try pdf_content = await app [ string ] . generate_pdf ( data . decode ( ) , * * config ) except runtime_error as e logger . info ( string , time ( ) _ start , config ) return web . response ( text = str ( e ) + string , status = number ) else logger . info ( string , time ( ) _ start , len ( data ) , len ( pdf_content ) ) return web . response ( body = pdf_content , content_type = string )	1
Q_88	convert html to pdf	C_88_15	def pdf_from_post ( self ) string string string html = self . request . form . get ( string ) style = self . request . form . get ( string ) reporthtml = string reporthtml = reporthtml . format ( style , html ) reporthtml = safe_unicode ( reporthtml ) . encode ( string ) pdf_fn = tempfile . mktemp ( suffix = string ) pdf_file = create_pdf ( htmlreport = reporthtml , outfile = pdf_fn ) return pdf_file	1
Q_88	convert html to pdf	C_88_16	def pdf_from_post ( self ) string string string html = self . request . form . get ( string ) style = self . request . form . get ( string ) reporthtml = string reporthtml = reporthtml . format ( style , html ) reporthtml = safe_unicode ( reporthtml ) . encode ( string ) pdf_fn = tempfile . mktemp ( suffix = string ) pdf_file = create_pdf ( htmlreport = reporthtml , outfile = pdf_fn ) return pdf_file	1
Q_88	convert html to pdf	C_88_17	def to_pdf ( self , out_file_name , image_file_name = none , show_boundingboxes = false , fontname = string , invisible_text = false , interword_spaces = false , ) string string string	1
Q_88	convert html to pdf	C_88_18	async def generate ( request ) start = time ( ) config = { } for var , var in request . headers . items ( ) if var . startswith ( string ) or var . startswith ( string ) config [ var [ number ] . lower ( ) ] = var . lower ( ) data = await request . read ( ) if not data logger . info ( string ) raise web . http_bad_request ( text = string ) try pdf_content = await app [ string ] . generate_pdf ( data . decode ( ) , * * config ) except runtime_error as e logger . info ( string , time ( ) _ start , config ) return web . response ( text = str ( e ) + string , status = number ) else logger . info ( string , time ( ) _ start , len ( data ) , len ( pdf_content ) ) return web . response ( body = pdf_content , content_type = string )	1
Q_88	convert html to pdf	C_88_19	def render_pdf ( self , * args , * * kwargs ) string string string html = self . render_html ( * args , * * kwargs ) options = self . get_pdfkit_options ( ) if string in self . request . get and settings . debug options [ string ] = number kwargs = { } wkhtmltopdf_bin = os . environ . get ( string ) if wkhtmltopdf_bin kwargs [ string ] = pdfkit . configuration ( wkhtmltopdf = wkhtmltopdf_bin ) pdf = pdfkit . from_string ( html , false , options , * * kwargs ) return pdf	1
Q_88	convert html to pdf	C_88_20	"def add_to_writer ( self , writer pdf_file_writer , start_recto bool = true ) _ > none string string string if self . is_html pdf = get_pdf_from_html ( html = self . html , header_html = self . header_html , footer_html = self . footer_html , wkhtmltopdf_filename = self . wkhtmltopdf_filename , wkhtmltopdf_options = self . wkhtmltopdf_options ) append_memory_pdf_to_writer ( pdf , writer , start_recto = start_recto ) elif self . is_filename if start_recto and writer . get_num_pages ( ) number = number writer . add_blank_page ( ) writer . append_pages_from_reader ( pdf_file_reader ( open ( self . filename , string ) ) ) else raise assertion_error ( string t get here "" )"	1
Q_88	convert html to pdf	C_88_21	"def add_to_writer ( self , writer pdf_file_writer , start_recto bool = true ) _ > none string string string if self . is_html pdf = get_pdf_from_html ( html = self . html , header_html = self . header_html , footer_html = self . footer_html , wkhtmltopdf_filename = self . wkhtmltopdf_filename , wkhtmltopdf_options = self . wkhtmltopdf_options ) append_memory_pdf_to_writer ( pdf , writer , start_recto = start_recto ) elif self . is_filename if start_recto and writer . get_num_pages ( ) number = number writer . add_blank_page ( ) writer . append_pages_from_reader ( pdf_file_reader ( open ( self . filename , string ) ) ) else raise assertion_error ( string t get here "" )"	1
Q_88	convert html to pdf	C_88_22	def _single_page_pdf ( page ) string string string pdf = pdf . new ( ) pdf . pages . append ( page ) bio = bytes_io ( ) pdf . save ( bio ) bio . seek ( number ) return bio . read ( )	1
Q_88	convert html to pdf	C_88_23	def _single_page_pdf ( page ) string string string pdf = pdf . new ( ) pdf . pages . append ( page ) bio = bytes_io ( ) pdf . save ( bio ) bio . seek ( number ) return bio . read ( )	1
Q_89	convert decimal to hex	C_89_0	def hexadecimal ( token ) string string string token = string . join ( [ var for var in token if var . isalnum ( ) ] ) if len ( token ) number = number raise value_error ( string ) data = string for i in compat . xrange ( number , len ( token ) , number ) x = token [ i i + number ] d = int ( x , number ) s = struct . pack ( string , d ) data + = s return data	1
Q_89	convert decimal to hex	C_89_1	def int_to_hex ( i ) string string bc number number e string string s = hex ( i ) [ number ] . upper ( ) if six . py2 is true and isinstance ( i , long )	1
Q_89	convert decimal to hex	C_89_2	def _hexvalue_to_rgb ( hexvalue ) string string string r = int ( hexvalue [ number number ] , number ) g = int ( hexvalue [ number number ] , number ) b = int ( hexvalue [ number number ] , number ) return ( r , g , b )	1
Q_89	convert decimal to hex	C_89_3	def dec2str ( n ) string string string s = hex ( int ( n ) ) [ number ] . rstrip ( string ) if len ( s ) number = number s = string + s return hex2str ( s )	1
Q_89	convert decimal to hex	C_89_4	def int_to_hex ( i ) string string bc number number e string string s = hex ( i ) [ number ] . upper ( ) if six . py2 is true and isinstance ( i , long )	1
Q_89	convert decimal to hex	C_89_5	def calculate_hex ( hex_string ) string string string hex_conv = hex_string . split ( string ) converted_hex = ( int ( hex_conv [ number ] , number ) + int ( hex_conv [ number ] , number ) ) / number return converted_hex	1
Q_89	convert decimal to hex	C_89_6	def t_bin ( self , t ) r string	1
Q_89	convert decimal to hex	C_89_7	def intto_der ( a ) string string string o = dechex ( a , number ) if int ( o [ number ] , number ) > number o = string + o olen = dechex ( len ( o ) / / number , number ) return string + olen + o	1
Q_89	convert decimal to hex	C_89_8	def dec2str ( n ) string string string s = hex ( int ( n ) ) [ number ] . rstrip ( string ) if len ( s ) number = number s = string + s return hex2str ( s )	1
Q_89	convert decimal to hex	C_89_9	def intto_der ( a ) string string string o = dechex ( a , number ) if int ( o [ number ] , number ) > number o = string + o olen = dechex ( len ( o ) / / number , number ) return string + olen + o	1
Q_89	convert decimal to hex	C_89_10	def hex2dec ( s ) string string string if not isinstance ( s , str ) s = str ( s ) return int ( s . upper ( ) , number )	1
Q_89	convert decimal to hex	C_89_11	def convert_to_hex_string ( string ) hex_str = string for var in string hex_tmp = hex ( ord ( var ) ) [ number ] if len ( hex_tmp ) = = number hex_tmp = string + hex_tmp hex_str + = hex_tmp return hex_str . upper ( )	1
Q_89	convert decimal to hex	C_89_12	def hex2dec ( s ) string string string if not isinstance ( s , str ) s = str ( s ) return int ( s . upper ( ) , number )	1
Q_89	convert decimal to hex	C_89_13	def convert_to_hex_string ( string ) hex_str = string for var in string hex_tmp = hex ( ord ( var ) ) [ number ] if len ( hex_tmp ) = = number hex_tmp = string + hex_tmp hex_str + = hex_tmp return hex_str . upper ( )	1
Q_89	convert decimal to hex	C_89_14	def _hexvalue_to_rgb ( hexvalue ) string string string r = int ( hexvalue [ number number ] , number ) g = int ( hexvalue [ number number ] , number ) b = int ( hexvalue [ number number ] , number ) return ( r , g , b )	0
Q_89	convert decimal to hex	C_89_15	def normalize_hex ( hex_value ) string string	0
Q_89	convert decimal to hex	C_89_16	def t_bin ( self , t ) r string	0
Q_89	convert decimal to hex	C_89_17	def hexadecimal ( token ) string string string token = string . join ( [ var for var in token if var . isalnum ( ) ] ) if len ( token ) number = number raise value_error ( string ) data = string for i in compat . xrange ( number , len ( token ) , number ) x = token [ i i + number ] d = int ( x , number ) s = struct . pack ( string , d ) data + = s return data	0
Q_89	convert decimal to hex	C_89_18	def normalize_hex ( hex_value ) string string	0
Q_89	convert decimal to hex	C_89_19	def calculate_hex ( hex_string ) string string string hex_conv = hex_string . split ( string ) converted_hex = ( int ( hex_conv [ number ] , number ) + int ( hex_conv [ number ] , number ) ) / number return converted_hex	0
Q_89	convert decimal to hex	C_89_20	def normalize_hex ( hex_value ) string string	0
Q_90	convert a utc time to epoch	C_90_0	def utc_epoch ( ) string string string	1
Q_90	convert a utc time to epoch	C_90_1	def to_epoch ( t ) string string string if isinstance ( t , str ) if string not in t t = t + string t = parser . parse ( t ) elif t . tzinfo is none or t . tzinfo . utcoffset ( t ) is none t = t . replace ( tzinfo = pytz . timezone ( string ) ) t0 = datetime . datetime ( number , number , number , number , number , number , number , pytz . timezone ( string ) ) delta = t _ t0 return int ( delta . total_seconds ( ) )	1
Q_90	convert a utc time to epoch	C_90_2	def _dt_to_epoch ( self , dt ) string string string if py2	1
Q_90	convert a utc time to epoch	C_90_3	def _dt_to_epoch ( self , dt ) string string string if py2	1
Q_90	convert a utc time to epoch	C_90_4	def epoch ( self ) string string us / pacific string string epoch_sec = pytz . utc . localize ( datetime . utcfromtimestamp ( number ) ) now_sec = pytz . utc . normalize ( self . _dt ) delta_sec = now_sec _ epoch_sec return get_total_second ( delta_sec )	1
Q_90	convert a utc time to epoch	C_90_5	def get_time_array ( self , datetime_simulation_start = none , simulation_time_step_seconds = none , return_datetime = false , time_index_array = none ) string string / path / to / qout . nc string / path / to / qout . nc string string	1
Q_90	convert a utc time to epoch	C_90_6	def _datetime_to_epoch ( self , date_time ) string string string date_time_utc = none if date_time . tzinfo is none date_time_utc = date_time . replace ( tzinfo = pytz . utc ) else date_time_utc = date_time . astimezone ( pytz . utc ) epoch_utc = datetime . datetime . utcfromtimestamp ( number ) . replace ( tzinfo = pytz . utc ) return ( date_time_utc _ epoch_utc ) . total_seconds ( )	1
Q_90	convert a utc time to epoch	C_90_7	def _dt_to_epoch ( self , dt ) string string string if py2	1
Q_90	convert a utc time to epoch	C_90_8	def epoch ( self ) string string us / pacific string string epoch_sec = pytz . utc . localize ( datetime . utcfromtimestamp ( number ) ) now_sec = pytz . utc . normalize ( self . _dt ) delta_sec = now_sec _ epoch_sec return get_total_second ( delta_sec )	1
Q_90	convert a utc time to epoch	C_90_9	def epoch ( self ) string string us / pacific string string epoch_sec = pytz . utc . localize ( datetime . utcfromtimestamp ( number ) ) now_sec = pytz . utc . normalize ( self . _dt ) delta_sec = now_sec _ epoch_sec return get_total_second ( delta_sec )	1
Q_90	convert a utc time to epoch	C_90_10	def _datetime_to_epoch ( self , date_time ) string string string date_time_utc = none if date_time . tzinfo is none date_time_utc = date_time . replace ( tzinfo = pytz . utc ) else date_time_utc = date_time . astimezone ( pytz . utc ) epoch_utc = datetime . datetime . utcfromtimestamp ( number ) . replace ( tzinfo = pytz . utc ) return ( date_time_utc _ epoch_utc ) . total_seconds ( )	1
Q_90	convert a utc time to epoch	C_90_11	def from_epoch ( cls , epoch_time ) string string string	1
Q_90	convert a utc time to epoch	C_90_12	def _dt_to_epoch ( self , dt ) string string string if py2	1
Q_90	convert a utc time to epoch	C_90_13	def _datetime_to_utc_int ( date ) string string string if date is none return none	1
Q_90	convert a utc time to epoch	C_90_14	def from_epoch ( cls , epoch_time ) string string string	1
Q_90	convert a utc time to epoch	C_90_15	def to_epoch ( t ) string string string if isinstance ( t , str ) if string not in t t = t + string t = parser . parse ( t ) elif t . tzinfo is none or t . tzinfo . utcoffset ( t ) is none t = t . replace ( tzinfo = pytz . timezone ( string ) ) t0 = datetime . datetime ( number , number , number , number , number , number , number , pytz . timezone ( string ) ) delta = t _ t0 return int ( delta . total_seconds ( ) )	1
Q_90	convert a utc time to epoch	C_90_16	def _dt_to_epoch ( self , dt ) string string string if py2	1
Q_90	convert a utc time to epoch	C_90_17	def epoch_to_human_time ( epoch_time ) string string string if isinstance ( epoch_time , int ) try d = datetime . datetime . fromtimestamp ( epoch_time / number ) return d . strftime ( string ) except value_error return none	1
Q_90	convert a utc time to epoch	C_90_18	def _datetime_to_utc_int ( date ) string string string if date is none return none	1
Q_90	convert a utc time to epoch	C_90_19	def epoch_to_human_time ( epoch_time ) string string string if isinstance ( epoch_time , int ) try d = datetime . datetime . fromtimestamp ( epoch_time / number ) return d . strftime ( string ) except value_error return none	1
Q_90	convert a utc time to epoch	C_90_20	def utc_epoch ( ) string string string	1
Q_90	convert a utc time to epoch	C_90_21	def epoch_to_human_time ( epoch_time ) string string string if isinstance ( epoch_time , int ) try d = datetime . datetime . fromtimestamp ( epoch_time / number ) return d . strftime ( string ) except value_error return none	0
Q_91	convert a date string into yyyymmdd	C_91_0	def date_string_to_date ( p_date ) string string string result = none if p_date parsed_date = re . match ( r string , p_date ) if parsed_date result = date ( int ( parsed_date . group ( number ) ) ,	1
Q_91	convert a date string into yyyymmdd	C_91_1	def day_to_month ( timeperiod ) string string string t = datetime . strptime ( timeperiod , synergy_daily_pattern ) return t . strftime ( synergy_monthly_pattern )	1
Q_91	convert a date string into yyyymmdd	C_91_2	def string_to_date ( input ) string string string	1
Q_91	convert a date string into yyyymmdd	C_91_3	def date_convert ( string , match , ymd = none , mdy = none , dmy = none , d_m_y = none , hms = none , am = none , tz = none , mm = none , dd = none ) string string string groups = match . groups ( ) time_only = false if mm and dd y = datetime . today ( ) . year m = groups [ mm ] d = groups [ dd ] elif ymd is not none y , m , d = re . split ( r string , groups [ ymd ] ) elif mdy is not none m , d , y = re . split ( r string , groups [ mdy ] ) elif dmy is not none d , m , y = re . split ( r string , groups [ dmy ] ) elif d_m_y is not none d , m , y = d_m_y d = groups [ d ] m = groups [ m ] y = groups [ y ] else time_only = true h = m = s = u = number if hms is not none and groups [ hms ] t = groups [ hms ] . split ( string ) if len ( t ) = = number h , m = t else h , m , s = t if string in s s , u = s . split ( string ) u = int ( float ( string + u ) * number ) s = int ( s ) h = int ( h ) m = int ( m ) if am is not none am = groups [ am ] if am am = am . strip ( ) if am = = string and h = = number	1
Q_91	convert a date string into yyyymmdd	C_91_4	def date_from_ldap_timestamp ( timestamp ) string string string	1
Q_91	convert a date string into yyyymmdd	C_91_5	def convert ( self , auto = none , datetime = none , timezone = none , timestamp = none , yyyymmdd = none , yyyymmddhhiiss = none , ms = false ) return self . helper . datetime . convert ( auto = auto , datetime = datetime , timezone = timezone , timestamp = timestamp , yyyymmdd = yyyymmdd , yyyymmddhhiiss = yyyymmddhhiiss , ms = ms )	1
Q_91	convert a date string into yyyymmdd	C_91_6	def date_from_ldap_timestamp ( timestamp ) string string string	1
Q_91	convert a date string into yyyymmdd	C_91_7	def string_to_date ( input ) string string string	1
Q_91	convert a date string into yyyymmdd	C_91_8	def disjoin_calendars ( self , cutoff ) string string string def truncate_period ( service_period , start , end ) string string string service_period . start_date = max ( service_period . start_date , start ) service_period . end_date = min ( service_period . end_date , end ) dates_to_delete = [ ] for var in service_period . date_exceptions if ( var < start ) or ( var > end ) dates_to_delete . append ( var ) for var in dates_to_delete del service_period . date_exceptions [ var ]	1
Q_91	convert a date string into yyyymmdd	C_91_9	def day_to_month ( timeperiod ) string string string t = datetime . strptime ( timeperiod , synergy_daily_pattern ) return t . strftime ( synergy_monthly_pattern )	1
Q_91	convert a date string into yyyymmdd	C_91_10	def date_string_to_date ( p_date ) string string string result = none if p_date parsed_date = re . match ( r string , p_date ) if parsed_date result = date ( int ( parsed_date . group ( number ) ) ,	1
Q_91	convert a date string into yyyymmdd	C_91_11	def day_to_month ( timeperiod ) string string string t = datetime . strptime ( timeperiod , synergy_daily_pattern ) return t . strftime ( synergy_monthly_pattern )	1
Q_91	convert a date string into yyyymmdd	C_91_12	def to_date ( self ) string string string y , m , d = self . to_ymd ( ) return date ( y , m , d )	0
Q_91	convert a date string into yyyymmdd	C_91_13	def convert ( self , auto = none , datetime = none , timezone = none , timestamp = none , yyyymmdd = none , yyyymmddhhiiss = none , ms = false ) return self . helper . datetime . convert ( auto = auto , datetime = datetime , timezone = timezone , timestamp = timestamp , yyyymmdd = yyyymmdd , yyyymmddhhiiss = yyyymmddhhiiss , ms = ms )	0
Q_91	convert a date string into yyyymmdd	C_91_14	def disjoin_calendars ( self , cutoff ) string string string def truncate_period ( service_period , start , end ) string string string service_period . start_date = max ( service_period . start_date , start ) service_period . end_date = min ( service_period . end_date , end ) dates_to_delete = [ ] for var in service_period . date_exceptions if ( var < start ) or ( var > end ) dates_to_delete . append ( var ) for var in dates_to_delete del service_period . date_exceptions [ var ]	0
Q_91	convert a date string into yyyymmdd	C_91_15	def disjoin_calendars ( self , cutoff ) string string string def truncate_period ( service_period , start , end ) string string string service_period . start_date = max ( service_period . start_date , start ) service_period . end_date = min ( service_period . end_date , end ) dates_to_delete = [ ] for var in service_period . date_exceptions if ( var < start ) or ( var > end ) dates_to_delete . append ( var ) for var in dates_to_delete del service_period . date_exceptions [ var ]	0
Q_91	convert a date string into yyyymmdd	C_91_16	def disjoin_calendars ( self , cutoff ) string string string def truncate_period ( service_period , start , end ) string string string service_period . start_date = max ( service_period . start_date , start ) service_period . end_date = min ( service_period . end_date , end ) dates_to_delete = [ ] for var in service_period . date_exceptions if ( var < start ) or ( var > end ) dates_to_delete . append ( var ) for var in dates_to_delete del service_period . date_exceptions [ var ]	0
Q_92	connect to sql	C_92_0	def connect ( self ) self . close ( ) self . _connect = pymysql . connect ( * * self . _db_options ) self . _connect . autocommit ( true )	1
Q_92	connect to sql	C_92_1	def _mysql_connect ( self , connect_using_database_name = true ) try conn = self . _mysql_driver . connect ( host = self . _mysql_host , port = self . _mysql_port , user = self . _mysql_user , passwd = self . _mysql_passwd ) conn . set_character_set ( self . _mysql_encoding ) if connect_using_database_name conn . select_db ( self . _mysql_db ) return conn except exception as e raise exception ( string e )	1
Q_92	connect to sql	C_92_2	def connect ( self , db_uri , debug = false ) string string string kwargs = { string debug , string true }	1
Q_92	connect to sql	C_92_3	def _connect ( self ) string string string if self . _conn_params self . _conn = my_sq_ldb . connect ( * * self . _conn_params ) else self . _conn = my_sq_ldb . connect ( string )	1
Q_92	connect to sql	C_92_4	def _connect ( self ) if mysql is none raise improperly_configured ( string ) conn = mysql . connect ( db = self . database , * * self . connect_params ) return conn	1
Q_92	connect to sql	C_92_5	def _mysql_connect ( self , connect_using_database_name = true ) try conn = self . _mysql_driver . connect ( host = self . _mysql_host , port = self . _mysql_port , user = self . _mysql_user , passwd = self . _mysql_passwd ) conn . set_character_set ( self . _mysql_encoding ) if connect_using_database_name conn . select_db ( self . _mysql_db ) return conn except exception as e raise exception ( string e )	1
Q_92	connect to sql	C_92_6	def _connect ( self ) if mysql_connector is none raise improperly_configured ( string ) return mysql_connector . connect ( db = self . database , * * self . connect_params )	1
Q_92	connect to sql	C_92_7	def _connect ( self ) string string string if self . _conn_params self . _conn = my_sq_ldb . connect ( * * self . _conn_params ) else self . _conn = my_sq_ldb . connect ( string )	1
Q_92	connect to sql	C_92_8	def _connect ( self , engine str = none , interface str = none , host str = none , port int = none , database str = none , driver str = none , dsn str = none , odbc_connection_string str = none , user str = none , password str = none , autocommit bool = true , charset str = string , use_unicode bool = true ) _ > bool	1
Q_92	connect to sql	C_92_9	def connect ( self ) future = super ( record_query_connection , self ) . connect ( ) origin_query = self . _connection . query def query ( sql , unbuffered = false ) self . _last_query_sql = sql return origin_query ( sql , unbuffered ) self . _connection . query = query return future	1
Q_92	connect to sql	C_92_10	def execute ( self , sql , args = ( ) ) if isinstance ( sql , ( list , tuple ) ) sql = string . join ( sql ) with sqlite3 . connect ( self . path ) as con return con . execute ( sql , args )	1
Q_92	connect to sql	C_92_11	def _connect ( self ) if mysql is none raise improperly_configured ( string ) conn = mysql . connect ( db = self . database , * * self . connect_params ) return conn	1
Q_92	connect to sql	C_92_12	def _connect ( self , engine str = none , interface str = none , host str = none , port int = none , database str = none , driver str = none , dsn str = none , odbc_connection_string str = none , user str = none , password str = none , autocommit bool = true , charset str = string , use_unicode bool = true ) _ > bool	1
Q_92	connect to sql	C_92_13	def execute ( self , sql , args = ( ) ) if isinstance ( sql , ( list , tuple ) ) sql = string . join ( sql ) with sqlite3 . connect ( self . path ) as con return con . execute ( sql , args )	1
Q_92	connect to sql	C_92_14	def connect ( self ) future = super ( record_query_connection , self ) . connect ( ) origin_query = self . _connection . query def query ( sql , unbuffered = false ) self . _last_query_sql = sql return origin_query ( sql , unbuffered ) self . _connection . query = query return future	1
Q_92	connect to sql	C_92_15	def sqlalchemy_mysql_trace ( request ) try engine = sqlalchemy . create_engine ( string . format ( string , mysql_password , db_host ) ) conn = engine . connect ( ) query = string result_set = conn . execute ( query ) result = [ ] for var in result_set result . append ( var ) return http_response ( str ( result ) ) except exception msg = string return http_response ( msg , status = number )	1
Q_92	connect to sql	C_92_16	def _connect ( self ) if mysql_connector is none raise improperly_configured ( string ) return mysql_connector . connect ( db = self . database , * * self . connect_params )	1
Q_92	connect to sql	C_92_17	def connect ( self ) future = super ( record_query_connection , self ) . connect ( ) origin_query = self . _connection . query def query ( sql , unbuffered = false ) self . _last_query_sql = sql return origin_query ( sql , unbuffered ) self . _connection . query = query return future	1
Q_92	connect to sql	C_92_18	def _connect ( self , engine str = none , interface str = none , host str = none , port int = none , database str = none , driver str = none , dsn str = none , odbc_connection_string str = none , user str = none , password str = none , autocommit bool = true , charset str = string , use_unicode bool = true ) _ > bool	1
Q_92	connect to sql	C_92_19	def sqlalchemy_mysql_trace ( request ) try engine = sqlalchemy . create_engine ( string . format ( string , mysql_password , db_host ) ) conn = engine . connect ( ) query = string result_set = conn . execute ( query ) result = [ ] for var in result_set result . append ( var ) return http_response ( str ( result ) ) except exception msg = string return http_response ( msg , status = number )	1
Q_92	connect to sql	C_92_20	def execute ( self , sql , args = ( ) ) if isinstance ( sql , ( list , tuple ) ) sql = string . join ( sql ) with sqlite3 . connect ( self . path ) as con return con . execute ( sql , args )	1
Q_92	connect to sql	C_92_21	def connect ( self ) self . close ( ) self . _connect = pymysql . connect ( * * self . _db_options ) self . _connect . autocommit ( true )	1
Q_92	connect to sql	C_92_22	def connect ( self , db_uri , debug = false ) string string string kwargs = { string debug , string true }	1
Q_93	confusion matrix	C_93_0	def from_existing ( cls , confusion , * args , * * kwargs ) string string true string pred string _binary_sensitivity string _binary_sensitivity string string	1
Q_93	confusion matrix	C_93_1	def confusion_matrix ( self ) string string string return plot . confusion_matrix ( self . y_true , self . y_pred , self . target_names , ax = _gen_ax ( ) )	1
Q_93	confusion matrix	C_93_2	def confusion_matrix ( self ) string string string confusion_matrix = self . pixel_classification_sum . astype ( np . float ) confusion_matrix = np . divide ( confusion_matrix . t , self . pixel_truth_sum . t ) . t return confusion_matrix * number . number	1
Q_93	confusion matrix	C_93_3	def plot_confusion_reports ( y , y_hat , class_names = none ) if class_names is none class_names = list ( set ( y ) . union ( set ( y_hat ) ) )	1
Q_93	confusion matrix	C_93_4	def confusion_matrix ( actual = [ ] , pred = [ ] ) idx = { string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number } matrix = [ [ number for var in range ( number ) ] for j in range ( number ) ] for var in range ( number , len ( actual ) ) matrix [ idx [ actual [ var ] ] ] [ idx [ pred [ var ] ] ] + = number return matrix	1
Q_93	confusion matrix	C_93_5	def confusion_matrix ( self ) string string string confusion_matrix = self . pixel_classification_sum . astype ( np . float ) confusion_matrix = np . divide ( confusion_matrix . t , self . pixel_truth_sum . t ) . t return confusion_matrix * number . number	1
Q_93	confusion matrix	C_93_6	def make_diagonal_povm ( pi_basis , confusion_rate_matrix ) string string string confusion_rate_matrix = np . asarray ( confusion_rate_matrix ) if not np . allclose ( confusion_rate_matrix . sum ( axis = number ) , np . ones ( confusion_rate_matrix . shape [ number ] ) ) raise crm_unnormalized_error ( string . format ( confusion_rate_matrix ) ) if not ( confusion_rate_matrix > = number ) . all ( ) or not ( confusion_rate_matrix < = number ) . all ( ) raise crm_value_error ( string string . format ( confusion_rate_matrix ) ) ops = [ sum ( ( pi_j * pjk for ( pi_j , pjk ) in izip ( pi_basis . ops , var ) ) , number ) for var in confusion_rate_matrix ] return diagonal_povm ( pi_basis = pi_basis , confusion_rate_matrix = confusion_rate_matrix , ops = ops )	1
Q_93	confusion matrix	C_93_7	def from_existing ( cls , confusion , * args , * * kwargs ) string string true string pred string _binary_sensitivity string _binary_sensitivity string string	1
Q_93	confusion matrix	C_93_8	def confusion_matrix ( actual = [ ] , pred = [ ] ) idx = { string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number } matrix = [ [ number for var in range ( number ) ] for j in range ( number ) ] for var in range ( number , len ( actual ) ) matrix [ idx [ actual [ var ] ] ] [ idx [ pred [ var ] ] ] + = number return matrix	1
Q_93	confusion matrix	C_93_9	def make_diagonal_povm ( pi_basis , confusion_rate_matrix ) string string string confusion_rate_matrix = np . asarray ( confusion_rate_matrix ) if not np . allclose ( confusion_rate_matrix . sum ( axis = number ) , np . ones ( confusion_rate_matrix . shape [ number ] ) ) raise crm_unnormalized_error ( string . format ( confusion_rate_matrix ) ) if not ( confusion_rate_matrix > = number ) . all ( ) or not ( confusion_rate_matrix < = number ) . all ( ) raise crm_value_error ( string string . format ( confusion_rate_matrix ) ) ops = [ sum ( ( pi_j * pjk for ( pi_j , pjk ) in izip ( pi_basis . ops , var ) ) , number ) for var in confusion_rate_matrix ] return diagonal_povm ( pi_basis = pi_basis , confusion_rate_matrix = confusion_rate_matrix , ops = ops )	1
Q_93	confusion matrix	C_93_10	def plot_confusion_matrix ( cm , classes , normalize = false , title = string , cmap = plt . cm . blues ) string string string if normalize cm = cm . astype ( string ) / cm . sum ( axis = number ) [ , np . newaxis ] print ( string ) else print ( string ) print ( cm ) plt . imshow ( cm , interpolation = string , cmap = cmap ) plt . title ( title ) plt . colorbar ( ) tick_marks = np . arange ( len ( classes ) ) plt . xticks ( tick_marks , classes , rotation = number ) plt . yticks ( tick_marks , classes ) fmt = string if normalize else string thresh = cm . max ( ) / number . for var , var in itertools . product ( range ( cm . shape [ number ] ) , range ( cm . shape [ number ] ) ) plt . text ( var , var , format ( cm [ var , var ] , fmt ) , horizontalalignment = string , color = string if cm [ var , var ] > thresh else string ) plt . tight_layout ( ) plt . ylabel ( string ) plt . xlabel ( string )	1
Q_93	confusion matrix	C_93_11	def confusion_matrix ( self ) string string string return plot . confusion_matrix ( self . y_true , self . y_pred , self . target_names , ax = _gen_ax ( ) )	1
Q_93	confusion matrix	C_93_12	def from_existing ( cls , confusion , * args , * * kwargs ) string string true string pred string _binary_sensitivity string _binary_sensitivity string string	1
Q_93	confusion matrix	C_93_13	def confusion_matrix ( actual = [ ] , pred = [ ] ) idx = { string number , string number , string number , string number , string number , string number , string number , string number , string number , string number , string number } matrix = [ [ number for var in range ( number ) ] for j in range ( number ) ] for var in range ( number , len ( actual ) ) matrix [ idx [ actual [ var ] ] ] [ idx [ pred [ var ] ] ] + = number return matrix	1
Q_93	confusion matrix	C_93_14	def from_existing ( cls , confusion , * args , * * kwargs ) string string true string pred string _binary_sensitivity string _binary_sensitivity string string	1
Q_93	confusion matrix	C_93_15	"def confusion_matrix ( self , data ) string string s default prediction threshold for a dataset . param h2_o_frame data the frame with the prediction results for which the confusion matrix should be extracted . string string post / number / predictions / models / s / frames / s string model_metrics string cm string table "" ]"	1
Q_93	confusion matrix	C_93_16	"def confusion_matrix ( self , data ) string string s default prediction threshold for a dataset . param h2_o_frame data the frame with the prediction results for which the confusion matrix should be extracted . string string post / number / predictions / models / s / frames / s string model_metrics string cm string table "" ]"	1
Q_93	confusion matrix	C_93_17	def plot_confusion_matrix ( cm , classes , normalize = false , title = string , cmap = plt . cm . blues ) string string string if normalize cm = cm . astype ( string ) / cm . sum ( axis = number ) [ , np . newaxis ] print ( string ) else print ( string ) print ( cm ) plt . imshow ( cm , interpolation = string , cmap = cmap ) plt . title ( title ) plt . colorbar ( ) tick_marks = np . arange ( len ( classes ) ) plt . xticks ( tick_marks , classes , rotation = number ) plt . yticks ( tick_marks , classes ) fmt = string if normalize else string thresh = cm . max ( ) / number . for var , var in itertools . product ( range ( cm . shape [ number ] ) , range ( cm . shape [ number ] ) ) plt . text ( var , var , format ( cm [ var , var ] , fmt ) , horizontalalignment = string , color = string if cm [ var , var ] > thresh else string ) plt . tight_layout ( ) plt . ylabel ( string ) plt . xlabel ( string )	1
Q_93	confusion matrix	C_93_18	def _get_accuracy ( self ) n = self . confusion . shape [ number ] assert n = = self . confusion . shape [ number ] , string return self . confusion [ range ( n ) , range ( n ) ] . sum ( ) , self . confusion . sum ( )	1
Q_93	confusion matrix	C_93_19	def _get_accuracy ( self ) n = self . confusion . shape [ number ] assert n = = self . confusion . shape [ number ] , string return self . confusion [ range ( n ) , range ( n ) ] . sum ( ) , self . confusion . sum ( )	1
Q_94	concatenate several file remove header line	C_94_0	def header_without_lines ( header , remove ) string string assembly string filter string pass string	1
Q_94	concatenate several file remove header line	C_94_1	def concatenate_aiml ( path = string , outfile = string ) string string string path = find_data_path ( path ) or path zf = zipfile . zip_file ( path ) for var in zf . namelist ( ) if not var . lower ( ) . endswith ( string ) continue with zf . open ( var ) as fin happyending = string for i , line in enumerate ( fin ) try line = line . decode ( string ) . strip ( ) except unicode_decode_error line = line . decode ( string ) . strip ( ) if line . lower ( ) . startswith ( string ) or line . lower ( ) . endswith ( string ) happyending = ( i , line ) break else pass if happyending = ( i , line ) print ( string < / aiml > string . format ( var , i , line ) )	1
Q_94	concatenate several file remove header line	C_94_2	def concatenate ( files , version = string , sync = true , add_samples_origin = false , * * kwargs ) string string _samples_origin string string if not files raise mdf_exception ( string ) callback = kwargs . get ( string , none ) if callback callback ( number , number ) mdf_nr = len ( files ) versions = [ ] if sync timestamps = [ ] for var in files if isinstance ( var , mdf ) timestamps . append ( var . header . start_time ) versions . append ( var . version ) else with open ( var , string ) as mdf mdf . seek ( number ) blk_id = mdf . read ( number ) if blk_id = = b string header = header_v3 versions . append ( string ) else versions . append ( string ) blk_id + = mdf . read ( number ) if blk_id = = b string header = header_v4 else raise mdf_exception ( f string { var } string ) header = header ( address = number , stream = mdf ) timestamps . append ( header . start_time ) try oldest = min ( timestamps ) except type_error timestamps = [ timestamp . astimezone ( timezone . utc ) for timestamp in timestamps ] oldest = min ( timestamps ) offsets = [ ( timestamp _ oldest ) . total_seconds ( ) for timestamp in timestamps ] offsets = [ offset if offset > number else number for offset in offsets ] else var = files [ number ] if isinstance ( var , mdf ) oldest = var . header . start_time versions . append ( var . version ) else with open ( var , string ) as mdf mdf . seek ( number ) blk_id = mdf . read ( number ) if blk_id = = b string versions . append ( string ) header = header_v3 else versions . append ( string ) blk_id + = mdf . read ( number ) if blk_id = = b string header = header_v4 else raise mdf_exception ( f string { var } string ) header = header ( address = number , stream = mdf ) oldest = header . start_time offsets = [ number for _ in files ] version = validate_version_argument ( version ) merged = mdf ( version = version , callback = callback ) merged . header . start_time = oldest encodings = [ ] included_channel_names = [ ] if add_samples_origin origin_conversion = { } for i , mdf in enumerate ( files ) origin_conversion [ f string ] = i if isinstance ( mdf , mdf ) origin_conversion [ f string ] = str ( mdf . name ) else origin_conversion [ f string ] = str ( mdf ) origin_conversion = from_dict ( origin_conversion ) for mdf_index , ( offset , mdf ) in enumerate ( zip ( offsets , files ) ) if not isinstance ( mdf , mdf ) mdf = mdf ( mdf ) try for can_id , info in mdf . can_logging_db . items ( ) if can_id not in merged . can_logging_db merged . can_logging_db [ can_id ] = { } merged . can_logging_db [ can_id ] . update ( info ) except attribute_error pass if mdf_index = = number last_timestamps = [ none for gp in mdf . groups ] groups_nr = len ( mdf . groups ) cg_nr = _ number for i , group in enumerate ( mdf . groups ) included_channels = mdf . _included_channels ( i ) if mdf_index = = number included_channel_names . append ( [ group . channels [ k ] . name for k in included_channels ] ) else names = [ group . channels [ k ] . name for k in included_channels ] if names = included_channel_names [ i ] if sorted ( names ) = sorted ( included_channel_names [ i ] ) raise mdf_exception ( f string ) else logger . warning ( f string string string ) included_channels = [ mdf . _validate_channel_selection ( name = name_ , group = i , ) [ number ] for name_ in included_channel_names [ i ] ] if included_channels cg_nr + = number else continue channels_nr = len ( group . channels ) y_axis = merge idx = np . searchsorted ( channel_count , channels_nr , side = string ) _ number if idx < number idx = number read_size = y_axis [ idx ] idx = number last_timestamp = last_timestamps [ i ] first_timestamp = none original_first_timestamp = none if read_size mdf . configure ( read_fragment_size = int ( read_size ) ) parents , dtypes = mdf . _prepare_record ( group ) data = mdf . _load_data ( group ) for fragment in data if dtypes . itemsize group . record = np . core . records . fromstring ( fragment [ number ] , dtype = dtypes ) else group . record = none if mdf_index = = number and idx = = number encodings_ = [ ] encodings . append ( encodings_ ) signals = [ ] for j in included_channels sig = mdf . get ( group = i , index = j , data = fragment , raw = true , ignore_invalidation_bits = true , copy_master = false , ) if version < string if sig . samples . dtype . kind = = string encodings_ . append ( sig . encoding ) strsig = mdf . get ( group = i , index = j , samples_only = true , ignore_invalidation_bits = true , ) [ number ] sig . samples = sig . samples . astype ( strsig . dtype ) del strsig if sig . encoding = string if sig . encoding = = string sig . samples = ( sig . samples . view ( np . uint16 ) . byteswap ( ) . view ( sig . samples . dtype ) ) sig . samples = encode ( decode ( sig . samples , string ) , string , ) else sig . samples = encode ( decode ( sig . samples , sig . encoding ) , string , ) else encodings_ . append ( none ) if not sig . samples . flags . writeable sig . samples = sig . samples . copy ( ) signals . append ( sig ) if signals and len ( signals [ number ] ) if offset > number timestamps = sig [ number ] . timestamps + offset for sig in signals sig . timestamps = timestamps last_timestamp = signals [ number ] . timestamps [ _ number ] first_timestamp = signals [ number ] . timestamps [ number ] original_first_timestamp = first_timestamp if add_samples_origin if signals _s = signals [ _ number ] signals . append ( signal ( samples = np . ones ( len ( _s ) , dtype = string ) * mdf_index , timestamps = _s . timestamps , conversion = origin_conversion , name = string , ) ) _s = none if signals merged . append ( signals , common_timebase = true ) try if group . channel_group . flags v4c . flag_cg_bus_event merged . groups [ _ number ] . channel_group . flags = group . channel_group . flags merged . groups [ _ number ] . channel_group . acq_name = group . channel_group . acq_name merged . groups [ _ number ] . channel_group . acq_source = group . channel_group . acq_source merged . groups [ _ number ] . channel_group . comment = group . channel_group . comment except attribute_error pass else break idx + = number else master = mdf . get_master ( i , fragment , copy_master = false ) _copied = false if len ( master ) if original_first_timestamp is none original_first_timestamp = master [ number ] if offset > number master = master + offset _copied = true if last_timestamp is none last_timestamp = master [ _ number ] else if last_timestamp > = master [ number ] if len ( master ) > = number delta = master [ number ] _ master [ number ] else delta = number . number number if _copied master _ = master [ number ] else master = master _ master [ number ] _copied = true master + = last_timestamp + delta last_timestamp = master [ _ number ] signals = [ ( master , none ) ] for k , j in enumerate ( included_channels ) sig = mdf . get ( group = i , index = j , data = fragment , raw = true , samples_only = true , ignore_invalidation_bits = true , ) signals . append ( sig ) if version < string encoding = encodings [ i ] [ k ] samples = sig [ number ] if encoding if encoding = string if encoding = = string samples = ( samples . view ( np . uint16 ) . byteswap ( ) . view ( samples . dtype ) ) samples = encode ( decode ( samples , string ) , string , ) else samples = encode ( decode ( samples , encoding ) , string ) sig . samples = samples if signals if add_samples_origin _s = signals [ _ number ] [ number ] signals . append ( ( np . ones ( len ( _s ) , dtype = string ) * mdf_index , none ) ) _s = none merged . extend ( cg_nr , signals ) if first_timestamp is none first_timestamp = master [ number ] idx + = number group . record = none last_timestamps [ i ] = last_timestamp if callback callback ( i + number + mdf_index * groups_nr , groups_nr * mdf_nr ) if mdf . _terminate return merged . _transfer_events ( mdf ) return merged	1
Q_94	concatenate several file remove header line	C_94_3	def clean_file ( filename ) f = open ( filename , string ) new_lines = [ ] for var in f . readlines ( ) new_lines . append ( var . rstrip ( ) ) f . close ( ) f = open ( filename , string ) for var in new_lines f . write ( var + string ) f . close ( )	1
Q_94	concatenate several file remove header line	C_94_4	def parse_file ( file ) string string string lines = [ ] for var in file var = var . rstrip ( string ) if var = = string	1
Q_94	concatenate several file remove header line	C_94_5	def main ( fpcfile ) fw = sys . stdout f = fpc_reader ( fpcfile )	1
Q_94	concatenate several file remove header line	C_94_6	def vcf_as_df ( fn ) string string string header_lines = number with open ( fn , string ) as f line = f . readline ( ) . strip ( ) header_lines + = number while line [ number ] = = string line = f . readline ( ) . strip ( ) header_lines + = number header_lines _ = number df = pd . read_table ( fn , skiprows = header_lines , header = number ) df . columns = [ string ] + list ( df . columns [ number ] ) return df	1
Q_94	concatenate several file remove header line	C_94_7	def from_file ( filename ) string string string entries = [ ] with open ( filename ) as fd lines = [ ] for var in fd . readlines ( ) var = var . rstrip ( ) if not var if lines entries . append ( from_headers ( string . join ( lines ) ) ) lines = [ ] else lines . append ( var ) if lines entries . append ( from_headers ( string . join ( lines ) ) ) return entries	1
Q_94	concatenate several file remove header line	C_94_8	def parse_file ( file ) string string string lines = [ ] for var in file var = var . rstrip ( string ) if var = = string	1
Q_94	concatenate several file remove header line	C_94_9	def concatenate ( files , version = string , sync = true , add_samples_origin = false , * * kwargs ) string string _samples_origin string string if not files raise mdf_exception ( string ) callback = kwargs . get ( string , none ) if callback callback ( number , number ) mdf_nr = len ( files ) versions = [ ] if sync timestamps = [ ] for var in files if isinstance ( var , mdf ) timestamps . append ( var . header . start_time ) versions . append ( var . version ) else with open ( var , string ) as mdf mdf . seek ( number ) blk_id = mdf . read ( number ) if blk_id = = b string header = header_v3 versions . append ( string ) else versions . append ( string ) blk_id + = mdf . read ( number ) if blk_id = = b string header = header_v4 else raise mdf_exception ( f string { var } string ) header = header ( address = number , stream = mdf ) timestamps . append ( header . start_time ) try oldest = min ( timestamps ) except type_error timestamps = [ timestamp . astimezone ( timezone . utc ) for timestamp in timestamps ] oldest = min ( timestamps ) offsets = [ ( timestamp _ oldest ) . total_seconds ( ) for timestamp in timestamps ] offsets = [ offset if offset > number else number for offset in offsets ] else var = files [ number ] if isinstance ( var , mdf ) oldest = var . header . start_time versions . append ( var . version ) else with open ( var , string ) as mdf mdf . seek ( number ) blk_id = mdf . read ( number ) if blk_id = = b string versions . append ( string ) header = header_v3 else versions . append ( string ) blk_id + = mdf . read ( number ) if blk_id = = b string header = header_v4 else raise mdf_exception ( f string { var } string ) header = header ( address = number , stream = mdf ) oldest = header . start_time offsets = [ number for _ in files ] version = validate_version_argument ( version ) merged = mdf ( version = version , callback = callback ) merged . header . start_time = oldest encodings = [ ] included_channel_names = [ ] if add_samples_origin origin_conversion = { } for i , mdf in enumerate ( files ) origin_conversion [ f string ] = i if isinstance ( mdf , mdf ) origin_conversion [ f string ] = str ( mdf . name ) else origin_conversion [ f string ] = str ( mdf ) origin_conversion = from_dict ( origin_conversion ) for mdf_index , ( offset , mdf ) in enumerate ( zip ( offsets , files ) ) if not isinstance ( mdf , mdf ) mdf = mdf ( mdf ) try for can_id , info in mdf . can_logging_db . items ( ) if can_id not in merged . can_logging_db merged . can_logging_db [ can_id ] = { } merged . can_logging_db [ can_id ] . update ( info ) except attribute_error pass if mdf_index = = number last_timestamps = [ none for gp in mdf . groups ] groups_nr = len ( mdf . groups ) cg_nr = _ number for i , group in enumerate ( mdf . groups ) included_channels = mdf . _included_channels ( i ) if mdf_index = = number included_channel_names . append ( [ group . channels [ k ] . name for k in included_channels ] ) else names = [ group . channels [ k ] . name for k in included_channels ] if names = included_channel_names [ i ] if sorted ( names ) = sorted ( included_channel_names [ i ] ) raise mdf_exception ( f string ) else logger . warning ( f string string string ) included_channels = [ mdf . _validate_channel_selection ( name = name_ , group = i , ) [ number ] for name_ in included_channel_names [ i ] ] if included_channels cg_nr + = number else continue channels_nr = len ( group . channels ) y_axis = merge idx = np . searchsorted ( channel_count , channels_nr , side = string ) _ number if idx < number idx = number read_size = y_axis [ idx ] idx = number last_timestamp = last_timestamps [ i ] first_timestamp = none original_first_timestamp = none if read_size mdf . configure ( read_fragment_size = int ( read_size ) ) parents , dtypes = mdf . _prepare_record ( group ) data = mdf . _load_data ( group ) for fragment in data if dtypes . itemsize group . record = np . core . records . fromstring ( fragment [ number ] , dtype = dtypes ) else group . record = none if mdf_index = = number and idx = = number encodings_ = [ ] encodings . append ( encodings_ ) signals = [ ] for j in included_channels sig = mdf . get ( group = i , index = j , data = fragment , raw = true , ignore_invalidation_bits = true , copy_master = false , ) if version < string if sig . samples . dtype . kind = = string encodings_ . append ( sig . encoding ) strsig = mdf . get ( group = i , index = j , samples_only = true , ignore_invalidation_bits = true , ) [ number ] sig . samples = sig . samples . astype ( strsig . dtype ) del strsig if sig . encoding = string if sig . encoding = = string sig . samples = ( sig . samples . view ( np . uint16 ) . byteswap ( ) . view ( sig . samples . dtype ) ) sig . samples = encode ( decode ( sig . samples , string ) , string , ) else sig . samples = encode ( decode ( sig . samples , sig . encoding ) , string , ) else encodings_ . append ( none ) if not sig . samples . flags . writeable sig . samples = sig . samples . copy ( ) signals . append ( sig ) if signals and len ( signals [ number ] ) if offset > number timestamps = sig [ number ] . timestamps + offset for sig in signals sig . timestamps = timestamps last_timestamp = signals [ number ] . timestamps [ _ number ] first_timestamp = signals [ number ] . timestamps [ number ] original_first_timestamp = first_timestamp if add_samples_origin if signals _s = signals [ _ number ] signals . append ( signal ( samples = np . ones ( len ( _s ) , dtype = string ) * mdf_index , timestamps = _s . timestamps , conversion = origin_conversion , name = string , ) ) _s = none if signals merged . append ( signals , common_timebase = true ) try if group . channel_group . flags v4c . flag_cg_bus_event merged . groups [ _ number ] . channel_group . flags = group . channel_group . flags merged . groups [ _ number ] . channel_group . acq_name = group . channel_group . acq_name merged . groups [ _ number ] . channel_group . acq_source = group . channel_group . acq_source merged . groups [ _ number ] . channel_group . comment = group . channel_group . comment except attribute_error pass else break idx + = number else master = mdf . get_master ( i , fragment , copy_master = false ) _copied = false if len ( master ) if original_first_timestamp is none original_first_timestamp = master [ number ] if offset > number master = master + offset _copied = true if last_timestamp is none last_timestamp = master [ _ number ] else if last_timestamp > = master [ number ] if len ( master ) > = number delta = master [ number ] _ master [ number ] else delta = number . number number if _copied master _ = master [ number ] else master = master _ master [ number ] _copied = true master + = last_timestamp + delta last_timestamp = master [ _ number ] signals = [ ( master , none ) ] for k , j in enumerate ( included_channels ) sig = mdf . get ( group = i , index = j , data = fragment , raw = true , samples_only = true , ignore_invalidation_bits = true , ) signals . append ( sig ) if version < string encoding = encodings [ i ] [ k ] samples = sig [ number ] if encoding if encoding = string if encoding = = string samples = ( samples . view ( np . uint16 ) . byteswap ( ) . view ( samples . dtype ) ) samples = encode ( decode ( samples , string ) , string , ) else samples = encode ( decode ( samples , encoding ) , string ) sig . samples = samples if signals if add_samples_origin _s = signals [ _ number ] [ number ] signals . append ( ( np . ones ( len ( _s ) , dtype = string ) * mdf_index , none ) ) _s = none merged . extend ( cg_nr , signals ) if first_timestamp is none first_timestamp = master [ number ] idx + = number group . record = none last_timestamps [ i ] = last_timestamp if callback callback ( i + number + mdf_index * groups_nr , groups_nr * mdf_nr ) if mdf . _terminate return merged . _transfer_events ( mdf ) return merged	1
Q_94	concatenate several file remove header line	C_94_10	def sniff_csv_format ( csv_file , potential_sep = [ string , string , string , string , string , string ] , max_test_lines = number , zip_file = none ) string string t string , string string string _ string _ string csv_file string string def read_first_lines ( filehandle ) lines = [ ] for var in range ( max_test_lines ) line = ff . readline ( ) if line = = string break try line = line . decode ( string ) except attribute_error pass lines . append ( line [ _ number ] ) return lines if zip_file with zipfile . zip_file ( zip_file , string ) as zz with zz . open ( csv_file , string ) as ff test_lines = read_first_lines ( ff ) else with open ( csv_file , string ) as ff test_lines = read_first_lines ( ff ) sep_aly_lines = [ sorted ( [ ( line . count ( sep ) , sep ) for sep in potential_sep if line . count ( sep ) > number ] , key = lambda x x [ number ] , reverse = true ) for line in test_lines ] for nr , ( count , sep ) in enumerate ( sep_aly_lines [ number ] ) for line in sep_aly_lines if line [ nr ] [ number ] = = count break else sep = none if sep break nr_header_row = none nr_index_col = none if sep nr_index_col = find_first_number ( test_lines [ _ number ] . split ( sep ) ) if nr_index_col for nr_header_row , line in enumerate ( test_lines ) if find_first_number ( line . split ( sep ) ) = = nr_index_col break return dict ( sep = sep , nr_header_row = nr_header_row , nr_index_col = nr_index_col )	1
Q_94	concatenate several file remove header line	C_94_11	def concatenate_aiml ( path = string , outfile = string ) string string string path = find_data_path ( path ) or path zf = zipfile . zip_file ( path ) for var in zf . namelist ( ) if not var . lower ( ) . endswith ( string ) continue with zf . open ( var ) as fin happyending = string for i , line in enumerate ( fin ) try line = line . decode ( string ) . strip ( ) except unicode_decode_error line = line . decode ( string ) . strip ( ) if line . lower ( ) . startswith ( string ) or line . lower ( ) . endswith ( string ) happyending = ( i , line ) break else pass if happyending = ( i , line ) print ( string < / aiml > string . format ( var , i , line ) )	1
Q_94	concatenate several file remove header line	C_94_12	def main ( fpcfile ) fw = sys . stdout f = fpc_reader ( fpcfile )	0
Q_94	concatenate several file remove header line	C_94_13	def sniff_csv_format ( csv_file , potential_sep = [ string , string , string , string , string , string ] , max_test_lines = number , zip_file = none ) string string t string , string string string _ string _ string csv_file string string def read_first_lines ( filehandle ) lines = [ ] for var in range ( max_test_lines ) line = ff . readline ( ) if line = = string break try line = line . decode ( string ) except attribute_error pass lines . append ( line [ _ number ] ) return lines if zip_file with zipfile . zip_file ( zip_file , string ) as zz with zz . open ( csv_file , string ) as ff test_lines = read_first_lines ( ff ) else with open ( csv_file , string ) as ff test_lines = read_first_lines ( ff ) sep_aly_lines = [ sorted ( [ ( line . count ( sep ) , sep ) for sep in potential_sep if line . count ( sep ) > number ] , key = lambda x x [ number ] , reverse = true ) for line in test_lines ] for nr , ( count , sep ) in enumerate ( sep_aly_lines [ number ] ) for line in sep_aly_lines if line [ nr ] [ number ] = = count break else sep = none if sep break nr_header_row = none nr_index_col = none if sep nr_index_col = find_first_number ( test_lines [ _ number ] . split ( sep ) ) if nr_index_col for nr_header_row , line in enumerate ( test_lines ) if find_first_number ( line . split ( sep ) ) = = nr_index_col break return dict ( sep = sep , nr_header_row = nr_header_row , nr_index_col = nr_index_col )	0
Q_94	concatenate several file remove header line	C_94_14	def main ( fpcfile ) fw = sys . stdout f = fpc_reader ( fpcfile )	0
Q_94	concatenate several file remove header line	C_94_15	def filename_generator ( file_parts , new_m_time = none )	0
Q_94	concatenate several file remove header line	C_94_16	def vcf_as_df ( fn ) string string string header_lines = number with open ( fn , string ) as f line = f . readline ( ) . strip ( ) header_lines + = number while line [ number ] = = string line = f . readline ( ) . strip ( ) header_lines + = number header_lines _ = number df = pd . read_table ( fn , skiprows = header_lines , header = number ) df . columns = [ string ] + list ( df . columns [ number ] ) return df	0
Q_94	concatenate several file remove header line	C_94_17	def clean_file ( filename ) f = open ( filename , string ) new_lines = [ ] for var in f . readlines ( ) new_lines . append ( var . rstrip ( ) ) f . close ( ) f = open ( filename , string ) for var in new_lines f . write ( var + string ) f . close ( )	0
Q_95	buffer file reader read text	C_95_0	def read_all ( self , encoding = string ) string string string logger . info ( string self ) with codecs . open ( self . path , string , encoding ) as fin read_text = fin . read ( ) return read_text	1
Q_95	buffer file reader read text	C_95_1	def reader ( self ) if self . _reader is none self . _reader = warc_reader ( self . fileobj ) return self . _reader	1
Q_95	buffer file reader read text	C_95_2	def read_next ( self ) if not self . read_buffer self . _read_next_batch ( ) assert self . read_buffer self . read_item_offset + = number return self . read_buffer . pop ( number )	1
Q_95	buffer file reader read text	C_95_3	def reader ( self ) if self . _reader is none self . _reader = warc_reader ( self . fileobj ) return self . _reader	1
Q_95	buffer file reader read text	C_95_4	def read_all ( self , encoding = string ) string string string logger . info ( string self ) with codecs . open ( self . path , string , encoding ) as fin read_text = fin . read ( ) return read_text	1
Q_95	buffer file reader read text	C_95_5	def read ( self , size = _ number ) string string string logger . debug ( string , size ) if self . response is none return b string if size = = number return b string elif size < number and len ( self . _read_buffer ) = = number retval = self . response . raw . read ( ) elif size < number retval = self . _read_buffer . read ( ) + self . response . raw . read ( ) else while len ( self . _read_buffer ) < size logger . debug ( string , self . _current_pos , size ) bytes_read = self . _read_buffer . fill ( self . _read_iter ) if bytes_read = = number	1
Q_95	buffer file reader read text	C_95_6	def read_next ( self ) if not self . read_buffer self . _read_next_batch ( ) assert self . read_buffer self . read_item_offset + = number return self . read_buffer . pop ( number )	1
Q_95	buffer file reader read text	C_95_7	def _read_from_buffer ( self , delimiter = none , nbytes = none , regex = none ) if nbytes is not none return self . _read_buffer . read ( nbytes ) elif delimiter is not none return self . _read_buffer . read_until ( delimiter ) elif regex is not none return self . _read_buffer . read_until_regex ( regex )	1
Q_95	buffer file reader read text	C_95_8	def read_text ( self , text str ) _ > bool string string string ls string string if self . read_eof ( ) return false self . _stream . save_context ( ) if self . peek_text ( text ) self . _stream . incpos ( len ( text ) ) return self . _stream . validate_context ( ) return self . _stream . restore_context ( )	1
Q_95	buffer file reader read text	C_95_9	def read_text ( self , text str ) _ > bool string string string ls string string if self . read_eof ( ) return false self . _stream . save_context ( ) if self . peek_text ( text ) self . _stream . incpos ( len ( text ) ) return self . _stream . validate_context ( ) return self . _stream . restore_context ( )	1
Q_95	buffer file reader read text	C_95_10	def read_text ( self , text str ) _ > bool string string string ls string string if self . read_eof ( ) return false self . _stream . save_context ( ) if self . peek_text ( text ) self . _stream . incpos ( len ( text ) ) return self . _stream . validate_context ( ) return self . _stream . restore_context ( )	0
Q_95	buffer file reader read text	C_95_11	def _init_ ( self , read_size ) self . _stream = none self . _buffer = none self . _read_size = read_size self . encoding = none	0
Q_95	buffer file reader read text	C_95_12	def _init_ ( self , * , buffering = string ) self . _buffer = b string self . _lf = number self . _buffering = buffering if buffering = = string self . read = self . _readline else self . read = self . _read	0
Q_95	buffer file reader read text	C_95_13	def read_original_textlc ( lcpath ) string string hat _ number _ number number . epdlc string string loginfo ( string . format ( lcpath ) ) n_lines_to_parse_comments = number with open ( lcpath , string ) as file head = [ next ( file ) for var in range ( n_lines_to_parse_comments ) ] n_comment_lines = len ( [ l for l in head if l . decode ( string ) [ number ] = = string ] )	0
Q_95	buffer file reader read text	C_95_14	def reader1 ( cls , file ) def reader ( file ) temperature = open ( file ) . read ( ) . strip ( ) temperature = int ( temperature ) / / number return temperature return partial ( reader , file )	0
Q_95	buffer file reader read text	C_95_15	def read_original_textlc ( lcpath ) string string hat _ number _ number number . epdlc string string loginfo ( string . format ( lcpath ) ) n_lines_to_parse_comments = number with open ( lcpath , string ) as file head = [ next ( file ) for var in range ( n_lines_to_parse_comments ) ] n_comment_lines = len ( [ l for l in head if l . decode ( string ) [ number ] = = string ] )	0
Q_95	buffer file reader read text	C_95_16	def reader1 ( cls , file ) def reader ( file ) temperature = open ( file ) . read ( ) . strip ( ) temperature = int ( temperature ) / / number return temperature return partial ( reader , file )	0
Q_96	binomial distribution	C_96_0	def eval_binomial_pmf ( k , n , p ) string string string return scipy . stats . binom . pmf ( k , n , p )	1
Q_96	binomial distribution	C_96_1	def sample ( self , n = number ) p_vals = self . _p_dist . rvs ( size = n ) [ , np . newaxis ]	1
Q_96	binomial distribution	C_96_2	def sample ( self , n = number ) p_vals = self . _p_dist . rvs ( size = n ) [ , np . newaxis ]	1
Q_96	binomial distribution	C_96_3	def binomial ( n , p , tag = none ) string string string assert ( int ( n ) = = n and n > number ) , string n string assert ( number < p < number ) , string p string return uv ( ss . binom ( n , p ) , tag = tag )	1
Q_96	binomial distribution	C_96_4	def eval_binomial_pmf ( k , n , p ) string string string return scipy . stats . binom . pmf ( k , n , p )	1
Q_96	binomial distribution	C_96_5	def binomial ( n , p , tag = none ) string string string assert ( int ( n ) = = n and n > number ) , string n string assert ( number < p < number ) , string p string return uv ( ss . binom ( n , p ) , tag = tag )	1
Q_96	binomial distribution	C_96_6	def binomial ( n , k ) string string string if n = = k return number assert n > k , string ( n , k ) return factorial ( n ) / / ( factorial ( k ) * factorial ( n _ k ) )	1
Q_96	binomial distribution	C_96_7	def binomial ( n , k ) string string string if n = = k return number assert n > k , string ( n , k ) return factorial ( n ) / / ( factorial ( k ) * factorial ( n _ k ) )	1
Q_96	binomial distribution	C_96_8	def binomial ( n , k ) string string string if n = = k return number assert n > k , string ( n , k ) return factorial ( n ) / / ( factorial ( k ) * factorial ( n _ k ) )	1
Q_96	binomial distribution	C_96_9	def binomial ( n , k ) string string string if n = = k return number assert n > k , string ( n , k ) return factorial ( n ) / / ( factorial ( k ) * factorial ( n _ k ) )	1
Q_96	binomial distribution	C_96_10	def binomial ( n , p , tag = none ) string string string assert ( int ( n ) = = n and n > number ) , string n string assert ( number < p < number ) , string p string return uv ( ss . binom ( n , p ) , tag = tag )	1
Q_96	binomial distribution	C_96_11	def binomial_prefactor ( s , ia , ib , xpa , xpb ) string string string total = number for var in range ( s + number ) if s _ ia < = var < = ib total + = binomial ( ia , s _ var ) * binomial ( ib , var ) * pow ( xpa , ia _ s + var ) * pow ( xpb , ib _ var ) return total	1
Q_96	binomial distribution	C_96_12	def binomial ( n , k ) string string string if n = = k return number assert n > k , string ( n , k ) return factorial ( n ) / / ( factorial ( k ) * factorial ( n _ k ) )	1
Q_96	binomial distribution	C_96_13	def binomial ( n , k ) string string string if n = = k return number assert n > k , string ( n , k ) return factorial ( n ) / / ( factorial ( k ) * factorial ( n _ k ) )	1
Q_96	binomial distribution	C_96_14	def get_prob ( self ) if self . total < number return number . a , b = self . dup + number , self . nodup + number n = a + b p = a / n q = b / n	1
Q_96	binomial distribution	C_96_15	def anderson ( * args , dist = string ) string string norm string expon string logistic string gumbel string norm string expon string string from scipy . stats import anderson as ads k = len ( args ) from_dist = np . zeros ( k , string ) sig_level = np . zeros ( k ) for var in range ( k ) st , cr , sig = ads ( args [ var ] , dist = dist ) from_dist [ var ] = true if ( st > cr ) . any ( ) else false sig_level [ var ] = sig [ np . argmin ( np . abs ( st _ cr ) ) ] if k = = number from_dist = bool ( from_dist ) sig_level = float ( sig_level ) return from_dist , sig_level	1
Q_96	binomial distribution	C_96_16	def main ( )	1
Q_96	binomial distribution	C_96_17	def anderson ( * args , dist = string ) string string norm string expon string logistic string gumbel string norm string expon string string from scipy . stats import anderson as ads k = len ( args ) from_dist = np . zeros ( k , string ) sig_level = np . zeros ( k ) for var in range ( k ) st , cr , sig = ads ( args [ var ] , dist = dist ) from_dist [ var ] = true if ( st > cr ) . any ( ) else false sig_level [ var ] = sig [ np . argmin ( np . abs ( st _ cr ) ) ] if k = = number from_dist = bool ( from_dist ) sig_level = float ( sig_level ) return from_dist , sig_level	1
Q_96	binomial distribution	C_96_18	def get_prob ( self ) if self . total < number return number . a , b = self . dup + number , self . nodup + number n = a + b p = a / n q = b / n	1
Q_96	binomial distribution	C_96_19	def combine_indep_dstns ( * distributions ) string string string	0
Q_96	binomial distribution	C_96_20	def binomial_prefactor ( s , ia , ib , xpa , xpb ) string string string total = number for var in range ( s + number ) if s _ ia < = var < = ib total + = binomial ( ia , s _ var ) * binomial ( ib , var ) * pow ( xpa , ia _ s + var ) * pow ( xpb , ib _ var ) return total	0
Q_96	binomial distribution	C_96_21	def combine_indep_dstns ( * distributions ) string string string	0
Q_96	binomial distribution	C_96_22	def bin1d ( x , bins ) string string float string string left = [ _ float ( string ) ] left . extend ( bins [ number _ number ] ) right = bins cuts = list ( zip ( left , right ) ) k = len ( bins ) bin_ids = np . zeros ( x . shape , dtype = string ) while cuts k _ = number l , r = cuts . pop ( _ number ) bin_ids + = ( x > l ) * ( x < = r ) * k counts = np . bincount ( bin_ids , minlength = len ( bins ) ) return ( bin_ids , counts )	0
Q_96	binomial distribution	C_96_23	def bin1d ( x , bins ) string string float string string left = [ _ float ( string ) ] left . extend ( bins [ number _ number ] ) right = bins cuts = list ( zip ( left , right ) ) k = len ( bins ) bin_ids = np . zeros ( x . shape , dtype = string ) while cuts k _ = number l , r = cuts . pop ( _ number ) bin_ids + = ( x > l ) * ( x < = r ) * k counts = np . bincount ( bin_ids , minlength = len ( bins ) ) return ( bin_ids , counts )	0
Q_96	binomial distribution	C_96_24	def bin1d ( x , bins ) string string float string string left = [ _ float ( string ) ] left . extend ( bins [ number _ number ] ) right = bins cuts = list ( zip ( left , right ) ) k = len ( bins ) bin_ids = np . zeros ( x . shape , dtype = string ) while cuts k _ = number l , r = cuts . pop ( _ number ) bin_ids + = ( x > l ) * ( x < = r ) * k counts = np . bincount ( bin_ids , minlength = len ( bins ) ) return ( bin_ids , counts )	0
Q_96	binomial distribution	C_96_25	def main ( )	0
Q_97	all permutation of a list	C_97_0	def distinct_permutations ( iterable ) string string string def make_new_permutations ( permutations , e ) string string string for var in permutations for j in range ( len ( var ) ) yield var [ j ] + [ e ] + var [ j ] if var [ j ] = = e break else yield var + [ e ] permutations = [ [ ] ] for e in iterable permutations = make_new_permutations ( permutations , e ) return ( tuple ( t ) for t in permutations )	1
Q_97	all permutation of a list	C_97_1	def permutations ( x ) if len ( x ) > number for var in permutations ( x [ number ] )	1
Q_97	all permutation of a list	C_97_2	def permutations ( x ) string string string	1
Q_97	all permutation of a list	C_97_3	def distinct_permutations ( iterable ) string string string def make_new_permutations ( permutations , e ) string string string for var in permutations for j in range ( len ( var ) ) yield var [ j ] + [ e ] + var [ j ] if var [ j ] = = e break else yield var + [ e ] permutations = [ [ ] ] for e in iterable permutations = make_new_permutations ( permutations , e ) return ( tuple ( t ) for t in permutations )	1
Q_97	all permutation of a list	C_97_4	def permutations ( x ) string string string	1
Q_97	all permutation of a list	C_97_5	def permutations ( x ) if len ( x ) > number for var in permutations ( x [ number ] )	1
Q_97	all permutation of a list	C_97_6	def deleterious_permutation ( obs_del , context_counts , context_to_mut , seq_context , gene_seq , num_permutations = number , stop_criteria = number , pseudo_count = number , max_batch = number ) string string string mycontexts = context_counts . index . tolist ( ) somatic_base = [ base for var in mycontexts for base in context_to_mut [ var ] ]	1
Q_97	all permutation of a list	C_97_7	def p ( i , sample_size , weights ) string string string	1
Q_97	all permutation of a list	C_97_8	def print_permutations ( self ) string string string index = number permutations = [ ] for var in self . _input_permutations permutations . append ( { string index , string var } ) index + = number with open ( string , string ) as fh json . dump ( permutations , fh , indent = number ) print ( string permutations . json string )	1
Q_97	all permutation of a list	C_97_9	def series_with_permutation ( self , other ) string string string combined_permutation = tuple ( [ self . permutation [ var ] for var in other . permutation ] ) return c_permutation . create ( combined_permutation )	1
Q_97	all permutation of a list	C_97_10	def circ_permutation ( items ) string string string permutations = [ ] for var in range ( len ( items ) ) permutations . append ( items [ var ] + items [ var ] ) return permutations	1
Q_97	all permutation of a list	C_97_11	def permutation_from_block_permutations ( permutations ) string string string offset = number new_perm = [ ] for var in permutations new_perm [ offset offset + len ( var ) ] = [ p_i + offset for p_i in var ] offset + = len ( var ) return tuple ( new_perm )	1
Q_97	all permutation of a list	C_97_12	def p ( i , sample_size , weights ) string string string	0
Q_97	all permutation of a list	C_97_13	def permute ( self , permutations list [ mx . nd . nd_array ] ) _ > string string string string assert len ( self ) = = len ( permutations ) source = [ ] target = [ ] label = [ ] for var in range ( len ( self ) ) num_samples = self . source [ var ] . shape [ number ] if num_samples	0
Q_97	all permutation of a list	C_97_14	def print_permutations ( self ) string string string index = number permutations = [ ] for var in self . _input_permutations permutations . append ( { string index , string var } ) index + = number with open ( string , string ) as fh json . dump ( permutations , fh , indent = number ) print ( string permutations . json string )	0
Q_97	all permutation of a list	C_97_15	def circ_permutation ( items ) string string string permutations = [ ] for var in range ( len ( items ) ) permutations . append ( items [ var ] + items [ var ] ) return permutations	0
Q_97	all permutation of a list	C_97_16	def deleterious_permutation ( obs_del , context_counts , context_to_mut , seq_context , gene_seq , num_permutations = number , stop_criteria = number , pseudo_count = number , max_batch = number ) string string string mycontexts = context_counts . index . tolist ( ) somatic_base = [ base for var in mycontexts for base in context_to_mut [ var ] ]	0
Q_97	all permutation of a list	C_97_17	def permutation_from_block_permutations ( permutations ) string string string offset = number new_perm = [ ] for var in permutations new_perm [ offset offset + len ( var ) ] = [ p_i + offset for p_i in var ] offset + = len ( var ) return tuple ( new_perm )	0
Q_97	all permutation of a list	C_97_18	def series_with_permutation ( self , other ) string string string combined_permutation = tuple ( [ self . permutation [ var ] for var in other . permutation ] ) return c_permutation . create ( combined_permutation )	0
Q_97	all permutation of a list	C_97_19	def permute ( self , permutations list [ mx . nd . nd_array ] ) _ > string string string string assert len ( self ) = = len ( permutations ) source = [ ] target = [ ] label = [ ] for var in range ( len ( self ) ) num_samples = self . source [ var ] . shape [ number ] if num_samples	0
Q_98	aes encryption	C_98_0	def aes_encrypt ( base64_encryption_key , data ) string string string if isinstance ( data , text_type ) data = data . encode ( string ) aes_key_bytes , hmac_key_bytes = _extract_keys ( base64_encryption_key ) data = _pad ( data ) iv_bytes = os . urandom ( aes_block_size ) cipher = aes . new ( aes_key_bytes , mode = aes . mode_cbc , iv = iv_bytes ) data = iv_bytes + cipher . encrypt ( data )	1
Q_98	aes encryption	C_98_1	def aes_encrypt ( value , secret , block_size = aes . block_size ) string string hello , world string a_lwe_flwgwlre_welfnwefwl_egwklgbwe_lkwebgw string z_yg_vy_mbe_oui_hr50a_m_fin_y9_jsfy_mq_cvpz_i + l_nq_ncm_zhw = string z_yg_vy_mbe_oui_hr50a_m_fin_y9_jsfy_mq_cvpz_i + l_nq_ncm_zhw = string a_lwe_flwgwlre_welfnwefwl_egwklgbwe_lkwebgw string hello , world string string iv = os . urandom ( block_size * number ) cipher = aes . new ( secret [ number ] , aes . mode_cfb , iv [ block_size ] ) return b string ( iv , cipher . encrypt ( value ) )	1
Q_98	aes encryption	C_98_2	def encrypt_message ( self , signed_message , message , key , iv ) raw = signed_message + message block_size = aes . block_size pad = lambda s s + ( block_size _ len ( s ) block_size ) * chr ( block_size _ len ( s ) block_size ) . encode ( string ) message_to_encrypt = pad ( raw ) cipher = aes . new ( key , aes . mode_cbc , iv ) return cipher . encrypt ( message_to_encrypt )	1
Q_98	aes encryption	C_98_3	def _cbc_encrypt ( self , content , final_key ) string string string aes = aes . new ( final_key , aes . mode_cbc , self . _enc_iv ) padding = ( number _ len ( content ) aes . block_size ) for var in range ( padding ) content + = chr ( padding ) . encode ( ) temp = bytes ( content ) return aes . encrypt ( temp )	1
Q_98	aes encryption	C_98_4	def aes_ctr_encrypt ( text , key , params ) iv = big_endian_to_int ( decode_hex ( params [ string ] ) ) ctr = counter . new ( number , initial_value = iv , allow_wraparound = true ) mode = aes . mode_ctr encryptor = aes . new ( key , mode , counter = ctr ) return encryptor . encrypt ( text )	1
Q_98	aes encryption	C_98_5	def decode_aes256 ( cipher , iv , data , encryption_key ) string string string string if cipher = = string aes = aes . new ( encryption_key , aes . mode_cbc , iv ) elif cipher = = string aes = aes . new ( encryption_key , aes . mode_ecb ) else raise value_error ( string ) d = aes . decrypt ( data )	1
Q_98	aes encryption	C_98_6	def _encrypt ( data ) string string string bs = aes . block_size def pad ( s ) n = bs _ len ( s ) bs char = chr ( n ) . encode ( string ) return s + n * char password = settings . geckoboard_password salt = random . new ( ) . read ( bs _ len ( string ) ) key , iv = _derive_key_and_iv ( password , salt , number , bs ) cipher = aes . new ( key , aes . mode_cbc , iv ) encrypted = b string + salt + cipher . encrypt ( pad ( data ) ) return base64 . b64encode ( encrypted )	1
Q_98	aes encryption	C_98_7	def aes_encrypt ( value , secret , block_size = aes . block_size ) string string hello , world string a_lwe_flwgwlre_welfnwefwl_egwklgbwe_lkwebgw string z_yg_vy_mbe_oui_hr50a_m_fin_y9_jsfy_mq_cvpz_i + l_nq_ncm_zhw = string z_yg_vy_mbe_oui_hr50a_m_fin_y9_jsfy_mq_cvpz_i + l_nq_ncm_zhw = string a_lwe_flwgwlre_welfnwefwl_egwklgbwe_lkwebgw string hello , world string string iv = os . urandom ( block_size * number ) cipher = aes . new ( secret [ number ] , aes . mode_cfb , iv [ block_size ] ) return b string ( iv , cipher . encrypt ( value ) )	1
Q_98	aes encryption	C_98_8	def encrypt_message ( self , signed_message , message , key , iv ) raw = signed_message + message block_size = aes . block_size pad = lambda s s + ( block_size _ len ( s ) block_size ) * chr ( block_size _ len ( s ) block_size ) . encode ( string ) message_to_encrypt = pad ( raw ) cipher = aes . new ( key , aes . mode_cbc , iv ) return cipher . encrypt ( message_to_encrypt )	1
Q_98	aes encryption	C_98_9	def aes_cbc_encrypt ( plain_text bytes , key bytes , iv bytes = b string ) if len ( iv ) = = number iv = aes_handler . generate_iv ( ) cipher = aes . new ( key = key , mode = aes . mode_cbc , iv = iv ) return cipher . iv , cipher . encrypt ( pad ( plain_text , aes . block_size ) )	1
Q_98	aes encryption	C_98_10	def encrypt_message ( self , signed_message , message , key , iv ) raw = signed_message + message block_size = aes . block_size pad = lambda s s + ( block_size _ len ( s ) block_size ) * chr ( block_size _ len ( s ) block_size ) . encode ( string ) message_to_encrypt = pad ( raw ) cipher = aes . new ( key , aes . mode_cbc , iv ) return cipher . encrypt ( message_to_encrypt )	1
Q_98	aes encryption	C_98_11	def aes_encrypt ( base64_encryption_key , data ) string string string if isinstance ( data , text_type ) data = data . encode ( string ) aes_key_bytes , hmac_key_bytes = _extract_keys ( base64_encryption_key ) data = _pad ( data ) iv_bytes = os . urandom ( aes_block_size ) cipher = aes . new ( aes_key_bytes , mode = aes . mode_cbc , iv = iv_bytes ) data = iv_bytes + cipher . encrypt ( data )	1
Q_98	aes encryption	C_98_12	def _cbc_encrypt ( self , content , final_key ) string string string aes = aes . new ( final_key , aes . mode_cbc , self . _enc_iv ) padding = ( number _ len ( content ) aes . block_size ) for var in range ( padding ) content + = chr ( padding ) . encode ( ) temp = bytes ( content ) return aes . encrypt ( temp )	1
Q_98	aes encryption	C_98_13	def aes_ctr_encrypt ( text , key , params ) iv = big_endian_to_int ( decode_hex ( params [ string ] ) ) ctr = counter . new ( number , initial_value = iv , allow_wraparound = true ) mode = aes . mode_ctr encryptor = aes . new ( key , mode , counter = ctr ) return encryptor . encrypt ( text )	1
Q_98	aes encryption	C_98_14	def _cbc_encrypt ( self , content , final_key ) string string string aes = aes . new ( final_key , aes . mode_cbc , self . _enc_iv ) padding = ( number _ len ( content ) aes . block_size ) for var in range ( padding ) content + = chr ( padding ) . encode ( ) temp = bytes ( content ) return aes . encrypt ( temp )	1
Q_98	aes encryption	C_98_15	def _cbc_encrypt ( self , content , final_key ) string string string aes = aes . new ( final_key , aes . mode_cbc , self . _enc_iv ) padding = ( number _ len ( content ) aes . block_size ) for var in range ( padding ) content + = chr ( padding ) . encode ( ) temp = bytes ( content ) return aes . encrypt ( temp )	1
Q_98	aes encryption	C_98_16	def encrypt_message ( self , signed_message , message , key , iv ) raw = signed_message + message block_size = aes . block_size pad = lambda s s + ( block_size _ len ( s ) block_size ) * chr ( block_size _ len ( s ) block_size ) . encode ( string ) message_to_encrypt = pad ( raw ) cipher = aes . new ( key , aes . mode_cbc , iv ) return cipher . encrypt ( message_to_encrypt )	1
Q_98	aes encryption	C_98_17	def aes_cbc_encrypt ( plain_text bytes , key bytes , iv bytes = b string ) if len ( iv ) = = number iv = aes_handler . generate_iv ( ) cipher = aes . new ( key = key , mode = aes . mode_cbc , iv = iv ) return cipher . iv , cipher . encrypt ( pad ( plain_text , aes . block_size ) )	1
Q_98	aes encryption	C_98_18	def _encrypt ( data ) string string string bs = aes . block_size def pad ( s ) n = bs _ len ( s ) bs char = chr ( n ) . encode ( string ) return s + n * char password = settings . geckoboard_password salt = random . new ( ) . read ( bs _ len ( string ) ) key , iv = _derive_key_and_iv ( password , salt , number , bs ) cipher = aes . new ( key , aes . mode_cbc , iv ) encrypted = b string + salt + cipher . encrypt ( pad ( data ) ) return base64 . b64encode ( encrypted )	1
Q_98	aes encryption	C_98_19	def encrypt_data ( self , encrypt_key , priv_parameters , data_to_encrypt ) snmp_engine_boots , snmp_engine_time , salt = priv_parameters	0
Q_98	aes encryption	C_98_20	def decode_aes256 ( cipher , iv , data , encryption_key ) string string string string if cipher = = string aes = aes . new ( encryption_key , aes . mode_cbc , iv ) elif cipher = = string aes = aes . new ( encryption_key , aes . mode_ecb ) else raise value_error ( string ) d = aes . decrypt ( data )	0
Q_98	aes encryption	C_98_21	def _check_scheme ( self , config ) string string string try scheme = config . get ( escape_for_ini ( string ) , escape_for_ini ( string ) , ) except ( configparser . no_section_error , configparser . no_option_error ) raise attribute_error ( string )	0
Q_98	aes encryption	C_98_22	def _check_scheme ( self , config ) string string string try scheme = config . get ( escape_for_ini ( string ) , escape_for_ini ( string ) , ) except ( configparser . no_section_error , configparser . no_option_error ) raise attribute_error ( string )	0
Q_98	aes encryption	C_98_23	def _check_scheme ( self , config ) string string string try scheme = config . get ( escape_for_ini ( string ) , escape_for_ini ( string ) , ) except ( configparser . no_section_error , configparser . no_option_error ) raise attribute_error ( string )	0

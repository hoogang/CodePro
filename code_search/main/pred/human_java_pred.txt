Q_0	write csv	C_0_0	private static byte [ ] write_csv ( string [ ] column_headers , string [ ] [ ] rows ) throws io_exception { n try ( byte_array_output_stream csv_stream = new byte_array_output_stream ( ) output_stream_writer stream_writer = new output_stream_writer ( csv_stream , charset . for_name ( codstr ) ) ) { n csv_writer csv_writer = new csv_writer ( stream_writer , codstr ) n n csv_writer . write_next ( column_headers ) n n for ( string [ ] row rows ) { n csv_writer . write_next ( row ) n } n n csv_writer . close ( ) n n return csv_stream . to_byte_array ( ) n } n }	1
Q_0	write csv	C_0_1	public static void write_csv ( list < string [ ] > csv_data , string file_name ) throws io_exception { n preconditions . check_not_null ( csv_data , codstr ) n preconditions . check_not_null ( file_name , codstr ) n n csv_writer writer = null n try { n writer = new csv_writer ( files . new_writer ( new file ( file_name ) , standard_charsets . utf_8 ) ) n for ( string [ ] line csv_data ) { n writer . write_next ( line ) n } n } finally { n if ( writer = null ) { n writer . close ( ) n } n } n }	1
Q_0	write csv	C_0_2	public void csv ( string file ) throws io_exception { n csv_write_options options = csv_write_options . builder ( file ) . build ( ) n new csv_writer ( ) . write ( table , options ) n }	1
Q_0	write csv	C_0_3	public void render ( result result ) throws io_exception { n csv_writer csv_writer = new csv_writer ( this . output_stream , this . delimiter , this . charset ) n n / / basics n csv_writer . write ( codstr ) n csv_writer . write ( codstr ) n / / times n csv_writer . write ( codstr ) n csv_writer . write ( codstr ) n csv_writer . write ( codstr ) n csv_writer . write ( codstr ) n / / optimize stats n csv_writer . write ( codstr ) n csv_writer . write ( codstr ) n csv_writer . write ( codstr ) n / / solution n csv_writer . write ( codstr ) n csv_writer . write ( codstr ) n csv_writer . write ( codstr ) n csv_writer . write ( codstr ) n csv_writer . write ( codstr ) n csv_writer . write ( codstr ) n n csv_writer . end_record ( ) n n for ( result_entry result_entry result . get_result_entries ( ) ) { n precise_timestamp start = result_entry . get_start_timestamp ( ) n precise_timestamp stop = result_entry . get_stop_timestamp ( ) n n / / basics n csv_writer . write ( result_entry . get_algorithm ( ) . to_string ( ) ) n csv_writer . write ( result_entry . get_problem ( ) . to_string ( ) ) n / / times n csv_writer . write ( long . to_string ( start . get_cpu_time_spent ( stop ) ) ) n csv_writer .	1
Q_0	write csv	C_0_4	public void write_to_csv ( n data_request data_request , output_stream output_stream , char separator , boolean no_quotes ) n throws io_exception { n try ( csv_writer csv_writer = new csv_writer ( output_stream , separator , no_quotes ) ) { n csv_writer . set_entity_write_mode ( get_entity_write_mode ( data_request . get_entity_values ( ) ) ) n string entity_type_id = data_request . get_entity_name ( ) n write_csv_headers ( data_request , csv_writer ) n csv_writer . add ( data_service . find_all ( entity_type_id , data_request . get_query ( ) ) ) n } n }	1
Q_0	write csv	C_0_5	"suppress_warnings ( codstr ) n public static void main ( string [ ] args ) { n / / init logging n property_configurator . configure ( n idx_writing_example . class . get_resource ( package + codstr ) ) n n / / create some csv records n list < idx_record > records = new array_list < > ( ) n records . add ( create_record ( ) ) n records . add ( create_record ( ) ) n records . add ( create_record ( ) ) n records . add ( create_record ( ) ) n n / / write csv records into a java . io . file n try { n write ( records , file . create_temp_file ( codstr , codstr ) ) n } catch ( io_exception ex ) { n logger . error ( codstr t create temporary file codstr > "" + ex . get_localized_message ( ) , ex ) n system . exit ( codint ) n } n n / / write csv records into a java . io . output_stream n write ( records , new null_output_stream ( ) ) n n / / write csv records into a java . io . writer n write ( records , new null_writer ( ) ) n n / / write csv records into a string and send it to the console n write_to_console ( records ) n }"	1
Q_0	write csv	C_0_6	"suppress_warnings ( codstr ) n public static void main ( string [ ] args ) { n / / init logging n property_configurator . configure ( n is24_csv_writing_example . class . get_resource ( package + codstr ) ) n n / / create some csv records n list < is24_csv_record > records = new array_list < > ( ) n records . add ( create_haus_kauf_record ( ) ) n records . add ( create_haus_kauf_record ( ) ) n records . add ( create_wohnung_miete_record ( ) ) n records . add ( create_wohnung_miete_record ( ) ) n n / / write csv records into a java . io . file n try { n write ( records , file . create_temp_file ( codstr , codstr ) ) n } catch ( io_exception ex ) { n logger . error ( codstr t create temporary file codstr > "" + ex . get_localized_message ( ) , ex ) n system . exit ( codint ) n } n n / / write csv records into a java . io . output_stream n write ( records , new null_output_stream ( ) ) n n / / write csv records into a java . io . writer n write ( records , new null_writer ( ) ) n n / / write csv records into a string and send it to the console n write_to_console ( records ) n }"	1
Q_0	write csv	C_0_7	private void open_writer ( ) throws io_exception { n n if ( csv_writer = = null ) { n csv_writer = new csv_writer ( new java . io . file_writer ( file ) , separator ) n } n }	1
Q_1	unzip large file	C_1_0	private void un_zip ( file compressed_file ) throws io_exception { n file file = null n try ( zip_file zip_folder = new zip_file ( compressed_file ) ) { n enumeration < ? > enu = zip_folder . entries ( ) n n while ( enu . has_more_elements ( ) ) { n zip_entry zip_entry = ( zip_entry ) enu . next_element ( ) n n string name = zip_entry . get_name ( ) n long size = zip_entry . get_size ( ) n long compressed_size = zip_entry . get_compressed_size ( ) n log . trace ( codstr , n name , size , compressed_size ) n n file = new file ( compressed_file . get_parent_file ( ) , name ) n if ( file . exists ( ) config . is_override ( ) ) { n if ( name . ends_with ( codstr ) ) { n file . mkdirs ( ) n continue n } n n file parent = file . get_parent_file ( ) n if ( parent = null ) { n parent . mkdirs ( ) n } n n try ( input_stream is = zip_folder . get_input_stream ( zip_entry ) ) { n copy_input_stream_to_file ( is , file ) n } n set_file_executable ( file ) n } else { n log . debug ( codstr , file ) n } n n } n } n }	1
Q_1	unzip large file	C_1_1	private list < file > unzip_corpus ( file out_dir , zip_file zip ) n { n list < file > root_dirs = new array_list < > ( ) n n enumeration < ? extends zip_entry > zip_enum = zip . entries ( ) n while ( zip_enum . has_more_elements ( ) ) n { n zip_entry e = zip_enum . next_element ( ) n file out_file = new file ( out_dir , e . get_name ( ) . replace_all ( codstr , codstr ) ) n n if ( e . is_directory ( ) ) n { n if ( out_file . mkdirs ( ) ) n { n log . warn ( codstr + out_file . n get_absolute_path ( ) ) n } n } / / end if directory n else n { n if ( codstr . equals ( out_file . get_name ( ) ) codstr . equals ( n out_file . get_name ( ) ) ) n { n root_dirs . add ( out_file . get_parent_file ( ) ) n } n n if ( out_file . get_parent_file ( ) . is_directory ( ) ) n { n if ( out_file . get_parent_file ( ) . mkdirs ( ) ) n { n { n log . warn ( n codstr + out_file . n get_absolute_path ( ) ) n } n } n } n try ( file_output_stream out_stream = new file_output_stream ( out_file ) ) n { n n byte_streams . copy (	1
Q_1	unzip large file	C_1_2	private void unzip_to_watched_folder ( file file ) { n log . info ( codstr + file . get_name ( ) ) n try { n zip_utils . unzip ( file , new file ( ios_server_configuration . get_app_folder_to_monitor ( ) ) ) n } catch ( io_exception e ) { n log . warning ( codstr + file . get_absolute_path ( ) + codstr + e . to_string ( ) ) n } n }	1
Q_1	unzip large file	C_1_3	private void unzip_node_modules ( file pkg_dir ) throws io_exception { n file modules_zip = new file ( pkg_dir + codstr ) n long before = system . current_time_millis ( ) n logger . info ( codstr + pkg_dir + codstr ) n zip_helper . unzip ( modules_zip , pkg_dir , null , null , exist . ignore ) n if ( logger . is_debug_enabled ( ) ) n logger . debug ( codstr + ( system . current_time_millis ( ) _ before ) + codstr ) n }	1
Q_1	unzip large file	C_1_4	override n public void extract_to ( directory_resource directory_resource ) n { n try n { n get_zip_file ( ) . extract_all ( directory_resource . get_fully_qualified_name ( ) ) n } n catch ( zip_exception e ) n { n throw new resource_exception ( codstr , e ) n } n }	1
Q_1	unzip large file	C_1_5	private file unzip_file ( final file archive_file ) throws io_exception { n final zip_file zipfile = new zip_file ( archive_file ) n final file unzipped = utils . create_temp_dir ( this . temp_dir ) n utils . unzip ( zipfile , unzipped ) n zipfile . close ( ) n n return unzipped n }	1
Q_1	unzip large file	C_1_6	public static void zipping ( zip_output_stream zipout , list < file > files , file start_dir ) { n file_input_stream in = null n byte [ ] b = new byte [ codint * codint ] n for ( int i = codint i < = files . size ( ) i + + ) { n try { n file f = files . get ( i _ codint ) n in = new file_input_stream ( f ) n zip_entry entry = new zip_entry ( f . get_absolute_path ( ) . substring ( start_dir . get_absolute_path ( ) . length ( ) + codint ) ) n entry . set_method ( zip_entry . deflated ) n zipout . put_next_entry ( entry ) n io_tools . copy ( in , zipout , b ) n } catch ( io_exception ex ) { n throw unchecked . rethrow ( ex ) n } finally { n io_tools . close ( in ) n } n } n }	0
Q_2	unique element	C_2_0	override n public int count_unique ( ) { n int_set unique_elements = new int_open_hash_set ( ) n for ( int i = codint i < size ( ) i + + ) { n if ( is_missing_value ( get_int ( i ) ) ) { n unique_elements . add ( get_int ( i ) ) n } n } n return unique_elements . size ( ) n }	1
Q_2	unique element	C_2_1	public unique_model unique ( ) { n check_read_only ( ) n unique_model unique = new unique_model ( ) n unique . set_table_model ( this ) n get_unique_consts ( ) . add ( unique ) n return unique n }	1
Q_2	unique element	C_2_2	override n public int count_unique ( ) { n double_set unique_elements = new double_open_hash_set ( ) n for ( int i = codint i < size ( ) i + + ) { n if ( is_missing ( i ) ) { n unique_elements . add ( get_double ( i ) ) n } n } n return unique_elements . size ( ) n }	1
Q_2	unique element	C_2_3	public static string unique_impl_name ( e_named_element element ) { n string name = element . get_name ( ) n if ( name = = null ) n name = element . e_class ( ) . get_name ( ) n return unique_name ( element , name + impl_name_suffix , element2unique_impl_name ) n }	1
Q_2	unique element	C_2_4	private string uniquify ( string unique_id ) n { n while ( unique_ids . contains ( unique_id ) ) n { n unique_id = unique_id + codstr n } n unique_ids . add ( unique_id ) n return unique_id n }	0
Q_2	unique element	C_2_5	public static string create_unique_name ( x_name_access _x_element_container , string _s_element_name ) { n boolean b_elementexists = true n int i = codint n string s_inc_suffix = codstr n string base_name = _s_element_name n while ( b_elementexists ) { n b_elementexists = _x_element_container . has_by_name ( _s_element_name ) n if ( b_elementexists ) { n i + = codint n _s_element_name = base_name + integer . to_string ( i ) n } n } n return _s_element_name n }	0
Q_2	unique element	C_2_6	"public void check_component_constraint ( string role , string service , string instance , string [ ] constraints ) throws exception { n for ( int i = codint i < constraints . length i + + ) { n string [ ] elements = constraints [ i ] . split ( codstr ) n assertions . assert_that ( elements . length ) . overriding_error_message ( codstr s format is atribute constraint valor or atribute constraint codstr error while parsing constraints . constraints should be cluster , unique , like , unlike , group_by , max_per or is codstr unique codstr cluster codstr group_by codstr like codstr unlike codstr max_per codstr is codstr error while parsing constraints . the constraint codstr + elements [ codint ] + codstr ) . is_in ( codstr , codstr , codstr ) n if ( elements [ codint ] . equals ( codstr ) ) { n check_constraint ( role , service , instance , elements [ codint ] , elements [ codint ] , null ) n } n } else { n assertions . assert_that ( elements [ codint ] ) . overriding_error_message ( codstr s format codstr is atribute constraint codstr unique "" ) n check_constraint ( role , service , instance , elements [ codint ] , elements [ codint ] , elements [ codint ] ) n } n } n }"	0
Q_2	unique element	C_2_7	private static string unique_name ( e_named_element element , string original_name , n map < e_named_element , string > unique_name_map ) { n if ( unique_name_map . contains_key ( element ) ) { n return unique_name_map . get ( element ) n } n string unique_name = original_name n for ( int i = codint reserved_keywords . contains ( unique_name ) reserved_rules . contains ( unique_name . to_lower_case ( ) ) n element2unique_name . contains_value ( unique_name ) n element2unique_impl_name . contains_value ( unique_name ) + + i ) { n unique_name = original_name + i n } n unique_name_map . put ( element , unique_name ) n return unique_name n }	0
Q_2	unique element	C_2_8	public string add ( base_holder obj ) n { n if ( m_i_next_unique_id > = integer . max_value ) n m_i_next_unique_id = codint n m_i_next_unique_id + + n string str_unique_id = integer . to_string ( m_i_next_unique_id ) n this . put ( str_unique_id , obj ) n return str_unique_id n }	0
Q_3	underline text in label widget	C_3_0	public widget as_widget ( ) { n text_box_item name = new text_box_item ( codstr , codstr , true ) n combo_box_item base_role = new combo_box_item ( codstr , codstr ) n base_role . set_default_to_first_option ( true ) n collection < string > role_names = collections2 . transform ( standard_role . values ( ) , standard_role get_id ) n base_role . set_value_map ( role_names ) n n combo_box_item type = new combo_box_item ( codstr , codstr ) n type . set_default_to_first_option ( true ) n type . set_value_map ( new string [ ] { codstr , codstr } ) n n list_item scope = new list_item ( codstr , codstr ) n scope . set_required ( true ) n check_box_item include_all = new check_box_item ( codstr , codstr ) n n form < role_bean > form = new form < > ( role_bean . class ) n if ( scoped ) { n form . set_fields ( name , base_role , type , scope , include_all ) n } else { n form . set_fields ( name , include_all ) n } n if ( this . existing_role = null ) { n name . set_enabled ( false ) n type . set_enabled ( false ) n form . edit ( model_to_bean ( existing_role ) ) n } n n form . add_form_validator ( ( form_items , outcome ) _ > { n if ( existing_role = = null duplicate_name_and_type ( bean_to_model ( form . get_updated_entity ( ) ) )	1
Q_3	underline text in label widget	C_3_1	private void cut ( xy_chart_label label , double max_width , double max_height , double rotation ) n { n string text = label . get_label ( ) . get_text ( ) n n / / cut text . n cut_label_text ( label , max_width _ codint , max_height _ codint , rotation ) n n string cut_text = label . get_label ( ) . get_text ( ) n n / / if text is cut , add suffix characters . n if ( text . length ( ) = cut_text . length ( ) ) n { n label . get_label ( ) . set_text ( label . get_label ( ) . get_text ( ) + codstr ) n } n / / todo animate . n / / animate ( label , text , cut_text , original_rotation ) n n / / move label to top . n label . get_label_container ( ) . move_to_top ( ) n }	1
Q_3	underline text in label widget	C_3_2	protected widget add_marker ( string text ) { n n label label = new label ( text ) n label . add_style_name ( css . marker ( ) ) n get_list_item_widget ( ) . add_button ( label ) n return label n }	1
Q_3	underline text in label widget	C_3_3	private w_decorated_label make_heading_label ( final string text , final string status_text ) { n return new w_decorated_label ( new w_image ( codstr , codstr ) , n new w_text ( text ) , new w_styled_text ( status_text , w_styled_text . type . emphasised ) ) n }	1
Q_3	underline text in label widget	C_3_4	private void add_error_label ( validator validator , label label , widget widget ) { n errors . put ( label , widget ) / / keep a list of the errors for easily iteration later n validator_labels . put ( validator , label ) / / connect the label and the validator n }	0
Q_3	underline text in label widget	C_3_5	override n protected void handle_plain_text_line ( final string plain_text_line ) { n final label label = get_label ( ) n final string text_to_append = get_parser ( ) . parse_string ( plain_text_line , label ) n if ( strings . is_empty ( label . get_text ( ) ) ) { n / / label is currently empty , so we just set the text as initial value . n label . set_text ( text_to_append ) n } else { n if ( lml_utilities . is_multiline ( label ) ) { n / / label is multiline . we might want to append an extra new line char . n label . get_text ( ) . append ( codstr ) n } n label . get_text ( ) . append ( text_to_append ) n } n label . invalidate ( ) n }	0
Q_3	underline text in label widget	C_3_6	public void set_label_text ( string text ) { n m_label_text = text n text_view label_view = get_label_view ( ) n if ( label_view = null ) { n label_view . set_text ( text ) n } n }	0
Q_3	underline text in label widget	C_3_7	text_outline position_charge_label ( int hydrogens , hydrogen_position position , text_outline charge , text_outline element , n text_outline hydrogen ) { n n final rectangle2_d charge_bounds = charge . get_bounds ( ) n n / / the charge is placed to the top right of the element symbol n / / unless either the hydrogen label or the hydrogen count label n / / are in the way _ in which case we place it relative to the n / / hydrogen n rectangle2_d reference_bounds = element . get_bounds ( ) n if ( hydrogens > codint position = = right ) n reference_bounds = hydrogen . get_bounds ( ) n else if ( hydrogens > codint position = = above ) reference_bounds = hydrogen . get_bounds ( ) n n return charge . translate ( ( reference_bounds . get_max_x ( ) + padding ) _ charge_bounds . get_min_x ( ) , n ( reference_bounds . get_min_y ( ) _ ( charge_bounds . get_height ( ) / codint ) ) _ charge_bounds . get_min_y ( ) ) n }	0
Q_4	string to date	C_4_0	public static date date_string_to_date ( string date_string ) { n simple_date_format sdf = new simple_date_format ( date_time_kit . full_date_24_hr_style ) n date date = null n try { n date = sdf . parse ( date_string ) n } catch ( parse_exception e ) { } n return date n }	1
Q_4	string to date	C_4_1	private date to_date ( final string p_string_date ) { n n / / weird manipulation to parse the date . remove codstr from the timezone n / / before codint _ codint _ codint t22 codint number + codint codint n / / after codint _ codint _ codint t22 codint number + codint n final string_builder _date = new string_builder ( ) n _date . append ( p_string_date . substring ( codint , p_string_date . length ( ) _ codint ) ) n _date . append ( p_string_date . substring ( p_string_date . length ( ) _ codint ) ) n try { n return new simple_date_format ( rfc_339_date_format ) . parse ( _date . to_string ( ) ) n } catch ( final parse_exception e ) { n throw new illegal_argument_exception ( n codstr , e ) n } n }	1
Q_4	string to date	C_4_2	public string to_date_str ( ) { n if ( null = this . time_zone ) { n final simple_date_format simple_date_format = new simple_date_format ( date_pattern . norm_date_pattern ) n simple_date_format . set_time_zone ( this . time_zone ) n return to_string ( simple_date_format ) n } n return to_string ( date_pattern . norm_date_format ) n }	0
Q_4	string to date	C_4_3	public static string date_to_str_long ( date date_date ) { n string date_string = formatter_long . format ( date_date ) n return date_string n }	0
Q_4	string to date	C_4_4	public static string date_to_str ( date date_date ) { n string date_string = formatter_short . format ( date_date ) n return date_string n }	0
Q_4	string to date	C_4_5	public string get_date_string_or_supplied_string ( string empty_date_string ) { n local_date date = get_date ( ) n return ( date = = null ) ? empty_date_string date . to_string ( ) n }	0
Q_5	string similarity levenshtein	C_5_0	public static int levenshtein_distance ( char_sequence s , char_sequence t ) n { n / / degenerate cases s n if ( s = = null codstr . equals ( s ) ) n { n return t = = null codstr . equals ( t ) ? codint t . length ( ) n } n else if ( t = = null codstr . equals ( t ) ) n { n return s . length ( ) n } n n / / create two work vectors of integer distances n int [ ] v0 = new int [ t . length ( ) + codint ] n int [ ] v1 = new int [ t . length ( ) + codint ] n n / / initialize v0 ( the previous row of distances ) n / / this row is a [ codint ] [ i ] edit distance for an empty s n / / the distance is just the number of characters to delete from t n for ( int i = codint i < v0 . length i + + ) n { n v0 [ i ] = i n } n n int s_len = s . length ( ) n int t_len = t . length ( ) n for ( int i = codint i < s_len i + + ) n { n / / calculate v1 ( current row distances ) from the previous	1
Q_5	string similarity levenshtein	C_5_1	public static double similar_levenshtein ( string s1 , string s2 ) { n if ( s1 . equals ( s2 ) ) { n return number n } n n / / make sure s1 is the longest string n if ( s1 . length ( ) < s2 . length ( ) ) { n string swap = s1 n s1 = s2 n s2 = swap n } n n int big_length = s1 . length ( ) n return ( big_length _ string_utils . get_levenshtein_distance ( s2 , s1 ) ) / ( double ) big_length n }	1
Q_5	string similarity levenshtein	C_5_2	public static double similarity ( string s1 , string s2 ) { n if ( s1 . equals ( s2 ) ) n return number n n / / ensure that s1 is shorter than or same length as s2 n if ( s1 . length ( ) > s2 . length ( ) ) { n string tmp = s2 n s2 = s1 n s1 = tmp n } n / * n * this list of boolean values is used for avoiding duplicated count of n * common characters in s2 n * / n list < boolean > is_common_char_in_s2 = new array_list < boolean > ( ) n for ( int i = codint i < s2 . length ( ) i + + ) { n is_common_char_in_s2 . add ( false ) n } n n / / ( codint ) find the number of characters the two strings have in common . n / / note that matching characters can only be half the length of the n / / longer string apart . n int maxdist = ( int ) math . floor ( s2 . length ( ) / codint ) n int c = codint / / count of common characters n int t = codint / / count of transpositions n int prevpos = _ codint n for ( int ix = codint ix < s1 . length ( ) ix + + ) { n char ch =	1
Q_5	string similarity levenshtein	C_5_3	public static double similar_damerau_levenshtein ( string s1 , string s2 ) { n if ( s1 . equals ( s2 ) ) { n return number n } n n / / make sure s1 is the longest string n if ( s1 . length ( ) < s2 . length ( ) ) { n string swap = s1 n s1 = s2 n s2 = swap n } n n int big_length = s1 . length ( ) n return ( big_length _ get_damerau_levenshtein_distance ( s2 , s1 ) ) / ( double ) big_length n }	1
Q_5	string similarity levenshtein	C_5_4	public int get_coverage1 ( ) { n if ( my_results_similarity1 < codint ) { n int distance = ca1_length + ca2_length _ codint * get_nr_eqr ( ) n n int similarity = ( ca1_length + ca2_length _ distance ) / codint n n my_results_similarity1 = math . round ( similarity / ( float ) ca1_length * codint ) n } n return my_results_similarity1 n }	0
Q_5	string similarity levenshtein	C_5_5	public static double string_similarity ( string s1 , string s2 , similarity_strats method ) { n switch ( method ) { n case dice n default return string_similarity_dice ( s1 , s2 ) n } n }	0
Q_5	string similarity levenshtein	C_5_6	private static void similar_str ( string txt1 , int len1 , string txt2 , int len2 , tuple t ) { n t . set_max ( codint ) n for ( int p = codint p < len1 + + p ) { n for ( int q = codint q < len2 + + q ) { n int l n for ( l = codint ( p + l < len1 ) ( q + l < len2 ) ( txt1 . char_at ( p + l ) = = txt2 . char_at ( q + l ) ) + + l ) { n n } n if ( l > t . get_max ( ) ) { n t . set_max ( l ) n t . set_pos1 ( p ) n t . set_pos2 ( q ) n } n } n } n }	0
Q_5	string similarity levenshtein	C_5_7	public void set_similarity_class ( string class_name ) n { n try n { n class < ? > similarity_class = class_loading . for_name ( class_name , this ) n similarity = ( similarity ) similarity_class . new_instance ( ) n } n catch ( class_not_found_exception e ) n { n log . warn ( codstr + class_name , e ) n } n catch ( instantiation_exception e ) n { n log . warn ( codstr + class_name , e ) n } n catch ( illegal_access_exception e ) n { n log . warn ( codstr + class_name , e ) n } n }	0
Q_6	sort multiple array base on another array sort order	C_6_0	"override n public void sort_atom_containers ( final comparator < i_atom_container > comparator ) { n n / / need to use boxed primitives as we can "" t customise sorting of int primitives n integer [ ] indexes = new integer [ atom_container_count ] n for ( int i = codint i < indexes . length i + + ) n indexes [ i ] = i n n / / proxy the index comparison to the atom container comparator n arrays . sort ( indexes , new comparator < integer > ( ) { n n override n public int compare ( integer o1 , integer o2 ) { n return comparator . compare ( atom_containers [ o1 ] , atom_containers [ o2 ] ) n } n } ) n n / / copy the original arrays ( we could modify in place with swaps but this is cleaner ) n i_atom_container [ ] containers_tmp = arrays . copy_of ( atom_containers , indexes . length ) n double [ ] multipliers_tmp = arrays . copy_of ( multipliers , indexes . length ) n n / / order the arrays based on the order of the indices n for ( int i = codint i < indexes . length i + + ) { n atom_containers [ i ] = containers_tmp [ indexes [ i ] ] n multipliers [ i ] = multipliers_tmp [ indexes [ i ] ] n } n n }"	1
Q_6	sort multiple array base on another array sort order	C_6_1	public static int [ ] sort ( double [ ] arr ) { n int [ ] order = new int [ arr . length ] n for ( int i = codint i < order . length i + + ) { n order [ i ] = i n } n sort ( arr , order ) n return order n }	1
Q_6	sort multiple array base on another array sort order	C_6_2	public static < t extends comparable < ? super t int [ ] sort ( t [ ] arr ) { n int [ ] order = new int [ arr . length ] n for ( int i = codint i < order . length i + + ) { n order [ i ] = i n } n sort ( arr , order ) n return order n }	1
Q_6	sort multiple array base on another array sort order	C_6_3	public void sort_indices ( sort_coupled_array_f64 sorter ) { n if ( sorter = = null ) n sorter = new sort_coupled_array_f64 ( ) n n sorter . quick ( col_idx , num_cols + codint , nz_rows , nz_values ) n indices_sorted = true n }	0
Q_6	sort multiple array base on another array sort order	C_6_4	"private void load_sort_keys ( ) { n / / cache sort key so we won "" t reload it each time n if ( sort_keys = null ) return n if ( orders = = null orders . length = = codint ) return n sort_keys = new array_list < list < bstr ( orders . length ) n for ( sort_order order orders ) { n set < bstr > sort_values = new hash_set < bstr > ( ) n load_sort_key ( order . items , codint , sort_values ) n list < bstr > sort_array = new array_list < bstr > ( sort_values ) n collections . sort ( sort_array ) n sort_keys . add ( sort_array ) n } n }"	0
Q_6	sort multiple array base on another array sort order	C_6_5	public double median ( ) n { n int [ ] sorted_array = this . to_sorted_array ( ) n int middle_index = sorted_array . length codint n if ( sorted_array . length > codint ( sorted_array . length codint ) = = codint ) n { n int first = sorted_array [ middle_index ] n int second = sorted_array [ middle_index _ codint ] n return ( ( double ) first + ( double ) second ) / number n } n return ( double ) sorted_array [ middle_index ] n }	0
Q_6	sort multiple array base on another array sort order	C_6_6	public double median ( ) n { n if ( this . is_empty ( ) ) n { n throw new arithmetic_exception ( ) n } n byte [ ] sorted_array = this . to_sorted_array ( ) n int middle_index = sorted_array . length codint n if ( sorted_array . length > codint ( sorted_array . length codint ) = = codint ) n { n byte first = sorted_array [ middle_index ] n byte second = sorted_array [ middle_index _ codint ] n return ( ( double ) first + ( double ) second ) / number n } n return ( double ) sorted_array [ middle_index ] n }	0
Q_7	sort string list	C_7_0	private list < string > get_keys_sorted ( ) { n list < string > sorted_list = new array_list < > ( get_keys ( ) ) n collections . sort ( sorted_list ) n return sorted_list n }	1
Q_7	sort string list	C_7_1	private list decode_sort ( string value ) { n array_list sorts = new array_list ( ) n n string [ ] name_and_sorts = value . split ( delim_grid_name ) n if ( name_and_sorts . length = codint ) n return null n n string namespace = name_and_sorts [ codint ] n string [ ] sort_strings = name_and_sorts [ codint ] . split ( delim_sort_term ) n n / / find the list of sorted columns n / / two columns of the bugs grid would be sorted as n / / n / / netui_sort = bugs id , _ priority n for ( int i = codint i < sort_strings . length i + + ) { n string sort = sort_strings [ i ] n sort_direction sort_direction = sort_direction . none n if ( sort . starts_with ( codstr ) ) n sort_direction = sort_direction . descending n else n sort_direction = sort_direction . ascending n string sort_expression = ( sort_direction = = sort_direction . descending ? sort . substring ( codint ) sort ) n sort grid_sort = _config . create_sort ( ) n grid_sort . set_sort_expression ( sort_expression ) n grid_sort . set_direction ( sort_direction ) n sorts . add ( grid_sort ) n } n n return sorts n }	1
Q_7	sort string list	C_7_2	public list_sort get_sort ( ) { n if ( sort = = null ) { n sort = new list_sort ( null , list_sort . sort_direction . asc ) n } n return sort n }	1
Q_7	sort string list	C_7_3	private list < string > convert_sort ( string sort_str ) { n list < string > list = new array_list < string > ( ) n if ( sort_str = null sort_str . length ( ) = codint ) { n list = arrays . as_list ( sort_str . split ( codstr ) ) n } n return list n }	0
Q_7	sort string list	C_7_4	override n public string sort_ignore_empty ( string list , string sort_type , string sort_order , string delimiter ) throws page_exception { n return lucee . runtime . type . util . list_util . sort_ignore_empty ( list , sort_type , sort_order , delimiter ) n }	0
Q_7	sort string list	C_7_5	public static void remove_sort_columns ( list < string > select_columns , list < string > sorts , list < boolean > ascending ) { n list < string > removed_sorts = new array_list < string > ( ) n for ( string sort sorts ) { n if ( contains_column_by_alias ( select_columns , sort ) ) { n removed_sorts . add ( sort ) n } n } n for ( string sort removed_sorts ) { n remove_sort_by_column_name ( sorts , ascending , sort ) n } n }	0
Q_8	socket recv timeout	C_8_0	private void set_socket_timeout ( int millis ) throws psql_exception { n try { n socket s = pg_stream . get_socket ( ) n if ( s . is_closed ( ) ) { / / is this check required ? n pg_stream . get_socket ( ) . set_so_timeout ( millis ) n } n } catch ( socket_exception e ) { n throw new psql_exception ( gt . tr ( codstr ) , n psql_state . connection_failure , e ) n } n }	1
Q_8	socket recv timeout	C_8_1	private byte_buffer recv ( int attempt ) n throws io_exception , socket_exception , socket_timeout_exception { n int timeout = udp_base_timeout_seconds * ( int ) math . pow ( codint , attempt ) n logger . trace ( codstr , n timeout , attempt ) n this . socket . set_so_timeout ( timeout * codint ) n n try { n datagram_packet p = new datagram_packet ( n new byte [ udp_packet_length ] , n udp_packet_length ) n this . socket . receive ( p ) n return byte_buffer . wrap ( p . get_data ( ) , codint , p . get_length ( ) ) n } catch ( socket_timeout_exception ste ) { n throw ste n } n }	1
Q_8	socket recv timeout	C_8_2	private int configure_socket_timeout ( int timeout ) { n n if ( provider instanceof socket_timeout_support ) { n try { n socket_timeout_support sock = ( socket_timeout_support ) provider n int ret = sock . get_so_timeout ( ) n sock . set_so_timeout ( timeout ) n return ret n } catch ( io_exception ex ) { n } n } n n return codint n }	1
Q_8	socket recv timeout	C_8_3	public static socket setup_socket ( socket socket , int socket_send_buffer_size , int socket_recv_buffer_size ) throws packet_transport_exception n { n try n { n socket . set_tcp_no_delay ( true ) n socket . set_send_buffer_size ( socket_send_buffer_size ) n socket . set_receive_buffer_size ( socket_recv_buffer_size ) n socket . set_keep_alive ( false ) n n return socket n } n catch ( socket_exception e ) n { n throw new packet_transport_exception ( codstr , e ) n } n }	1
Q_8	socket recv timeout	C_8_4	protected socket accept_socket ( int timeout ) n { n try n { n socket s = null n n if ( _listen = null ) n { n if ( _so_time_out = timeout ) n { n _so_time_out = timeout n _listen . set_so_timeout ( _so_time_out ) n } n n s = _listen . accept ( ) n n try n { n if ( get_max_idle_time_ms ( ) > = codint ) s . set_so_timeout ( get_max_idle_time_ms ( ) ) n if ( _linger_time_secs > = codint ) n s . set_so_linger ( true , _linger_time_secs ) n else n s . set_so_linger ( false , codint ) n } n catch ( exception e ) n { n log_support . ignore ( log , e ) n } n } n return s n } n catch ( java . net . socket_exception e ) n { n / / todo _ this is caught and ignored due strange n / / exception from linux javanumber . v1a n log_support . ignore ( log , e ) n } n catch ( interrupted_io_exception e ) n { n log_support . ignore ( log , e ) n } n catch ( io_exception e ) n { n log . warn ( log_support . exception , e ) n } n return null n }	1
Q_8	socket recv timeout	C_8_5	public checked_socket create_socket ( long timeout ) n throws connect_exception , socket_exception n { n socket socket = socket_connector . connect n ( m_addr , m_port , m_local_addr , m_local_port , timeout ) n if ( socket = = null ) { n throw new connect_exception ( codstr + timeout ) n } n try { n socket = m_ssl_factory . create_socket n ( socket , m_addr . get_host_address ( ) , m_port , true ) n } n catch ( io_exception e ) { n throw new socket_exception ( e . to_string ( ) ) n } n return checked_socket . check ( socket ) n }	1
Q_8	socket recv timeout	C_8_6	private byte [ ] recv ( socket socket , int flags ) n { n utils . check_argument ( socket = null , codstr ) n data = socket . recv ( flags ) n more = socket . has_receive_more ( ) n return data n }	1
Q_8	socket recv timeout	C_8_7	public checked_socket create_socket ( long timeout ) n throws connect_exception , socket_exception n { n socket socket = socket_connector . connect n ( m_addr , m_port , m_local_addr , m_local_port , timeout ) n if ( socket = = null ) { n throw new connect_exception ( codstr + timeout ) n } n return checked_socket . check ( socket ) n }	1
Q_8	socket recv timeout	C_8_8	private static void set_timeout ( socket socket , long timeout_ms ) { n try { n socket . set_so_timeout ( ( int ) timeout_ms ) n } catch ( socket_exception e ) { n throw new runtime_exception ( e ) n } n }	0
Q_9	set work directory	C_9_0	override n public void set_working_directory ( path new_dir ) { n log . debug ( codstr , new_dir . to_string ( ) ) n storage_client . set_working_directory ( new_dir ) n }	1
Q_9	set work directory	C_9_1	public void set_working_directory ( file working_dir ) { n assert . not_null ( working_dir , codstr ) n n logger . info ( codstr n + working_dir . get_absolute_path ( ) ) n n if ( working_dir . exists ( ) ) { n throw new illegal_argument_exception ( n codstr codstr codstr n + codstr n + codstr ) n } n n this . working_dir = working_dir n n service . set_working_directory ( working_dir ) n }	1
Q_9	set work directory	C_9_2	public void set_working_directory ( string path ) { n if ( path = null ) { n file dir = new file ( path ) n check_working_dir ( dir ) n working_dir = dir n } else { n working_dir = null n } n }	1
Q_9	set work directory	C_9_3	public void set_working_directory ( path dir ) throws io_exception { n ensure_state ( job_state . define ) n conf . set_working_directory ( dir ) n }	1
Q_9	set work directory	C_9_4	private void create_working_directory_if_not_exist ( file build_working_directory ) { n if ( assignment . should_clean_working_dir ( ) build_working_directory . exists ( ) ) { n try { n file_utils . clean_directory ( build_working_directory ) n go_publisher . consume_line_with_prefix ( codstr codstr codstr ) n } catch ( io_exception e ) { n bomb ( codstr + build_working_directory . get_absolute_path ( ) + codstr + e . get_message ( ) ) n } n } n if ( build_working_directory . exists ( ) ) { n if ( build_working_directory . mkdirs ( ) ) { n bomb ( codstr + build_working_directory . get_absolute_path ( ) ) n } n } n }	0
Q_9	set work directory	C_9_5	public void set_work_dir ( string dir ) throws io_exception n { n file work_dir = new file ( dir ) n n if ( work_dir . exists ( ) work_dir . can_write ( ) work_dir . can_read ( ) ) n { n throw new io_exception ( codstr + dir ) n } n _work_dir = work_dir n }	0
Q_9	set work directory	C_9_6	public void set_working_directory ( path dir ) { n if ( dir . is_absolute ( ) ) { n file_system . log_for_collect n . info ( codstr + dir n + codstr + get_working_directory ( ) ) n } n dir = new path ( get_working_directory ( ) , dir ) n set ( codstr , dir . to_string ( ) ) n }	0
Q_10	set file attrib hide	C_10_0	deprecated n public void set_hidden ( final boolean hidden ) { n if ( hidden = = null ) { n set_attribute_value ( null ) n } else { n set_attribute_value ( n hidden . boolean_value ( ) ? codstr string . value_of ( hidden ) ) n } n this . hidden = hidden n }	1
Q_10	set file attrib hide	C_10_1	implementation n protected void set_scale ( float sx , float sy ) { n set_ops . put ( scale , sx + codstr + sy ) n simple_matrix = simple_matrix . scale ( sx , sy ) n }	0
Q_10	set file attrib hide	C_10_2	private void set_hiddens ( i_terminal_consumer . hidden_consumers ) { n for ( i_terminal_consumer hidden this . hiddens ) n hidden . set_hidden ( false ) n this . hiddens = hidden_consumers n for ( i_terminal_consumer hidden this . hiddens ) n hidden . set_hidden ( true ) n }	0
Q_10	set file attrib hide	C_10_3	public string fix_property_name ( string name ) { n if ( codstr . equals_ignore_case ( name ) ) { n return codstr n } else if ( codstr . equals_ignore_case ( name ) ) { n return codstr n } n return js_utils . camelize ( name ) n }	0
Q_10	set file attrib hide	C_10_4	public static file write_arff ( training_corpus corpus , lexicon lexicon , n boolean b , string vector_location , n map < integer , integer > attribute_mapping ) throws io_exception { n file vector_file = new file ( vector_location ) n print_writer out = null n out = new print_writer ( new file_writer ( vector_file ) ) n n out . print ( codstr ) n n / / generate the arff headers n out . print ( codstr ) n n / / label values n out . print ( codstr ) n boolean is_first = true n for ( string l lexicon . get_labels ( ) ) { n if ( is_first ) n out . print ( codstr ) n out . print ( l ) n is_first = false n } n out . print ( codstr ) n n / / dump the content of the lexicon file n int attribute_num = lexicon . get_attributes_num ( ) n map < integer , string > iindex = lexicon . get_inverted_index ( ) n for ( int c = codint c < = attribute_num c + + ) { n string attrib = iindex . get ( c ) n if ( attrib = = null ) n attrib = codstr n else n attrib = attrib . replace_all ( codstr , codstr ) n attrib = attrib . replace_all ( codstr codstr quote codstr codstr codstr + c + codstr + attrib + codstr codstr attribute	0
Q_10	set file attrib hide	C_10_5	public list < i_hidden > get_hidden ( ) n { n for ( final i_hidden hidden this . hidden ) { n hidden . set_added ( false ) n } n return this . hidden n }	0
Q_10	set file attrib hide	C_10_6	public void set_hidden ( final boolean hidden ) { n if ( hidden ) n attr_mixin . set_attribute ( hidden , boolean . to_string ( true ) ) n else n attr_mixin . remove_attribute ( hidden ) n }	0
Q_10	set file attrib hide	C_10_7	public void create_hidden_field ( abstract_render_appender results ) n throws jsp_exception n { n if ( _rep_idx = = codint _disabled ) { n n servlet_request req = page_context . get_request ( ) n n / / create hidden field for state tracking n string hidden_param_name = null n hidden_param_name = get_qualified_data_source_name ( ) + oldvalue_suffix n _hidden_state . name = hidden_param_name n _hidden_state . value = codstr n n tag_rendering_base hidden_tag = tag_rendering_base . factory . get_rendering ( tag_rendering_base . input_hidden_tag , req ) n hidden_tag . do_start_tag ( results , _hidden_state ) n hidden_tag . do_end_tag ( results ) n } n n }	0
Q_11	send binary data over a serial connection	C_11_0	public void send_binary ( sensitive byte_buffer data , opcode_type type , boolean is_last ) throws io_exception { n n opcode_type t = type n n if ( message_write_state = = message_write_state . partial_text_in_use ) { n if ( tc . is_debug_enabled ( ) ) { n tr . debug ( tc , codstr ) n } n / / another send is outstanding on this connection , as per spec behaivor , need to throw an illegal_state_exception n illegal_state_exception up = new illegal_state_exception ( ) n throw up n } n n if ( message_write_state = = message_write_state . partial_not_in_use ) { n message_write_state = message_write_state . partial_binary_in_use n if ( is_last ) { n t = opcode_type . binary_whole n } else { n t = opcode_type . binary_partial_first n } n } else { n if ( is_last ) { n t = opcode_type . binary_partial_last n } else { n t = opcode_type . binary_partial_continuation n } n } n n try { n return_status ret = send_binary_common ( data , t , false ) n if ( ret = return_status . ok ) { n / / another write of an io frame is outstanding on this connection n illegal_state_exception up = new illegal_state_exception ( codstr ) n throw up n } n } finally { n if ( is_last = = true ) { n message_write_state = message_write_state . partial_not_in_use n } n } n }	1
Q_11	send binary data over a serial connection	C_11_1	override n public void send_binary ( sensitive byte_buffer partial_byte , boolean is_last ) throws io_exception { n if ( partial_byte = = null ) { n illegal_argument_exception up = new illegal_argument_exception ( ) n throw up n } n n impl . send_binary ( partial_byte , opcode_type . binary_whole , is_last ) n return n n }	1
Q_11	send binary data over a serial connection	C_11_2	public void send_binary ( sensitive byte_buffer data , opcode_type type ) throws io_exception { n n if ( message_write_state = message_write_state . partial_not_in_use ) { n if ( tc . is_debug_enabled ( ) ) { n tr . debug ( tc , codstr ) n } n / / another send is outstanding on this connection , as per spec behaivor , need to throw an illegal_state_exception n illegal_state_exception up = new illegal_state_exception ( ) n throw up n } n n return_status ret = send_binary_common ( data , type , false ) n if ( ret = return_status . ok ) { n / / another write of an io frame is outstanding on this connection n illegal_state_exception up = new illegal_state_exception ( codstr ) n throw up n } n }	1
Q_11	send binary data over a serial connection	C_11_3	"override n public channel_future go_away ( channel_handler_context ctx , int last_stream_id , long error_code , byte_buf debug_data , n channel_promise promise ) { n if ( ctx . channel ( ) . is_active ( ) ) { n / / there "" s no point of sending a goaway frame because the connection is over already . n promise . unvoid ( ) . try_success ( ) n debug_data . release ( ) n return promise n } n n return super . go_away ( ctx , last_stream_id , error_code , debug_data , promise ) n }"	0
Q_11	send binary data over a serial connection	C_11_4	public void send_one_way ( message_out message , int id , inet_address to ) n { n if ( logger . is_trace_enabled ( ) ) n logger . trace ( fb_utilities . get_broadcast_address ( ) + codstr + message . verb + codstr + id + codstr + to ) n n if ( to . equals ( fb_utilities . get_broadcast_address ( ) ) ) n logger . trace ( codstr , message ) n n / / message sinks are a testing hook n message_out processed_message = sink_manager . process_outbound_message ( message , id , to ) n if ( processed_message = = null ) n { n return n } n n / / get pooled connection ( really , connection queue ) n outbound_tcp_connection connection = get_connection ( to , processed_message ) n n / / write it n connection . enqueue ( processed_message , id ) n }	0
Q_12	scatter plot	C_12_0	public static plot_canvas plot ( string id , double [ ] [ ] data , int [ ] y , char [ ] legend , color [ ] palette ) { n if ( data [ codint ] . length = codint data [ codint ] . length = codint ) { n throw new illegal_argument_exception ( codstr + data [ codint ] . length ) n } n n double [ ] lower_bound = math . col_min ( data ) n double [ ] upper_bound = math . col_max ( data ) n plot_canvas canvas = new plot_canvas ( lower_bound , upper_bound ) n n scatter_plot plot = new scatter_plot ( data , y , legend , palette ) n plot . set_id ( id ) n canvas . add ( plot ) n n return canvas n }	1
Q_12	scatter plot	C_12_1	protected plot_canvas paint_on_canvas ( double [ ] [ ] data , int [ ] label ) { n plot_canvas canvas = scatter_plot . plot ( data , point_legend ) n for ( int i = codint i < data . length i + + ) { n canvas . point ( point_legend , palette . colors [ label [ i ] ] , data [ i ] ) n } n return canvas n }	1
Q_12	scatter plot	C_12_2	public scatter_plot points ( string id , double [ ] [ ] data , color color ) { n if ( data [ codint ] . length = base . dimension ) { n throw new illegal_argument_exception ( codstr + data [ codint ] . length ) n } n n double [ ] lower_bound = math . col_min ( data ) n double [ ] upper_bound = math . col_max ( data ) n extend_bound ( lower_bound , upper_bound ) n n scatter_plot plot = new scatter_plot ( data ) n plot . set_id ( id ) n plot . set_color ( color ) n add ( plot ) n n return plot n }	1
Q_12	scatter plot	C_12_3	public void add_scatter_plot ( string scatter_id , string x_axis_label , string y_axis_label ) throws shanks_exception { n if ( this . time_charts . contains_key ( scatter_id ) ) { n scatter_plot_generator scatter = new scatter_plot_generator ( ) n scatter . set_title ( scatter_id ) n scatter . set_x_axis_label ( x_axis_label ) n scatter . set_y_axis_label ( y_axis_label ) n this . scatter_plots . put ( scatter_id , scatter ) n } else { n throw new duplicated_chart_id_exception ( scatter_id ) n } n }	1
Q_12	scatter plot	C_12_4	public void scatter_plot ( matrix matrix , string . format ) throws exception { n matrix . export_to ( ) . file ( matrix_file ) . as_dense_csv ( ) n execute ( get_plot_command ( matrix , false , false ) ) n }	1
Q_12	scatter plot	C_12_5	public static final void plot ( frequency_domain fd , double min_mag , path out ) throws io_exception n { n int sample_count = fd . get_sample_count ( ) n plotter plotter = new plotter ( sample_count , sample_count / codint ) n fd . stream ( min_mag ) . for_each ( ( f ) _ > plotter . draw_line ( f . get_frequency ( ) , codint , f . get_frequency ( ) , f . get_magnitude ( ) ) ) n plotter . draw_coordinate_x ( ) n plotter . plot ( out . to_file ( ) , codstr ) n }	0
Q_12	scatter plot	C_12_6	public staircase_plot staircase ( string id , double [ ] [ ] data , color color ) { n if ( data [ codint ] . length = codint data [ codint ] . length = codint ) { n throw new illegal_argument_exception ( codstr + data [ codint ] . length ) n } n n staircase_plot plot = new staircase_plot ( data ) n plot . set_id ( id ) n plot . set_color ( color ) n add ( plot ) n return plot n }	0
Q_13	save list to file	C_13_0	public synchronized void save ( ) { n if ( bulk_change . contains ( this ) ) { n return n } n n file file = get_config_file ( ) n try { n list < string > all_signatures = new array_list < > ( whitelist_signatures_from_user_controlled_list ) n blacklist_signatures_from_user_controlled_list . stream ( ) n . map ( signature _ > codstr + signature ) n . for_each ( all_signatures add ) n n file_utils . write_lines ( file , all_signatures ) n } catch ( io_exception e ) { n logger . log ( level . warning , codstr + file . get_absolute_path ( ) , e ) n } n }	1
Q_13	save list to file	C_13_1	public void save_list_to ( final string file_name ) { n try { n print_stream stream = new print_stream ( new file ( file_name ) ) n print_list ( stream ) n stream . close ( ) n } catch ( file_not_found_exception e ) { n e . print_stack_trace ( ) n } n }	1
Q_13	save list to file	C_13_2	public static boolean save_to_file ( int type , collection < ? > list , file file ) { n buffered_writer out = null n try { n if ( type = = append ) { n out = new buffered_writer ( new file_writer ( file , true ) ) n } else { n out = new buffered_writer ( new file_writer ( file ) ) n } n n for ( object str list ) { n out . write ( str + carriage_return ) n } n out . close ( ) n return true n } catch ( exception e ) { n e . print_stack_trace ( ) n return false n } finally { n try { n if ( out = null ) { n out . close ( ) n } n } catch ( io_exception e ) { n e . print_stack_trace ( ) n } n } n }	1
Q_13	save list to file	C_13_3	public void save ( file file ) throws io_exception { n try ( file_output_stream fout = new file_output_stream ( file ) ) { n save ( fout ) n } n }	1
Q_13	save list to file	C_13_4	shell_method ( value = codstr ) n public list < string > history ( shell_option ( help = codstr , default_value = shell_option . null ) file file ) throws io_exception { n if ( file = = null ) { n list < string > result = new array_list < > ( j_line_history . size ( ) ) n j_line_history . for_each ( e _ > result . add ( e . line ( ) ) ) n return result n } else { n try ( file_writer w = new file_writer ( file ) ) { n for ( org . jline . reader . history . entry entry j_line_history ) { n w . append ( entry . line ( ) ) . append ( system . line_separator ( ) ) n } n } n return collections . singleton_list ( string . format ( codstr , j_line_history . size ( ) , file ) ) n } n }	1
Q_13	save list to file	C_13_5	public void save ( non_null file mean_file , non_null file std_file ) throws io_exception { n nd4j . save_binary ( get_mean ( ) , mean_file ) n nd4j . save_binary ( get_std ( ) , std_file ) n }	0
Q_13	save list to file	C_13_6	public void save ( file file ) throws io_exception { n try ( file_output_stream out = new file_output_stream ( file ) ) { n save ( out ) n } n }	0
Q_13	save list to file	C_13_7	public void save ( ) { n if ( cat_list_box = null ) cat_list_box . save ( ) n n if ( prefs = null ) { n if ( file_chooser = null ) n file_chooser . save ( ) n if ( catgen_file_chooser = null ) n catgen_file_chooser . save ( ) n prefs . put_int ( hdivider , split . get_divider_location ( ) ) n } n }	0
Q_14	replace in file	C_14_0	private void replace_in_file ( string old_text , string new_text ) { n string_builder old_content = new string_builder ( ) n n try ( file_reader fr = new file_reader ( file ) buffered_reader reader = new buffered_reader ( fr ) ) { n string line n while ( ( line = reader . read_line ( ) ) = null ) { n old_content . append ( line ) n old_content . append ( codstr ) n } n } catch ( io_exception e ) { n log . error ( e ) n } n n / / replace a word in a file n string new_content = old_content . to_string ( ) . replace_all ( old_text , new_text ) n n try ( file_writer writer = new file_writer ( file ) ) { n writer . write ( new_content ) n } catch ( io_exception ioe ) { n log . error ( ioe ) n } n }	1
Q_14	replace in file	C_14_1	public boolean replace_strings_in_file ( string file_path , map < string , string > replace_values , string output_file_path ) { n string method = codstr n if ( file_path = = null file_path . is_empty ( ) ) { n log . info ( c , method , codstr ) n return false n } n try { n log . info ( c , method , codstr + file_path ) n n file inp = new file ( file_path ) n input_stream_reader input_stream = new input_stream_reader ( new file_input_stream ( inp ) ) n buffered_reader data_stream = new buffered_reader ( input_stream ) n n vector < string > vec = new vector < string > ( codint , codint ) n n string current_line = null n boolean change_made = false n while ( ( current_line = data_stream . read_line ( ) ) = null ) { n for ( string key replace_values . key_set ( ) ) { n string orig_line = current_line n string replace_val = replace_values . get ( key ) n current_line = current_line . replace ( key , replace_val ) n if ( orig_line . equals ( current_line ) ) { n change_made = true n / / comment out for now to reduce size of output . txt n / / log . info ( c , method , codstr + key + codstr + replace_val + codstr ) n / / log . info ( c , method , codstr + orig_line	1
Q_14	replace in file	C_14_2	public static void replace_in_file ( file file , string regex , n string replacement ) n { n replace_in_file ( file . get_absolute_path ( ) , regex , replacement ) n }	1
Q_14	replace in file	C_14_3	override n protected file write_file_content ( string file_content ) throws io_exception { n n / / load the template n byte_array_output_stream out = new byte_array_output_stream ( ) n input_stream in = get_class ( ) . get_resource_as_stream ( codstr ) n utils . copy_stream_safely ( in , out ) n n / / copy the header in output_directory n input_stream h = get_class ( ) . get_resource_as_stream ( codstr ) n file img_file = new file ( this . output_directory , codstr ) n utils . copy_stream ( h , img_file ) n n / / create the target directory n file target_file = new file ( this . output_directory , codstr ) n utils . create_directory ( target_file . get_parent_file ( ) ) n n / / write the main file n string to_write = out . to_string ( codstr ) n . replace ( title_markup , this . application_template . get_name ( ) ) n . replace ( content_markup , file_content ) n . replace ( codstr , this . output_directory . get_absolute_path ( ) + codstr ) n . replace ( codstr , this . output_directory . get_absolute_path ( ) + codstr ) n . replace_all ( codstr , codstr ) n n utils . write_string_into ( to_write , target_file ) n return target_file n }	0
Q_14	replace in file	C_14_4	static string replace_slashes ( final string target ) { n string replaced = target n if ( replaced = null ) { n replaced = replaced . replace_all ( codstr , codstr ) n } n return replaced n }	0
Q_14	replace in file	C_14_5	public static void replace_file ( string file_name , final map < string , list < replacer profiles , charset charset ) n throws exception , file_not_found_exception { n file file = new file ( file_name ) n if ( file . is_file ( ) file . is_hidden ( ) ) { n list < replacer > replacers = profiles . get ( strings . substring_after_last ( file_name , codstr ) ) n if ( null = = replacers ) { return } n logger . info ( codstr , file_name ) n string filecontent = files . read_file_to_string ( file , charset ) n filecontent = replacer . process ( filecontent , replacers ) n write_to_file ( filecontent , file_name , charset ) n } else { n string [ ] sub_files = file . list ( new filename_filter ( ) { n public boolean accept ( file dir , string name ) { n if ( dir . is_directory ( ) ) return true n boolean matched = false n for ( string key profiles . key_set ( ) ) { n matched = name . ends_with ( key ) n if ( matched ) return true n } n return false n } n } ) n if ( null = sub_files ) { n for ( int i = codint i < sub_files . length i + + ) { n replace_file ( file_name + codstr + sub_files [ i ] , profiles , charset )	0
Q_15	regex case insensitive	C_15_0	public static int index_of_ignore_case ( string text , string str , int start_index ) { n matcher m = pattern . compile ( pattern . quote ( str ) , pattern . case_insensitive ) . matcher ( text ) n return m . find ( start_index ) ? m . start ( ) _ codint n }	1
Q_15	regex case insensitive	C_15_1	private static pattern regex_to_pattern_or_null ( string regex ) { n if ( regex = null regex . is_empty ( ) regex . equals ( codstr ) ) { n return pattern . compile ( regex ) n } n return null n }	1
Q_15	regex case insensitive	C_15_2	private void set_up_text_view11 ( view view ) { n / / setup single span n text_view tv11 = ( text_view ) view . find_view_by_id ( r . id . tv11 ) n n char_sequence formatted_text11 = trestle . get_formatted_text ( n new span . builder ( codstr ) n . regex ( new regex ( codstr , regex . case_insensitive ) ) n . foreground_color ( get_context ( ) , r . color . green_500 ) n . background_color ( get_context ( ) , r . color . red_200 ) n . typeface ( bold_italic_font ) n . build ( ) ) n n tv11 . set_text ( formatted_text11 ) n }	1
Q_15	regex case insensitive	C_15_3	public static pattern convert_object_name_regex ( string regex ) { n string j_regex = regex . replace ( codstr , codstr ) . replace ( codstr , codstr ) n return pattern . compile ( j_regex ) n }	1
Q_15	regex case insensitive	C_15_4	public static boolean match_regex ( string str , string regex ) { n try { n return str . matches ( regex ) n } catch ( pattern_syntax_exception e ) { n log . error ( codstr , regex ) n return false n } n }	0
Q_15	regex case insensitive	C_15_5	public case_insensitive_regex_hash_map to_case_insensitive_regex_multi_map ( list < t > entries ) { n case_insensitive_regex_hash_map case_insensitive_regex_hash_map = new case_insensitive_regex_hash_map ( ) n if ( entries = null ) { n for ( key_and_value key_to_multi_value entries ) { n case_insensitive_regex_hash_map . put ( key_to_multi_value . get_name ( ) , key_to_multi_value . get_value ( ) ) n } n } n return case_insensitive_regex_hash_map n }	0
Q_15	regex case insensitive	C_15_6	private static boolean match_rule_regex ( string regex , string value ) { n n if ( value = = null ) { n value = codstr n } n n if ( regex = = null ) { n return true n } n if ( ( regex . length ( ) > codint ) ( regex . char_at ( codint ) = = codstr ) ) { n return value . matches ( regex . substring ( codint ) ) n } else { n return value . matches ( regex ) n } n }	0
Q_15	regex case insensitive	C_15_7	public static string create_like_regex ( string expr , boolean ignore_case ) n { n string regex = create_regex ( expr , ignore_case ) n regex = regex . replace ( codstr , codstr ) . replace ( codstr , codstr ) n n return regex n }	0
Q_15	regex case insensitive	C_15_8	public boolean is_case_sensitive ( ) { n switch ( get_jcr_type ( ) ) { n case property_type . double n case property_type . long n case property_type . decimal n case property_type . weakreference n case property_type . reference / / conversion is case _ insensitive n case property_type . boolean / / conversion is case _ insensitive n return false n } n return true n }	0
Q_16	readonly array	C_16_0	"private not_null list < ? > read_array ( not_null array array ) { n try { n boolean allow_nulls = type_utils . is_primitive ( element_type ) n result_set result_set = array . get_result_set ( ) n try { n named_type_list types = named_type_list . builder ( codint ) . add ( codstr , result_set_utils . get_column_type ( result_set . get_meta_data ( ) , codint ) ) . build ( ) n instantiator < ? > ctor = instantiator_registry . find_instantiator ( element_type , types ) n array_list < object > result = new array_list < > ( ) n n / / for performance reasons we reuse the same arguments _ array and instantiator_arguments _ object for all rows . n / / this should be fine as long as the instantiators don codstr expected codstr , but got null "" ) n } n n return result n n } finally { n try { n result_set . close ( ) n } finally { n sql_utils . free_array ( array ) n } n } n n } catch ( sql_exception e ) { n throw new database_sql_exception ( e ) n } n }"	0
Q_16	readonly array	C_16_1	public void switch_read_only_connection ( boolean must_be_read_only ) throws sql_exception { n if ( url_parser . get_options ( ) . assure_read_only current_read_only_asked = must_be_read_only ) { n proxy . lock . lock ( ) n try { n / / verify not updated now that hold lock , double check safe due to volatile n if ( current_read_only_asked = must_be_read_only ) { n current_read_only_asked = must_be_read_only n set_session_read_only ( must_be_read_only , current_protocol ) n } n } finally { n proxy . lock . unlock ( ) n } n } n }	0
Q_16	readonly array	C_16_2	public static list < string > get_read_only_list ( string read_only_name ) { n list ret_list = new array_list ( ) n string read_only_str = ( string ) read_only_map . get ( read_only_name ) n if ( read_only_str = null ) { n string [ ] temp_array = read_only_str . split ( codstr ) n ret_list = arrays . as_list ( temp_array ) n } n return ret_list n }	0
Q_16	readonly array	C_16_3	protected void read_only_updated ( ) { n boolean local_read_only = is_read_only ( ) n if ( has_changed ( old_read_only , local_read_only ) ) { n old_read_only = local_read_only n fire_property_change ( readonly_property , local_read_only , local_read_only ) n } n }	0
Q_16	readonly array	C_16_4	private object read_new_array ( boolean unshared ) throws optional_data_exception , n class_not_found_exception , io_exception { n object_stream_class class_desc = read_class_desc ( ) n n if ( class_desc = = null ) { n throw missing_class_descriptor ( ) n } n n int new_handle = next_handle ( ) n n / / array size n int size = input . read_int ( ) n class < ? > array_class = class_desc . for_class ( ) n class < ? > component_type = array_class . get_component_type ( ) n object result = array . new_instance ( component_type , size ) n n register_object_read ( result , new_handle , unshared ) n n / / now we have code duplication just because java is typed . we have to n / / read n elements and assign to array positions , but we must typecast n / / the array first , and also call different methods depending on the n / / elements . n if ( component_type . is_primitive ( ) ) { n if ( component_type = = int . class ) { n int [ ] int_array = ( int [ ] ) result n for ( int i = codint i < size i + + ) { n int_array [ i ] = input . read_int ( ) n } n } else if ( component_type = = byte . class ) { n byte [ ] byte_array = ( byte [ ] ) result n	0
Q_16	readonly array	C_16_5	suppress_warnings ( codstr ) n public json_navi < t > array ( ) { n if ( failure ) n return this n if ( current = = null readonly ) n failure ( codstr , null ) n if ( current = null ) { n if ( is_array ( ) ) n return this n if ( is_object ( ) ) n failure ( codstr , null ) n failure ( codstr , null ) n } else { n current = mapper . create_array ( ) n } n if ( root = = null ) n root = ( t ) current n else n store ( ) n return this n }	0
Q_16	readonly array	C_16_6	public void set_external_array_data ( external_array_data array ) n { n external_data = array n n if ( array = = null ) { n delete ( codstr ) n } else { n / / define codstr to return whatever length the list gives us . n define_property ( codstr , null , n get_array_length , null , readonly dontenum ) n } n }	0
Q_16	readonly array	C_16_7	public object [ ] read_amf0_array ( ) throws io_exception { n int length = in . read_int ( ) n n object [ ] arr = new object [ length ] n for ( int i = codint i < length i + + ) { n arr [ i ] = decode_amf0 ( ) n } n n amf0_object_references . add ( arr ) n return arr n }	0
Q_16	readonly array	C_16_8	public void set_read_only ( boolean read_only ) { n this . read_only = read_only n fire_property_change ( read_only_property , old_read_only , is_read_only ( ) ) n old_read_only = is_read_only ( ) n }	0
Q_17	read element from html _ td	C_17_0	public html_element find_html_element_by_id ( string element_id ) { n try { n return html_page . get_html_element_by_id ( element_id ) n } catch ( element_not_found_exception e ) { n return null n } n }	1
Q_17	read element from html _ td	C_17_1	static void read_wmo_xml_table_b ( input_stream ios , table_b b ) throws io_exception { n org . jdom2 . document doc n try { n sax_builder builder = new sax_builder ( ) n doc = builder . build ( ios ) n } catch ( jdom_exception e ) { n throw new io_exception ( e . get_message ( ) ) n } n n element root = doc . get_root_element ( ) n n string [ ] elems = null n for ( version v version . values ( ) ) { n elems = v . get_elem_names_b ( ) n list < element > feat_list = root . get_children ( elems [ codint ] ) n if ( feat_list = null feat_list . size ( ) > codint ) { n break n } n } n n / / if not found using element name , assume its bufr_wmo n if ( elems = = null ) { n elems = version . bufr_wmo . get_elem_names_b ( ) n } n n list < element > feat_list = root . get_children ( ) n for ( element elem feat_list ) { n element ce = elem . get_child ( elems [ codint ] ) n if ( ce = = null ) continue n n string name = util . clean_name ( elem . get_child_text_normalize ( elems [ codint ] ) ) n string units = clean_unit ( elem . get_child_text_normalize ( codstr ) ) n int x	1
Q_17	read element from html _ td	C_17_2	private string get_html_for_pdf_conversion ( ) throws io_exception { n string_builder old_content = new string_builder ( ) n n file_reader fr = new file_reader ( file ) n try ( buffered_reader reader = new buffered_reader ( fr ) ) { n string line n while ( ( line = reader . read_line ( ) ) = null ) { n old_content . append ( line ) n old_content . append ( codstr ) n } n } n n / / replace all non convertible elements with empty text or modify for conversion n string str = old_content . to_string ( ) n . replace_all ( codstr text / javascript codstr , codstr ) n . replace_all ( codstr , codstr ) n . replace_all ( codstr , codstr ) n n string image_pattern = codstr ( . * ? ) codstr n pattern r = pattern . compile ( image_pattern ) n matcher m = r . matcher ( str ) n int image_count = codint n while ( m . find ( ) ) { n str = str . replace_first ( codstr javascript void ( codint ) codstr ( . * ? ) codstr + n codstr , n codstr # image _ codstr codstr ) n str = str . replace_first ( codstr , codstr page _ break _ before always codstr image _ codstr codstr + n codstr + n m . group ( ) . replace_all ( codstr codint px codstr > codstr height =	0
Q_17	read element from html _ td	C_17_3	private int _check_inline_html ( final markdown_hc_stack out , final string in , final int n_start ) n { n final string_builder a_tmp = new string_builder ( ) n n / / check for auto links n a_tmp . set_length ( codint ) n int n_pos = markdown_helper . read_until ( a_tmp , in , n_start + codint , codstr , codstr , codstr , codstr ) n if ( n_pos = _ codint in . char_at ( n_pos ) = = codstr markdown_html . is_link_prefix ( a_tmp . to_string ( ) ) ) n { n n_pos = markdown_helper . read_until ( a_tmp , in , n_pos , codstr ) n if ( n_pos = _ codint ) n { n final string s_link = a_tmp . to_string ( ) n final hca a_link = m_a_config . get_decorator ( ) . open_link ( out ) n a_link . set_href ( new simple_url ( s_link ) ) . add_child ( s_link ) n m_a_config . get_decorator ( ) . close_link ( out ) n return n_pos n } n } n n / / check for mailto or address auto link n a_tmp . set_length ( codint ) n n_pos = markdown_helper . read_until ( a_tmp , in , n_start + codint , codstr , codstr , codstr , codstr ) n if ( n_pos = _ codint in . char_at ( n_pos ) = = codstr ) n { n n_pos = markdown_helper . read_until ( a_tmp , in	0
Q_17	read element from html _ td	C_17_4	private void print_fields_array_table_header ( string [ ] fields_array , print_writer html ) { n html . append ( codstr codint codstr codint codstr codint codstr codint codstr silver codstr n + codstr ) n for ( string element fields_array ) { n html n . append ( codstr top codstr ) n html . append ( element ) n html . append ( codstr ) n } n html . append ( codstr ) n }	0
Q_18	read text file line by line	C_18_0	private string get_text_line ( search_location loc ) n { n try ( buffered_reader reader = path_util . create_reader ( get_node ( ) . get_file ( ) . get_file_or_dir ( ) ) ) n { n for ( int line = codint line < loc . _i_line line + + ) n { n string text_line = reader . read_line ( ) n if ( line = = loc . _i_line _ codint ) n { n return text_line n } n } n } n catch ( exception e ) n { n throw new runtime_exception ( e ) n } n return codstr n }	1
Q_18	read text file line by line	C_18_1	public void get_value ( string_buffer res ) throws sigar_exception { n string line , last_line = codstr n try { n while ( ( line = get_reader ( ) . read_line ( ) ) = null ) { n log . debug ( codstr + line ) n last_line = line n } n res . append ( last_line ) n } catch ( io_exception e ) { n log . error ( codstr + filename ) n } n }	1
Q_18	read text file line by line	C_18_2	protected void read_line_by_line ( ) { n string line n try { n while ( ( line = data . read_line ( ) ) = null ) { n / / system . out . println ( line ) n object_node interaction = ( object_node ) data_sift_client . mapper . read_tree ( line ) n send ( new interaction ( interaction ) ) n } n buffer . discard_read_bytes ( ) n } catch ( io_exception e ) { n log . info ( codstr , e ) n } n }	1
Q_18	read text file line by line	C_18_3	public static string read_input_text_line ( ) { n buffered_reader line_of_text = new buffered_reader ( new input_stream_reader ( n system . in ) ) n string text_line = null n try { n text_line = line_of_text . read_line ( ) n } catch ( io_exception e ) { n e . print_stack_trace ( ) n } n return text_line n }	1
Q_18	read text file line by line	C_18_4	protected void read_lines ( ) { n line_number = line_reader . get_current_line_number ( ) n string line = line_reader . get_current_line ( ) n if ( line = null line . length ( ) > codint ) { n / / remove double spaces . n line = flat_file_utils . shrink ( line ) n read_line ( line ) n } n }	1
Q_18	read text file line by line	C_18_5	protected void read_line ( int line_number , string line ) throws line_exception { n matcher matcher = get_accepted_line_pattern ( ) . matcher ( line ) n if ( matcher . find ( ) ) { n process_line ( line_number , line , matcher ) n } else { n if ( is_header_line ( line ) ) { n throw new line_exception ( line_number , line , new exception ( codstr ) , false ) n } n } n }	0
Q_18	read text file line by line	C_18_6	public static void write_file ( array_list < string > content , string rule_file ) { n array_list < string > output = new array_list < string > ( ) n file file = new file ( rule_file ) n buffered_writer reader = null n try { n reader = new buffered_writer ( new file_writer ( file ) ) n n / / read rules line by line to construct the regular expression n for ( string line content ) { n reader . write ( line + codstr ) n } n reader . close ( ) n } catch ( file_not_found_exception e ) { n e . print_stack_trace ( ) n } catch ( io_exception e ) { n e . print_stack_trace ( ) n } n n }	0
Q_18	read text file line by line	C_18_7	private boolean is_binary ( ) { n try ( input_stream in = get_input_stream ( ) ) { n long size = files . size ( file . to_path ( ) ) n if ( size = = codint ) { n / / empty file , so no need to check n return true n } n n byte [ ] b = new byte [ ( size < stream_utils . default_probe_size ? ( int ) size stream_utils . default_probe_size ) ] n int read = in . read ( b ) n if ( read = b . length ) { n / / something went wrong , so better not to read line by line n return true n } n n return stream_utils . is_non_whitespace_control_character ( b ) n } catch ( io_exception e ) { n / / if cannot be checked , then considered as binary , so we do not n / / read line by line n return true n } n }	0
Q_19	read property file	C_19_0	public static properties read_properties_from_file ( file file ) n throws io_exception { n try ( file_input_stream fis = new file_input_stream ( file ) ) { n properties prop = new properties ( ) n prop . load ( fis ) n return prop n } n }	1
Q_19	read property file	C_19_1	public static properties read_properties ( file file ) { n try { n return read_properties ( new file_input_stream ( file ) ) n } catch ( file_not_found_exception e ) { n return new properties ( ) n } n }	1
Q_19	read property file	C_19_2	private void read_property_file ( string prop_file ) { n file file = null n if ( prop_file = null prop_file . is_empty ( ) ) { n file = new file ( prop_file ) n } n if ( file = = null file . exists ( ) ) { n file = new file ( cloud_conductor_property_provider . cloudconductor_prop_file_default_path ) n } n if ( file . exists ( ) ) { n try ( input_stream reader = new file_input_stream ( file ) ) { n properties prop = new properties ( ) n prop . load ( reader ) n if ( this . server = = null prop . contains_key ( cloud_conductor_property_provider . cloudconductor_url ) ) { n this . server = prop . get_property ( cloud_conductor_property_provider . cloudconductor_url ) n } n if ( this . template = = null prop . contains_key ( cloud_conductor_property_provider . template_name ) ) { n this . template = prop . get_property ( cloud_conductor_property_provider . template_name ) n } n if ( this . jwt = = null prop . contains_key ( cloud_conductor_property_provider . cloudconductor_prop_file_token ) ) { n this . jwt = this . get_auth_token ( prop . get_property ( cloud_conductor_property_provider . cloudconductor_prop_file_token ) ) n } n } catch ( io_exception ex ) { n this . logger . warn ( codstr { } codstr , file ) n } n } n }	1
Q_19	read property file	C_19_3	private properties read_property_file ( string file ) throws io_exception { n string file_name = file . starts_with ( codstr ) ? file codstr + file n logger . info ( codstr + file_name + codstr ) n return util . read_properties ( file_name ) n }	1
Q_19	read property file	C_19_4	public static properties read_properties_from_file ( string _file_name , properties _props ) { n properties props = _props = = null ? new properties ( ) _props n n logger . debug ( codstr + _file_name ) n properties new_properties = read_properties ( new file ( _file_name ) ) n if ( new_properties = null ) { n logger . debug ( codstr + _file_name ) n props . put_all ( new_properties ) n } n n return props n }	1
Q_19	read property file	C_19_5	private void read_property_file ( ) n { n java . util . properties props = new java . util . properties ( ) n try n { n file property_file = new file ( property_file_path + file . separator + propertyfilename ) n if ( property_file . exists ( ) ) n { n java . io . file_input_stream fis = null n try n { n fis = new java . io . file_input_stream ( property_file ) n props . load ( fis ) n } n finally n { n if ( fis = null ) try { fis . close ( ) } catch ( io_exception ex ) { log . error ( codstr , ex ) } n } n } n n search_path = props . get_property ( property_searchpath , helpers . homedir ) n export_path = props . get_property ( property_exportpath , helpers . homedir ) n ui_class_name = props . get_property ( property_lookandfeel , javax . swing . ui_manager . get_system_look_and_feel_class_name ( ) ) n use_system_tray = boolean . parse_boolean ( props . get_property ( property_systemtray , codstr ) ) n current_volume = float . parse_float ( props . get_property ( property_volume_value , codstr ) ) n current_balance = float . parse_float ( props . get_property ( property_balance_value , codstr ) ) n last_loaded = new array_list < url > ( property_lastloaded_maxentries ) n for ( int i = codint i < property_lastloaded_maxentries i + + ) n { n string url	1
Q_19	read property file	C_19_6	private void read_properties_files ( ) { n n if ( this . message_file_wildcard . is_empty ( ) core_parameters . log_resolution . get ( ) ) { n / / skip configuration loading n logger . info ( j_rebirth_markers . message , codstr ) n n } else { n / / assemble the regex pattern n final pattern file_pattern = pattern . compile ( this . message_file_wildcard + codstr ) n n / / retrieve all resources from default classpath n final collection < string > list = classpath_utility . get_classpath_resources ( file_pattern ) n n logger . info ( j_rebirth_markers . message , codstr , list . size ( ) , list . size ( ) > codint ? codstr codstr ) n n for ( final string rb_filename list ) { n read_properties_file ( rb_filename ) n } n } n }	1
Q_19	read property file	C_19_7	"private synchronized void read_properties ( ) { n try { n property_file_uri = catalog_manager . class . get_resource ( codstr + property_file ) n input_stream in = n catalog_manager . class . get_resource_as_stream ( codstr + property_file ) n if ( in = = null ) { n if ( ignore_missing_properties ) { n system . err . println ( codstr + property_file ) n / / there codstr cannot read codstr failure trying to read codstr ve successfully read the properties , n / / use them to set the default debug level , if the user hasn codstr verbosity "" ) n int verb = integer . parse_int ( verb_str . trim ( ) ) n debug . set_debug ( verb ) n verbosity = new integer ( verb ) n } catch ( exception e ) { n / / nop n } n } n }"	1
Q_20	randomly extract x item from a list	C_20_0	private < t > list < t > extract_random_list ( list < t > elements , int count ) { n random . shuffle ( elements ) n return elements . sub_list ( codint , count ) n }	1
Q_20	randomly extract x item from a list	C_20_1	public static < t > list < t > random_sample ( collection < t > collection , int n ) { n list < t > list = new array_list < t > ( collection ) n list < t > sample = new array_list < t > ( n ) n random random = new random ( ) n while ( n > codint list . is_empty ( ) ) { n int index = random . next_int ( list . size ( ) ) n sample . add ( list . get ( index ) ) n int index_last = list . size ( ) _ codint n t last = list . remove ( index_last ) n if ( index < index_last ) { n list . set ( index , last ) n } n n _ n } n return sample n }	1
Q_20	randomly extract x item from a list	C_20_2	public static < e > list < e > extract_random_sub_list ( random random , list < e > list , double . thresholds ) { n int size = generate_random_int_from_thresholds ( random , thresholds ) n if ( size > list . size ( ) ) { n size = list . size ( ) n } n return extract_random_sub_list_of_size ( random , list , size ) n }	1
Q_20	randomly extract x item from a list	C_20_3	public < t > list < t > random_elements ( list < t > elements , int count ) { n if ( elements . size ( ) > = count ) { n return extract_random_list ( elements , count ) n } else { n list < t > random_elements = new array_list < t > ( ) n random_elements . add_all ( extract_random_list ( elements , count elements . size ( ) ) ) n do { n random_elements . add_all ( extract_random_list ( elements , elements . size ( ) ) ) n } while ( random_elements . size ( ) < count ) n return random_elements n } n }	1
Q_20	randomly extract x item from a list	C_20_4	public void add_extract_result_item ( extract_result_item extract_result_item ) { n list < extract_result_item > list = extract_result_items . get ( extract_result_item . get_field ( ) ) n if ( list = = null ) { n list = new array_list < > ( ) n extract_result_items . put ( extract_result_item . get_field ( ) , list ) n } n list . add ( extract_result_item ) n }	0
Q_20	randomly extract x item from a list	C_20_5	public list < demo_item > moar_items ( int qty ) { n list < demo_item > items = new array_list < > ( ) n n for ( int i = codint i < qty i + + ) { n int col_span = math . random ( ) < numberf ? codint codint n / / swap the next codint lines to have items with variable n / / column / row span . n / / int row_span = math . random ( ) < numberf ? codint codint n int row_span = col_span n demo_item item = new demo_item ( col_span , row_span , current_offset + i ) n items . add ( item ) n } n n current_offset + = qty n n return items n }	0
Q_20	randomly extract x item from a list	C_20_6	suppress_warnings ( codstr ) n public static < t > list < t > range ( iterable < t > items , int from , int to ) { n u . must ( from < = to , codstr from codstr to codstr , from , to ) n n if ( from = = to ) { n return collections . empty_list ( ) n } n n if ( items instanceof results ) { n results results = ( results ) items n return results . page ( from , to _ from ) n } n n list < ? > list = ( items instanceof list < ? > ) ? ( list < ? > ) items u . list ( items ) n n from = math . min ( from , list . size ( ) ) n to = math . min ( to , list . size ( ) ) n n return u . cast ( list . sub_list ( from , to ) ) n }	0
Q_20	randomly extract x item from a list	C_20_7	"public list < point2_d3_d > create_observations ( se3_f64 world_to_camera , int total ) { n n se3_f64 camera_to_world = world_to_camera . invert ( null ) n n / / transform from pixel coordinates to normalized pixel coordinates , which removes lens distortion n point2_transform2_f64 pixel_to_norm = lens_distortion_factory . narrow ( intrinsic ) . undistort_f64 ( true , false ) n n list < point2_d3_d > observations = new array_list < > ( ) n n point2_d_f64 norm = new point2_d_f64 ( ) n for ( int i = codint i < total i + + ) { n / / randomly pixel a point inside the image n double x = rand . next_double ( ) * intrinsic . width n double y = rand . next_double ( ) * intrinsic . height n n / / convert to normalized image coordinates because that codstr t process pixel coordinates n pixel_to_norm . compute ( x , y , norm ) n n / / randomly pick a depth and compute codreal coordinate n double z = rand . next_double ( ) + codint n double x = norm . x * z n double y = norm . y * z n n / / change the point "" s reference frame from camera to world n point3_d_f64 camera_pt = new point3_d_f64 ( x , y , z ) n point3_d_f64 world_pt = new point3_d_f64 ( ) n n se_point_ops_f64 . transform ( camera_to_world , camera_pt , world_pt )"	0
Q_20	randomly extract x item from a list	C_20_8	public static < t > list < t > random_list_from ( iterable < t > elements , range < integer > size ) { n check_argument ( is_empty ( elements ) , codstr ) n return random_list_from ( ( ) _ > iterable_utils . random_from ( elements ) , size ) n }	0
Q_20	randomly extract x item from a list	C_20_9	public static < t extends eureka_endpoint > list < t > randomize ( list < t > list ) { n list < t > random_list = new array_list < > ( list ) n if ( random_list . size ( ) < codint ) { n return random_list n } n random random = new random ( local_ipv4_address . hash_code ( ) ) n int last = random_list . size ( ) _ codint n for ( int i = codint i < last i + + ) { n int pos = random . next_int ( random_list . size ( ) _ i ) n if ( pos = i ) { n collections . swap ( random_list , i , pos ) n } n } n return random_list n }	0
Q_21	priority queue	C_21_0	suppress_warnings ( codstr ) n override n public priority_queue read_object ( o_input in , class < priority_queue > clazz ) throws io_exception { n int size = natural_number_io_helper . read_natural_number ( in ) n n comparator comparator = ( comparator ) in . read_object ( ) n priority_queue queue = new priority_queue ( size , comparator ) n n for ( int i = codint i < size i + + ) { n queue . add ( in . read_object ( ) ) n } n n return queue n }	1
Q_21	priority queue	C_21_1	public priority_queue < pair < t , double as_priority_queue ( ) { n priority_queue < pair < t , double pq = new priority_queue < > ( math . max ( codint , map . size ( ) ) , new pair_comparator ( ) ) n for ( map . entry < t , atomic_double > entry map . entry_set ( ) ) { n pq . add ( pair . create ( entry . get_key ( ) , entry . get_value ( ) . get ( ) ) ) n } n n return pq n }	1
Q_21	priority queue	C_21_2	safe_varargs n public static < t > priority_queue < t > as_priority_queue ( final t . a ) { n if ( n . is_null_or_empty ( a ) ) { n return new priority_queue < > ( ) n } n n final priority_queue < t > queue = new priority_queue < > ( a . length ) n n for ( t e a ) { n queue . add ( e ) n } n n return queue n }	1
Q_21	priority queue	C_21_3	synchronized int size ( int priority ) { n if ( priority < codint priority > = level ) { n throw new illegal_argument_exception ( codstr + priority ) n } n return priority_queues . get ( priority ) . size ( ) n }	1
Q_21	priority queue	C_21_4	public void send ( queue queue , message message , int delivery_mode , int priority , long time_to_live ) throws jms_exception { n if ( trace_component . is_any_tracing_enabled ( ) tc . is_entry_enabled ( ) ) sib_tr . entry ( this , tc , codstr , new object [ ] { queue , message , delivery_mode , priority , time_to_live } ) n super . send ( queue , message , delivery_mode , priority , time_to_live ) n if ( trace_component . is_any_tracing_enabled ( ) tc . is_entry_enabled ( ) ) sib_tr . exit ( this , tc , codstr ) n }	1
Q_21	priority queue	C_21_5	public priority set_priority ( integer priority ) { n priority prop = ( priority = = null ) ? null new priority ( priority ) n set_priority ( prop ) n return prop n }	0
Q_21	priority queue	C_21_6	override n public final void set_priority ( int priority ) throws jms_exception n { n if ( priority < codint priority > codint ) n throw new ffmq_exception ( codstr + priority , codstr ) n n this . default_priority = priority n }	0
Q_22	print model summary	C_22_0	private void print_summary ( pmml pmml ) { n memory_measurer measurer = new memory_measurer ( ) n measurer . apply_to ( pmml ) n n number_format number_format = number_format . get_instance ( locale . us ) n number_format . set_grouping_used ( true ) n n long size = measurer . get_size ( ) n system . out . println ( codstr + number_format . format ( size ) ) n n set < object > objects = measurer . get_objects ( ) n system . out . println ( codstr + number_format . format ( objects . size ( ) ) ) n }	1
Q_22	print model summary	C_22_1	public static map < string , model_summary > generate_model_summaries ( set < string > keys , map < string , model > models , boolean find_compatible_frames , map < string , frame > all_frames , map < string , set < string all_frames_cols ) { n map < string , model_summary > model_summaries = new tree_map < string , model_summary > ( ) n n if ( null = = keys ) { n keys = models . key_set ( ) n } n n for ( string key keys ) { n model_summary summary = new model_summary ( ) n models . summarize_and_enhance_model ( summary , models . get ( key ) , find_compatible_frames , all_frames , all_frames_cols ) n model_summaries . put ( key , summary ) n } n n return model_summaries n }	1
Q_22	print model summary	C_22_2	public void write_summary ( string s ) { n if ( summary_writer = null ) { n summary_writer . println ( s ) n } n n logger . info ( s ) n }	1
Q_22	print model summary	C_22_3	private static void summarize_nb_model ( model_summary summary , hex . nb . nb_model model ) { n / / add generic fields such as column names n summarize_model_common_fields ( summary , model ) n n summary . model_algorithm = codstr n n json_object all_params = ( model . get_params ( ) ) . to_json ( ) n summary . critical_parameters = whitelist_json_object ( all_params , nb_critical_params ) n summary . secondary_parameters = whitelist_json_object ( all_params , nb_secondary_params ) n summary . expert_parameters = whitelist_json_object ( all_params , nb_expert_params ) n }	1
Q_22	print model summary	C_22_4	protected void print_result_summary ( results_summary s , list < feature_token > features_list ) { n new failure_summary_writer ( ) . print_failure_summary ( features_list , this print_message ) n new result_summary_writer ( ) . print_result_summary ( s , this print_message ) n }	0
Q_22	print model summary	C_22_5	private static void summarize_deep_learning_model ( model_summary summary , hex . deeplearning . deep_learning_model model ) { n / / add generic fields such as column names n summarize_model_common_fields ( summary , model ) n n summary . model_algorithm = codstr n n json_object all_params = ( model . get_params ( ) ) . to_json ( ) n summary . critical_parameters = whitelist_json_object ( all_params , dl_critical_params ) n summary . secondary_parameters = whitelist_json_object ( all_params , dl_secondary_params ) n summary . expert_parameters = whitelist_json_object ( all_params , dl_expert_params ) n }	0
Q_22	print model summary	C_22_6	private static void summarize_glm_model ( model_summary summary , hex . glm . glm_model model ) { n / / add generic fields such as column names n summarize_model_common_fields ( summary , model ) n n summary . model_algorithm = codstr n n json_object all_params = ( model . get_params ( ) ) . to_json ( ) n summary . critical_parameters = whitelist_json_object ( all_params , glm_critical_params ) n summary . secondary_parameters = whitelist_json_object ( all_params , glm_secondary_params ) n summary . expert_parameters = whitelist_json_object ( all_params , glm_expert_params ) n }	0
Q_23	pretty print json	C_23_0	private string pretty_print ( final json_object root_json , final boolean pretty_print ) { n if ( pretty_print ) { n final gson gson = new gson_builder ( ) . set_pretty_printing ( ) n . disable_html_escaping ( ) n . create ( ) n return gson . to_json ( root_json ) n } n return root_json . to_string ( ) n }	1
Q_23	pretty print json	C_23_1	public void pretty_print_object ( json_object json_obj , int indent_level ) throws exception { n writer . write ( codstr ) n n iterator < ? > it = json_obj . keys ( ) n if ( it . has_next ( ) ) { n / / accumulate keys n list < string > keys = new vector < string > ( ) n while ( it . has_next ( ) ) { n object key = it . next ( ) n if ( key instanceof string ) { n keys . add ( ( string ) key ) n } n } n n / / sort keys n collections . sort ( keys ) n n / / print out each key n boolean first = true n for ( string key keys ) { n object value = json_obj . get ( key ) n n / / print indentation n writer . write ( codstr ) n for ( int i = codint , e = indent_level + codint i < e + + i ) { n writer . write ( tab ) n } n n / / print comma , if needed n if ( first ) { n first = false n } else { n writer . write ( codstr ) n } n n / / print key n writer . write ( json_object . quote ( key ) ) n writer . write ( codstr ) n n	1
Q_23	pretty print json	C_23_2	private string get_rendered_json ( processor_result result ) throws o_data_exception { n log . debug ( codstr ) n json_renderer renderer = new json_renderer ( ) n n o_data_response . builder builder = new o_data_response . builder ( ) n . set_status ( result . get_status ( ) ) n renderer . render ( result . get_request_context ( ) , result . get_query_result ( ) , builder ) n n try { n / / pretty print n object_mapper object_mapper = new object_mapper ( ) n object json_object = object_mapper . read_value ( builder . build ( ) . get_body_text ( standard_charsets . utf_8 . name ( ) ) , n object . class ) n return object_mapper . writer_with_default_pretty_printer ( ) . write_value_as_string ( json_object ) n } catch ( io_exception ex ) { n throw new o_data_batch_renderer_exception ( codstr ) n } n }	1
Q_23	pretty print json	C_23_3	private string pretty_print_if_needed ( logger logger , string content_type , string body ) { n string result = body n if ( pretty_print_json content_type = null ( content_type . starts_with ( codstr ) content_type . starts_with ( codstr ) ) ) { n try { n final object deserialized = pretty_printer . read_tree ( body ) n result = pretty_printer . write_value_as_string ( deserialized ) n } catch ( exception e ) { n log ( logger , codstr + e . get_message ( ) ) n } n } n return result n }	1
Q_23	pretty print json	C_23_4	private string pretty_print ( final json_object json ) { n final map < string , object > properties = new hash_map < > ( codint ) n properties . put ( json_generator . pretty_printing , true ) n final json_writer_factory writer_factory = json . create_writer_factory ( properties ) n n final string_writer sw = new string_writer ( ) n try ( final json_writer json_writer = writer_factory . create_writer ( sw ) ) { n json_writer . write_object ( json ) n n } n return sw . to_string ( ) n }	1
Q_23	pretty print json	C_23_5	public static string pretty_print_json ( json_node json_node ) { n string indented = json_node . to_string ( ) n n final object_mapper object_mapper = new object_mapper_provider ( ) . get ( ) n n try { n return object_mapper . writer_with_default_pretty_printer ( ) . write_value_as_string ( json_node ) n n } catch ( io_exception e ) { n / * n * pretty _ print logic threw an exception , not a big deal , print the original json then . n * / n return indented n } n }	1
Q_23	pretty print json	C_23_6	public static string to_pretty_json_string ( object object ) { n try { n return json_mapper . writer_with_default_pretty_printer ( ) n . write_value_as_string ( object ) n } catch ( json_processing_exception e ) { n return jm_exception_manager . handle_exception_and_return_null ( log , e , n codstr , object ) n } n }	0
Q_23	pretty print json	C_23_7	public static void main ( string [ ] args ) throws exception { n string_buffer pretty_print = new string_buffer ( ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n n system . out . println ( codstr + pretty_print . to_string ( ) ) n n pretty_print . delete ( codint , pretty_print . length ( ) ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n pretty_print . append ( codstr ) n n system . out . println ( codstr + pretty_print . to_string ( ) ) n n i_tree_node root = new tree_node_unique_children ( new integer ( codint ) , new i_tree_node [ ] { n new default_tree_node ( new integer ( codint )	0
Q_24	postgresql connection	C_24_0	override n public void open ( properties configuration ) throws transformation_exception { n try { n connection = postgre_sql_utils . connect ( configuration ) n } catch ( sql_exception e ) { n throw new transformation_exception ( codstr , e ) n } n }	1
Q_24	postgresql connection	C_24_1	public void connect_to_postgre_sql_database ( string database , string host , string port , string user , string password , boolean secure , string ca , string crt , string key ) throws sql_exception { n n if ( port . starts_with ( codstr ) ) { n port = port . substring ( codint , port . length ( ) _ codint ) n } n if ( secure ) { n if ( password = = null ) { n password = codstr n } n try { n my_connection = driver_manager . get_connection ( codstr + host + codstr + port + codstr + database , user , password ) n } catch ( sql_exception se ) { n / / log the exception n this . get_logger ( ) . error ( se . get_message ( ) ) n / / re _ throw the exception n throw se n } n n } else { n properties props = new properties ( ) n if ( user = null ) { n props . set_property ( codstr , user ) n } n if ( ca = null ) { n props . set_property ( codstr , ca ) n } n if ( crt = null ) { n props . set_property ( codstr , crt ) n } n if ( key = null ) { n props . set_property ( codstr , key ) n } n props . set_property ( codstr	1
Q_24	postgresql connection	C_24_2	not_null n private connection ensure_connection ( ) { n if ( sql_connection = = null ) { n try { n sql_connection = db . data_source . get_connection ( ) n } catch ( sql_exception e ) { n throw new runtime_exception ( codstr , e ) n } n } n return sql_connection n }	1
Q_24	postgresql connection	C_24_3	private void post_get_connection_handling ( connection conn ) throws sql_exception { n helper . do_connection_setup ( conn ) n n string [ ] sql_commands = ds_config . get ( ) . on_connect n if ( sql_commands = null sql_commands . length > codint ) n on_connect ( conn , sql_commands ) n n / / log the database and driver versions on first get_connection . n if ( was_used_to_get_a_connection ) { n / / wait until after the connection succeeds to set the indicator . n / / this accounts for the scenario where the first connection attempt is bad . n / / the information needs to be read again on the second attempt . n helper . gather_and_display_meta_data_info ( conn , this ) n was_used_to_get_a_connection = true n } n }	1
Q_24	postgresql connection	C_24_4	private static long to_java_secs ( long secs ) { n / / postgres epoc to java epoc n secs + = codint n n / / julian / gregorian calendar cutoff point n if ( secs < _ codint ) { / / october codint , codint _ > october codint , codint n secs + = codint * codint n if ( secs < _ codint ) { / / codint _ codint _ codint _ > codint _ codint _ codint n int extra_leaps = ( int ) ( ( secs + codint ) / codint ) n extra_leaps _ n extra_leaps _ = extra_leaps / codint n secs + = extra_leaps * codint n } n } n return secs n }	0
Q_24	postgresql connection	C_24_5	override n void handle ( connection connection , database_charset_checker . state state ) throws sql_exception { n / / postgre_sql does not have concept of case _ sensitive collation . only charset ( codstr in postgresql terminology ) n / / must be verified . n expect_utf8_as_default ( connection ) n n if ( state = = database_charset_checker . state . upgrade state = = database_charset_checker . state . startup ) { n / / no need to check columns on fresh installs . as they are not supposed to exist n expect_utf8_columns ( connection ) n } n }	0
Q_24	postgresql connection	C_24_6	private connection create_ddl_connection ( ) throws sql_exception { n connection write_connection = db . get_data_source ( ) . get_connection ( ) n write_connection . set_auto_commit ( false ) n return write_connection n }	0
Q_24	postgresql connection	C_24_7	private static long to_pg_secs ( long secs ) { n / / java epoc to postgres epoc n secs _ = codint n n / / julian / greagorian calendar cutoff point n if ( secs < _ codint ) { / / october codint , codint _ > october codint , codint n secs _ = codint * codint n if ( secs < _ codint ) { / / codint _ codint _ codint _ > codint _ codint _ codint n int years = ( int ) ( ( secs + codint ) / _ codint ) n years + + n years _ = years / codint n secs + = years * codint n } n } n n return secs n }	0
Q_25	position of substring in string	C_25_0	public static string [ ] split ( final string src , final string delimiter ) { n int maxparts = ( src . length ( ) / delimiter . length ( ) ) + codint / / one more for the last n int [ ] positions = new int [ maxparts ] n int dellen = delimiter . length ( ) n n int i , j = codint n int count = codint n positions [ codint ] = _ dellen n while ( ( i = src . index_of ( delimiter , j ) ) = _ codint ) { n count + + n positions [ count ] = i n j = i + dellen n } n count + + n positions [ count ] = src . length ( ) n n string [ ] result = new string [ count ] n n for ( i = codint i < count i + + ) { n result [ i ] = src . substring ( positions [ i ] + dellen , positions [ i + codint ] ) n } n return result n }	1
Q_25	position of substring in string	C_25_1	public template_filter description_contains ( string . substrings ) { n all_items_not_null ( substrings , codstr ) n n predicate = predicate . and ( combine ( n template_metadata get_description , in ( as_list ( substrings ) , predicates contains_ignore_case ) n ) ) n n return this n }	0
Q_25	position of substring in string	C_25_2	private int transpositions ( string common1 , string common2 ) n { n int transpositions = codint n for ( int i = codint i < common1 . length ( ) i + + ) { n if ( common1 . char_at ( i ) = common2 . char_at ( i ) ) n transpositions + + n } n transpositions / = codint n return transpositions n }	0
Q_25	position of substring in string	C_25_3	public string pos_subst ( string s , string [ ] subs , int behavior ) { n matcher matcher = pos_pattern . matcher ( s ) n int previous_end = codint n string_buffer sb = new string_buffer ( ) n string var_value n int var_index n string condl_val / / conditional value n while ( matcher . find ( ) ) { n var_index = integer . parse_int ( matcher . group ( codint ) ) _ codint n condl_val = ( ( matcher . group_count ( ) > codint ) ? matcher . group ( codint ) null ) n var_value = ( ( var_index < subs . length ) ? subs [ var_index ] null ) n if ( condl_val = null ) { n / / replace var_value ( the value to be substituted ) , with n / / the post _ + portion of the expression . n var_value = ( ( var_value = = null ) n ? codstr n condl_val . replace_all ( codstr + ( var_index + codint ) + codstr , n ref_capable_property_resource_bundle . literalize ( n var_value ) ) ) n } n / / system . err . println ( codstr + behavior ) n if ( var_value = = null ) switch ( behavior ) { n case throw_behavior n throw new runtime_exception ( n integer . to_string ( subs . length ) n + codstr n + codstr + matcher . group ( ) + codstr	0
Q_25	position of substring in string	C_25_4	public static string [ ] split_string ( final string s , final char c ) { n final char [ ] chars = s . to_char_array ( ) n int num_substrings = codint n for ( final char x chars ) { n if ( x = = c ) { n num_substrings + + n } n } n final string [ ] result = new string [ num_substrings ] n final int len = chars . length n int start = codint / / starting index in chars of the current substring . n int pos = codint / / current index in chars . n int i = codint / / number of the current substring . n for ( pos < len pos + + ) { n if ( chars [ pos ] = = c ) { n result [ i + + ] = new string ( chars , start , pos _ start ) n start = pos + codint n } n } n result [ i ] = new string ( chars , start , pos _ start ) n return result n }	0
Q_25	position of substring in string	C_25_5	public load_balancer_filter description_contains ( string . sub_strings ) { n all_items_not_null ( sub_strings , codstr ) n n predicate = predicate . and ( combine ( n load_balancer_metadata get_description , in ( as_list ( sub_strings ) , predicates contains_ignore_case ) n ) ) n n return this n }	0
Q_26	parse query string in url	C_26_0	public static string strip_protocol_and_port ( string url ) { n / / workaround to properly parse url . without schema and available port , uri . create fails to parse n if ( url . contains ( codstr ) ) { n url = codstr + url n } n n uri uri = uri . create ( url ) n n string host = uri . get_host ( ) n string path = uri . get_path ( ) n n string query = uri . get_query ( ) n string query_append = codstr n if ( query = null ) { n query_append = codstr + query n } n n string fragment = uri . get_fragment ( ) n string fragment_append = codstr n if ( fragment = null ) { n fragment_append = codstr + fragment n } n n return ( host = = null ? codstr host ) + ( path = = null ? codstr path ) + query_append + fragment_append n }	1
Q_26	parse query string in url	C_26_1	protected static set < string > parse_query ( string query ) throws io_exception { n set < string > names = new hash_set < string > ( ) n if ( query = null ) { n string [ ] pairs = query . split ( codstr ) n for ( string pair pairs ) { n int idx = pair . index_of ( codstr ) n if ( idx = _ codint url_decoder . decode ( pair . substring ( codint , idx ) , codstr ) . equals ( codstr ) ) { n names . add ( url_decoder . decode ( pair . substring ( idx + codint ) , codstr ) ) n } n } n } n return names n }	1
Q_26	parse query string in url	C_26_2	private map < string , string > parse_url_parameters ( string urlstring ) n throws malformed_url_exception , unsupported_encoding_exception { n url url = new url ( codstr + urlstring ) n string query = url . get_query ( ) n hashtable < string , string > params = new hashtable < string , string > ( ) n if ( query = null ) { n string [ ] queries = query . split ( codstr ) n for ( string q queries ) { n int k = q . index_of ( codstr ) n string name , value n if ( k > codint ) { n name = q . substring ( codint , k ) n value = q . substring ( k + codint ) n } else { n name = q n value = codstr n } n value = java . net . url_decoder . decode ( value , codstr ) n / / system . out . println ( codstr + name + codstr codstr codstr ) n params . put ( name , value ) n } n } n return params n }	1
Q_26	parse query string in url	C_26_3	private void parse_query ( string query ) { n / / throw out the funky business _ codstr [ name codstr value codstr ] + n query = query . replace_all ( codstr , codstr ) . replace_all ( codstr , codstr ) n n if ( query . is_empty ( ) ) n return n n query_params = gwt . create ( buckets . class ) n string [ ] p , pairs = query . split ( codstr ) n string name , value n for ( final string pair pairs ) { n p = pair . split ( codstr ) n name = url_codec . decode_query_string ( p [ codint ] ) n / / no codstr is null according to http / / dvcs . w3 . org / hg / url / raw _ file / tip / overview . html # collect _ url _ parameters n value = p . length > codint p [ codint ] . is_empty ( ) ? url_codec . decode_query_string ( p [ codint ] ) null n query_params . add ( name , value ) n } n }	1
Q_26	parse query string in url	C_26_4	protected string parse_url ( string url , list < param > param_list ) throws unsupported_encoding_exception { n string_builder sb = new string_builder ( ) n for ( param param param_list ) { n if ( param . get_value ( ) = = null ) { n continue n } n if ( sb . length ( ) > codint ) { n sb . append ( codstr ) n } n n sb . append ( param . get_name ( ) ) . append ( codstr ) . append ( url_encoder . encode ( param . get_value ( ) . to_string ( ) , codstr ) ) n } n string query_string = sb . to_string ( ) n / / system . err . println ( codstr + query_string ) n if ( url . index_of ( codstr ) = = _ codint ) { n return url + codstr + query_string n } n else { n return url + codstr + query_string n } n }	0
Q_26	parse query string in url	C_26_5	private string append_query_string ( string url , map < string , object > query ) { n if ( query = null query . size ( ) > codint ) { n string query_string = this . query_as_string ( query ) n return string . format ( codstr , url , query_string ) n } else { n return url n } n }	0
Q_26	parse query string in url	C_26_6	public static string strip_protocol ( string url ) { n / / workaround to properly parse url . without schema and available port , uri . create fails to parse n if ( url . contains ( codstr ) ) { n url = codstr + url n } n n uri uri = uri . create ( url ) n n string user_info = uri . get_user_info ( ) n n string host = uri . get_host ( ) n int port = uri . get_port ( ) n string path = uri . get_path ( ) n n string query = uri . get_query ( ) n string query_append = codstr n if ( query = null ) { n query_append = codstr + query n } n n string fragment = uri . get_fragment ( ) n string fragment_append = codstr n if ( fragment = null ) { n fragment_append = codstr + fragment n } n n return ( user_info = = null ? codstr user_info + codstr ) + ( host = = null ? codstr host ) + ( port = = _ codint ? codstr codstr + port ) + ( path = = null ? codstr path ) + query_append + fragment_append n }	0
Q_27	parse json file	C_27_0	public static json_object parse_json_file ( string config_info_path ) { n json_object json_object = null n n try { n buffered_reader buffered_reader = new buffered_reader ( new input_stream_reader ( new file_input_stream ( config_info_path ) ) ) n n string_builder builder = new string_builder ( ) n string line = null n while ( ( line = buffered_reader . read_line ( ) ) = null ) { n builder . append ( line ) n } n buffered_reader . close ( ) n n json_object = new json_object ( builder . to_string ( ) ) n } catch ( file_not_found_exception e ) { n system . err . println ( codstr codstr codstr ) n volt_db . exit ( _ codint ) n } catch ( io_exception e ) { n system . err . println ( e . get_message ( ) ) n volt_db . exit ( _ codint ) n } catch ( json_exception e ) { n system . err . println ( codstr + config_info_path ) n system . err . println ( e . get_localized_message ( ) ) n volt_db . exit ( _ codint ) n } n n return json_object n }	1
Q_27	parse json file	C_27_1	static public json_object read_json_object_file ( file file ) throws exception { n try { n json_object json = null n n string json_str = text_file_utils . read_text_file ( file ) n n json_tokener tokener = new json_tokener ( json_str ) n object o = tokener . next_value ( ) n if ( o instanceof json_object ) { n json = ( json_object ) o n } else { n throw new exception ( codstr + o . get_class ( ) . get_name ( ) ) n } n n / / check that file is empty n if ( tokener . more ( ) ) { n throw new exception ( codstr ) n } n n return json n n } catch ( exception e ) { n throw new exception ( codstr + file ) n } n }	1
Q_27	parse json file	C_27_2	override n public document_context parse ( file json ) throws io_exception { n not_null ( json , codstr ) n file_input_stream fis = null n try { n fis = new file_input_stream ( json ) n return parse ( fis ) n } finally { n utils . close_quietly ( fis ) n } n }	1
Q_27	parse json file	C_27_3	private json_object load_json ( input_stream input ) throws json_syntax_exception , io_exception { n return json_tracking_parser . parse ( text_file . stream_to_string ( input ) , null ) n / / return parser . parse ( text_file . stream_to_string ( input ) ) . get_as_json_object ( ) n }	1
Q_27	parse json file	C_27_4	public void parse ( file file ) throws update_exception { n logger . debug ( codstr + file . get_name ( ) ) n try ( input_stream fin = new file_input_stream ( file ) n input_stream in = new gzip_input_stream ( fin ) n input_stream_reader isr = new input_stream_reader ( in , utf_8 ) n json_reader reader = new json_reader ( isr ) ) { n final gson gson = new gson_builder ( ) . create ( ) n n reader . begin_object ( ) n n while ( reader . has_next ( ) json_token . begin_array . equals ( reader . peek ( ) ) ) { n reader . skip_value ( ) n } n reader . begin_array ( ) n while ( reader . has_next ( ) ) { n final def_cve_item cve = gson . from_json ( reader , def_cve_item . class ) n n / / cve . get_cve ( ) . get_cve_data_meta ( ) . get_state ( ) n if ( test_cve_cpe_start_with_filter ( cve ) ) { n cve_db . update_vulnerability ( cve ) n } n } n } catch ( file_not_found_exception ex ) { n logger . error ( ex . get_message ( ) ) n throw new update_exception ( codstr + file + codstr , ex ) n } catch ( io_exception ex ) { n logger . error ( codstr , file ) n logger . debug ( codstr + file . to_string ( ) , ex ) n	1
Q_27	parse json file	C_27_5	"private c_file parse_c_file ( json_object j_obj ) n { n c_file cfile n n if ( j_obj . opt_boolean ( codstr , false ) ) { n cfile = new c_folder ( new c_path ( j_obj . get_string ( codstr ) ) ) n n } else { n cfile = new c_blob ( new c_path ( j_obj . get_string ( codstr ) ) , j_obj . get_long ( codstr ) , j_obj . get_string ( codstr ) ) n string string_date = j_obj . get_string ( codstr ) n n try { n / / string_date looks like codstr n simple_date_format sdf = new simple_date_format ( codstr , locale . us ) n date modified = sdf . parse ( string_date ) n cfile . set_modification_date ( modified ) n n } catch ( parse_exception ex ) { n throw new c_storage_exception ( codstr t parse date modified codstr ( codstr ) "" , ex ) n } n } n n return cfile n }"	1
Q_28	parse command line argument	C_28_0	private < a extends args_base > n int parse_command_option ( command < ? super a > command , n a args , n string arg , n int i ) n { n final string [ ] argv = args . get_raw_argv ( ) n option_command_line < ? super a > option = command . get_option ( arg ) n n if ( option = null ) { n i = option . parse ( args , argv , i ) n } n else if ( arg . starts_with ( codstr ) arg . index_of ( codstr ) > codint ) { n int p = arg . index_of ( codstr ) n n string key = arg . substring ( codint , p ) n string value = arg . substring ( p + codint ) n n args . property ( key , value ) n } n else if ( arg . starts_with ( codstr ) ) { n throw new command_argument_exception ( l . l ( codstr { codint } codstr , n arg , n command . name ( ) ) ) n } n else if ( command . get_tail_args_min_count ( ) > = codint ) { n args . add_tail_arg ( arg ) n } n else { n throw new command_argument_exception ( l . l ( codstr { codint } codstr , n arg , n command . name ( ) ) ) n } n n return i n }	1
Q_28	parse command line argument	C_28_1	private void parse_command_line_args ( string [ ] args ) throws configuration_exception { n if ( args = = null args . length = = codint ) { n return n } n logger . info ( codstr ) n m_command_line_args = args n n try { n for ( int inx = codint inx < args . length inx + + ) { n string arg = args [ inx ] n if ( arg . equals ( codstr ) arg . equals_ignore_case ( codstr ) arg . equals_ignore_case ( codstr ) ) { n system . out . println ( codstr ) n system . exit ( codint ) n } n utils . require ( arg . char_at ( codint ) = = codstr , codstr , arg ) n utils . require ( inx + codint < args . length , codstr , arg ) n string name = arg . substring ( codint ) n string value = args [ + + inx ] n set_command_line_param ( name , value ) n } n } catch ( exception e ) { n logger . error ( codstr , e ) n throw new configuration_exception ( codstr , e ) n } n }	1
Q_28	parse command line argument	C_28_2	private start_args do_parse ( final string [ ] args ) throws parse_exception { n command_line_parser parser = new default_parser ( ) n command_line cmd = parser . parse ( options ( ) , args ) n return parse_args ( cmd ) n }	1
Q_28	parse command line argument	C_28_3	private command_line parse_args ( string [ ] args ) throws parse_exception { n final command_line_parser parser = new default_parser ( ) n final options options = create_command_line_options ( ) n return parser . parse ( options , args ) n }	1
Q_28	parse command line argument	C_28_4	command_line parse ( default_command_line cl , string [ ] args ) { n parse_internal ( cl , args , true ) n return cl n }	1
Q_28	parse command line argument	C_28_5	suppress_warnings ( codstr ) n public static map < string , string > parse_command_line_arguments ( string [ ] args ) { n return ( map ) parse_command_line_arguments ( args , false ) n }	1
Q_28	parse command line argument	C_28_6	public void parse ( string arg ) { n if ( super . parse_arg ( arg ) ) n return n if ( arg . starts_with ( main . stdout_prefix ) ) { n / / ignore this n } else if ( src_file = = null ) { n src_file = new file ( arg ) n } else { n set_invalid ( format ( codstr s codstr , arg ) ) n } n }	1
Q_28	parse command line argument	C_28_7	public static void main ( string [ ] args ) throws io_exception { n n arguments arguments = new arguments ( ) . parse ( args ) n n if ( arguments . is_use_commons_lang3 ( ) ) { n system . err . println ( codstr ) n } n n jsonschema2_pojo . generate ( arguments ) n }	1
Q_28	parse command line argument	C_28_8	"private static void parse_command_line_args ( string [ ] args ) throws configuration_exception { n n if ( args [ codint ] . equals_ignore_case ( codstr ) args [ codint ] . equals_ignore_case ( codstr ) n args [ codint ] . equals_ignore_case ( codstr ) args [ codint ] . equals_ignore_case ( codstr ) ) { n system . out . println ( codstr ) n system . exit ( codint ) n } n n list < string > unknown_args = new array_list < string > ( ) n n for ( int inx = codint inx < args . length inx + + ) { n string name = args [ inx ] . substring ( codint ) n if ( inx + codint > = args . length ) { n throw new configuration_exception ( codstr + args [ inx ] ) n } n string value = args [ + + inx ] n if ( set_param_from_string ( name , value ) ) { n unknown_args . add ( name ) n } n } n n if ( unknown_args . is_empty ( ) ) { n string_builder b = new string_builder ( ) n for ( string arg unknown_args ) { n b . append ( codstr codstr codstr ) n } n n throw new configuration_exception ( codstr t parse argument ( s ) "" + b . to_string ( ) ) n } n }"	1
Q_29	parse binary file to custom class	C_29_0	public bioml parse ( ) throws file_parsing_exception { n / / class_loader class_loader_orig = thread . current_thread ( ) . get_context_class_loader ( ) n try { n n / / string file_path = codstr n / / string file_path = codstr n path file_path = paths . get ( this . get_path ( ) ) n file_input_stream fis = new file_input_stream ( file_path . to_file ( ) ) n buffered_input_stream bis = new buffered_input_stream ( fis , codint * codint * codint ) / / codint mb buffer n n class < bioml > clazz = bioml . class n n jaxb_context jaxb_context = jaxb_context . new_instance ( clazz ) n unmarshaller unmarshaller = jaxb_context . create_unmarshaller ( ) n object unmarshalled = unmarshaller . unmarshal ( bis ) n n bioml bioml = convert_jaxb_object_to_domain ( clazz , unmarshalled ) n return bioml n n } catch ( jaxb_exception file_not_found_exception e ) { n throw new file_parsing_exception ( e ) n } finally { n / / thread . current_thread ( ) . set_context_class_loader ( class_loader_orig ) n } n }	1
Q_29	parse binary file to custom class	C_29_1	public void parse ( page page , string context_url ) throws not_allowed_content_exception , parse_exception { n if ( util . has_binary_content ( page . get_content_type ( ) ) ) { / / binary n binary_parse_data parse_data = new binary_parse_data ( ) n if ( config . is_include_binary_content_in_crawling ( ) ) { n if ( config . is_process_binary_content_in_crawling ( ) ) { n try { n parse_data . set_binary_content ( page . get_content_data ( ) ) n } catch ( exception e ) { n if ( config . is_halt_on_error ( ) ) { n throw new parse_exception ( e ) n } else { n logger . error ( codstr , e ) n } n } n } else { n parse_data . set_html ( codstr ) n } n page . set_parse_data ( parse_data ) n if ( parse_data . get_html ( ) = = null ) { n throw new parse_exception ( ) n } n parse_data . set_outgoing_urls ( net . extract_urls ( parse_data . get_html ( ) ) ) n } else { n throw new not_allowed_content_exception ( ) n } n } else if ( util . has_css_text_content ( page . get_content_type ( ) ) ) { / / text / css n try { n css_parse_data parse_data = new css_parse_data ( ) n if ( page . get_content_charset ( ) = = null ) { n parse_data . set_text_content ( new string ( page . get_content_data ( ) ) ) n }	1
Q_29	parse binary file to custom class	C_29_2	private file [ ] accept ( file file , final boolean recursive ) { n / / custom filtering rules if you can loop ( include subdirectories ) or is the end of the file . class ( compiled java class file ) n return file . list_files ( file1 _ > ( recursive file1 . is_directory ( ) ) ( file1 . get_name ( ) . ends_with ( codstr ) ) ) n }	0
Q_29	parse binary file to custom class	C_29_3	public static byte [ ] build ( string class_name , string super_name ) { n byte_buffer bb = byte_buffer . allocate ( codint ) n bb . put ( ba0_1 ) n n / / bb . put ( ba2 ) n write_utf8 ( bb , convert_dots ( class_name ) ) n n bb . put ( ba3 ) n n / / bb . put ( ba4 ) n write_utf8 ( bb , convert_dots ( super_name ) ) n n bb . put ( ba5_12 ) n n / / bb . put ( ba13 ) n write_utf8 ( bb , codstr + convert_dots ( class_name ) + codstr ) n n bb . put ( ba14 ) n n / / bb . put ( ba15 ) n string f_name = convert_dots ( class_name ) n f_name = f_name . substring ( f_name . last_index_of ( codstr ) + codint ) n f_name + = codstr n write_utf8 ( bb , f_name ) n n bb . put ( ba_end ) n n byte [ ] ba = new byte [ bb . position ( ) ] n bb . rewind ( ) n bb . get ( ba ) n return ba n }	0
Q_29	parse binary file to custom class	C_29_4	public < t > t render ( class < t > bean ) throws exception { n if ( body_type . equals ( body_type . text ) ) { n return parse ( bean , this . content ) n } else { n throw new seimi_process_excepiton ( codstr ) n } n }	0
Q_30	output to html file	C_30_0	public void print_html_footer ( print_writer out , resource_bundle reg ) n { n string str_html = reg . get_string ( codstr ) n if ( ( str_html = = null ) ( str_html . length ( ) = = codint ) ) n str_html = codstr n out . println ( str_html ) n out . flush ( ) n }	1
Q_30	output to html file	C_30_1	public void to_html ( file file ) throws io_exception { n print_writer out = new print_writer ( file ) n n out . printf ( codstr stylesheet codstr text / css codstr s codstr , style_url ) n out . printf ( codstr , title ) n out . println ( ) n out . println ( codstr ) n out . printf ( codstr , constants . namespace ) n out . printf ( codstr , constants . abbreviation ) n out . printf ( codstr , functions . get ( codint ) . uri . string_value ( ) ) n out . print ( codstr http / / www . ldodds . com / schemas / sparql _ extension _ description / codstr ) n out . printf ( codstr s codstr s codstr , link_xml , link_turtle ) n out . println ( codstr ) n for ( function_doc . reference reference function_doc . reference . values ( ) ) { n for ( function_doc . type type function_doc . type . values ( ) ) { n n boolean show = false n / / test if it should be displayed n for ( function function functions ) { n if ( function . reference = = reference function . type_name . equals ( type . get_name ( ) ) function . type . equals ( type . get_uri ( ) ) ) { n show = true break n } n } n n	1
Q_30	output to html file	C_30_2	public file get_output_html_file ( ) { n file out_file = new file ( n this . get_output_directory ( ) + file . separator + this . get_output_name ( ) n + codstr + this . report_suffix ( ) + codstr ) n return out_file n }	0
Q_30	output to html file	C_30_3	protected void render_file ( map < string , object > options , file f ) throws io_exception { n file filtered = get_filtered_version ( f ) n boolean unfiltered n n if ( filtered = = null ) { n / / it was not copied . n get_log ( ) . error ( codstr + f . get_absolute_path ( ) + codstr + n codstr ) n filtered = f n unfiltered = true n } else { n / / it was copied . n unfiltered = false n } n n instance . render_file ( filtered , options ) n n / / move the file to the expected place if not filtered n if ( unfiltered ) { n string name = filtered . get_name ( ) . substring ( codint , filtered . get_name ( ) . last_index_of ( codstr ) ) + codstr n file output = new file ( filtered . get_parent_file ( ) , name ) n if ( output . is_file ( ) ) { n / / move . n file final_file = get_output_file ( filtered , codstr ) n file_utils . move_file ( output , final_file ) n } else { n get_log ( ) . error ( codstr + filtered . get_absolute_path ( ) ) n } n } n }	0
Q_30	output to html file	C_30_4	public static file earl_html_report ( string output_dir ) n throws file_not_found_exception { n n class_loader cl = thread . current_thread ( ) . get_context_class_loader ( ) n string resource_dir = cl . get_resource ( codstr ) . get_path ( ) n string earl_xsl = cl . get_resource ( codstr ) . to_string ( ) n n file html_output = new file ( output_dir , codstr ) n html_output . mkdir ( ) n logr . fine ( codstr + html_output ) n file earl_result = new file ( output_dir , codstr ) n n try { n transformer_factory tf = transformer_factory . new_instance ( ) n transformer transformer = tf . new_transformer ( new stream_source ( earl_xsl ) ) n transformer . set_parameter ( codstr , html_output ) n file index_html = new file ( html_output , codstr ) n index_html . create_new_file ( ) n file_output_stream output_stream = new file_output_stream ( index_html ) n transformer . transform ( new stream_source ( earl_result ) , new stream_result ( output_stream ) ) n / / foritfy mod close the output_stream releasing its resources n output_stream . close ( ) n file_utils . copy_directory ( new file ( resource_dir ) , html_output ) n } catch ( exception e ) { n logr . log ( level . severe , codstr , e ) n throw new runtime_exception ( e ) n } n if ( html_output . exists ( ) ) { n throw new file_not_found_exception ( codstr + html_output	0
Q_31	normal distribution	C_31_0	public static org . nd4j . linalg . api . rng . distribution . distribution create_distribution ( distribution dist ) { n if ( dist = = null ) n return null n if ( dist instanceof normal_distribution ) { n normal_distribution nd = ( normal_distribution ) dist n return nd4j . get_distributions ( ) . create_normal ( nd . get_mean ( ) , nd . get_std ( ) ) n } n if ( dist instanceof gaussian_distribution ) { n gaussian_distribution nd = ( gaussian_distribution ) dist n return nd4j . get_distributions ( ) . create_normal ( nd . get_mean ( ) , nd . get_std ( ) ) n } n if ( dist instanceof uniform_distribution ) { n uniform_distribution ud = ( uniform_distribution ) dist n return nd4j . get_distributions ( ) . create_uniform ( ud . get_lower ( ) , ud . get_upper ( ) ) n } n if ( dist instanceof binomial_distribution ) { n binomial_distribution bd = ( binomial_distribution ) dist n return nd4j . get_distributions ( ) . create_binomial ( bd . get_number_of_trials ( ) , bd . get_probability_of_success ( ) ) n } n if ( dist instanceof log_normal_distribution ) { n log_normal_distribution lnd = ( log_normal_distribution ) dist n return nd4j . get_distributions ( ) . create_log_normal ( lnd . get_mean ( ) , lnd . get_std ( ) ) n } n if ( dist instanceof truncated_normal_distribution ) { n truncated_normal_distribution tnd = ( truncated_normal_distribution ) dist n	1
Q_31	normal distribution	C_31_1	static n public double probability ( gaussian_distribution gaussian_distribution , number x ) { n normal_distribution distribution = new normal_distribution ( gaussian_distribution . get_mean ( ) , math . sqrt ( gaussian_distribution . get_variance ( ) ) ) n n return distribution . density ( x . double_value ( ) ) n }	1
Q_31	normal distribution	C_31_2	static n public double probability ( continuous_distribution distribution , number x ) { n n if ( distribution instanceof gaussian_distribution ) { n return probability ( ( gaussian_distribution ) distribution , x ) n } else n n if ( distribution instanceof poisson_distribution ) { n return probability ( ( poisson_distribution ) distribution , x ) n } n n throw new unsupported_element_exception ( distribution ) n }	1
Q_31	normal distribution	C_31_3	override public double normal ( double mean , double sd ) { n normal_distribution normal = new normal_distribution ( mean , sd ) n return normal . sample ( ) n }	1
Q_31	normal distribution	C_31_4	public static time_generator new_time_generator ( map < string , object > data ) { n string distribution = ( string ) data . get ( simulation_constants . distribution_type ) n if ( codstr . equals_ignore_case ( distribution ) ) { n return new random_time_generator ( data ) n } else if ( codstr . equals_ignore_case ( distribution ) ) { n return new uniform_time_generator ( data ) n } else if ( codstr . equals_ignore_case ( distribution ) ) { n return new normal_time_generator ( data ) n } else if ( codstr . equals_ignore_case ( distribution ) ) { n return new poisson_time_generator ( data ) n } else if ( codstr . equals_ignore_case ( distribution ) ) { n return new exact_time_generator ( data ) n } else { n throw new runtime_exception ( codstr + distribution ) n } n }	1
Q_31	normal distribution	C_31_5	public static double cdf ( double x , double mu , double sigma ) { n if ( x < = codint . ) { n return codint . n } n return . codint * ( codint + normal_distribution . erf ( ( fast_math . log ( x ) _ mu ) / ( math_util . sqrt2 * sigma ) ) ) n }	1
Q_31	normal distribution	C_31_6	public static < e > distribution < e > get_distribution_from_partially_specified_counter ( counter < e > c , int num_keys ) { n distribution < e > d n double total = c . total_count ( ) n if ( total > = number ) { n d = get_distribution ( c ) n d . number_of_keys = num_keys n } else { n d = new distribution < e > ( ) n d . number_of_keys = num_keys n d . counter = c n d . reserved_mass = number _ total n } n return d n }	0
Q_31	normal distribution	C_31_7	public static double norminv ( double p , double mu , double sigma ) { n if ( sigma < = codint ) { n return double . na_n n } n n if ( math_util . is_na_n_or_infinite ( p ) ) { n return double . na_n n } n n if ( p = = codint ) { n return double . positive_infinity n } n n if ( p = = codint ) { n return double . negative_infinity n } n n if ( p < codint p > codint ) { n return double . na_n n } n n double r , val n double p_ = p n double q = p_ _ number n n if ( math . abs ( q ) < = . codint ) { n r = . codint _ q * q n val = q n * ( ( ( ( ( ( ( r * number + number ) * r + number ) n * r + number ) n * r + number ) n * r + number ) n * r + number ) n * r + number ) n / ( ( ( ( ( ( ( r * number + number ) * r + number ) n * r + number ) n * r + number ) n * r + number ) n * r + number ) n * r + codint	0
Q_32	nelder mead optimize	C_32_0	public boolean do_optimization ( optimized_tag_context context ) { n boolean optimize = true n n if ( context . is_jsp_attribute ( codstr ) ) { n optimize = false n } n else if ( context . is_jsp_attribute ( codstr ) ) { n optimize = false n } n n return optimize n }	0
Q_32	nelder mead optimize	C_32_1	override n public long last_used ( ) { n return params . find ( meta_last_used . class ) . map ( ml _ > ml . get ( ) ) . or_else ( codint ) n }	0
Q_32	nelder mead optimize	C_32_2	override n public void exit_standard_file_option_optimize_for ( final standard_file_option_optimize_for_context ctx ) { n verify_option_name_unique ( codstr , ctx . get_start ( ) ) n scopes . get_file_options ( ) . set_optimize_for ( optimize_mode . value_of ( ctx . optimize_mode ( ) . get_text ( ) ) ) n }	0
Q_32	nelder mead optimize	C_32_3	public boolean do_optimization ( optimized_tag_context context ) { n boolean optimize = true n n if ( context . has_attribute ( codstr ) ) { n optimize = false n } n else if ( context . is_jsp_attribute ( codstr ) ) { n optimize = false n } n else if ( context . is_jsp_attribute ( codstr ) ) { n optimize = false n } n else if ( context . is_jsp_attribute ( codstr ) ) { n optimize = false n } n else if ( context . is_jsp_attribute ( codstr ) ) { n optimize = false n } n else if ( context . is_jsp_attribute ( codstr ) ) { n optimize = false n } n n return optimize n }	0
Q_32	nelder mead optimize	C_32_4	public boolean do_optimization ( optimized_tag_context context ) { n boolean optimize = false n if ( context . get_parent ( ) = null context . get_parent ( ) instanceof jstl_choose_optimized_tag ) { n optimize = true n } n return optimize n }	0
Q_32	nelder mead optimize	C_32_5	private void optimize ( int maxi ) throws structure_exception n { n long opt_start = system . current_time_millis ( ) n if ( debug ) n system . out . println ( codstr + maxi + codstr ) n boolean ifstop = true n int i , aln_len n aln_len = codint n n int [ ] [ ] aln_list = new int [ codint ] [ max_len ] n for ( i = codint i < maxi i + + ) { n n / / if ( debug ) { n / / system . out . println ( codstr + i ) n / / } n n cal_matrix ( ) n n fc_align_helper aln = new fc_align_helper ( sij , pro1_len , pro2_len , gap_ini , gap_ext ) n n / / align0 * aln = new align0 ( sij , pro1_len , pro2_len , gap_ini , gap_ext ) n aln_len = aln . get_align_pos ( aln_list ) n if ( aln_len < codint ) ifstop = true / / very rare , mark by y . y on codint / codint / codint n else ifstop = define_equ_pos ( aln_len , aln_list ) n n if ( ifstop ) break n dc + = increase n n / / if ( show_alig ) n / / if ( i = = codint ) n / / show_current_alignment ( aln_len , aln_list , codstr + i + codstr + aln_len + codstr + rmsd )	0
Q_32	nelder mead optimize	C_32_6	override n public intermediate_query optimize ( intermediate_query query ) throws empty_query_exception { n intermediate_query optimized_query = super . optimize ( query ) n log . trace ( codstr + optimized_query . to_string ( ) ) n return optimized_query n }	0
Q_33	memoize to disk _ persistent memoization	C_33_0	private < t , r > function < t , r > memoize ( final function < t , r > fn ) { n n if ( auto_memoize ) n return fn n if ( memoize_factory = = null ) n return memoize . memoize_function ( fn ) n return memoize . memoize_function ( fn , memoize_factory ) n }	1
Q_33	memoize to disk _ persistent memoization	C_33_1	public closure < v > memoize_at_most ( final int max_cache_size ) { n if ( max_cache_size < codint ) throw new illegal_argument_exception ( codstr ) n n return memoize . build_memoize_function ( new lru_cache ( max_cache_size ) , this ) n }	1
Q_33	memoize to disk _ persistent memoization	C_33_2	public tuple3 < t1 , t2 , t3 > memo ( ) { n tuple3 < t1 , t2 , t3 > host = this n return new tuple3 < t1 , t2 , t3 > ( null , null , null ) { n final supplier < t1 > memo1 = memoize . memoize_supplier ( host _1 ) n final supplier < t2 > memo2 = memoize . memoize_supplier ( host _2 ) n final supplier < t3 > memo3 = memoize . memoize_supplier ( host _3 ) n override n public t1 _1 ( ) { n n return memo1 . get ( ) n } n n override n public t2 _2 ( ) { n return memo2 . get ( ) n } n override n public t3 _3 ( ) { n return memo3 . get ( ) n } n } n }	0
Q_33	memoize to disk _ persistent memoization	C_33_3	public closure < v > memoize_at_least ( final int protected_cache_size ) { n if ( protected_cache_size < codint ) throw new illegal_argument_exception ( codstr ) n n return memoize . build_soft_reference_memoize_function ( protected_cache_size , new concurrent_soft_cache < object , object > ( ) , this ) n }	0
Q_33	memoize to disk _ persistent memoization	C_33_4	override n public void forget ( int from , int to ) { n if ( is_observing_inputs ( ) ) { / / memoization is off n throw new illegal_state_exception ( n codstr n + codstr n + codstr ) n } n n lists . check_range ( from , to , size ( ) ) n int memo_change_from = sparse_list . get_present_count_before ( from ) n list < e > memo_removed = sparse_list . collect ( from , to ) n sparse_list . splice_by_void ( from , to , to _ from ) n memoized_items . fire_remove_range ( memo_change_from , memo_removed ) n }	0
Q_33	memoize to disk _ persistent memoization	C_33_5	void export_to_memory ( final writable_memory wmem ) { n final format format = get_format ( ) n switch ( format ) { n case empty_merged { n put_empty_merged ( wmem , lg_k , seed_hash ) n break n } n case empty_hip { n put_empty_hip ( wmem , lg_k , seed_hash ) n break n } n case sparse_hybrid_merged { n put_sparse_hybrid_merged ( wmem , n lg_k , n ( int ) num_coupons , / / unsigned n csv_length_ints , n seed_hash , n csv_stream ) n break n } n case sparse_hybrid_hip { n put_sparse_hybrid_hip ( wmem , n lg_k , n ( int ) num_coupons , / / unsigned n csv_length_ints , n kxp , n hip_est_accum , n seed_hash , n csv_stream ) n break n } n case pinned_sliding_merged_nosv { n put_pinned_sliding_merged_no_sv ( wmem , n lg_k , n fi_col , n ( int ) num_coupons , / / unsigned n cw_length_ints , n seed_hash , n cw_stream ) n break n } n case pinned_sliding_hip_nosv { n put_pinned_sliding_hip_no_sv ( wmem , n lg_k , n fi_col , n ( int ) num_coupons , / / unsigned n cw_length_ints , n kxp , n hip_est_accum , n seed_hash , n cw_stream ) n break n } n case pinned_sliding_merged { n put_pinned_sliding_merged ( wmem , n lg_k , n fi_col , n ( int ) num_coupons , / / unsigned n num_csv , n csv_length_ints , n cw_length_ints , n seed_hash , n csv_stream ,	0
Q_34	matrix multiply	C_34_0	public matrix multiply ( matrix b , executor_service thread_pool ) n { n matrix c = new dense_matrix ( this . rows ( ) , b . cols ( ) ) n multiply ( b , c , thread_pool ) n return c n }	1
Q_34	matrix multiply	C_34_1	public matrix2f mul ( matrix2f m ) { n return new matrix2f ( n m00 * m . m00 + m01 * m . m10 , m00 * m . m01 + m01 * m . m11 , n m10 * m . m00 + m11 * m . m10 , m10 * m . m01 + m11 * m . m11 ) n }	1
Q_34	matrix multiply	C_34_2	"public matrix multiply ( matrix m ) throws matrix_exception n { n / / validate m "" s dimensions . n if ( n_cols = m . n_rows ) { n throw new matrix_exception ( n matrix_exception . invalid_dimensions ) n } n n double pv [ ] [ ] = new double [ n_rows ] [ m . n_cols ] / / product values n n / / compute values of the product . n for ( int r = codint r < n_rows + + r ) { n for ( int c = codint c < m . n_cols + + c ) { n double dot = codint n for ( int k = codint k < n_cols + + k ) { n dot + = values [ r ] [ k ] * m . values [ k ] [ c ] n } n pv [ r ] [ c ] = dot n } n } n n return new matrix ( pv ) n }"	1
Q_34	matrix multiply	C_34_3	public matrix multiply ( matrix c ) { n check_khatri_rao ( c ) n n for ( int i = codint i < a . num_columns ( ) + + i ) n for ( int j = codint j < a . num_rows ( ) + + j ) n for ( int k = codint k < b . num_rows ( ) + + k ) { n double value = a . get ( j , i ) * b . get ( k , i ) n int dest_line = b . num_rows ( ) * j + k n c . add ( dest_line , i , value ) n } n return c n n }	1
Q_34	matrix multiply	C_34_4	public matrix multiply ( matrix b ) n { n matrix c = new dense_matrix ( this . rows ( ) , b . cols ( ) ) n multiply ( b , c ) n return c n }	1
Q_34	matrix multiply	C_34_5	public matrix multiply ( final float k ) n { n final float pv [ ] [ ] = new float [ m_n_rows ] [ m_n_cols ] / / product values n n / / compute values of the product . n for ( int r = codint r < m_n_rows + + r ) n { n for ( int c = codint c < m_n_cols + + c ) n { n pv [ r ] [ c ] = k * m_a_values [ r ] [ c ] n } n } n n return new matrix ( pv ) n }	1
Q_34	matrix multiply	C_34_6	public matrix multiply ( double k ) n { n double pv [ ] [ ] = new double [ n_rows ] [ n_cols ] / / product values n n / / compute values of the product . n for ( int r = codint r < n_rows + + r ) { n for ( int c = codint c < n_cols + + c ) { n pv [ r ] [ c ] = k * values [ r ] [ c ] n } n } n n return new matrix ( pv ) n }	1
Q_34	matrix multiply	C_34_7	public void scalar_multiply ( double c ) n { n int m = rows n int n = cols n for ( int i = codint i < m i + + ) n { n for ( int j = codint j < n j + + ) n { n consumer . set ( i , j , c * supplier . get ( i , j ) ) n } n } n }	0
Q_34	matrix multiply	C_34_8	public nd_matrix mul ( double x , nd_matrix c ) { n a . muli ( x , c . a ) n return c n }	0
Q_35	map to json	C_35_0	private static json . j_object to_object ( map < string , value > object ) { n map < string , json . j_value > map = new linked_hash_map < > ( ) n object . for_each ( ( k , v ) _ > map . put ( k , v . as_json ( ) ) ) n return json . j_object ( map ) n }	1
Q_35	map to json	C_35_1	public void set_json_map ( map < string , object > result_map ) { n string json = gson . to_json ( result_map , map . class ) n set_json_object ( new json_parser ( ) . parse ( json ) . get_as_json_object ( ) ) n }	1
Q_35	map to json	C_35_2	public static string generate ( input_stream input_stream ) throws io_exception { n logger . trace ( codstr ) n / / extracting xml content n / / see # codint https / / github . com / dadoonet / fscrawler / issues / codint n n map < string , object > map = generate_map ( input_stream ) n n / / serialize to json n string json = mapper . write_value_as_string ( map ) n n logger . trace ( codstr , json ) n return json n }	1
Q_35	map to json	C_35_3	public static map < string , object > json_to_map ( json_object json ) throws json_exception { n map < string , object > ret_map = new hash_map < string , object > ( ) n n if ( json = json_object . null ) { n ret_map = to_map ( json ) n } n return ret_map n }	1
Q_35	map to json	C_35_4	suppress_warnings ( codstr ) n public static map < string , object > deserialize ( byte [ ] json ) { n try { n return gets_mapper ( ) . read_value ( json , map . class ) n } catch ( runtime_exception e ) { n throw e n } catch ( exception e ) { n throw new illegal_state_exception ( codstr + n bytes_to_string ( json ) ) n } n }	0
Q_35	map to json	C_35_5	public map < ? , ? > format_json2_map ( string json ) { n map < ? , ? > map = null n try { n map = mapper . read_value ( json , map . class ) n } catch ( exception e ) { n logger . error ( codstr + json , e ) n } n return map n }	0
Q_35	map to json	C_35_6	private map < string , object > to_map ( json_object o ) { n map < string , object > map = new linked_hash_map < > ( ) n / / https / / github . com / jwtk / jjwt / issues / codint use . keys ( ) and * not * . key_set ( ) for android compatibility n iterator < string > iterator = o . keys ( ) n while ( iterator . has_next ( ) ) { n string key = iterator . next ( ) n object value = o . get ( key ) n value = convert_if_necessary ( value ) n map . put ( key , value ) n } n return map n }	0
Q_35	map to json	C_35_7	json n public map < integer , string > map ( ) { n map < integer , string > map = new hash_map < integer , string > ( ) n map . put ( codint , codstr ) n map . put ( codint , codstr ) n map . put ( codint , codstr ) n map . put ( codint , codstr ) n return map n }	0
Q_35	map to json	C_35_8	public map < string , object > to_json ( ) { n map < string , object > json_map = new linked_hash_map < > ( ) n json_map . put ( key , value ) n return json_map n }	0
Q_36	linear regression	C_36_0	public static double [ ] linear_reg ( double [ ] x_data , double [ ] y_data ) { n same_array_len ( x_data , y_data ) n double sum_y_value = codint n double mean_y_value = codint n double sum_x_value = codint n double mean_x_value = codint n double sum_x = codint n double sum_y = codint n double prod = codint n double nodata = _ codint n int nstat = x_data . length n double [ ] reg_coef = new double [ codint ] / / ( intercept , gradient , r ? ) n int counter = codint n / / calculating sums n for ( int i = codint i < nstat i + + ) { n if ( ( y_data [ i ] = nodata ) ( x_data [ i ] = nodata ) ) { n sum_y_value + = y_data [ i ] n sum_x_value + = x_data [ i ] n counter + + n } n } n / / calculating means n mean_y_value = sum_y_value / counter n mean_x_value = sum_x_value / counter n n / / calculating regression coefficients n for ( int i = codint i < nstat i + + ) { n if ( ( y_data [ i ] = nodata ) ( x_data [ i ] = nodata ) ) { n sum_x + = math . pow ( ( x_data [ i ] _ mean_x_value ) , codint ) n sum_y + = math .	1
Q_36	linear regression	C_36_1	override n public double regress ( data_point data ) n { n vec x = feed_forward ( data . get_numerical_values ( ) ) n n double val = x . get ( codint ) n n val = ( val _ f . min ( ) _ target_bump ) / target_multiplier + target_min n n return val n }	0
Q_36	linear regression	C_36_2	override n public double regress ( data_point data ) n { n list < ? extends vec_paired < vec_paired < vec , integer > , double near_by = kde . get_nearby ( data . get_numerical_values ( ) ) n if ( near_by . is_empty ( ) ) n return codint / / / hmmm . what should be retruned in this case ? n double weight_sum = codint n double sum = codint n n for ( vec_paired < vec_paired < vec , integer > , double > v near_by ) n { n double weight = v . get_pair ( ) n double regression_value = ( ( vec_paired < vec , double > ) v . get_vector ( ) . get_vector ( ) ) . get_pair ( ) n weight_sum + = weight n sum + = weight * regression_value n } n n return sum / weight_sum n }	0
Q_36	linear regression	C_36_3	override n public double regress ( data_point data ) n { n if ( base_regressor = = null ) n throw new runtime_exception ( codstr ) n else if ( learners = = null learners . is_empty ( ) ) n throw new runtime_exception ( codstr ) n on_line_statistics stats = new on_line_statistics ( ) n for ( int i = codint i < learners . size ( ) i + + ) n { n double x = ( ( regressor ) learners . get ( i ) ) . regress ( data ) n stats . add ( x ) n } n n return stats . get_mean ( ) n }	0
Q_36	linear regression	C_36_4	public static double score ( multi_layer_network model , data_set_iterator test_set , regression_value regression_value ) { n regression_evaluation eval = model . evaluate_regression ( test_set ) n return get_score_from_regression_eval ( eval , regression_value ) n }	0
Q_37	k mean cluster	C_37_0	public static double k_means ( list < double [ ] > centroids , list < double [ ] > input ) { n int k = centroids . size ( ) n assert ( k > codint ) n int d = centroids . get ( codint ) . length n int size = input . size ( ) n n double [ ] [ ] center = new double [ k ] [ ] n iterator < double [ ] > i_iter = centroids . iterator ( ) n for ( int i = codint i < k i + + ) { n center [ i ] = i_iter . next ( ) n } n n double [ ] [ ] new_center = new double [ k ] [ d ] n double [ ] new_center_weight = new double [ k ] n int [ ] nearest_cluster = new int [ size ] n boolean converged n do { n for ( int i = codint i < k i + + ) { n for ( int j = codint j < d j + + ) { n new_center [ i ] [ j ] = number n } n new_center_weight [ i ] = number n } n iterator < double [ ] > l_iter = input . iterator ( ) n for ( int l = codint l < size l + + ) { n / / calculates the distance from	1
Q_37	k mean cluster	C_37_1	public static clustering k_means_gta ( int k , clustering clustering , clustering gt_clustering ) { n n array_list < cf_cluster > microclusters = new array_list < cf_cluster > ( ) n for ( int i = codint i < clustering . size ( ) i + + ) { n if ( clustering . get ( i ) instanceof cf_cluster ) { n microclusters . add ( ( cf_cluster ) clustering . get ( i ) ) n } else { n system . out . println ( codstr + clustering . get ( i ) . get_class ( ) + codstr ) n } n } n n int n = microclusters . size ( ) n assert ( k < = n ) n n / * k _ means * / n random random = new random ( codint ) n cluster [ ] centers = new cluster [ k ] n int k = gt_clustering . size ( ) n n for ( int i = codint i < k i + + ) { n if ( i < k ) { / / gt _ aided n centers [ i ] = new sphere_cluster ( gt_clustering . get ( i ) . get_center ( ) , codint ) n } else { / / randomized n int rid = random . next_int ( n ) n centers [ i ] = new sphere_cluster ( microclusters . get ( rid ) . get_center (	1
Q_37	k mean cluster	C_37_2	protected static clustering k_means ( int k , cluster [ ] centers , list < ? extends cluster > data ) { n assert ( centers . length = = k ) n assert ( k > codint ) n n int dimensions = centers [ codint ] . get_center ( ) . length n n array_list < array_list < cluster clustering = new array_list < array_list < cluster ( ) n for ( int i = codint i < k i + + ) { n clustering . add ( new array_list < cluster > ( ) ) n } n n while ( true ) { n / / assign points to clusters n for ( cluster point data ) { n double min_distance = distance ( point . get_center ( ) , centers [ codint ] . get_center ( ) ) n int closest_cluster = codint n for ( int i = codint i < k i + + ) { n double distance = distance ( point . get_center ( ) , centers [ i ] . get_center ( ) ) n if ( distance < min_distance ) { n closest_cluster = i n min_distance = distance n } n } n n clustering . get ( closest_cluster ) . add ( point ) n } n n / / calculate new centers and clear clustering lists n sphere_cluster [ ] new_centers = new sphere_cluster [ centers . length ] n for ( int i	1
Q_37	k mean cluster	C_37_3	protected static clustering clean_up_k_means ( clustering k_means_result , array_list < cf_cluster > microclusters ) { n / * convert k _ means result to cf_clusters * / n int k = k_means_result . size ( ) n cf_cluster [ ] converted = new cf_cluster [ k ] n n for ( cf_cluster mc microclusters ) { n / / find closest k_means cluster n double min_distance = double . max_value n int closest_cluster = codint n for ( int i = codint i < k i + + ) { n double distance = distance ( k_means_result . get ( i ) . get_center ( ) , mc . get_center ( ) ) n if ( distance < min_distance ) { n closest_cluster = i n min_distance = distance n } n } n n / / add to cluster n if ( converted [ closest_cluster ] = = null ) { n converted [ closest_cluster ] = ( cf_cluster ) mc . copy ( ) n } else { n converted [ closest_cluster ] . add ( mc ) n } n } n n / / clean up n int count = codint n for ( int i = codint i < converted . length i + + ) { n if ( converted [ i ] = null ) n count + + n } n n cf_cluster [ ] cleaned = new cf_cluster [ count ] n count = codint n for ( int i	1
Q_37	k mean cluster	C_37_4	public static < v extends number_vector > double log_likelihood_zhao ( relation < v > relation , clustering < ? extends mean_model > clustering , number_vector_distance_function < ? super v > distance_function ) { n list < ? extends cluster < ? extends mean_model clusters = clustering . get_all_clusters ( ) n / / number of clusters n final int m = clusters . size ( ) n n / / number of objects in the clustering n int n = codint n / / cluster sizes n int [ ] n_i = new int [ m ] n / / variances n double [ ] d_i = new double [ m ] n n / / iterate over clusters n iterator < ? extends cluster < ? extends mean_model it = clusters . iterator ( ) n for ( int i = codint it . has_next ( ) + + i ) { n cluster < ? extends mean_model > cluster = it . next ( ) n n + = n_i [ i ] = cluster . size ( ) n / / note the paper used codint / ( n _ m ) but that is probably a typo n / / as it will cause divisions by zero . n d_i [ i ] = variance_of_cluster ( cluster , distance_function , relation ) / ( double ) n_i [ i ] n } n n final int dim = relation_util . dimensionality ( relation ) n	1
Q_37	k mean cluster	C_37_5	void section ( int nclusters ) n { n if ( size ( ) < nclusters ) n return n n sectioned_clusters_ = new array_list < cluster < k ( nclusters ) n list < document > centroids = new array_list < document > ( nclusters ) n / / choose_randomly ( nclusters , centroids ) n choose_smartly ( nclusters , centroids ) n for ( int i = codint i < centroids . size ( ) i + + ) n { n cluster < k > cluster = new cluster < k > ( ) n sectioned_clusters_ . add ( cluster ) n } n n for ( document < k > d documents_ ) n { n double max_similarity = _ number n int max_index = codint n for ( int j = codint j < centroids . size ( ) j + + ) n { n double similarity = sparse_vector . inner_product ( d . feature ( ) , centroids . get ( j ) . feature ( ) ) n if ( max_similarity < similarity ) n { n max_similarity = similarity n max_index = j n } n } n sectioned_clusters_ . get ( max_index ) . add_document ( d ) n } n }	1
Q_37	k mean cluster	C_37_6	public double evaluate_clustering ( database db , relation < ? extends number_vector > rel , clustering < ? > c ) { n list < ? extends cluster < ? clusters = c . get_all_clusters ( ) n number_vector [ ] centroids = new number_vector [ clusters . size ( ) ] n int ignorednoise = centroids ( rel , clusters , centroids , noise_option ) n n mean_variance mssil = new mean_variance ( ) n n iterator < ? extends cluster < ? ci = clusters . iterator ( ) n for ( int i = codint ci . has_next ( ) i + + ) { n cluster < ? > cluster = ci . next ( ) n if ( cluster . size ( ) < = codint ) { n / / as suggested in rousseeuw , we use codint for singletons . n mssil . put ( codint . , cluster . size ( ) ) n continue n } n if ( cluster . is_noise ( ) ) { n switch ( noise_option ) { n case ignore_noise n continue / / ignore elements n case treat_noise_as_singletons n / / as suggested in rousseeuw , we use codint for singletons . n mssil . put ( codint . , cluster . size ( ) ) n continue n case merge_noise n break / / treat as cluster below n } n } n n / / cluster center n final number_vector center =	0
Q_37	k mean cluster	C_37_7	override n public clustering < mean_model > run ( database database , relation < v > relation ) { n / / database objects to process n final dbi_ds ids = relation . get_dbi_ds ( ) n / / choose initial means n double [ ] [ ] means = initializer . choose_initial_means ( database , relation , k , get_distance_function ( ) ) n / / setup cluster assignment store n list < modifiable_dbi_ds > clusters = new array_list < > ( ) n for ( int i = codint i < k i + + ) { n clusters . add ( dbid_util . new_hash_set ( relation . size ( ) / k + codint ) ) n } n n / / meta data storage n final writable_data_store < meta > metas = initialize_meta ( relation , means ) n / / perform the initial assignment n array_modifiable_dbi_ds tids = initial_assignment ( clusters , metas , ids ) n / / recompute the means after the initial assignment n means = means ( clusters , means , relation ) n / / refine the result via k _ means like iterations n means = refine_result ( relation , means , clusters , metas , tids ) n n / / wrap result n clustering < mean_model > result = new clustering < > ( codstr , codstr ) n for ( int i = codint i < clusters . size ( ) i + + )	0
Q_37	k mean cluster	C_37_8	"private void cluster_and_assign_senses ( n online_clustering < sparse_double_vector > contexts , n string primary_key , n double merge_threshold ) { n / / first forcefully condense everything down to the required n / / number of clusters . n list < cluster < sparse_double_vector new_clusters = cluster_stream ( n contexts . get_clusters ( ) , num_clusters , number ) n n / / then try to merge these new centroids based on the similarity n / / threshold . n new_clusters = cluster_stream ( contexts . get_clusters ( ) , codint , merge_threshold ) n n / / store a mapping for each word sense to it codstr _ "" + i , new_clusters . get ( i ) . centroid ( ) ) n } n n / / if there is no reporter , skip any post processing . n if ( reporter = = null ) n return n n / / get the set of context labels for each data point for the n / / given word . n string [ ] context_labels = reporter . context_labels ( primary_key ) n if ( context_labels . length = = codint ) n return n n / / output the assignments for a single clustering . n int cluster_id = codint n for ( cluster < sparse_double_vector > cluster new_clusters ) { n bit_set context_ids = cluster . data_point_ids ( ) n for ( int context_id = context_ids . next_set_bit ( codint ) context_id > ="	0
Q_38	json to xml conversion	C_38_0	public string json_to_xml ( string json ) { n string xml = codstr n / / json row tag n if ( codstr . equals ( json . substring ( codint , codint ) ) ) { n xml = xml . to_string ( new json_array ( json ) , codstr ) n } else { n xml = xml . to_string ( new json_object ( json ) ) n } n n return xml n }	1
Q_38	json to xml conversion	C_38_1	override n public document convert ( json_object json ) { n return json_xml_convert_hint . convert ( json , osgl_config . xml_root_tag ( ) , osgl_config . xml_list_item_tag ( ) ) n }	1
Q_38	json to xml conversion	C_38_2	deprecated n private string convert_to_xml ( string json_data ) { n xml_serializer serializer = new xml_serializer ( ) n json json = json_serializer . to_json ( json_data ) n serializer . set_root_name ( codstr ) n serializer . set_type_hints_enabled ( false ) n return serializer . write ( json ) n }	0
Q_38	json to xml conversion	C_38_3	private json_object convert_xml_elements_to_json_object ( final list < element > xml_elements , final boolean include_attributes , final string text_prop_name ) { n json_object result = new json_object ( ) n for ( final element xml_element xml_elements ) { n result = add_xml_element_to_json_object ( result , xml_element , include_attributes , text_prop_name ) n } n return result n }	0
Q_39	initialize array	C_39_0	private void init ( final int var ) { n / / creates and / or resizes the initializations array if necessary n if ( initializations = = null ) { n initializations = new int [ codint ] n } n int n = initializations . length n if ( initialization_count > = n ) { n int [ ] t = new int [ math . max ( initialization_count + codint , codint * n ) ] n system . arraycopy ( initializations , codint , t , codint , n ) n initializations = t n } n / / stores the type to be initialized n initializations [ initialization_count + + ] = var n }	1
Q_39	initialize array	C_39_1	public void init_as_copy_of ( m_array array , boolean is_mutable ) { n super . init_as_copy_of ( array , is_mutable ) n base_array = array = null ? array . get_base_array ( ) null n values = array = null ? new array_list < > ( array . values ) new array_list < > ( ) n }	1
Q_39	initialize array	C_39_2	private void init_arrays ( final int len ) { n offsets = new int [ len ] n mementos = new object [ len ] n arg_ids = new object [ len ] n patterns = new conversion_pattern [ len ] n }	1
Q_39	initialize array	C_39_3	private void init_empty_array ( ) { n string [ ] empty_array = { } n spinner7 = find_view_by_id ( r . id . spinner7 ) n spinner7 . set_adapter ( new array_adapter < > ( this , android . r . layout . simple_spinner_item , empty_array ) ) n }	0
Q_39	initialize array	C_39_4	public void init ( string pin ) { n keygen . set_wallet ( get_descriptor ( false ) ) n log . info ( codstr + descriptor . key + codstr + pin_enabled ) n try { n keygen . init ( pin_enabled , pin_salt , pin ) n } catch ( exception e ) { n system . out . println ( codstr ) n log . error ( codstr + descriptor . key + codstr + pin_enabled ) n } n }	0
Q_39	initialize array	C_39_5	public static void initialize_cdi ( application application ) { n jsf_extension_factory factory = instance . get ( ) n if ( factory = null ) { n if ( factory . cdi_jsf_initializer_service = null ) { n cdijsf_initializer cdi_initializer = factory . cdi_jsf_initializer_service . get_service ( ) n if ( cdi_initializer = null ) { n cdi_initializer . initialize_cdijsfel_context_listener_and_el_resolver ( application ) n cdi_initializer . initialize_cdijsf_view_handler ( application ) n } n } n } n }	0
Q_39	initialize array	C_39_6	public abstract_jdbc_helper init ( ) { n data_sources . for_each ( ( key , ds ) _ > dbc_helper . register_jdbc_data_source ( id + codstr + key , ds ) ) n return this n }	0
Q_39	initialize array	C_39_7	public void init ( ) { n re . put ( codstr , lang . jdk_tool . get_process_id ( codstr ) ) n re . put ( codstr , lang . jdk_tool . get_major_version ( ) ) n re . put ( codstr , runtime . get_runtime ( ) . available_processors ( ) ) n update_monitors ( ) n }	0
Q_39	initialize array	C_39_8	protected void init ( ) throws ssh_exception { n n log . info ( this , codstr ) n n ssh2ciphers_sc = new component_factory ( ssh_cipher . class ) n initialize_ssh2_cipher_factory ( ssh2ciphers_sc ) n n if ( enable_none_cipher ) { n ssh2ciphers_sc . add ( codstr , none_cipher . class ) n log . info ( this , codstr ) n } n n log . info ( this , codstr ) n n ssh2ciphers_cs = new component_factory ( ssh_cipher . class ) n initialize_ssh2_cipher_factory ( ssh2ciphers_cs ) n n if ( enable_none_cipher ) { n ssh2ciphers_cs . add ( codstr , none_cipher . class ) n log . info ( this , codstr ) n } n n log . info ( this , codstr ) n n hmacs_sc = new component_factory ( ssh_hmac . class ) n initialize_hmac_factory ( hmacs_sc ) n n if ( enable_none_mac ) { n hmacs_sc . add ( codstr , none_hmac . class ) n log . info ( this , codstr ) n } n n log . info ( this , codstr ) n n hmacs_cs = new component_factory ( ssh_hmac . class ) n initialize_hmac_factory ( hmacs_cs ) n n if ( enable_none_mac ) { n hmacs_cs . add ( codstr , none_hmac . class ) n log . info ( this , codstr ) n } n n log . info ( this , codstr ) n n publickeys = new component_factory ( ssh_public_key . class )	0
Q_40	httpclient post json	C_40_0	public void post ( string json_body , integer expected_response_code ) throws io_exception { n http_url_connection conn = get_url_connection ( ) n n try { n / / send post request with json body for the topology n if ( network_utils . send_http_post_request ( conn , network_utils . json_type , json_body . get_bytes ( ) ) ) { n throw new io_exception ( codstr + endpoint_uri ) n } n n / / check the response n if ( network_utils . check_http_response_code ( conn , expected_response_code ) ) { n byte [ ] bytes = network_utils . read_http_response ( conn ) n log . log ( level . severe , codstr ) n log . log ( level . severe , new string ( bytes ) ) n throw new io_exception ( codstr n + expected_response_code + codstr + conn . get_response_code ( ) ) n } n } finally { n conn . disconnect ( ) n } n }	1
Q_40	httpclient post json	C_40_1	override n public json_node post ( http_entity data , string path , object . parameters ) { n return http_client . post ( n this to_json , n data , n path , n parameters n ) n }	1
Q_40	httpclient post json	C_40_2	public static void main ( string [ ] args ) { n phaser phaser = new phaser ( codint ) n n http2_server_builder server = . http_server ( ) n server . router ( ) . post ( codstr ) n . produces ( codstr ) . consumes ( codstr ) n . handler ( ctx _ > { n map < string , object > ret = new hash_map < > ( ) n ret . put ( codstr , codstr + ctx . get_json_body ( task . class ) + codstr ) n ret . put ( codstr , codint ) n ctx . put ( http_header . content_type , mime_types . type . application_json_utf_8 . as_string ( ) ) n . end ( . json . to_json ( ret ) ) n } ) . listen ( codstr , codint ) n n task task = new task ( ) n task . name = codstr n task . date = new date ( ) n . http_client ( ) . post ( codstr ) n . put ( http_header . accept , codstr ) n . json_body ( task ) . submit ( ) n . then_accept ( res _ > { n system . out . println ( res . get_json_object_body ( ) ) n phaser . arrive ( ) n } ) n n phaser . arrive_and_await_advance ( ) n server . stop ( ) n . http_client ( ) . stop (	1
Q_40	httpclient post json	C_40_3	override n public string post ( string host , int port , string schema , string uri , string body ) { n try { n http_client client = http_clients . create_default ( ) n http_post post = new http_post ( uri ) n post . set_header ( codstr , host ) n post . set_header ( codstr , codstr ) n post . set_entity ( new string_entity ( body ) ) n http_response execute = client . execute ( new http_host ( host , port , schema ) , post ) n return response ( execute ) n } catch ( client_protocol_exception e ) { n e . print_stack_trace ( ) n throw new runtime_exception ( e ) n } catch ( io_exception e ) { n e . print_stack_trace ( ) n throw new runtime_exception ( e ) n } n }	1
Q_40	httpclient post json	C_40_4	private static json_object do_post_request ( http_post http_post , hash_map < string , string > params ) throws json_exception { n json_object json = null n http_client post_client = http_client_builder . create ( ) . build ( ) n http_response response n n try { n response = post_client . execute ( http_post ) n n if ( response . get_status_line ( ) . get_status_code ( ) = = codint ) { n http_entity entity = response . get_entity ( ) n n if ( entity = null ) { n input_stream instream = entity . get_content ( ) n string result = convert_stream_to_string ( instream ) n instream . close ( ) n n json = new json_object ( result ) n } n } else { n json = upwork_rest_client . gen_error ( response ) n } n } catch ( client_protocol_exception e ) { n json = upwork_rest_client . gen_error ( http_response_503 , codstr ) n } catch ( io_exception e ) { n json = upwork_rest_client . gen_error ( http_response_503 , codstr ) n } catch ( json_exception e ) { n json = upwork_rest_client . gen_error ( http_response_503 , codstr ) n } catch ( exception e ) { n json = upwork_rest_client . gen_error ( http_response_503 , codstr + e . to_string ( ) ) n } finally { n http_post . abort ( ) n } n n return json n }	1
Q_40	httpclient post json	C_40_5	public closeable_http_response post_json ( string url , string json , map < string , string > req_headers ) throws io_exception { n closeable_http_client req = get_client ( ) n closeable_http_response resp = null n http_post post = new http_post ( url ) n add_headers ( post , req_headers ) n post . set_header ( json , url ) n string_entity input = new string_entity ( json , content_type . application_json ) n post . set_entity ( input ) n resp = req . execute ( post ) n return resp n }	1
Q_40	httpclient post json	C_40_6	private boolean http_post ( string url , string msg ) { n boolean ret = false n n closeable_http_client http_client = http_client_builder . create ( ) . build ( ) n closeable_http_response response = null n try { n http_post request = new http_post ( url ) n list < name_value_pair > nvps = new array_list < > ( ) n nvps . add ( new basic_name_value_pair ( codstr , monitor_name ) ) n nvps . add ( new basic_name_value_pair ( codstr , msg ) ) n request . set_entity ( new url_encoded_form_entity ( nvps ) ) n response = http_client . execute ( request ) n http_entity entity = response . get_entity ( ) n if ( entity = null ) { n log . info ( entity_utils . to_string ( entity ) ) n } n entity_utils . consume ( entity ) n ret = true n } catch ( exception e ) { n log . error ( codstr , e ) n } finally { n try { n if ( response = null ) n response . close ( ) n http_client . close ( ) n } catch ( exception e ) { n log . error ( codstr , e ) n } n } n n return ret n }	0
Q_40	httpclient post json	C_40_7	public observable < http_client_response < byte_buf n post_smile ( string uri_str , json_payload payload ) { n byte [ ] entity = to_byte_array ( smile_factory , payload ) n uri uri = uri . create ( uri_str ) n return rx_http . post ( uri , smile_content_type , entity ) n }	0
Q_41	html entity replace	C_41_0	public static string replace_html_entities ( string content , map < string , character > map ) { n n for ( entry < string , character > entry escape_strings . entry_set ( ) ) { n n if ( content . index_of ( entry . get_key ( ) ) = _ codint ) { n content = content . replace ( entry . get_key ( ) , string . value_of ( entry . get_value ( ) ) ) n } n n } n n return content n }	1
Q_41	html entity replace	C_41_1	public static string_builder escape_ascii_html_entities ( final char_sequence input ) { n if ( input = = null ) n return null n n string_builder replaced = new string_builder ( ) n string_builder to_be_replaced = new string_builder ( ) n boolean is_entity = false n n for ( int i = codint i < input . length ( ) i + + ) { n char c = input . char_at ( i ) n if ( is_entity ) { n if ( c = = codstr ) { n replaced . append ( to_be_replaced ) n to_be_replaced = new string_builder ( ) n to_be_replaced . append ( c ) n } else { n to_be_replaced . append ( c ) n if ( c = = codstr ) { n if ( entity_name_to_char . contains_key ( to_be_replaced . to_string ( ) ) ) { n replaced . append ( entity_name_to_char . get ( to_be_replaced . to_string ( ) ) ) n } else { n matcher m = entity_number_pattern . matcher ( to_be_replaced ) n if ( m . matches ( ) ) { n int ascii = integer . parse_int ( m . group ( codint ) ) n replaced . append ( ascii > = codint ascii < = codint ? character . to_string ( ( char ) ascii ) to_be_replaced ) n } else { n replaced . append ( to_be_replaced ) n } n } n is_entity = false n to_be_replaced = new string_builder (	1
Q_41	html entity replace	C_41_2	public static string html_decode ( final string encoded_html ) { n validate ( encoded_html , null_string_predicate , null_string_msg_supplier ) n string [ ] entities = encoded_html . split ( codstr ) n return arrays . stream ( entities ) . map ( e _ > html_entities . decoded_entities . get ( e ) ) . collect ( joining ( ) ) n }	1
Q_41	html entity replace	C_41_3	private string filter_known_entities ( string html ) { n return html . replace ( entity_quote , symbol_quote ) n . replace ( entity_equal_ , symbol_equal ) n . replace ( entity_equal , symbol_equal ) n }	1
Q_41	html entity replace	C_41_4	public static string replace_html_entities_with_codes ( string input ) throws io_exception { n string output = input n map < string , string > entities_map = new hash_map < string , string > ( ) n input_stream is = string_conversion_utils . class . get_resource_as_stream ( codstr ) n string [ ] result = io_utils . to_string ( is ) . split ( codstr ) n is . close ( ) n for ( string line result ) { n entities_map . put ( line . split ( codstr ) [ codint ] , line . split ( codstr ) [ codint ] ) n } n for ( entry < string , string > entry entities_map . entry_set ( ) ) { n output = output . replace ( entry . get_key ( ) , entry . get_value ( ) ) n } n return output n }	1
Q_41	html entity replace	C_41_5	private static string remove_html_markup ( string html ) { n / / replace any amount of white space with newline between through one n / / space n html = html . replace_all ( codstr , codstr ) n / / remove all valid html tags n html = html . replace_all ( codstr , codstr ) n html = html . replace_all ( codstr , codstr ) n / / convert some of the entities which are used in current fb n / / messages . xml n html = html . replace_all ( codstr , codstr ) n html = html . replace_all ( codstr , codstr ) n html = html . replace_all ( codstr , codstr ) n html = html . replace_all ( codstr , codstr ) n return html . trim ( ) n }	1
Q_42	html encode string	C_42_0	public static string escape ( string html , boolean encode ) { n if ( encode ) { n html = html . replace_all ( codstr , codstr ) n } else { n html = html . replace ( codstr , codstr ) n } n return html . replace ( codstr , codstr ) . replace ( codstr , codstr ) . replace ( codstr codstr quot codstr codstr , codstr ) n }	1
Q_42	html encode string	C_42_1	public static void for_html_unquoted_attribute ( writer out , string input ) n throws io_exception n { n encode ( encoders . html_unquoted_attribute_encoder , out , input ) n }	1
Q_42	html encode string	C_42_2	public static string url_encode ( string str ) { n try { n return url_encoder . encode ( str , utf8 ) n } catch ( unsupported_encoding_exception e ) { n throw new illegal_argument_exception ( codstr , e ) n } n }	1
Q_42	html encode string	C_42_3	public static string html_decode ( final string encoded_html ) { n validate ( encoded_html , null_string_predicate , null_string_msg_supplier ) n string [ ] entities = encoded_html . split ( codstr ) n return arrays . stream ( entities ) . map ( e _ > html_entities . decoded_entities . get ( e ) ) . collect ( joining ( ) ) n }	0
Q_42	html encode string	C_42_4	public static string url_encode ( string str ) n { n string ret = str n n try n { n ret = url_encoder . encode ( str , codstr ) n } n catch ( unsupported_encoding_exception e ) n { n logger . severe ( codstr + str ) n } n n return ret n }	0
Q_42	html encode string	C_42_5	"public static string encode_to ( string button_caption , string html ) { n try { n return new expandable_details_note ( button_caption , html ) . encode ( ) n } catch ( io_exception e ) { n / / impossible , but don codstr failed to serialize codstr "" n } n }"	0
Q_42	html encode string	C_42_6	public static string encode ( string str ) n { n string encoded_value = str n n try n { n encoded_value = url_encoder . encode ( encoded_value , codstr ) n n / / spaces in nrql queries expected to be encoded as codstr instead of codstr . n encoded_value = encoded_value . replace ( codstr , codstr ) n } n catch ( unsupported_encoding_exception e ) n { n logger . severe ( codstr + str ) n } n n return encoded_value n }	0
Q_42	html encode string	C_42_7	override n public string get_page_html ( string page_title ) throws exception { n string params = codstr + encode ( page_title ) n parse parse = get_parse ( params ) n string html = parse . get_text ( ) n return html n }	0
Q_43	how to reverse a string	C_43_0	public static string reverse ( final string string ) { n n return is_empty ( string ) ? string new string_builder ( string ) . reverse ( ) . to_string ( ) n }	1
Q_43	how to reverse a string	C_43_1	public static string reverse ( final string str ) { n if ( str = = null ) { n return null n } n return new string_builder ( str ) . reverse ( ) . to_string ( ) n }	1
Q_43	how to reverse a string	C_43_2	public static string reverse_string ( string str ) { n string_builder string_buffer = new string_builder ( str ) n return string_buffer . reverse ( ) . to_string ( ) n }	1
Q_43	how to reverse a string	C_43_3	public static string reverse ( string string ) { n if ( string = null ) { n return new string_builder ( string ) . reverse ( ) . to_string ( ) n } n return null n }	1
Q_43	how to reverse a string	C_43_4	private static string reverse_string ( string in ) { n string_builder out = new string_builder ( in ) . reverse ( ) n return out . to_string ( ) n }	1
Q_43	how to reverse a string	C_43_5	public static string reverse ( string str ) { n if ( str = = null ) { n return null n } n return new string_buffer ( str ) . reverse ( ) . to_string ( ) n }	1
Q_43	how to reverse a string	C_43_6	public static string reverse ( final string str ) { n if ( n . is_null_or_empty ( str ) ) { n return str n } n n final string_builder sb = objectory . create_string_builder ( ) n n try { n sb . append ( str ) n n return sb . reverse ( ) . to_string ( ) n } finally { n objectory . recycle ( sb ) n } n }	1
Q_43	how to reverse a string	C_43_7	public static string reverse ( final string s ) { n string_builder result = new string_builder ( s . length ( ) ) n for ( int i = s . length ( ) _ codint i > = codint i _ ) { n result . append ( s . char_at ( i ) ) n } n return result . to_string ( ) n }	1
Q_43	how to reverse a string	C_43_8	"override n protected void do_in_background ( string . arg0 ) { n n act . print_sample_start_info ( codstr ) n n try { n / / setup the cloud storage account . n cloud_storage_account account = cloud_storage_account n . parse ( main_activity . storage_connection_string ) n n / / create a table service client . n table_client = account . create_cloud_table_client ( ) n n / / retrieve a reference to a table . n / / append a random uuid to the end of the table name so that this n / / sample can be run more than once in quick succession . n table = table_client . get_table_reference ( table_name n + uuid . random_uuid ( ) . to_string ( ) . replace ( codstr , codstr ) ) n n / / create the table if it doesn codstr table_basics "" ) n n return null n }"	0
Q_43	how to reverse a string	C_43_9	suppress_warnings ( codstr ) / / how to explain ? n override n public < s extends t > ordering < s > reverse ( ) { n return ( ordering < s > ) forward_order n }	0
Q_44	how to read the content of a gz compress file	C_44_0	public static input_stream decompress ( final input_stream in , final string file_name ) throws io_exception n { n if ( file_name . ends_with ( gz_suffix ) ) { n return gzip_input_stream ( in ) n } else if ( file_name . ends_with ( bz2_suffix ) ) { n return new b_zip2_compressor_input_stream ( in , true ) n } else if ( file_name . ends_with ( xz_suffix ) ) { n return new xz_compressor_input_stream ( in , true ) n } else if ( file_name . ends_with ( snappy_suffix ) ) { n return new framed_snappy_compressor_input_stream ( in ) n } else if ( file_name . ends_with ( zstd_suffix ) ) { n return new zstd_compressor_input_stream ( in ) n } else if ( file_name . ends_with ( zip_suffix ) ) { n / / this reads the first file in the archive . n final zip_input_stream zip_in = new zip_input_stream ( in , standard_charsets . utf_8 ) n try { n final zip_entry next_entry = zip_in . get_next_entry ( ) n if ( next_entry = = null ) { n zip_in . close ( ) n n / / no files in the archive _ return an empty stream . n return new byte_array_input_stream ( new byte [ codint ] ) n } n return zip_in n } n catch ( io_exception e ) { n try { n zip_in . close ( ) n } n catch ( io_exception e2 ) { n e . add_suppressed ( e2	1
Q_44	how to read the content of a gz compress file	C_44_1	public static void zip_compress ( string filename ) throws io_exception { n file_output_stream fos = new file_output_stream ( filename + compression_suffix ) n checked_output_stream csum = new checked_output_stream ( fos , new crc32 ( ) ) n zip_output_stream out = new zip_output_stream ( new buffered_output_stream ( csum ) ) n out . set_comment ( codstr ) n n buffered_reader in = new buffered_reader ( new file_reader ( filename ) ) n out . put_next_entry ( new zip_entry ( new file ( filename ) . get_name ( ) ) ) n int c n while ( ( c = in . read ( ) ) = _ codint ) n out . write ( c ) n in . close ( ) n n out . finish ( ) n out . close ( ) n }	1
Q_44	how to read the content of a gz compress file	C_44_2	input_stream get_input_stream ( ) throws io_exception { n switch ( filetype ) { n case gz n log . debug ( codstr ) n return new gzip_compressor_input_stream ( new file_input_stream ( compressed_file ) ) n case bz2 n log . debug ( codstr ) n return new b_zip2_compressor_input_stream ( new file_input_stream ( compressed_file ) ) n } n return null n }	1
Q_44	how to read the content of a gz compress file	C_44_3	public array read_compressed_zlib ( ucar . nc2 . variable v2 , long data_pos , int nx , int ny , int [ ] origin , int [ ] shape , int [ ] stride ) throws io_exception , invalid_range_exception { n n long length = raf . length ( ) n n raf . seek ( data_pos ) n n int data_size = ( int ) ( length _ data_pos ) / / or codint as read buffer size n byte [ ] data = new byte [ data_size ] n raf . read_fully ( data ) n n / / decompress the bytes n int result_length n int result = codint n byte [ ] tmp n int uncomp_len / * length of decompress space * / n byte [ ] uncomp = new byte [ nx * ( ny + codint ) + codint ] n inflater inflater = new inflater ( false ) n n inflater . set_input ( data , codint , data_size ) n int offset = codint n int limit = nx * ny + nx n n while ( inflater . get_remaining ( ) > codint ) { n try { n result_length = inflater . inflate ( uncomp , offset , codint ) n n } catch ( data_format_exception ex ) { n ex . print_stack_trace ( ) n throw new io_exception ( ex . get_message ( ) ) n } n n offset = offset + result_length n result =	1
Q_44	how to read the content of a gz compress file	C_44_4	private file extract ( file compressed_file ) n throws io_exception , interrupted_exception { n string file_name = compressed_file . get_name ( ) . to_lower_case ( ) n n boolean extract_file = file_name . ends_with ( codstr ) n file_name . ends_with ( codstr ) n if ( extract_file ) { n log . info ( codstr , file_name ) n } n if ( file_name . ends_with ( codstr ) ) { n un_b_zip2 ( compressed_file ) n } else if ( file_name . ends_with ( codstr ) ) { n un_tar_gz ( compressed_file ) n } else if ( file_name . ends_with ( codstr ) ) { n un_gzip ( compressed_file ) n } else if ( file_name . ends_with ( codstr ) ) { n extract_msi ( compressed_file ) n } else if ( file_name . ends_with ( codstr ) ) { n un_zip ( compressed_file ) n } n n if ( extract_file ) { n delete_file ( compressed_file ) n } n n file result = web_driver_manager . get_instance ( driver_manager_type ) n . post_download ( compressed_file ) . get_absolute_file ( ) n log . trace ( codstr , result ) n n return result n }	1
Q_44	how to read the content of a gz compress file	C_44_5	private static string invert_filename ( file file , string compression ) { n / / first invert the filename n string [ ] name = string_utils . split ( file . get_name ( ) , codstr ) n if ( name . length < codint ) n return null n string extension = name [ name . length _ codint ] n boolean compressed = false n if ( extension . equals_ignore_case ( codstr ) ) { n extension = name [ name . length _ codint ] n compressed = true n } n string_builder result = new string_builder ( ) n for ( int i = codint i < ( compressed ? name . length _ codint name . length _ codint ) i + + ) n result . append ( name [ i ] ) . append ( codstr ) n result . append ( extension . equals_ignore_case ( codstr ) ? codstr codstr ) n if ( compressed ) n result . append ( codstr ) n n / / then update the extension using the requested compression n string new_name = result . to_string ( ) n if ( codstr . equals ( compression ) ) { n if ( new_name . ends_with ( codstr ) ) n new_name = new_name . replace ( codstr , codstr ) n if ( new_name . ends_with ( codstr ) ) n new_name = new_name + codstr n } n else if ( codstr . equals	0
Q_44	how to read the content of a gz compress file	C_44_6	public static boolean test_compressed_warc_file ( final file f ) n throws io_exception { n file_utils . assert_readable ( f ) n boolean compressed = false n final input_stream is = new file_input_stream ( f ) n try { n compressed = archive_utils . is_gzipped ( is ) n } finally { n is . close ( ) n } n return compressed n }	0
Q_44	how to read the content of a gz compress file	C_44_7	private void compress_file_contents ( nonnull compressor compressor , nonnull file file ) { n log . trace ( codstr , file ) n n final file target_file = find_new_file ( file . get_absolute_path ( ) , compressed_file_suffix ) n final file temp_file = find_new_file ( file . get_absolute_path ( ) , temp_compressed_file_suffix ) n n / / compress source file contents and write result to the temp file n try ( final input_stream source_stream = new file_input_stream ( file ) ) { n try ( final output_stream temp_file_stream = new file_output_stream ( temp_file ) ) { n try ( final output_stream compression_stream = compressor . open_output_stream ( temp_file_stream , file . get_name ( ) ) ) { n final byte [ ] buffer = new byte [ default_buffer_size ] n n for ( ) { n int read = source_stream . read ( buffer ) n if ( read < codint ) { n break n } n n compression_stream . write ( buffer , codint , read ) n } n } n } n } catch ( io_exception e ) { n log . error ( codstr , file . get_absolute_path ( ) , temp_file . get_absolute_file ( ) , e ) n n / / delete temp file n if ( temp_file . exists ( ) temp_file . delete ( ) ) { n log . error ( codstr , temp_file . get_absolute_path ( ) ) n } n n return n } n n if	0
Q_44	how to read the content of a gz compress file	C_44_8	protected void get_compressed_data ( ) throws io_exception { n check_stream ( ) n n int n = in . read ( buffer , codint , buffer . length ) n if ( n = = _ codint ) { n throw new codec_premature_eof_exception ( n codstr + n codstr ) n } n n decompressor . set_input ( buffer , codint , n ) n }	0
Q_44	how to read the content of a gz compress file	C_44_9	public static boolean test_compressed_stream ( final input_stream is ) n throws io_exception { n boolean compressed_arc_file = false n try { n new gzip_header ( is ) n compressed_arc_file = true n } catch ( no_gzip_magic_exception e ) { n return compressed_arc_file n } n return compressed_arc_file n }	0
Q_45	how to read csv file in an efficient way	C_45_0	private map < string , string > parse_csv_file ( ) throws io_exception { n final input_stream input_stream = files . new_input_stream ( paths . get ( config . path ( ) ) ) n final input_stream_reader file_reader = new input_stream_reader ( input_stream , standard_charsets . utf_8 ) n final immutable_map . builder < string , string > new_lookup_builder = immutable_map . builder ( ) n n try ( final csv_reader csv_reader = new csv_reader ( file_reader , config . separator_as_char ( ) , config . quotechar_as_char ( ) ) ) { n int line = codint n int key_column = _ codint n int value_column = _ codint n n while ( true ) { n final string [ ] next = csv_reader . read_next ( ) n if ( next = = null ) { n break n } n line + + n n if ( line = = codint ) { n / / the first line in the csv file provides the column names n int col = codint n for ( final string column next ) { n if ( is_null_or_empty ( column ) ) { n if ( config . key_column ( ) . equals ( column ) ) { n key_column = col n } n if ( config . value_column ( ) . equals ( column ) ) { n value_column = col n } n } n col + + n } n } else { n / / the	1
Q_45	how to read csv file in an efficient way	C_45_1	private list < string [ ] > read_file ( string absolute_path , boolean header_row_only ) { n n try ( input_stream in = new bom_input_stream ( new file_input_stream ( absolute_path ) ) n reader reader = new input_stream_reader ( in , pm . get_csv_charset ( ) ) ) { n n rfc4180_parser rfc4180_parser = new rfc4180_parser_builder ( ) . build ( ) n csv_reader_builder csv_reader_builder = new csv_reader_builder ( reader ) n . with_csv_parser ( rfc4180_parser ) n n try ( csv_reader csv_reader = csv_reader_builder . build ( ) ) { n n if ( header_row_only ) { n return collections . singleton_list ( csv_reader . read_next ( ) ) n } else { n return csv_reader . read_all ( ) n } n n } n } catch ( io_exception e ) { n throw new illegal_state_exception ( e ) n } n }	1
Q_45	how to read csv file in an efficient way	C_45_2	public table_data read_csv ( string file ) { n n list < string > all_lines = new array_list < string > ( ) n try { n / / csv n string text = io_utils . to_string ( file_io_utils . get_input_stream ( file ) , n file_io_utils . get_file_encoding ( ) ) n n / / split n for ( string line file_io_utils . split_to_lines ( text ) ) { n all_lines . add ( line ) n } n n } catch ( io_exception e ) { n throw new illegal_state_exception ( e ) n } n n table_data table_data = new table_data ( ) n n / / schema n map < string , integer > schema = retrive_schema ( all_lines . remove ( codint ) ) n log . debug ( message_manager . get_message ( codstr ) , schema ) n n for ( int i = codint i < all_lines . size ( ) i + + ) { n row_data row = read_row ( schema , all_lines . get ( i ) ) n table_data . add ( row ) n n log . debug ( message_manager . get_message ( codstr ) , i + codint , n file_io_utils . escape_return ( row ) ) n } n n log . info ( message_manager . get_message ( codstr ) , table_data . get_row_count ( ) ) n n return table_data n }	1
Q_45	how to read csv file in an efficient way	C_45_3	public void read_external ( object_input in ) throws io_exception , class_not_found_exception n { n order_number = in . read_int ( ) n n / / read canonical file path n int size = in . read_int ( ) n if ( size > codint ) n { n byte [ ] buf = new byte [ size ] n in . read_fully ( buf ) n n file f = new file ( new string ( buf , codstr ) ) n / / validate if exists n if ( privileged_file_helper . exists ( f ) ) n { n file = f n } n else n { n file = null n } n } n else n { n / / should not occurs but since we have a way to recover , it should not be n / / an issue n file = null n } n }	0
Q_45	how to read csv file in an efficient way	C_45_4	private void open ( ) { n if ( vcf_reader = = null ) { n if ( index_path = null ) { n vcf_reader = new vcf_file_reader ( data_path . to_file ( ) , index_path . to_file ( ) ) n } else { n vcf_reader = new vcf_file_reader ( data_path . to_file ( ) ) n } n } n }	0
Q_45	how to read csv file in an efficient way	C_45_5	private boolean read_cmap ( font_file_reader in ) throws io_exception { n n unicode_mapping = new java . util . array_list ( ) n n / / read cmap table and correct mtx_tab . index n int mtx_ptr = codint n n seek_tab ( in , codstr , codint ) n int num_c_map = in . read_ttfu_short ( ) / / number of cmap subtables n long cmap_uni_offset = codint n n log . info ( num_c_map + codstr ) n n / / read offset for all tables . we are only interested in the unicode table n for ( int i = codint i < num_c_map i + + ) { n int cmap_pid = in . read_ttfu_short ( ) n int cmap_eid = in . read_ttfu_short ( ) n long cmap_offset = in . read_ttfu_long ( ) n n log . debug ( codstr + cmap_pid + codstr + cmap_eid ) n n if ( cmap_pid = = codint cmap_eid = = codint ) { n cmap_uni_offset = cmap_offset n } n } n n if ( cmap_uni_offset < = codint ) { n log . fatal ( codstr ) n log . fatal ( codstr ) n return false n } n n / / read unicode cmap n seek_tab ( in , codstr , cmap_uni_offset ) n int cmap_format = in . read_ttfu_short ( ) n / * int cmap_length = * / in . read_ttfu_short ( ) / / skip cmap length n n	0
Q_45	how to read csv file in an efficient way	C_45_6	private set < string > convert_csv_to_set ( string csv ) { n / / a null line in the file indicates an empty file so return an empty n / / set as it means no apa_rs were found n if ( csv = = null ) { n return collections . empty_set ( ) n } n n / / if we got this far then we must of found the csv file so process it n / / to find the apar i_ds n set < string > fix_pack_apar_ids = new hash_set < string > ( ) n string [ ] apar_ids = csv . split ( codstr ) n for ( string id apar_ids ) { n fix_pack_apar_ids . add ( id ) n } n return fix_pack_apar_ids n }	0
Q_46	how to randomly pick a number	C_46_0	public int random_choose_from_distribution ( double . probs ) { n int result = _ codint n int [ ] range = new int [ probs . length ] n double accuracy = codint n int total = codint n n for ( int i = codint i < probs . length i + + ) { n range [ i ] = ( int ) ( probs [ i ] * accuracy ) n total + = range [ i ] n } n n int rand_num = ( int ) ( rng . next_double ( ) * total ) n for ( int i = codint i < range . length i + + ) { n rand_num _ = range [ i ] n if ( rand_num < = codint ) { n result = i n break n } n } n return result n }	1
Q_46	how to randomly pick a number	C_46_1	private int generate_random_id ( ) { n int num = ( int ) ( math . random ( ) * integer . max_value ) n while ( result_holder . contains_key ( num ) ) { n num = ( int ) ( math . random ( ) * integer . max_value ) n } n return num n }	1
Q_46	how to randomly pick a number	C_46_2	public static < t > t pick_random ( list < t > values , t skip , random r ) n { n int size = values . size ( ) n if ( size < codint ) { n throw new illegal_argument_exception ( n codstr + size + codstr ) n } n n int pick = r . next_int ( size _ codint ) n for ( int ii = codint ii < size ii + + ) { n t val = values . get ( ii ) n if ( ( val = skip ) ( pick _ = = codint ) ) { n return val n } n } n return null n }	1
Q_46	how to randomly pick a number	C_46_3	private int pick_random_slot_in_r ( ) { n assert r_ > codint n final int offset = h_ + m_ n if ( r_ = = codint ) { n return offset n } else { n return offset + sampling_util . rand . next_int ( r_ ) n } n }	1
Q_46	how to randomly pick a number	C_46_4	public void read ( ) throws exception { n long end_time = system . current_time_millis ( ) + rtc . max_time n while ( system . current_time_millis ( ) < end_time ) { n / / randomly pick a datanode from victims n int idx = rb . next_int ( rtc . victims . length ) n / / randomly pick a file to read n array_list < path > file_list = ns_pick_lists . get ( rtc . victims [ idx ] . get_host_name ( ) ) n int fid = rb . next_int ( file_list . size ( ) ) n path read_file = file_list . get ( fid ) n fs_data_input_stream in = null n try { n in = fs . open ( read_file ) n if ( in . is_under_construction ( ) ) { n log . info ( codstr + read_file + codstr ) n } n file_status file_status = fs . get_file_status ( read_file ) n long offset = rb . next_int ( ( int ) math . max ( n file_status . get_len ( ) _ rtc . buffer_size , codint ) + codint ) n int size = codint n in . seek ( offset ) n size = in . read ( buffer , codint , rtc . buffer_size ) n if ( size < codint ) { n continue n } n processed_size + = size n read_size + = size n log . info ( codstr + read_file	1
Q_46	how to randomly pick a number	C_46_5	private int pick_a_port ( int port ) { n if ( port = = codint ) { n port = codint + random . next_int ( codint ) n logger . debug ( codstr , port ) n } n return port n }	1
Q_46	how to randomly pick a number	C_46_6	public string generate_bsn ( ) { n string result1 = codstr n int nr9 = random_util . random ( codint ) n int nr8 = random_util . random ( codint ) n int nr7 = random_util . random ( codint ) n int nr6 = random_util . random ( codint ) n int nr5 = random_util . random ( codint ) n int nr4 = random_util . random ( codint ) n int nr3 = random_util . random ( codint ) n int nr2 = random_util . random ( codint ) n int nr1 = codint n int sofi_nr = codint n if ( ( nr9 = = codint ) ( nr8 = = codint ) ( nr7 = = codint ) ) { n nr8 = codint n } n sofi_nr = codint * nr9 + codint * nr8 + codint * nr7 + codint * nr6 + codint * nr5 + codint * nr4 + codint * nr3 + codint * nr2 n nr1 = floor ( sofi_nr _ ( floor ( sofi_nr / codint ) ) * codint ) n if ( nr1 > codint ) { n if ( nr2 > codint ) { n nr2 _ = codint n nr1 = codint n } else { n nr2 + = codint n nr1 = codint n } n } n result1 + = nr9 n result1 + = nr8 n result1 + = nr7 n result1 + = nr6 n result1 + = nr5	1
Q_46	how to randomly pick a number	C_46_7	"public ternary_vector generate ( ) { n hash_set < integer > pos = new hash_set < integer > ( ) n hash_set < integer > neg = new hash_set < integer > ( ) n n / / randomly decide how many bits to set in the index vector based on the n / / variance . n int bits_to_set = num_vector_values + n ( int ) ( random . next_double ( ) * variance * n ( ( random . next_double ( ) > . codint ) ? codint _ codint ) ) n n for ( int i = codint i < bits_to_set + + i ) { n boolean picked = false n / / loop to ensure we actually pick the full number of bits n while ( picked ) { n / / pick some random index n int index = random . next_int ( index_vector_length ) n n / / check that we haven "" t already added this index n if ( pos . contains ( index ) neg . contains ( index ) ) n continue n n / / decide positive or negative n ( ( random . next_double ( ) > . codint ) ? pos neg ) . add ( index ) n picked = true n } n } n n int [ ] positive = new int [ pos . size ( ) ] n int [ ] negative = new int [ neg . size"	1
Q_47	how to make the checkbox check	C_47_0	protected void select_checkbox ( page_element element , string value_key_or_key , map < string , boolean > values ) throws technical_exception , failure_exception { n final string value_key = context . get_value ( value_key_or_key ) = null ? context . get_value ( value_key_or_key ) value_key_or_key n try { n final web_element web_element = context . wait_until ( expected_conditions . element_to_be_clickable ( utilities . get_locator ( element ) ) ) n boolean checkbox_value = values . get ( value_key ) n if ( checkbox_value = = null ) { n checkbox_value = values . get ( codstr ) n } n if ( web_element . is_selected ( ) = checkbox_value . boolean_value ( ) ) { n web_element . click ( ) n } n } catch ( final exception e ) { n new result . failure < > ( e . get_message ( ) , messages . format ( messages . get_message ( messages . fail_message_unable_to_check_element ) , element , element . get_page ( ) . get_application ( ) ) , true , n element . get_page ( ) . get_call_back ( ) ) n } n }	1
Q_47	how to make the checkbox check	C_47_1	protected j_check_box add_check_box ( final e item , final boolean checked ) { n final string name = get_name ( item ) n dc_check_box < e > check_box = _check_boxes . get ( name ) n if ( check_box = null ) { n check_box . set_selected ( checked ) n return check_box n } n check_box = new dc_check_box < > ( name , checked ) n check_box . set_value ( item ) n check_box . set_opaque ( false ) n check_box . add_listener ( _change_listener ) n _check_boxes . put ( name , check_box ) n add ( check_box ) n n update_visibility ( ) n update_ui ( ) n n return check_box n }	1
Q_47	how to make the checkbox check	C_47_2	private void link_to_emitter ( string name , linear_interpolator interpol ) { n / / put to value map n value_map . put ( name , interpol ) n n / / now update the checkbox to represent the state of the given n / / interpolator n boolean checked = interpol . is_active ( ) n j_check_box enable_control = ( j_check_box ) value_name_to_control . get ( name ) n enable_control . set_selected ( false ) n if ( checked ) n enable_control . set_selected ( checked ) n }	1
Q_47	how to make the checkbox check	C_47_3	public void visit ( list_item_node node ) { n if ( node instanceof task_list_node ) { n / / vsch # codint handle git_hub style task list items , these are a bit messy because the < input > checkbox needs to be n / / included inside the optional < p > < / p > first grand _ child of the list item , first child is always root_node n / / because the list item text is recursively parsed . n node first_child = node . get_children ( ) . get ( codint ) . get_children ( ) . get ( codint ) n boolean first_is_para = first_child instanceof para_node n int indent = node . get_children ( ) . size ( ) > codint ? codint codint n boolean start_was_new_line = printer . ends_with_new_line ( ) n n printer . println ( ) . print ( codstr task _ list _ item codstr ) . indent ( indent ) n if ( first_is_para ) { n printer . println ( ) . print ( codstr ) n printer . print ( codstr checkbox codstr task _ list _ item _ checkbox codstr + ( ( ( task_list_node ) node ) . is_done ( ) ? codstr checked codstr codstr ) + codstr disabled codstr ) n visit_children ( ( super_node ) first_child ) n n / / render the other children , the p tag is taken care of here n visit_children_skip_first ( node )	1
Q_47	how to make the checkbox check	C_47_4	public void uncheck_checkbox_in_cell ( int row , int column ) { n string checkbox_locator = get_x_path_base ( ) + codstr + row + codstr + column + codstr n check_box cb = new check_box ( checkbox_locator ) n cb . uncheck ( ) n }	1
Q_47	how to make the checkbox check	C_47_5	public static check_box new_check_box ( final string id , final i_model < boolean > model ) n { n final check_box check_box = new check_box ( id , model ) n check_box . set_output_markup_id ( true ) n return check_box n }	1
Q_47	how to make the checkbox check	C_47_6	private check_box create_permission_check_box ( string id ) { n check_box check_box = new check_box ( id ) n check_box . set_output_markup_id ( true ) n n return check_box n }	0
Q_47	how to make the checkbox check	C_47_7	private void check ( check_box check_box ) { n if ( check_box . get_value ( ) ) { n selected_list_items . add ( check_box . get_text ( ) ) n check_box . add_style_name ( style_checkboxlist_item_checked ) n clear_selection_control . set_visible ( true ) n } else { n remove_item ( check_box . get_text ( ) ) n check_box . remove_style_name ( style_checkboxlist_item_checked ) n if ( selected_list_items . size ( ) = = codint ) { n clear_selection_control . set_visible ( false ) n } n } n }	0
Q_47	how to make the checkbox check	C_47_8	private j_check_box create_check_box ( final string label , final boolean selected ) { n final j_check_box check_box = new j_check_box ( label , selected ) n check_box . set_opaque ( false ) n check_box . set_foreground ( widget_utils . bg_color_brightest ) n check_box . add_item_listener ( item _ > on_settings_updated ( false ) ) n n return check_box n }	0
Q_48	how to get html of website	C_48_0	public static html_page to_html_page ( web_driver web_driver ) { n try { n return html_parser . parse_html ( n new string_web_response ( web_driver . get_page_source ( ) , new url ( web_driver . get_current_url ( ) ) ) , n new web_client ( ) . get_current_window ( ) n ) n } catch ( io_exception e ) { n throw new runtime_exception ( codstr , e ) n } n }	1
Q_48	how to get html of website	C_48_1	get n produces ( media_type . text_html ) n public response error_html ( context http_servlet_request request ) { n string_builder html = new string_builder ( codint ) n n html . append ( codstr + n codstr + n codstr text / css codstr + n codstr + n codstr + n codstr ) n n html . append ( codstr ) n number status_code = ( number ) request . get_attribute ( request_dispatcher . error_status_code ) n if ( status_code = null ) { n html . append ( codstr ) . append ( status_code ) n } n html . append ( codstr ) n object request_uri = request . get_attribute ( request_dispatcher . error_request_uri ) n if ( request_uri = null ) { n html . append ( codstr ) n html . append ( jsp_helper . escape_xml ( request_uri ) ) n } n html . append ( codstr ) n n object message = request . get_attribute ( request_dispatcher . error_message ) n if ( message = null ) { n html . append ( codstr ) n html . append ( jsp_helper . escape_xml ( message ) ) n html . append ( codstr ) n } n n throwable throwable = ( throwable ) request . get_attribute ( request_dispatcher . error_exception ) n if ( throwable = null ) { n string_writer sw = new string_writer ( ) n throwable . print_stack_trace ( new print_writer ( sw ) ) n html .	1
Q_48	how to get html of website	C_48_2	public static html_page to_html_page ( string string ) { n try { n url url = new url ( codstr ) n return html_parser . parse_html ( new string_web_response ( string , url ) , new web_client ( ) . get_current_window ( ) ) n } catch ( io_exception e ) { n throw new runtime_exception ( codstr , e ) n } n }	1
Q_48	how to get html of website	C_48_3	private string get_html_example ( ) { n final string_builder html = new string_builder ( ) n html . append ( codstr ) n html . append ( codstr http / / www . w3 . org / codint / xhtml codstr ) n html . append ( codstr http / / xmlns . jcp . org / jsf / html codstr ) n html . append ( codstr http / / butterfaces . org / components codstr ) n html . append ( codstr ) n html . append ( codstr ) n html . append ( codstr ) n html . append ( codstr ) n html . append ( codstr ) n html . append ( codstr ) n html . append ( codstr ) n n return html . to_string ( ) n }	1
Q_48	how to get html of website	C_48_4	request_mapping ( value = codstr , method = request_method . get ) n response_body n public json_object < ? > is_page_html_available ( n request_param ( value = codstr , required = true ) string url ) { n json_object < ? > result = json_object . create ( ) n log . info ( codstr + url ) n try { n result . add_data ( codstr , string_utils . is_not_empty ( page_fetcher . get_page_html ( url ) ) ) n } catch ( runtime_exception e ) { n log . error ( codstr + url + codstr + e . get_message ( ) , e ) n return sys_error ( global_response_status_msg . get_html_page_failed . get_message ( url ) n . get_message ( ) ) n } n return result n }	0
Q_48	how to get html of website	C_48_5	nullable n public static ihc_node create_linked_website ( nullable final string s_website , nullable final hc_target a_target ) n { n if ( string_helper . has_no_text ( s_website ) ) n return null n n if ( url_validator . is_valid ( s_website ) ) n return new hc_text_node ( s_website ) n n return new hca ( new simple_url ( s_website ) ) . set_target ( a_target ) . add_child ( s_website ) n }	0
Q_48	how to get html of website	C_48_6	nullable n public static ihc_node create_linked_website ( nullable final string s_website ) n { n return create_linked_website ( s_website , ( hc_target ) null ) n }	0
Q_48	how to get html of website	C_48_7	private void output_license_restriction_message ( ) { n try { n / / todo need to work out how to strip the ibm branding knowledge out of here . n product_info pi = product_info . get_all_product_info ( ) . get ( codstr ) n if ( pi = null pi . get_replaced_by ( ) = = null ) { n string edition = string . value_of ( pi . get_edition ( ) ) . to_lower_case ( ) n string license_type = string . value_of ( pi . get_property ( codstr ) ) . to_lower_case ( ) n string key = codstr + edition + codstr + license_type n resource_bundle rb = trace_nls . get_base_resource_bundle ( framework_manager . class , tc . get_resource_bundle_name ( ) ) n if ( rb . contains_key ( key ) ) { n string file = get_lang ( locale . get_default ( ) ) + codstr n tr . audit ( tc , key , codstr + n edition + codstr + license_type + codstr + pi . get_version ( ) + codstr + file ) n } n } n } catch ( product_info_parse_exception e ) { n } catch ( duplicate_product_info_exception e ) { n } catch ( product_info_replace_exception e ) { n } n }	0
Q_49	how to get database table name	C_49_0	public string get_fq_table_name ( ) n { n string str_return = null n / / are table names supported in table definitions ? n if ( a_schema . get_db_catalog ( ) . get_db_meta ( ) . get_supports_catalogs_in_table_definitions ( ) ) n { n / / yes , include catalog name in fq table name n / / now check , where we have to specify the catalog n if ( a_schema . get_db_catalog ( ) . get_db_meta ( ) . get_is_catalog_at_start ( ) ) n { n / / at the beginning n str_return = a_schema . get_db_catalog ( ) . get_catalog_name ( ) n + a_schema . get_db_catalog ( ) . get_db_meta ( ) . get_catalog_separator ( ) n + a_schema . get_schema_name ( ) + codstr + this . get_table_name ( ) n } n else n { n / / at the end n str_return = a_schema . get_schema_name ( ) + codstr + this . get_table_name ( ) n + a_schema . get_db_catalog ( ) . get_db_meta ( ) . get_catalog_separator ( ) n + a_schema . get_db_catalog ( ) . get_catalog_name ( ) n } n } n else n { n str_return = a_schema . get_schema_name ( ) + codstr + this . get_table_name ( ) n } n return str_return n }	1
Q_49	how to get database table name	C_49_1	protected string get_real_table_name ( string schema , string table_name ) throws database_exception { n string_buffer sql = new string_buffer ( ) n n / / sql sql1 = select ( codstr ) n / / . from ( codstr ) . as ( codstr ) n / / . field ( codstr ) n / / . left_join ( codstr ) . as ( codstr ) n / / . on ( codstr , codstr ) n / / . where ( lower ( codstr ) ) . equal_to ( lower ( table_name ) ) n n sql . append ( codstr + n codstr table codstr + n codstr + n codstr + n codstr + n codstr ) n if ( schema = null ) { n sql . append ( codstr ) n } n sql . append ( codstr ) n object [ ] parameters = null n if ( schema = null ) { n parameters = new object [ codint ] n parameters [ codint ] = table_name n parameters [ codint ] = schema n } else { n parameters = new object [ codint ] n parameters [ codint ] = table_name n } n n try { n result_set rs = execute_select_sql ( sql . to_string ( ) , parameters ) n if ( rs = null ) { n if ( rs . next ( ) ) { n string real_table_name = rs . get_string ( codint ) n	1
Q_49	how to get database table name	C_49_2	public string get_database_product_name ( ) throws database_exception { n connection connection = null n database database = null n string name = codstr n try { n connection = get_data_source ( ) . get_connection ( ) n database = database_factory . get_instance ( ) . find_correct_database_implementation ( new jdbc_connection ( connection ) ) n name = database . get_database_product_name ( ) n } catch ( sql_exception e ) { n throw new database_exception ( e ) n } finally { n if ( database = null ) { n database . close ( ) n } else if ( connection = null ) { n try { n if ( connection . get_auto_commit ( ) ) { n connection . rollback ( ) n } n connection . close ( ) n } catch ( sql_exception e ) { n log . warning ( log_type . log , codstr , e ) n } n } n } n return name n }	1
Q_49	how to get database table name	C_49_3	public string get_table_names ( boolean b_add_quotes ) n { n return ( m_table_name = = null ) ? record . format_table_names ( class_fields_file , b_add_quotes ) super . get_table_names ( b_add_quotes ) n }	0
Q_49	how to get database table name	C_49_4	"override n protected void do_in_background ( string . arg0 ) { n n act . print_sample_start_info ( codstr ) n n try { n / / setup the cloud storage account . n cloud_storage_account account = cloud_storage_account n . parse ( main_activity . storage_connection_string ) n n / / create a table service client . n table_client = account . create_cloud_table_client ( ) n n / / retrieve a reference to a table . n / / append a random uuid to the end of the table name so that this n / / sample can be run more than once in quick succession . n table = table_client . get_table_reference ( table_name n + uuid . random_uuid ( ) . to_string ( ) . replace ( codstr , codstr ) ) n n / / create the table if it doesn codstr table_basics "" ) n n return null n }"	0
Q_49	how to get database table name	C_49_5	private void create_table ( string database , string table ) n { n while ( true ) { n try { n client . create_table ( database , table ) n log . info ( codstr , database , table ) n return n } n catch ( td_client_http_exception e ) { n switch ( e . get_status_code ( ) ) { n case codint n log . info ( codstr , database , table ) n return n case codint n case codint n throw new non_retryable_exception ( n string . format ( codstr , database , table ) , e ) n case codint n create_database ( database ) n / / retry to create the table n break n default n throw new retryable_exception ( n string . format ( codstr , database , table ) , e ) n } n } n catch ( non_retryable_exception e ) { n throw e n } n catch ( throwable e ) { n throw new retryable_exception ( n string . format ( codstr , database , table ) , e ) n } n } n }	0
Q_49	how to get database table name	C_49_6	public static string build_create_property_table_sql ( db_name_resolver db_name_resolver ) { n string_builder sql_builder = new string_builder ( codstr ) n sql_builder . append ( db_name_resolver . get_table_name ( table_name . logging_event_property ) ) . append ( codstr ) n . append ( db_name_resolver . get_column_name ( column_name . event_id ) ) . append ( codstr ) n . append ( db_name_resolver . get_column_name ( column_name . mapped_key ) ) . append ( codstr ) n . append ( db_name_resolver . get_column_name ( column_name . mapped_value ) ) . append ( codstr ) n . append ( codstr ) n . append ( db_name_resolver . get_column_name ( column_name . event_id ) ) . append ( codstr ) n . append ( db_name_resolver . get_column_name ( column_name . mapped_key ) ) . append ( codstr ) n . append ( codstr ) n . append ( db_name_resolver . get_column_name ( column_name . event_id ) ) . append ( codstr ) n . append ( codstr ) n . append ( db_name_resolver . get_table_name ( table_name . logging_event ) ) . append ( codstr ) n . append ( db_name_resolver . get_column_name ( column_name . event_id ) ) . append ( codstr ) n . append ( codstr ) n return sql_builder . to_string ( ) n }	0
Q_49	how to get database table name	C_49_7	public string get_table_names ( boolean b_add_quotes ) n { n if ( m_table_name = = null ) n { n string str_database_name = codstr n if ( this . get_database_name ( ) = null ) n if ( this . get_database_name ( ) . ends_with ( codstr + this . get_database_name ( ) ) ) n str_database_name = codstr + this . get_database_name ( ) n return record . format_table_names ( database_info_file , b_add_quotes ) + str_database_name n } n return super . get_table_names ( b_add_quotes ) n }	0
Q_50	how to get current date	C_50_0	non_null n public static string get_now_date_time ( non_null string format ) { n simple_date_format formatter = new simple_date_format ( format , locale . english ) n date cur_date = new date ( system . current_time_millis ( ) ) n return formatter . format ( cur_date ) n }	1
Q_50	how to get current date	C_50_1	private date get_current_date ( ) n throws marshalling_error , invalid_response_exception , communication_error_exception , cryptography_error , n invalid_credentials_exception { n if ( server_time_offset_expires = = null server_time_offset_expires . before ( new date ( ) ) ) { n set_server_time_offset ( ) n } n calendar calendar = calendar . get_instance ( ) n calendar . set_time ( new date ( ) ) n calendar . add ( calendar . millisecond , server_time_offset ) n return calendar . get_time ( ) n }	1
Q_50	how to get current date	C_50_2	public static date get_current_date_time ( ) throws parse_exception { n calendar current_date = calendar . get_instance ( ) n simple_date_format formatter = new simple_date_format ( date_yyyy_m_mdd_th_hmmss_sssz ) n string date_now = formatter . format ( current_date . get_time ( ) ) n return get_date_from_string ( date_now ) n }	1
Q_50	how to get current date	C_50_3	public static string get_current_date ( ) { n long now = system . current_time_millis ( ) n n if ( ( now _ current_date_generated ) > codint ) { n synchronized ( format ) { n if ( ( now _ current_date_generated ) > codint ) { n current_date_generated = now n current_date = format . format ( new date ( now ) ) n } n } n } n n return current_date n }	1
Q_50	how to get current date	C_50_4	public static date get_date_with_prev_days ( int no_of_days ) throws parse_exception { n calendar current_date = calendar . get_instance ( ) n current_date . add ( calendar . date , _ no_of_days ) n simple_date_format formatter = new simple_date_format ( date_yyyy_m_mdd_th_hmmss_sssz ) n string date_now = formatter . format ( current_date . get_time ( ) ) n return get_date_from_string ( date_now ) n }	1
Q_50	how to get current date	C_50_5	override n public date get ( ) n { n string current = supplier . get ( ) n if ( current = null ) n { n date new_date = parse_date ( current ) n if ( new_date = null ) n { n return new_date n } n } n return default_value n }	0
Q_50	how to get current date	C_50_6	public array_list < duration > segment_work ( project_calendar project_calendar , list < timephased_work > work , timescale_units range_units , list < date_range > date_list ) n { n array_list < duration > result = new array_list < duration > ( date_list . size ( ) ) n int last_start_index = codint n n / / n / / iterate through the list of dates range we are interested in . n / / each date range in this list corresponds to a column n / / shown on the codstr view by ms project n / / n for ( date_range range date_list ) n { n / / n / / if the current date range does not intersect with any of the n / / assignment date ranges in the list , then we show a zero n / / duration for this date range . n / / n int start_index = last_start_index = = _ codint ? _ codint get_start_index ( range , work , last_start_index ) n if ( start_index = = _ codint ) n { n result . add ( duration . get_instance ( codint , time_unit . hours ) ) n } n else n { n / / n / / we have found an assignment which intersects with the current n / / date range , call the method below to determine how n / / much time from this resource assignment can be allocated n / / to	0
Q_51	how to extract zip file recursively	C_51_0	private static string extract_folder ( file zip_file ) throws zip_exception , io_exception { n int buffer = codint n n zip_file zip = new zip_file ( zip_file ) n string new_path = get_extracted_folder ( zip_file ) . get_absolute_path ( ) n n new file ( new_path ) . mkdir ( ) n enumeration zip_file_entries = zip . entries ( ) n n / / process each entry n while ( zip_file_entries . has_more_elements ( ) ) { n / / grab a zip file entry n zip_entry entry = ( zip_entry ) zip_file_entries . next_element ( ) n string current_entry = entry . get_name ( ) n file dest_file = new file ( new_path , current_entry ) n / / dest_file = new file ( new_path , dest_file . get_name ( ) ) n file destination_parent = dest_file . get_parent_file ( ) n n / / create the parent directory structure if needed n destination_parent . mkdirs ( ) n n if ( entry . is_directory ( ) ) { n buffered_input_stream is = new buffered_input_stream ( zip n . get_input_stream ( entry ) ) n int current_byte n / / establish buffer for writing file n byte data [ ] = new byte [ buffer ] n n / / write the current file to disk n file_output_stream fos = new file_output_stream ( dest_file ) n buffered_output_stream dest = new buffered_output_stream ( fos , n buffer ) n n / / read and write until last byte is	1
Q_51	how to extract zip file recursively	C_51_1	public static void extract_zip ( file zip , file to_dir ) throws io_exception { n if ( to_dir . exists ( ) ) { n throw new io_exception ( codstr codstr codstr ) n } n n try ( zip_file zip_file = new zip_file ( zip ) ) { n enumeration < ? extends zip_entry > entries = zip_file . entries ( ) n n while ( entries . has_more_elements ( ) ) { n zip_entry entry = entries . next_element ( ) n n file target = new file ( to_dir , entry . get_name ( ) ) n if ( entry . is_directory ( ) ) { n / / assume directories are stored parents first then children . n / / logger . info ( codstr + entry . get_name ( ) ) n / / this is not robust , just for demonstration purposes . n if ( target . mkdirs ( ) ) { n logger . warning ( codstr + target ) n } n continue n } n n / / zips can contain nested files in sub _ dirs without separate entries for the directories n if ( target . get_parent_file ( ) . exists ( ) target . get_parent_file ( ) . mkdirs ( ) ) { n logger . warning ( codstr + target . get_parent_file ( ) ) n } n n / / logger . info ( codstr + entry . get_name ( ) ) n try	1
Q_51	how to extract zip file recursively	C_51_2	public static void unzip ( file file , file dest_dir ) throws io_exception { n if ( dest_dir . exists ( ) ) { n dest_dir . mkdir ( ) n } n zip_input_stream zip_in = new zip_input_stream ( new file_input_stream ( file ) ) n zip_entry entry = zip_in . get_next_entry ( ) n / / iterates over entries in the zip file n while ( entry = null ) { n file entry_file = new file ( dest_dir , entry . get_name ( ) ) n if ( entry . is_directory ( ) ) { n / / if the entry is a file , extracts it n extract_file ( zip_in , entry_file ) n } else { n / / if the entry is a directory , make the directory n entry_file . mkdir ( ) n } n zip_in . close_entry ( ) n entry = zip_in . get_next_entry ( ) n } n zip_in . close ( ) n }	1
Q_51	how to extract zip file recursively	C_51_3	private int extract_zip ( zip_file zip_file , file dest_folder , map < string , string > replace_tokens , set < path_matcher > extract_matchers , set < path_matcher > skip_matchers , set < path_matcher > filter_matchers , boolean overwrite , boolean write_md5_sums ) throws io_exception { n enumeration < zip_archive_entry > en = zip_file . get_entries ( ) n int entries = codint n while ( en . has_more_elements ( ) ) { n zip_archive_entry next_entry = en . next_element ( ) n extract_entry ( zip_file . get_input_stream ( next_entry ) , next_entry , dest_folder , replace_tokens , extract_matchers , skip_matchers , filter_matchers , overwrite , write_md5_sums ) n entries + + n } n return entries n }	1
Q_51	how to extract zip file recursively	C_51_4	public static void extract_zip ( input_stream zip , final file to_dir ) throws io_exception { n if ( to_dir . exists ( ) ) { n throw new io_exception ( codstr codstr codstr ) n } n n / / use the zip_file_visitor to walk all the entries in the zip _ stream and create n / / directories and files accordingly n new zip_file_visitor ( ) { n override n public void visit ( zip_entry entry , input_stream data ) throws io_exception { n file target = new file ( to_dir , entry . get_name ( ) ) n if ( entry . is_directory ( ) ) { n / / assume directories are stored parents first then children . n / / logger . info ( codstr + entry . get_name ( ) + codstr + target ) n / / this is not robust , just for demonstration purposes . n if ( target . mkdirs ( ) ) { n logger . warning ( codstr + target ) n } n return n } n n / / zips can contain nested files in sub _ dirs without separate entries for the directories n if ( target . get_parent_file ( ) . exists ( ) target . get_parent_file ( ) . mkdirs ( ) ) { n logger . warning ( codstr + target . get_parent_file ( ) ) n } n n / / it seems we cannot use io_utils / file_utils to copy	1
Q_51	how to extract zip file recursively	C_51_5	public static void extract_zip ( file file ) throws file_not_found_exception , io_exception { n final string original_path = file . get_path ( ) n final file zip = new file ( original_path + codstr ) n if ( zip . is_file ( ) zip . delete ( ) ) { n logger . debug ( codstr zip codstr , zip . to_string ( ) ) n zip . delete_on_exit ( ) n } n if ( file . rename_to ( zip ) ) { n throw new io_exception ( codstr codstr codstr ) n } n final file new_file = new file ( original_path ) n try ( file_input_stream fis = new file_input_stream ( zip ) n zip_input_stream cin = new zip_input_stream ( fis ) n file_output_stream out = new file_output_stream ( new_file ) ) { n cin . get_next_entry ( ) n io_utils . copy ( cin , out ) n } finally { n if ( zip . is_file ( ) org . apache . commons . io . file_utils . delete_quietly ( zip ) ) { n logger . debug ( codstr zip codstr , zip . to_string ( ) ) n zip . delete_on_exit ( ) n } n } n }	1
Q_51	how to extract zip file recursively	C_51_6	private void advance ( ) throws io_exception { n if ( entries . has_next ( ) ) { n if ( files . has_next ( ) ) { n next = null n return n } n file file = files . next ( ) n if ( has_extension ( file . get_name ( ) , codstr ) ) { n zip_file zip = new jar_file ( file ) n zips . add ( zip ) n entries = new zip_iterator ( zip ) n } else if ( has_extension ( file . get_name ( ) , codstr ) ) { n zip_file zip = new zip_file ( file ) n zips . add ( zip ) n entries = new zip_iterator ( zip ) n } else if ( file . is_directory ( ) ) { n entries = new file_iterator ( file ) n } else { n throw new illegal_argument_exception ( codstr + file ) n } n } n n boolean found_class = false n while ( found_class entries . has_next ( ) ) { n next = entries . next ( ) n found_class = is_class ( next . get_name ( ) ) n } n if ( found_class ) { n advance ( ) n } n }	1
Q_51	how to extract zip file recursively	C_51_7	private void extract_one_from_zip ( file src_file , string entry_name , file dst_file ) n throws io_exception { n n try ( zip_file zip_file = new zip_file ( src_file ) ) { n enumeration < ? extends zip_entry > enu = zip_file . entries ( ) n n while ( enu . has_more_elements ( ) ) { n zip_entry zip_entry = enu . next_element ( ) n n if ( zip_entry . get_name ( ) . equals ( entry_name ) ) { n n file parent_dir = dst_file . get_parent_file ( ) n if ( parent_dir . exists ( ) ) { n parent_dir . mkdirs ( ) n } n n try ( input_stream is = zip_file . get_input_stream ( zip_entry ) ) { n files . copy ( is , dst_file . to_path ( ) ) n } n } n n } n } n }	1
Q_51	how to extract zip file recursively	C_51_8	private void action_read ( boolean binary ) throws zip_exception , io_exception , page_exception { n required ( codstr , file , true ) n required ( codstr , variable ) n required ( codstr , entry_paths ) n zip_file zip = get_zip ( file ) n n if ( entry_paths . length > codint ) throw new application_exception ( codstr ) n n try { n zip_entry ze = get_zip_entry ( zip , entry_paths [ codint ] ) n if ( ze = = null ) { n string msg = exception_util . similar_key_message ( names ( zip ) , entry_paths [ codint ] , codstr , codstr , codstr + file + codstr , true ) n throw new application_exception ( msg ) n / / throw new application_exception ( codstr + file + codstr + entry_path + codstr ) n } n n byte_array_output_stream baos = new byte_array_output_stream ( ) n n input_stream is = zip . get_input_stream ( ze ) n io_util . copy ( is , baos , true , false ) n zip . close ( ) n n if ( binary ) page_context . set_variable ( variable , baos . to_byte_array ( ) ) n else { n if ( charset = = null ) charset = ( ( page_context_impl ) page_context ) . get_resource_charset ( ) . name ( ) n page_context . set_variable ( variable , new string ( baos . to_byte_array ( ) , charset ) ) n } n	1
Q_52	how to empty array	C_52_0	public static double [ ] null_to_empty ( double [ ] array ) { n if ( array = = null array . length = = codint ) { n return empty_double_object_array n } n return array n }	0
Q_52	how to empty array	C_52_1	suppress_warnings ( codstr ) n public < a > a [ ] to_array ( a [ ] empty_array ) { n if ( empty_array . length = codint ) { n throw new illegal_argument_exception ( codstr ) n } n return stream ( ) . to_array ( size _ > size = = codint ? empty_array n ( a [ ] ) array . new_instance ( empty_array . get_class ( ) . get_component_type ( ) , size ) ) n }	0
Q_52	how to empty array	C_52_2	private void grow ( long length ) n { n / / how many segments are required to get to the length ? n int required_segments = segment ( length ) + codint n n / / grow base array if necessary n if ( array . length < required_segments ) { n array = arrays . copy_of ( array , required_segments ) n } n n / / add new segments n while ( segments < required_segments ) { n allocate_new_segment ( ) n } n }	0
Q_52	how to empty array	C_52_3	public static long [ ] null_to_empty ( long [ ] array ) { n if ( array = = null array . length = = codint ) { n return empty_long_object_array n } n return array n }	0
Q_52	how to empty array	C_52_4	private int [ ] fill_missing_array ( int [ ] array_to_extend ) { n int [ ] extended_array = new int [ build_numbers . length ] n system . arraycopy ( array_to_extend , codint , extended_array , build_numbers . length _ array_to_extend . length , array_to_extend . length ) n return extended_array n }	0
Q_53	how to determine a string be a valid word	C_53_0	private static boolean is_valid_ip4_word ( string word ) { n char c n if ( word . length ( ) < codint word . length ( ) > codint ) { n return false n } n for ( int i = codint i < word . length ( ) i + + ) { n c = word . char_at ( i ) n if ( ( c > = codstr c < = codstr ) ) { n return false n } n } n return integer . parse_int ( word ) < = codint n }	1
Q_53	how to determine a string be a valid word	C_53_1	public static boolean is_reserved_word ( string word ) n { n return java_keywords . contains ( word ) boolean_literals . contains ( word ) null_literal . equals ( word ) n }	1
Q_53	how to determine a string be a valid word	C_53_2	private boolean use_this_word ( integer word_id , map < integer , string > id2word , map < integer , double > id2occurrences ) { n string word = id2word . get ( word_id ) n if ( word = = null ) { n return false n } n else if ( word . length ( ) < parameters . get_min_word_length ( ) ) { n return false n } n else if ( id2occurrences . get ( word_id ) < parameters . get_min_word_occurrence ( ) ) { n return false n } n return true n }	1
Q_53	how to determine a string be a valid word	C_53_3	public static void main ( string [ ] args ) throws io_exception { n n string serialized_classifier = codstr n n if ( args . length > codint ) { n serialized_classifier = args [ codint ] n } n n abstract_sequence_classifier < core_label > classifier = crf_classifier . get_classifier_no_exceptions ( serialized_classifier ) n n / * for either a file to annotate or for the hardcoded text example , n this demo file shows two ways to process the output , for teaching n purposes . for the file , it shows both how to run ner on a string n and how to run it on a whole file . for the hard _ coded string , n it shows how to run it on a single sentence , and how to do this n and produce an inline xml output format . n * / n if ( args . length > codint ) { n string file_contents = io_utils . slurp_file ( args [ codint ] ) n list < list < core_label out = classifier . classify ( file_contents ) n for ( list < core_label > sentence out ) { n for ( core_label word sentence ) { n system . out . print ( word . word ( ) + codstr + word . get ( answer_annotation . class ) + codstr ) n } n system . out . println ( ) n } n out = classifier . classify_file (	0
Q_53	how to determine a string be a valid word	C_53_4	private static int words_with_three_syllables ( string str_text ) { n int int_long_word_count = codint n n list < string > arr_words = ( new whitespace_tokenizer ( ) ) . tokenize ( str_text ) n int int_word_count = arr_words . size ( ) n for ( int i = codint i < int_word_count + + i ) { n if ( syllable_count ( arr_words . get ( i ) ) > codint ) { n + + int_long_word_count / / it also counts the proper nouns which should be excluded for fog index , but this is not a major issue n } n } n n return int_long_word_count n }	0
Q_53	how to determine a string be a valid word	C_53_5	"private static boolean detect_name_word_in_sentence_by_position ( final list < token > _text , final int _pos ) { n boolean is_first_word = false n boolean next_word_is_name = false n if ( _pos = = codint is_letter_or_digit ( ( _text . get ( _pos _ codint ) . text . char_at ( codint ) ) ) ) { n is_first_word = true n / / noinspection simplifiable_if_statement n if ( _text . size ( ) > _pos + codint ) { n final string plus1 = _text . get ( _pos + codint ) . text n next_word_is_name = ( codstr . equals_ignore_case ( plus1 ) codstr s codstr jj "" ) ) { n / / if the first word is determined not to be a name but it is an adj . , n / / and if the second word is a name , we consider the first word to be a name as well . n if ( is_name ( _text . get ( _pos + codint ) , false ) ) n return true n } n * / n n return is_name n }"	0
Q_53	how to determine a string be a valid word	C_53_6	public static boolean is_valid_ip4_word ( string word ) { n char c n if ( word . length ( ) < codint word . length ( ) > codint ) n return false n for ( int i = codint i < word . length ( ) i + + ) { n c = word . char_at ( i ) n if ( ( c > = codstr c < = codstr ) ) n return false n } n if ( integer . parse_int ( word ) > codint ) n return false n return true n }	0
Q_53	how to determine a string be a valid word	C_53_7	public synchronized list < string > suggest ( string word ) { n require_valid_handle ( ) n if ( is_valid_input ( word ) ) { n return collections . empty_list ( ) n } n pointer voikko_suggest_cstr = get_lib ( ) . voikko_suggest_cstr ( handle , s2n ( word ) ) n if ( voikko_suggest_cstr = = null ) { n return collections . empty_list ( ) n } n pointer [ ] pointer_array = voikko_suggest_cstr . get_pointer_array ( codint ) n list < string > suggestions = new array_list < string > ( pointer_array . length ) n for ( pointer c_str pointer_array ) { n suggestions . add ( string_from_pointer ( c_str ) ) n } n get_lib ( ) . voikko_free_cstr_array ( voikko_suggest_cstr ) n return suggestions n }	0
Q_53	how to determine a string be a valid word	C_53_8	public int get_dimension ( dependency_path path ) { n string end_token = path . last ( ) . word ( ) n n / / extract out how the current word is related to the last word in the n / / path . n string relation = path . get_relation ( path . length ( ) _ codint ) n return get_dimension_internal ( end_token + codstr + relation ) n }	0
Q_54	how to check if a checkbox be check	C_54_0	public void check ( cell . cells ) { n check_box check_box = new check_box ( get_row ( cells ) ) n boolean selected = check_box . is_selected ( ) check_box . click ( ) n assert_that ( codstr + to_string ( ) , selected ) n }	1
Q_54	how to check if a checkbox be check	C_54_1	public boolean verify_checked ( final by checkbox_by ) { n web_element element = driver . find_element ( checkbox_by ) n n if ( element . is_selected ( ) ) { n log . info ( codstr + element + codstr ) n return true n } n n log . info ( codstr + element + codstr ) n return false n }	1
Q_54	how to check if a checkbox be check	C_54_2	public boolean is_check_box_checked ( string text ) n { n if ( config . command_logging ) { n log . d ( config . command_logging_tag , codstr codstr codstr ) n } n n return checker . is_button_checked ( check_box . class , text ) n }	1
Q_54	how to check if a checkbox be check	C_54_3	private void check ( check_box check_box ) { n if ( check_box . get_value ( ) ) { n selected_list_items . add ( check_box . get_text ( ) ) n check_box . add_style_name ( style_checkboxlist_item_checked ) n clear_selection_control . set_visible ( true ) n } else { n remove_item ( check_box . get_text ( ) ) n check_box . remove_style_name ( style_checkboxlist_item_checked ) n if ( selected_list_items . size ( ) = = codint ) { n clear_selection_control . set_visible ( false ) n } n } n }	1
Q_54	how to check if a checkbox be check	C_54_4	public void check ( ) { n get_dispatcher ( ) . before_check ( this ) n n remote_web_element e = ( remote_web_element ) get_element ( ) n while ( e . is_selected ( ) ) { n e . click ( ) n } n if ( config . get_bool_config_property ( config_property . enable_gui_logging ) ) { n log_ui_action ( ui_actions . checked ) n } n n get_dispatcher ( ) . after_check ( this ) n }	1
Q_54	how to check if a checkbox be check	C_54_5	protected j_check_box add_check_box ( final e item , final boolean checked ) { n final string name = get_name ( item ) n dc_check_box < e > check_box = _check_boxes . get ( name ) n if ( check_box = null ) { n check_box . set_selected ( checked ) n return check_box n } n check_box = new dc_check_box < > ( name , checked ) n check_box . set_value ( item ) n check_box . set_opaque ( false ) n check_box . add_listener ( _change_listener ) n _check_boxes . put ( name , check_box ) n add ( check_box ) n n update_visibility ( ) n update_ui ( ) n n return check_box n }	1
Q_54	how to check if a checkbox be check	C_54_6	private void print_search_form_to_html ( set < string > field_hash , string terms , string query , print_writer html ) { n html . append ( codstr post codstr search codstr n + codstr n + codstr n + codstr n + codstr checkbox codstr pid codstr true codstr # codstr javascript alert ( codstr ) codstr n + codstr checkbox codstr label codstr true codstr ) n html . append ( field_hash . contains ( codstr ) ? codstr n codstr ) n html . append ( codstr # codstr javascript alert ( codstr ) codstr n + codstr checkbox codstr state codstr true codstr ) n html . append ( field_hash . contains ( codstr ) ? checked n codstr ) n html . append ( codstr # codstr javascript alert ( codstr ) codstr n + codstr checkbox codstr owner_id codstr true codstr ) n html . append ( field_hash . contains ( codstr ) ? checked codstr ) n html . append ( codstr # codstr javascript alert ( codstr ) codstr n + codstr checkbox codstr c_date codstr true codstr ) n html . append ( field_hash . contains ( codstr ) ? checked codstr ) n html . append ( codstr # codstr javascript alert ( codstr ) codstr n + codstr checkbox codstr m_date codstr true codstr ) n html . append ( field_hash . contains ( codstr ) ? checked codstr ) n html . append ( codstr # codstr javascript alert	0
Q_54	how to check if a checkbox be check	C_54_7	public boolean is_passing_checks ( ) { n for ( check check this . service . get_checks ( ) ) { n if ( check . get_status ( ) = check . check_status . passing ) { n return false n } n } n return true n }	0
Q_55	heatmap from tagint d coordinate	C_55_0	private void get_lat_lons_for_polygon ( list < double > pol_lons , list < double > pol_lats ) { n n gridset gridset = grid_dataset . get_gridsets ( ) . get ( codint ) n n grid_coord_system coord_system = gridset . get_geo_coord_system ( ) n projection_impl from_proj = coord_system . get_projection ( ) n coord_system . get_lat_lon_bounding_box ( ) n n if ( coord_system . get_y_horiz_axis ( ) instanceof coordinate_axis1_d coord_system . get_x_horiz_axis ( ) instanceof coordinate_axis1_d ) { n n coordinate_axis1_d x_axis = ( coordinate_axis1_d ) coord_system . get_x_horiz_axis ( ) n coordinate_axis1_d y_axis = ( coordinate_axis1_d ) coord_system . get_y_horiz_axis ( ) n n if ( coord_system . is_global_lon ( ) ) { n n double maxy = y_axis . get_max_value ( ) n double miny = y_axis . get_min_value ( ) n n pol_lons . add ( number ) n pol_lats . add ( miny ) n n pol_lons . add ( number ) n pol_lats . add ( miny ) n n pol_lons . add ( number ) n pol_lats . add ( maxy ) n n pol_lons . add ( number ) n pol_lats . add ( maxy ) n n pol_lons . add ( number ) n pol_lats . add ( miny ) n n / / polygon_wkt . append ( codstr + miny + codstr + miny + codstr + maxy + codstr + maxy + codstr + miny + codstr ) n / / polygon_wkt . append ( codstr + miny + codstr	1
Q_55	heatmap from tagint d coordinate	C_55_1	private void update_coordinates ( ) { n / / top _ left of heat map . n int x = margin + axis_thickness + y_axis_label_size . height n x + = ( y_values_horizontal ? y_axis_values_width_max y_axis_values_height ) n int y = title_size . height + margin n heat_map_tl = new point ( x , y ) n n / / top _ right of heat map . n x = heat_map_tl . x + heat_map_size . width n y = heat_map_tl . y + heat_map_size . height n heat_map_br = new point ( x , y ) n n / / centre of heat map . n x = heat_map_tl . x + ( heat_map_size . width / codint ) n y = heat_map_tl . y + ( heat_map_size . height / codint ) n heat_map_c = new point ( x , y ) n }	1
Q_55	heatmap from tagint d coordinate	C_55_2	public static axis_aligned_bounding_box3_d get_bounding_box3_d ( list < ifc_cartesian_point > points ) throws geometry_exception { n axis_aligned_bounding_box3_d box3d = new axis_aligned_bounding_box3_d ( ) n for ( ifc_cartesian_point ifc_cartesian_point points ) { n e_list < double > coordinates = ifc_cartesian_point . get_coordinates ( ) n if ( coordinates . size ( ) < codint ) { n throw new geometry_exception ( codstr + coordinates . size ( ) + codstr ) n } n box3d . process ( coordinates ) n } n return box3d n }	0
Q_55	heatmap from tagint d coordinate	C_55_3	private coordinate [ ] get_ordered_nodes ( coordinate c , coordinate coordinate1 , coordinate coordinate2 , coordinate coordinate3 ) { n double d = distance3d ( c , coordinate1 , null ) n coordinate nearest = coordinate1 n coordinate c2 = coordinate2 n coordinate c3 = coordinate3 n n double d2 = distance3d ( c , coordinate2 , null ) n if ( d2 < d ) { n nearest = coordinate2 n d = d2 n c2 = coordinate1 n c3 = coordinate3 n } n double d3 = distance3d ( c , coordinate3 , null ) n if ( d3 < d ) { n nearest = coordinate3 n c2 = coordinate1 n c3 = coordinate2 n } n return new coordinate [ ] { nearest , c2 , c3 } n }	0
Q_55	heatmap from tagint d coordinate	C_55_4	private static geometric_parity geometric3_d ( int i , int [ ] adjacent , i_atom_container container ) { n n i_atom atom = container . get_atom ( i ) n point3d [ ] coordinates = new point3d [ codint ] n n / / set the forth ligand to centre as default ( overwritten if n / / we have codint neighbors ) n if ( atom . get_point3d ( ) = null ) n coordinates [ codint ] = atom . get_point3d ( ) n else n return null n n / / for each neighboring atom check if we have codreal coordinates n for ( int j = codint j < adjacent . length j + + ) { n i_atom neighbor = container . get_atom ( adjacent [ j ] ) n n if ( neighbor . get_point3d ( ) = null ) n coordinates [ j ] = neighbor . get_point3d ( ) n else n return null / / skip to next atom n } n n / / add new codreal stereo encoder n return new tetrahedral3_d_parity ( coordinates ) n n }	0
Q_55	heatmap from tagint d coordinate	C_55_5	public point3d [ ] get3_d_coordinates_for_sp3_ligands ( i_atom ref_atom , i_atom_container no_coords , i_atom_container with_coords , n i_atom atom_c , int nwanted , double length , double angle ) { n / / logger . debug ( codstr ) n point3d new_points [ ] = new point3d [ codint ] n point3d a_point = ref_atom . get_point3d ( ) n int nwith_coords = with_coords . get_atom_count ( ) n if ( angle < codint ) { n angle = tetrahedral_angle n } n if ( nwith_coords = = codint ) { n new_points = calculate3_d_coordinates0 ( ref_atom . get_point3d ( ) , nwanted , length ) n } else if ( nwith_coords = = codint ) { n new_points = calculate3_d_coordinates1 ( a_point , ( with_coords . get_atom ( codint ) ) . get_point3d ( ) , n ( atom_c = null ) ? atom_c . get_point3d ( ) null , nwanted , length , angle ) n } else if ( nwith_coords = = codint ) { n point3d b_point = with_coords . get_atom ( codint ) . get_point3d ( ) n point3d c_point = with_coords . get_atom ( codint ) . get_point3d ( ) n new_points = calculate3_d_coordinates2 ( a_point , b_point , c_point , nwanted , length , angle ) n } else if ( nwith_coords = = codint ) { n point3d b_point = with_coords . get_atom ( codint ) . get_point3d ( ) n point3d c_point = with_coords . get_atom ( codint ) . get_point3d	0
Q_55	heatmap from tagint d coordinate	C_55_6	public list < class_stats > caculate_histogram ( int excact_age , int min_age ) { n hash_map < klass , class_stats > class_stats_map = new hash_map < > ( codint , numberf ) n collected_heap heap = heap_utils . get_heap ( ) n object_heap object_heap = heap_utils . get_object_heap ( ) n n / / survivor n address from_bottom = null n address from_top = null n n if ( heap_utils . is_cmsgc ( heap ) ) { n def_new_generation young_gen = heap_utils . get_young_gen_for_cms ( heap ) n contiguous_space from = young_gen . from ( ) n from_bottom = from . bottom ( ) n from_top = from . top ( ) n n from . print_on ( tty ) n tty . println ( codstr ) n } else if ( heap_utils . is_parallel_gc ( heap ) ) { n ps_young_gen ps_young = heap_utils . get_yong_gen_for_par ( heap ) n mutable_space from = ps_young . from_space ( ) n from_bottom = from . bottom ( ) n from_top = from . top ( ) n n from . print_on ( tty ) n tty . println ( codstr ) n } else { n throw new illegal_argument_exception ( n codstr + heap . get_class ( ) . get_name ( ) ) n } n n / / n long [ ] age_size = new long [ codint ] n int [ ] age_count = new int [ codint ] n int max_age = codint n n / /	0
Q_55	heatmap from tagint d coordinate	C_55_7	private void map_mouse_to_plane ( simple1_dof_camera camera , point point2d , double [ ] vec ) { n / / far plane n camera . unproject ( point2d . x , point2d . y , _ codint . , far ) n / / near plane n camera . unproject ( point2d . x , point2d . y , codint . , near ) n / / delta vector far _ = near . n v_math . minus_equals ( far , near ) n / / intersection with z = codint plane n / / far . z _ a * near . z = codint _ > a = far . z / near . z n if ( near [ codint ] < codint near [ codint ] > codint ) { n double a = far [ codint ] / near [ codint ] n vec [ codint ] = far [ codint ] _ a * near [ codint ] n vec [ codint ] = far [ codint ] _ a * near [ codint ] n vec [ codint ] = codint n } n }	0
Q_55	heatmap from tagint d coordinate	C_55_8	private void seven_membered_ring_possibilities ( i_atom_container m , i_ring r , list < list < list < string master_list ) { n / / for now only consider case where have codint double bonds n n i_atom [ ] ringatoms = new i_atom [ codint ] n n ringatoms [ codint ] = r . get_atom ( codint ) n n int [ ] num = new int [ codint ] n n for ( int j = codint j < = codint j + + ) { n num [ j ] = m . index_of ( r . get_atom ( j ) ) n } n n list < string > al1 = new array_list < string > ( ) n list < string > al2 = new array_list < string > ( ) n list < string > al3 = new array_list < string > ( ) n list < string > al4 = new array_list < string > ( ) n list < string > al5 = new array_list < string > ( ) n n al1 . add ( num [ codint ] + codstr + num [ codint ] ) n al1 . add ( num [ codint ] + codstr + num [ codint ] ) n al1 . add ( num [ codint ] + codstr + num [ codint ] ) n n al2 . add ( num [ codint ] + codstr + num [ codint ] ) n al2	0
Q_56	hash set for count distinct element	C_56_0	"override n public void describe_mismatch_safely ( final iterable < ? extends e > actual , final description mismatch_description ) { n final set < e > elements = new hash_set < > ( ) n final collection < e > non_distinct_elements = new array_list < > ( ) / / keep actual codstr non distinct elements are codstr [ codstr , codstr ] "" , n non_distinct_elements ) n }"	1
Q_56	hash set for count distinct element	C_56_1	override n public collator < map . entry < integer , set < distinct_type , set < distinct_type get_collator ( ) { n return new collator < map . entry < integer , set < distinct_type , set < distinct_type ( ) { n n override n public set < distinct_type > collate ( iterable < map . entry < integer , set < distinct_type values ) { n set < distinct_type > distinct_values = new hash_set < distinct_type > ( ) n for ( map . entry < integer , set < distinct_type value values ) { n distinct_values . add_all ( value . get_value ( ) ) n } n return distinct_values n } n } n }	1
Q_56	hash set for count distinct element	C_56_2	public immutable_bag < t > new_without ( t element ) n { n int element_index = array_iterate . detect_index_with ( this . keys , predicates2 . equal ( ) , element ) n if ( element_index > _ codint ) n { n int distinct_item_count = this . size_distinct ( ) _ ( this . counts [ element_index ] = = codint ? codint codint ) n t [ ] new_keys = ( t [ ] ) new object [ distinct_item_count ] n int [ ] new_counts = new int [ distinct_item_count ] n if ( distinct_item_count = = this . size_distinct ( ) ) n { n system . arraycopy ( this . keys , codint , new_keys , codint , distinct_item_count ) n system . arraycopy ( this . counts , codint , new_counts , codint , distinct_item_count ) n new_counts [ element_index ] _ n } n else n { n system . arraycopy ( this . keys , codint , new_keys , codint , element_index ) n system . arraycopy ( this . counts , codint , new_counts , codint , element_index ) n system . arraycopy ( this . keys , element_index + codint , new_keys , element_index , new_keys . length _ element_index ) n system . arraycopy ( this . counts , element_index + codint , new_counts , element_index , new_counts . length _ element_index ) n } n return new immutable_array_bag < t > ( new_keys , new_counts ) n }	1
Q_56	hash set for count distinct element	C_56_3	nonnull n public static < e extends comparable < ? super e set < e > of_iterable ( final iterable < e > elements ) { n if ( elements instanceof collection ) { n return of_collection ( ( collection < e > ) elements ) n } n return of_seq_internal ( seq . of_iterable ( elements ) . distinct ( ) ) n }	0
Q_56	hash set for count distinct element	C_56_4	public number_expression < long > count_distinct ( ) { n if ( count_distinct = = null ) { n count_distinct = expressions . number_operation ( long . class , ops . agg_ops . count_distinct_agg , mixin ) n } n return count_distinct n }	0
Q_56	hash set for count distinct element	C_56_5	public static < t > array_list < t > distinct ( array_list < t > list , hashing_strategy < ? super t > hashing_strategy ) n { n int size = list . size ( ) n mutable_set < t > seen_so_far = unified_set_with_hashing_strategy . new_set ( hashing_strategy ) n array_list < t > result = new array_list < t > ( ) n if ( array_list_iterate . is_optimizable_array_list ( list , size ) ) n { n t [ ] elements = array_list_iterate . get_internal_array ( list ) n for ( int i = codint i < size i + + ) n { n if ( seen_so_far . add ( elements [ i ] ) ) n { n result . add ( elements [ i ] ) n } n } n } n else n { n for ( int i = codint i < size i + + ) n { n t item = list . get ( i ) n if ( seen_so_far . add ( item ) ) n { n result . add ( item ) n } n } n } n return result n }	0
Q_56	hash set for count distinct element	C_56_6	public static < key , value , distinct_type > aggregation < key , value , set < distinct_type distinct_values ( ) { n agg_type < key , value , integer , distinct_type , set < distinct_type > , set < distinct_type > , set < distinct_type agg_type n agg_type = new distinct_values_aggregation < key , value , distinct_type > ( ) n return new aggregation_adapter < key , value , set < distinct_type ( agg_type ) n }	0
Q_57	group by count	C_57_0	protected static string get_group ( final matcher matcher , final int group ) n { n final int group_count = matcher . group_count ( ) n if ( group_count > group _ codint ) n { n return matcher . group ( group ) n } n else n { n return null n } n }	1
Q_57	group by count	C_57_1	private int count_non_default_groups ( string path_template ) { n int count = codint n for ( string bit path_template . split ( codstr ) ) { n if ( bit . starts_with ( codstr ) bit . ends_with ( codstr ) bit . contains ( codstr ) ) { n count + + n } n } n return count n }	0
Q_57	group by count	C_57_2	public list < workflow_status_count > find_worklow_status_count ( ) { n string select = codstr n string where = codstr n string group = codstr n string sql = codstr n + select + codstr + get_table_name ( true ) + where + group n + codstr n + select + codstr + get_table_name ( false ) + where + group n advanced_parameter_source source = new advanced_parameter_source ( ) n . add_value ( codstr , config . get_cluster_name ( ) ) n return get_named_parameter_jdbc_template ( ) . query ( sql , source , workflow_status_count_row_mapper . instance ) n }	0
Q_57	group by count	C_57_3	public void groups_count_by_component_id_and_permission ( db_session db_session , list < long > component_ids , result_handler result_handler ) { n map < string , object > parameters = new hash_map < > ( codint ) n parameters . put ( anyone_group_parameter , default_groups . anyone ) n n execute_large_inputs_without_output ( n component_ids , n partitioned_component_ids _ > { n parameters . put ( codstr , partitioned_component_ids ) n mapper ( db_session ) . groups_count_by_project_id_and_permission ( parameters , result_handler ) n } ) n }	0
Q_57	group by count	C_57_4	public map < string , integer > count_users_by_groups ( db_session session , collection < integer > group_ids ) { n map < string , integer > result = maps . new_hash_map ( ) n execute_large_inputs ( n group_ids , n input _ > { n list < group_user_count > user_counts = mapper ( session ) . count_users_by_group ( input ) n for ( group_user_count count user_counts ) { n result . put ( count . group_name ( ) , count . user_count ( ) ) n } n return user_counts n } ) n n return result n }	0
Q_57	group by count	C_57_5	public country_group get_country_group ( ) { n if ( null = = _country_group null = = country_group ) { _country_group = helper . eu } n return null = = country_group ? _country_group country_group . get ( ) n }	0
Q_57	group by count	C_57_6	override n public void _group_by_count ( string projected_name ) { n assert_no_raw_query ( ) n is_group_by = true n n select_tokens . add ( group_by_count_token . create ( projected_name ) ) n }	0
Q_57	group by count	C_57_7	public counter get_counter ( string group , string name ) { n map < string , counter > group_counters = get_group ( group ) n if ( group_counters = null ) { n return group_counters . get ( name ) n } n n return null n }	0
Q_58	get the description of a http status code	C_58_0	public static string get_status_description ( int status ) n { n string description = codstr n n integer status_key = new integer ( status ) n if ( status_descriptions . contains_key ( status_key ) ) n { n description = status_descriptions . get ( status_key ) n } n n return string . format ( codstr , web_dav_const . httpver , status , description ) n }	1
Q_58	get the description of a http status code	C_58_1	public static string get_http_status_code_text ( int sc ) { n http_status_code s_code = http_status_code . from_num_status_code ( sc ) n if ( s_code = = null ) { n return sc + codstr n } else { n return s_code . to_string ( ) n } n }	1
Q_58	get the description of a http status code	C_58_2	private http_status get_http_status_code ( client_http_response response ) throws io_exception { n http_status status_code n try { n status_code = response . get_status_code ( ) n } n catch ( illegal_argument_exception ex ) { n throw new unknown_http_status_code_exception ( response . get_raw_status_code ( ) , n response . get_status_text ( ) , response . get_headers ( ) , get_response_body ( response ) , get_charset ( response ) ) n } n return status_code n }	1
Q_58	get the description of a http status code	C_58_3	private static status . code http_status_to_grpc_code ( int http_status_code ) { n if ( http_status_code > = codint http_status_code < codint ) { n / / codint xx . these headers should have been ignored . n return status . code . internal n } n switch ( http_status_code ) { n case http_url_connection . http_bad_request / / codint n case codint / / request header fields too large n return status . code . internal n case http_url_connection . http_unauthorized / / codint n return status . code . unauthenticated n case http_url_connection . http_forbidden / / codint n return status . code . permission_denied n case http_url_connection . http_not_found / / codint n return status . code . unimplemented n case codint / / too many requests n case http_url_connection . http_bad_gateway / / codint n case http_url_connection . http_unavailable / / codint n case http_url_connection . http_gateway_timeout / / codint n return status . code . unavailable n default n return status . code . unknown n } n }	1
Q_58	get the description of a http status code	C_58_4	nullable n public string get_gps_status_description ( ) n { n final string value = _directory . get_string ( tag_status ) n if ( value = = null ) n return null n string gps_status = value . trim ( ) n if ( codstr . equals_ignore_case ( gps_status ) ) { n return codstr n } else if ( codstr . equals_ignore_case ( gps_status ) ) { n return codstr n } else { n return codstr + gps_status + codstr n } n }	0
Q_58	get the description of a http status code	C_58_5	protected ref_property register_error_model ( swagger swagger ) { n string ref = error . class . get_simple_name ( ) n if ( swagger . get_definitions ( ) = null swagger . get_definitions ( ) . contains_key ( ref ) ) { n / / model already registered n return new ref_property ( ref ) n } n n model_impl model = new model_impl ( ) n swagger . add_definition ( ref , model ) n n model . set_description ( codstr ) n n model . add_property ( codstr , new integer_property ( ) . read_only ( ) . description ( codstr ) ) n model . add_property ( codstr , new string_property ( ) . read_only ( ) . description ( codstr ) ) n model . add_property ( codstr , new string_property ( ) . read_only ( ) . description ( codstr ) ) n model . add_property ( codstr , new string_property ( ) . read_only ( ) . description ( codstr ) ) n model . add_property ( codstr , new string_property ( ) . read_only ( ) . description ( codstr ) ) n n if ( settings . is_dev ( ) ) { n / / in dev mode the stacktrace is returned in the error message n model . add_property ( codstr , new string_property ( ) . read_only ( ) . description ( codstr ) ) n } n n return new ref_property ( ref ) n }	0
Q_58	get the description of a http status code	C_58_6	override n public property get_named_property ( int _hash , string _name , boolean _check_valid ) throws fhir_exception { n switch ( _hash ) { n case _ codint / * identifier * / return new property ( codstr , codstr , codstr , codint , java . lang . integer . max_value , identifier ) n case _ codint / * status * / return new property ( codstr , codstr , codstr , codint , codint , status ) n case codint / * category * / return new property ( codstr , codstr , codstr , codint , java . lang . integer . max_value , category ) n case codint / * code * / return new property ( codstr , codstr , codstr , codint , codint , code ) n case _ codint / * description * / return new property ( codstr , codstr , codstr , codint , codint , description ) n case codint / * instance * / return new property ( codstr , codstr , codstr , codint , java . lang . integer . max_value , instance ) n case _ codint / * ingredient * / return new property ( codstr , codstr , codstr , codint , java . lang . integer . max_value , ingredient ) n default return super . get_named_property ( _hash , _name , _check_valid ) n } n n }	0
Q_59	get name of enumerate value	C_59_0	public static string get_enum_name ( enum [ ] e , int value ) { n if ( e = null ) { n int to_compare_value n for ( enum en e ) { n if ( en instanceof enum_readable ) { n to_compare_value = ( ( enum_readable ) en ) . value ( ) n } else { n to_compare_value = en . ordinal ( ) n } n if ( value = = to_compare_value ) { n return en . name ( ) n } n } n } n return codstr n }	1
Q_59	get name of enumerate value	C_59_1	static string get_enum_element_name ( xsd_enumeration enum_elem ) { n string value = enum_elem . get_value ( ) n n if ( value . equals ( codstr ) ) { n return codstr n } n n if ( value . matches ( codstr ) ) { n return codstr + value n } n n return enum_elem . get_value ( ) . to_upper_case ( ) . replace_all ( codstr , codstr ) n }	1
Q_59	get name of enumerate value	C_59_2	private void parse_att_def ( string element_name ) throws exception { n string name n string type n string enumer = null n n / / read the attribute name . n name = read_nmtoken ( true ) n n / / read the attribute type . n require_whitespace ( ) n type = read_att_type ( ) n n / / get the string of enumerated values if necessary . n if ( handler . string_interning ) { n if ( ( codstr = = type ) ( codstr = = type ) ) { n enumer = data_buffer_to_string ( ) n } n } else { n if ( codstr . equals ( type ) codstr . equals ( type ) ) { n enumer = data_buffer_to_string ( ) n } n } n n / / read the default value . n require_whitespace ( ) n parse_default ( element_name , name , type , enumer ) n }	0
Q_59	get name of enumerate value	C_59_3	private static enum < ? > get_enum ( string enum_full_name ) { n string [ ] x = enum_full_name . split ( codstr ) n if ( x . length = = codint ) { n string enum_class_name = x [ codint ] n string enum_name = x [ codint ] n try { n class < enum > cl = ( class < enum > ) class . for_name ( enum_class_name ) n return enum . value_of ( cl , enum_name ) n } catch ( class_not_found_exception e ) { n throw new runtime_exception ( codstr , e ) n } n } n return null n }	0
Q_59	get name of enumerate value	C_59_4	private enum manage_enum ( e_enum obj ) { n final enum e = enum . of ( get_full_name ( obj ) ) n obj . get_e_literals ( ) . stream ( ) . for_each ( l _ > e . add_value ( l . get_literal ( ) ) ) n return e n }	0
Q_59	get name of enumerate value	C_59_5	private static enumeration_datatype get_enumeration_datatype ( n com . siemens . ct . exi . grammars . _2017 . schemaforgrammars . enumeration en , n q_name_context qnc ) throws exi_exception { n value [ ] enum_values n datatype dt_enum_values n n datatype_basics enum_dt = en . get_enumeration_value_datatype ( ) n if ( enum_dt . get_base64_binary ( ) = null ) { n dt_enum_values = new binary_base64_datatype ( qnc ) n enum_values = new binary_base64_value [ en . get_base64_binary_value ( ) . size ( ) ] n for ( int k = codint k < en . get_base64_binary_value ( ) . size ( ) k + + ) { n enum_values [ k ] = new binary_base64_value ( en . get_base64_binary_value ( ) n . get ( k ) ) n } n } else if ( enum_dt . get_hex_binary ( ) = null ) { n dt_enum_values = new binary_hex_datatype ( qnc ) n enum_values = new binary_hex_value [ en . get_hex_binary_value ( ) . size ( ) ] n for ( int k = codint k < en . get_hex_binary_value ( ) . size ( ) k + + ) { n enum_values [ k ] = new binary_hex_value ( en . get_hex_binary_value ( ) n . get ( k ) ) n } n } else if ( enum_dt . get_boolean ( ) = null ) { n dt_enum_values = new boolean_datatype ( qnc ) n enum_values = new boolean_value [ en . get_boolean_value ( ) . size	0
Q_60	get inner html	C_60_0	private static string get_matched_elements_html ( web_locator web_locator ) { n string result = codstr n n for ( web_element element web_locator . find_elements ( ) ) { n n string outer_html = element . get_attribute ( codstr ) n string inner_html = element . get_attribute ( codstr ) n if ( inner_html . length ( ) < codint ) { n result = result . concat ( outer_html ) . concat ( codstr ) n } else { n result = result . concat ( outer_html . replace ( inner_html , codstr ) ) . concat ( codstr ) n } n } n n return result . trim ( ) n }	1
Q_60	get inner html	C_60_1	list < list < double multiply_with_out_amp ( list < list < double list1 , list < list < double list2 ) { n list < list < double c n list < double > c_temp n n c = new array_list < > ( ) n for ( int row = codint row < list1 . size ( ) row + + ) { n c_temp = new array_list < > ( ) n for ( int col = codint col < list2 . get ( codint ) . size ( ) col + + ) { n c_temp . add ( number ) n } n c . add ( c_temp ) n } n n for ( int row = codint row < list1 . size ( ) row + + ) { n for ( int col = codint col < list2 . get ( row ) . size ( ) col + + ) { n for ( int inner = codint inner < list1 . get ( codint ) . size ( ) inner + + ) { n double val = c . get ( row ) . get ( col ) n c . get ( row ) . set ( col , val + list1 . get ( row ) . get ( inner ) * list2 . get ( inner ) . get ( col ) ) n } n } n } n return c n }	0
Q_60	get inner html	C_60_2	private string get_html_example ( ) { n final string_builder html = new string_builder ( ) n html . append ( codstr ) n html . append ( codstr http / / www . w3 . org / codint / xhtml codstr ) n html . append ( codstr http / / xmlns . jcp . org / jsf / html codstr ) n html . append ( codstr http / / butterfaces . org / components codstr ) n html . append ( codstr ) n html . append ( codstr ) n html . append ( codstr ) n html . append ( codstr ) n html . append ( codstr ) n html . append ( codstr ) n html . append ( codstr ) n n return html . to_string ( ) n }	0
Q_60	get inner html	C_60_3	suppress_warnings ( codstr ) n private string extract_first ( map data , string field , string property ) { n list < map > inner = ( list < map > ) data . get ( field ) n if ( inner = = null inner . is_empty ( ) ) { n return null n } n return ( string ) inner . get ( codint ) . get ( property ) n }	0
Q_60	get inner html	C_60_4	private string get_html ( ) n { n string html = content n n if ( html . matches ( codstr ) ) n { n string base_href = url . to_string ( ) . replace_all ( codstr , codstr ) n html = html . replace_all ( codstr , codstr codstr codstr ) n } n n return html n }	0
Q_60	get inner html	C_60_5	public static string strip_html ( string html ) { n n if ( html = = null ) { n return null n } n element el = dom . create_div ( ) n el . set_inner_html ( html ) n return el . get_inner_text ( ) n }	0
Q_60	get inner html	C_60_6	public static void inner_html ( html_element element , safe_html html ) { n if ( element = null ) { n element . inner_html = html . as_string ( ) n } n }	0
Q_60	get inner html	C_60_7	public string get_html ( ) { n string html n try { n html = ( string ) execute_javascript ( n codstr + n codstr codstr + n codstr + n codstr < doctype codstr + n codstr + n codstr public codstr + node . public_id + codstr codstr codstr + n codstr system codstr codstr + n codstr codstr + node . system_id + codstr codstr codstr + n codstr > codstr + n codstr + n codstr < html > codstr < / html > codstr + n codstr n ) n } catch ( runtime_exception e ) { n / / unable to get via javascript n try { n / / this is very web_driver implementation dependent , so we only use as fallback n html = driver ( ) . get_page_source ( ) n } catch ( exception ex ) { n ex . print_stack_trace ( ) n / / throw original exception n throw e n } n } n return html n }	0
Q_61	get executable path	C_61_0	public static file get_executable_location ( final string exe_name ) { n / / n / / must add current working directory to the n / / from of the path from the codstr environment variable n final file current_dir = new file ( system . get_property ( codstr ) ) n if ( new file ( current_dir , exe_name ) . exists ( ) ) { n return current_dir n } n final file [ ] env_path = c_util . get_path_from_environment ( codstr , file . path_separator ) n for ( final file element env_path ) { n if ( new file ( element , exe_name ) . exists ( ) ) { n return element n } n } n return null n }	1
Q_61	get executable path	C_61_1	public static void copy ( path source_path , path target_path , boolean executable ) throws io_exception { n / / we unwrap the file system to get raw streams without safety net n file_system s_fs = file_system . get_unguarded_file_system ( source_path . to_uri ( ) ) n file_system t_fs = file_system . get_unguarded_file_system ( target_path . to_uri ( ) ) n if ( t_fs . exists ( target_path ) ) { n if ( s_fs . get_file_status ( source_path ) . is_dir ( ) ) { n internal_copy_directory ( source_path , target_path , executable , s_fs , t_fs ) n } else { n internal_copy_file ( source_path , target_path , executable , s_fs , t_fs ) n } n } n }	1
Q_61	get executable path	C_61_2	public static builder running ( file executable ) { n check_argument ( executable . is_file ( ) , codstr , executable ) n check_argument ( executable . can_execute ( ) , codstr ) n return running ( executable . get_path ( ) ) n }	1
Q_61	get executable path	C_61_3	protected string get_java_executable_path ( ) { n string executable_name = is_windows ( ) ? codstr codstr n return properties . get_java_home ( ) . resolve ( executable_name ) . to_absolute_path ( ) . to_string ( ) n }	1
Q_61	get executable path	C_61_4	private static string java_command ( ) { n path java_bin_path = paths . get ( system . get_property ( codstr ) , codstr ) n file java_executable = java_bin_path . resolve ( codstr ) . to_file ( ) n if ( java_executable . exists ( ) ) { n java_executable = java_bin_path . resolve ( codstr ) . to_file ( ) n } n return java_executable . get_absolute_path ( ) n }	1
Q_61	get executable path	C_61_5	private string get_module_executable ( string module_path ) { n string executable = executable_name = = null ? module_name executable_name n return module_path + file . separator + codstr + file . separator + executable n }	0
Q_61	get executable path	C_61_6	public static file get_execution_path ( ) throws os_exception { n try { n return new file ( os_utils . class . get_protection_domain ( ) . get_code_source ( ) . get_location ( ) . to_uri ( ) . get_path ( ) ) n } catch ( uri_syntax_exception ex ) { n throw new os_exception ( ex ) n } n }	0
Q_61	get executable path	C_61_7	"command_line get_executable_path ( map < string , string > enviro , file dir ) n { n file exec_file = new file ( executable ) n string exec = null n if ( exec_file . is_file ( ) ) n { n get_log ( ) . debug ( codstr executable codstr + executable ) n exec = exec_file . get_absolute_path ( ) n } n n if ( exec = = null ) n { n toolchain tc = get_toolchain ( ) n n / / if the file doesn codstr toolchain in exec _ maven _ plugin codstr com_spec codstr cmd codstr / c "" ) n to_ret . add_argument ( exec ) n } n else n { n to_ret = new command_line ( exec ) n } n n return to_ret n }"	0
Q_62	get current process id	C_62_0	protected int get_current_process_id ( ) throws process_handler_exception { n int pid n / / not ideal but using jna failed on rhel5 . n runtime_mx_bean runtime = management_factory . get_runtime_mx_bean ( ) n field jvm = null n try { n jvm = runtime . get_class ( ) . get_declared_field ( codstr ) n jvm . set_accessible ( true ) n vm_management mgmt = ( vm_management ) jvm . get ( runtime ) n method pid_method = mgmt . get_class ( ) . get_declared_method ( codstr ) n pid_method . set_accessible ( true ) n pid = ( integer ) pid_method . invoke ( mgmt ) n } catch ( no_such_field_exception no_such_method_exception illegal_access_exception invocation_target_exception e ) { n throw new process_handler_exception ( e ) n } n return pid n }	1
Q_62	get current process id	C_62_1	public process get_process_by_id ( string id ) { n for ( process process processes ) { n if ( process . get_id ( ) . equals ( id ) ) { n return process n } n } n return null n }	1
Q_62	get current process id	C_62_2	public order start_instance_by_execution ( execution execution ) { n process process = execution . get_process ( ) n start_model start = process . get_model ( ) . get_start ( ) n assert_helper . not_null ( start , codstr + process . get_id ( ) + codstr ) n n execution current = execute ( process , execution . get_operator ( ) , execution . get_args ( ) , n execution . get_parent_order ( ) . get_id ( ) , execution . get_parent_node_name ( ) ) n start . execute ( current ) n return current . get_order ( ) n }	1
Q_62	get current process id	C_62_3	private process get_process_instance_definition0 ( long process_id , long process_inst_def_id ) { n process procdef = get_process0 ( process_id ) n if ( procdef = null ) { n try { n document instance_doc = get_workflow_dao ( ) . get_document ( process_inst_def_id ) n process process = ( process ) instance_doc . get_object ( jsonable . class . get_name ( ) , null ) n process . set_name ( procdef . get_name ( ) ) n process . set_package_name ( procdef . get_package_name ( ) ) n return process n } catch ( data_access_exception ex ) { n logger . severe_exception ( codstr , ex ) n } n } n return null n }	1
Q_62	get current process id	C_62_4	public long wait_for_process ( ) throws interrupted_exception { n long process_id = wait_process_ids . peek ( ) n if ( logger . is_debug_enabled ( ) ) { n logger . debug ( codstr , get_pipeline_id ( ) , process_id ) n } n return process_id n }	0
Q_62	get current process id	C_62_5	private string get_process_id ( options_and_args p_opts ) throws invocation_target_exception , no_such_method_exception , illegal_access_exception { n if ( p_opts . get_pid ( ) = null ) { n return p_opts . get_pid ( ) n } else if ( p_opts . get_process_pattern ( ) = null ) { n return find_process ( p_opts . get_process_pattern ( ) ) . get_id ( ) n } else { n throw new illegal_argument_exception ( codstr ) n } n }	0
Q_62	get current process id	C_62_6	"file guess_user_data_directory ( string package_name ) { n integer uid = get_process_uid ( ) n if ( uid = = null ) { n / / if we couldn codstr re trying to get the id of the android user that codstr / data / user / d / s "" , user_id , package_name ) ) n }"	0
Q_62	get current process id	C_62_7	protected string current_process_id ( ) { n string current_process_id = get_runtime_mx_bean ( ) . get_name ( ) n n if ( is_blank ( current_process_id ) ) throw new illegal_state_exception ( codstr ) n n int index_of_at_symbol = current_process_id . index_of ( codstr ) n n if ( index_of_at_symbol > codint ) current_process_id = current_process_id . substring ( codint , index_of_at_symbol ) n n return current_process_id n }	0
Q_62	get current process id	C_62_8	private process_diagram build_diagram_by_process_instance_id ( long process_instance_id ) { n process_instance pi = process_service . get_process_instance_by_id ( process_instance_id ) n long process_id = codint , root_id = codint n if ( pi = null ) { n process_id = pi . get_process_id ( ) n root_id = pi . get_root_id ( ) n } else { n history_process_instance hpi = history_service . get_history_process_instance ( process_instance_id ) n if ( hpi = null ) { n process_id = hpi . get_process_id ( ) n root_id = hpi . get_process_instance_id ( ) n } else { n throw new illegal_argument_exception ( codstr + process_instance_id + codstr ) n } n } n process_definition pd = process_service . get_process_by_id ( process_id ) n process_diagram diagram = pd . get_diagram ( ) n try { n diagram = ( process_diagram ) diagram . clone ( ) n reset_process_diagram_default_style ( diagram ) n } catch ( clone_not_supported_exception e ) { n throw new runtime_exception ( e ) n } n rebuild_process_diagram ( diagram , root_id ) n return diagram n }	0
Q_63	get current observable value	C_63_0	private static func1 < observable_http_response , boolean > successful ( ) { n return new func1 < observable_http_response , boolean > ( ) { n n override n public boolean call ( observable_http_response response ) { n if ( response . get_response ( ) . get_status_line ( ) . get_status_code ( ) > = codint ) { n throw new runtime_exception ( codstr + response . get_response ( ) . get_status_line ( ) ) n } n return true n } n n } n }	1
Q_63	get current observable value	C_63_1	public static < t > observable < t > map ( observable < ? > from_observable , final t to_value ) { n if ( from_observable = null ) { n return from_observable . subscribe_on ( schedulers . io ( ) ) n . map ( new rx_mapper < t > ( to_value ) ) n } else { n return observable . empty ( ) n } n }	1
Q_63	get current observable value	C_63_2	override non_null public observable < value_update < t observe ( ) { n observable < value_update < t starting_value = get ( ) n . map ( new function < t , value_update < t ( ) { n override public value_update < t > apply ( t value ) throws exception { n return new value_update < t > ( value ) n } n } ) n . default_if_empty ( value_update . < t > empty ( ) ) n . to_observable ( ) n n return update_subject . start_with ( starting_value ) n }	0
Q_63	get current observable value	C_63_3	override n public observable < observable < integer call ( observable < observable < r observable ) { n return observable . map ( new func1 < observable < r > , observable < integer ( ) { n override n public observable < integer > call ( observable < r > parameters ) { n return builder . clear_parameters ( ) . parameters ( parameters ) . count ( ) n } n } ) n }	0
Q_63	get current observable value	C_63_4	public static < t > observable < t > from_observable_value ( final observable_value < t > fx_observable ) { n return observable . create ( ( observable_emitter < t > emitter ) _ > { n if ( fx_observable . get_value ( ) = null ) n emitter . on_next ( fx_observable . get_value ( ) ) n n final change_listener < t > listener = ( observable_value , prev , current ) _ > { n emitter . on_next ( current ) n } n n fx_observable . add_listener ( listener ) n n emitter . set_disposable ( java_fx_subscriptions . unsubscribe_in_event_dispatch_thread ( ( ) _ > fx_observable . remove_listener ( listener ) ) ) n } ) n }	0
Q_63	get current observable value	C_63_5	override n public observable < t > call ( observable < r > source ) { n if ( operator_type = = operator_type . parameter ) n return builder . parameters ( source ) . get ( function ) n else if ( operator_type = = operator_type . dependency ) n / / dependency n return builder . depends_on ( source ) . get ( function ) n else / / parameter_list n { n suppress_warnings ( codstr ) n observable < observable < object obs = ( observable < observable < object ) source n return obs . concat_map ( new func1 < observable < object > , observable < t ( ) { n override n public observable < t > call ( observable < object > parameters ) { n return builder . parameters ( parameters ) . get ( function ) n } n } ) n } n }	0
Q_64	get current ip address	C_64_0	public static inet_address get_host_address ( ) { n inet_address local_address = null n try { n local_address = inet_address . get_local_host ( ) n if ( is_valid_host_address ( local_address ) ) { n return local_address n } n } catch ( throwable e ) { n logger . warn ( codstr n + e . get_message ( ) ) n } n try { n enumeration < network_interface > interfaces = network_interface . get_network_interfaces ( ) n if ( interfaces = null ) { n while ( interfaces . has_more_elements ( ) ) { n try { n network_interface network = interfaces . next_element ( ) n enumeration < inet_address > addresses = network . get_inet_addresses ( ) n if ( addresses = null ) { n while ( addresses . has_more_elements ( ) ) { n try { n inet_address address = addresses . next_element ( ) n if ( is_valid_host_address ( address ) ) { n return address n } n } catch ( throwable e ) { n logger . warn ( codstr + e . get_message ( ) ) n } n } n } n } catch ( throwable e ) { n logger . warn ( codstr + e . get_message ( ) ) n } n } n } n } catch ( throwable e ) { n logger . warn ( codstr + e . get_message ( ) ) n } n logger . error ( codstr ) n return local_address	1
Q_64	get current ip address	C_64_1	public byte [ ] get_hardware_address ( ) n { n if ( current_time . is_test ( ) system . get_property ( codstr ) = null ) { n return new byte [ ] { codint , codint , codint , codint , codint , codint } n } n n for ( network_interface_base nic get_network_interfaces ( ) ) { n if ( nic . is_loopback ( ) ) { n return nic . get_hardware_address ( ) n } n } n n try { n inet_address local_host = inet_address . get_local_host ( ) n n return local_host . get_address ( ) n } catch ( exception e ) { n log . log ( level . finer , e . to_string ( ) , e ) n } n n return new byte [ codint ] n }	1
Q_64	get current ip address	C_64_2	nullable n override n public ip_address get_ip_address ( nonnull string address_id ) throws internal_exception , cloud_exception { n api_trace . begin ( get_provider ( ) , codstr ) n try { n try { n compute gce = get_provider ( ) . get_google_compute ( ) n address_aggregated_list address_list = gce . addresses ( ) . aggregated_list ( get_context ( ) . get_account_number ( ) ) . set_filter ( codstr + address_id ) . execute ( ) n if ( address_list = null address_list . get_items ( ) = null address_list . get_items ( ) . is_empty ( ) ) { n iterator < string > regions = address_list . get_items ( ) . key_set ( ) . iterator ( ) n while ( regions . has_next ( ) ) { n string region = regions . next ( ) n if ( address_list . get_items ( ) = null address_list . get_items ( ) . get ( region ) = null address_list . get_items ( ) . get ( region ) . get_addresses ( ) = null address_list . get_items ( ) . get ( region ) . get_addresses ( ) . is_empty ( ) ) { n for ( address address address_list . get_items ( ) . get ( region ) . get_addresses ( ) ) { n if ( address . get_name ( ) . equals ( address_id ) ) return to_ip_address ( address ) n } n } n } n } n } catch (	1
Q_64	get current ip address	C_64_3	public static ip_address_type get_address_type ( string ip_address ) n { n if ( ip_address_util . is_i_pv4_literal_address ( ip_address ) ) n return ip_address_type . ipv4 n n if ( ip_address_util . is_i_pv6_literal_address ( ip_address ) ) n return ip_address_type . ipv6 n n return ip_address_type . invalid n }	1
Q_64	get current ip address	C_64_4	override n public string get_name ( ) n { n try { n if ( this . ip_address . length = codint this . ip_address . length = codint ) { n return get_ip_address ( ) . get_host_address ( ) n } n return get_ip_address ( ) . get_host_address ( ) + codstr + get_ip_mask ( ) . get_host_address ( ) n } catch ( unknown_host_exception e ) { n return arrays . to_string ( this . ip_address ) n } n }	1
Q_64	get current ip address	C_64_5	private void read_config ( ) throws knx_exception n { n final list config = new array_list ( ) n int pid = property_client . pid . knx_individual_address n byte [ ] data = query ( pid ) n if ( data = null ) n add ( config , pid , codstr , new individual_address ( data ) . to_string ( ) ) n add ( config , property_client . pid . friendly_name , codstr , query_friendly_name ( ) ) n n pid = property_client . pid . ip_capabilities n if ( ( data = query ( pid ) ) = null ) n add ( config , pid , codstr , n get_ip_assignment ( new byte [ ] { ( byte ) ( data [ codint ] < < codint codint ) } ) ) n n pid = property_client . pid . ip_assignment_method n if ( ( data = query ( pid ) ) = null ) n add ( config , pid , codstr , get_ip_assignment ( data ) ) n n pid = property_client . pid . current_ip_assignment_method n if ( ( data = query ( pid ) ) = null ) n add ( config , pid , codstr , get_ip_assignment ( data ) ) n n pid = property_client . pid . knxnetip_routing_capabilities n if ( ( data = query ( pid ) ) = null ) n add ( config , pid , codstr , get_routing_caps ( data ) ) n n	1
Q_64	get current ip address	C_64_6	public inet_address get_ip_address ( ) throws unknown_host_exception n { n byte [ ] ip = this . ip_address n n if ( ip . length = = codint ip . length = = codint ) { n ip = new byte [ ip . length / codint ] n system . arraycopy ( this . ip_address , codint , ip , codint , ip . length ) n } n n return inet_address . get_by_address ( ip ) n }	1
Q_64	get current ip address	C_64_7	nullable n public string get_ip_address_id_from_ip ( nonnull string ip_address , nonnull string region_id ) throws internal_exception , cloud_exception { n try { n compute gce = get_provider ( ) . get_google_compute ( ) n address_list address_list = gce . addresses ( ) . list ( get_context ( ) . get_account_number ( ) , region_id ) . execute ( ) n if ( address_list = null address_list . get_items ( ) = null address_list . get_items ( ) . is_empty ( ) ) { n for ( address address address_list . get_items ( ) ) { n if ( ip_address . equals ( address . get_address ( ) ) ) return address . get_name ( ) n } n } n throw new internal_exception ( codstr + ip_address + codstr + region_id ) n } catch ( io_exception ex ) { n logger . error ( ex . get_message ( ) ) n if ( ex . get_class ( ) = = google_json_response_exception . class ) { n google_json_response_exception gjre = ( google_json_response_exception ) ex n throw new google_exception ( cloud_error_type . general , gjre . get_status_code ( ) , gjre . get_content ( ) , gjre . get_details ( ) . get_message ( ) ) n } else n throw new cloud_exception ( codstr + ex . get_message ( ) ) n } n }	0
Q_65	get all parent of xml node	C_65_0	public xml_element get_parent_element ( ) { n xml_node parent = get_parent_node ( ) n if ( parent = null parent . get_inner ( ) . get_node_type ( ) = = node . element_node ) { n return ( xml_element ) parent n } n return null n }	1
Q_65	get all parent of xml node	C_65_1	private void _get_all_parents ( list < string > accum , profile_record profile ) { n n list < string > parents = profile . get_includes ( ) n for ( string parent parents ) { n _get_all_parents ( accum , profile_store . get_profile ( parent ) ) n } n n accum . add_all ( parents ) n }	0
Q_65	get all parent of xml node	C_65_2	private observable_list < node > get_parent_children ( parent parent ) { n try { n return ( observable_list < node > ) parent_children_field . get ( parent ) n } catch ( illegal_access_exception e ) { n e . print_stack_trace ( ) n } n return null n }	0
Q_65	get all parent of xml node	C_65_3	protected list < string > get_parent_shas ( object commit ) { n object parents = rest_client . get_as_object ( commit , codstr ) n object nodes = rest_client . get_as_object ( parents , codstr ) n list < string > parent_shas = new array_list < > ( ) n n if ( nodes instanceof json_array ) { n json_array parent_nodes = ( json_array ) nodes n for ( object parent_obj parent_nodes ) { n parent_shas . add ( rest_client . get_string ( parent_obj , codstr ) ) n } n } n n return parent_shas n }	0
Q_65	get all parent of xml node	C_65_4	override n xml_list children ( ) { n xml_list rv = new_xml_list ( ) n xml_name all = xml_name . form_star ( ) n rv . set_targets ( this , all . to_qname ( ) ) n xml_node [ ] children = this . node . get_matching_children ( xml_node . filter . true ) n for ( int i = codint i < children . length i + + ) { n rv . add_to_list ( to_xml ( children [ i ] ) ) n } n return rv n }	0
Q_65	get all parent of xml node	C_65_5	private static list < osm_node > get_nodes ( node_list children , map < string , osm_node > nodes ) { n list < osm_node > result = new array_list < osm_node > ( ) n n node node n string node_name n n for ( int i = codint i < children . get_length ( ) i + + ) { n n node = children . item ( i ) n node_name = node . get_node_name ( ) n n if ( node_name . equals ( codstr ) ) { n n result . add ( nodes . get ( node . get_attributes ( ) . n get_named_item ( codstr ) . get_node_value ( ) ) ) n n } n } n n return result n }	0
Q_65	get all parent of xml node	C_65_6	xml xml_from_node ( xml_node node ) { n if ( node . get_xml ( ) = = null ) { n node . set_xml ( new_xml ( node ) ) n } n return node . get_xml ( ) n }	0
Q_66	fuzzy match ranking	C_66_0	public boolean fuzzy_match ( value_number v1 , value_number v2 ) { n if ( redundant_load_elimination ) { n return v1 . equals ( v2 ) from_matching_loads ( v1 , v2 ) have_matching_flags ( v1 , v2 ) n } else { n return v1 . equals ( v2 ) n } n }	0
Q_66	fuzzy match ranking	C_66_1	private variant_graph_ranking rank_the_graph ( list < list < match phrase_matches , variant_graph base ) { n / / rank the variant graph n set < variant_graph . vertex > matched_vertices = new hash_set < > ( ) n for ( list < match > phrase_match phrase_matches ) { n matched_vertices . add ( phrase_match . get ( codint ) . vertex ) n } n final variant_graph_ranking ranking = variant_graph_ranking . of_only_certain_vertices ( base , matched_vertices ) n return ranking n }	0
Q_66	fuzzy match ranking	C_66_2	public void set_unacceptable ( e element ) { n n ranking ranking = this . map . get ( element ) n if ( ranking = = null ) { n ranking = new ranking ( ) n this . map . put ( element , ranking ) n } n ranking . set_unacceptable ( ) n }	0
Q_66	fuzzy match ranking	C_66_3	public list < e > get_better_or_equal ( int threshold ) { n n list < e > bests = new array_list < > ( ) n for ( e element this . map . key_set ( ) ) { n ranking ranking = this . map . get ( element ) n if ( ( ranking = null ) ( ranking . rank > = threshold ) ) { n bests . add ( element ) n } n } n return bests n }	0
Q_66	fuzzy match ranking	C_66_4	protected query_builder convert_fuzzy_query ( final query_context context , final fuzzy_query fuzzy_query , final float boost ) { n final term term = fuzzy_query . get_term ( ) n final string field = get_search_field ( context , term . field ( ) ) n / / todo fuzzy value n if ( constants . default_field . equals ( field ) ) { n context . add_field_log ( field , term . text ( ) ) n return build_default_query_builder ( ( f , b ) _ > query_builders . fuzzy_query ( f , term . text ( ) ) n . fuzziness ( fuzziness . from_edits ( fuzzy_query . get_max_edits ( ) ) ) . boost ( b * boost ) ) n } else if ( is_search_field ( field ) ) { n context . add_field_log ( field , term . text ( ) ) n return query_builders . fuzzy_query ( field , term . text ( ) ) . boost ( boost ) . fuzziness ( fuzziness . from_edits ( fuzzy_query . get_max_edits ( ) ) ) n } else { n final string orig_query = fuzzy_query . to_string ( ) n context . add_field_log ( constants . default_field , orig_query ) n context . add_highlighted_query ( orig_query ) n return build_default_query_builder ( ( f , b ) _ > query_builders . fuzzy_query ( f , orig_query ) n . fuzziness ( fuzziness . from_edits ( fuzzy_query . get_max_edits ( ) ) ) . boost ( b * boost	0
Q_67	format date	C_67_0	private string format_date ( date value ) n { n return ( value = = null ? null m_formats . get_date_format ( ) . format ( value ) ) n }	1
Q_67	format date	C_67_1	public static string format ( date date , string format ) n { n parameters . check_not_null ( date ) n return new simple_date_format ( format ) . format ( date ) n }	1
Q_67	format date	C_67_2	public static string get_rfc3881_timestamp ( date date ) n { n n string_builder formatted_date = new string_builder ( rfc3881_date_formatter . format ( date ) ) n formatted_date . insert ( ( formatted_date . length ( ) _ codint ) , codstr ) n return formatted_date . to_string ( ) n }	1
Q_67	format date	C_67_3	private string format_date ( non_null calendar date ) { n if ( custom_date_format = = null ) n return date_utils . format_date_time ( get_context ( ) , date . get_time_in_millis ( ) , date_utils . format_show_date ) n else n return custom_date_format . format ( date . get_time ( ) ) n }	1
Q_67	format date	C_67_4	private string formatted_date ( date d ) { n string formatted_date = codstr n if ( d = null ) { n synchronized ( simple_date_format ) { n formatted_date = simple_date_format . format ( d ) n } n } n return formatted_date n }	1
Q_67	format date	C_67_5	public static date format_to_start_of_day ( final date date ) { n n try { n simple_date_format date_format = build_date_format ( default_date_simple_pattern ) n string formatted_date = date_format . format ( date ) n return date_format . parse ( formatted_date ) n } catch ( parse_exception pe ) { n throw new date_exception ( codstr , pe ) n } n }	1
Q_67	format date	C_67_6	private date get_date_by_supported_date_format ( string date_str ) { n n for ( string format supported_date_format ) { n try { n date date = time_util . get_date_formatter ( format ) . parse ( date_str ) n return date n } catch ( exception e ) { n n } n } n return null n }	0
Q_67	format date	C_67_7	public string format_date ( string format , locale loc ) { n multivalued_map < string , string > params = new multivalued_hash_map < > ( ) n params . put_single ( codstr , format ) n params . put_single ( codstr , loc = = null ? null loc . to_string ( ) ) n return get_entity ( invoke_get ( codstr , params ) , string . class ) n }	0
Q_68	finding time elapse use a timer	C_68_0	public long get_elapsed_minutes ( ) { n long elapsed n if ( running ) { n elapsed = ( system . nano_time ( ) _ start_time ) n } else { n elapsed = ( stop_time _ start_time ) n } n return elapsed / ns_per_mm n }	1
Q_68	finding time elapse use a timer	C_68_1	public long get_elapsed_hours ( ) { n long elapsed n if ( running ) { n elapsed = ( system . nano_time ( ) _ start_time ) n } else { n elapsed = ( stop_time _ start_time ) n } n return elapsed / ns_per_hh n }	1
Q_68	finding time elapse use a timer	C_68_2	public long get_elapsed_ticks ( ) { n long elapsed n if ( running ) { n elapsed = ( system . nano_time ( ) _ start_time ) n } else { n elapsed = ( stop_time _ start_time ) n } n return elapsed / ns_per_tick n }	1
Q_68	finding time elapse use a timer	C_68_3	public long get_elapsed_seconds ( ) { n long elapsed n if ( running ) { n elapsed = ( system . nano_time ( ) _ start_time ) n } else { n elapsed = ( stop_time _ start_time ) n } n return elapsed / ns_per_ss n }	1
Q_68	finding time elapse use a timer	C_68_4	public s animate ( timer timer ) n { n long elapsed = timer . elapsed_time ( ) _ timer . tick_to_time ( delay ) n started = elapsed > transform . get_delay ( ) n finished = elapsed > transform . total_duration ( ) transform . get_loops ( ) = _ codint n n if ( started render_before ) n return null n if ( finished render_after ) n return null n n transform . transform ( transformable , elapsed ) n return transformable n }	1
Q_68	finding time elapse use a timer	C_68_5	public static string elapsed_time ( string watch_name ) { n long elapsed = codint n date start = watches_map . get ( watch_name ) n if ( start = null ) { n date end = new date ( ) n elapsed = end . get_time ( ) _ start . get_time ( ) n } n return long . to_string ( elapsed ) n }	1
Q_68	finding time elapse use a timer	C_68_6	override n public void on_timer_stop ( timer timer ) { n string name = timer . name ( ) n long ns = timer . ns ( ) n logger ( name ) . trace ( codstr , name , ns ) n on_timer_stop_ ( name , ns ) n }	1
Q_68	finding time elapse use a timer	C_68_7	public void print_time_statistics ( ) { n print ( codstr ) n n list < string > timers = lists . new_array_list ( get_all_timers ( ) ) n collections . sort ( timers ) n for ( string timer timers ) { n double total = ( double ) get_timer_elapsed_time ( timer ) n long invocations = get_timer_invocations ( timer ) n double average = total / invocations n print ( string . format ( codstr , timer , ( total / codint ) , average , invocations ) ) n } n }	1
Q_68	finding time elapse use a timer	C_68_8	public static timer get_stats_timer ( string name ) { n timer timer = timer_map . get ( name ) n if ( timer = null ) return timer n write_lock . lock ( ) n try { n if ( timer_map . contains_key ( name ) ) { n return timer_map . get ( name ) n } else { n final stats_config stats_config = new stats_config . builder ( ) . with_percentiles ( new double [ ] { codint , codint } ) n . with_publish_max ( true ) . with_publish_min ( true ) . with_publish_mean ( true ) n . with_publish_count ( true ) . with_sample_size ( sample_size . get ( ) ) . build ( ) n final monitor_config monitor_config = monitor_config . builder ( name ) . with_tag ( owner ) . build ( ) n timer = new stats_timer ( monitor_config , stats_config , time_unit . milliseconds ) n default_monitor_registry . get_instance ( ) . register ( timer ) n timer_map . put ( name , timer ) n return timer n } n } finally { n write_lock . unlock ( ) n } n }	0
Q_69	find int in string	C_69_0	private int find_token ( string token , int integer , int location ) { n int index = location _ codint n while ( index > = codint ) { n object o = parser_list . get ( index ) n if ( o instanceof drools_token ) { n if ( codstr . equals ( ( ( drools_token ) o ) . get_text ( ) ) ) { n if ( get_next_integer ( index ) = = integer ) { n return index n } n / / o = parser_list . get ( index + codint ) n / / if ( o instanceof integer ) { n / / if ( integer = = ( integer ) o ) { n / / return index n / / } n / / } n } n } n index _ n } n return _ codint n }	1
Q_69	find int in string	C_69_1	suppress_warnings ( { codstr , codstr , codstr , codstr , codstr } ) n public static int index_of ( char [ ] src , char [ ] find , int start_at ) { n int start_pos = start_at n final int max = src . length _ find . length n if ( start_pos > max ) { n return _ codint n } n final char find0 = find [ codint ] n final int len = find . length n int j n int k n n / / find the first character n start_over n while ( start_pos < = max ) { n if ( src [ start_pos + + ] = = find0 ) { n / / first character found _ look for the rest n j = start_pos n k = codint n while ( k < len ) { n if ( src [ j + + ] = find [ k + + ] ) { n continue start_over n } n } n return start_pos _ codint n } n } n return _ codint n }	1
Q_69	find int in string	C_69_2	public static int get_occur ( string src , string find ) { n int o = codint n int index = _ codint n while ( ( index = src . index_of ( find , index ) ) > _ codint ) { n + + index n + + o n } n return o n }	1
Q_69	find int in string	C_69_3	public string find ( pushback_reader in , int size ) throws io_exception , syntax_error_exception n { n if ( accept_empty ) n { n throw new illegal_argument_exception ( codstr codstr codstr ) n } n input_reader reader = input . get_instance ( in , size ) n int rc = find ( reader ) n reader . release ( ) n if ( rc = = codint ) n { n return reader . get_string ( ) n } n else n { n throw new syntax_error_exception ( codstr codstr codstr ) n } n }	0
Q_69	find int in string	C_69_4	private static int parse_int ( string str , int default_value ) { n n if ( str = = null ) n return default_value n n return integer . parse_int ( str ) n n }	0
Q_69	find int in string	C_69_5	static int index_of ( byte [ ] buff , int num_bytes , byte [ ] find_bytes , int pos ) { n final int find_len = find_bytes . length n if ( find_len > codint ) { n while ( ( pos + find_len ) < num_bytes ) { n boolean found = true n for ( int i = codint i < find_len i + + ) { n if ( buff [ pos + i ] = find_bytes [ i ] ) { n found = false n break n } n } n if ( found ) return pos n pos + + n } n } n return _ codint n }	0
Q_69	find int in string	C_69_6	protected find add_range ( find find , integer start , integer count ) { n if ( start = null ) { n find = find . skip ( start ) n n if ( count = null ) { n find = find . limit ( count ) n } n } n n return find n }	0
Q_69	find int in string	C_69_7	public static string replace ( final string string , final string find , final string replacement ) { n int pos = string . index_of ( find ) n / / system . out . println ( string + codstr + find + codstr + pos ) n if ( pos = = _ codint ) return string n string_builder sb = new string_builder ( ) n int lastpos = codint n final int find_len = find . length ( ) n do { n sb . append ( string , lastpos , pos ) . append ( replacement ) n lastpos = pos + find_len n pos = string . index_of ( find , lastpos ) n } while ( pos = _ codint ) n int len = string . length ( ) n if ( lastpos < len ) sb . append ( string , lastpos , len ) n return sb . to_string ( ) n }	0
Q_70	filter array	C_70_0	public static < a > a [ ] array_filter ( a [ ] arr , predicate < a > accept ) { n if ( arr = = null arr . length = = codint ) n return arr n a [ ] accepted = new_array ( arr , arr . length ) n int j = codint n for ( int i = codint i < arr . length i + + ) n if ( accept . test ( arr [ i ] ) ) n accepted [ j + + ] = arr [ i ] n return j = = arr . length ? arr copy_of ( accepted , j ) n }	1
Q_70	filter array	C_70_1	suppress_warnings ( codstr ) n public static < t > t [ ] filter ( t [ ] array , filter < t > filter ) { n n assert . not_null ( array , codstr ) n assert . not_null ( filter , codstr ) n n list < t > array_list = stream ( array ) . filter ( filter accept ) . collect ( collectors . to_list ( ) ) n n return array_list . to_array ( ( t [ ] ) array . new_instance ( array . get_class ( ) . get_component_type ( ) , array_list . size ( ) ) ) n }	1
Q_70	filter array	C_70_2	private list < string > filter_mwe ( string [ ] arr ) { n if ( arr = = null ) return null n list < string > out = new array_list < string > ( arr . length ) n for ( string t arr ) { n if ( ( t . starts_with ( codstr ) t . starts_with ( codstr ) ) ) n out . add ( t ) n } n return out n }	1
Q_70	filter array	C_70_3	public static < t > t [ ] filter ( t array [ ] , filter < t > filter ) { n list < t > filtered_list = new array_list < t > ( array . length ) n for ( t element array ) { n if ( filter . select ( element ) ) n filtered_list . add ( element ) n } n suppress_warnings ( codstr ) n t filtered_array [ ] = ( t [ ] ) array . new_instance ( array . get_class ( ) . get_component_type ( ) , filtered_list . size ( ) ) n return filtered_list . to_array ( filtered_array ) n }	1
Q_70	filter array	C_70_4	suppress_warnings ( codstr ) n public final t [ ] filter ( final t [ ] objects ) { n final collection < t > filtered = filter ( arrays . as_list ( objects ) ) n try { n return filtered . to_array ( ( t [ ] ) array . new_instance ( objects n . get_class ( ) , filtered . size ( ) ) ) n } catch ( array_store_exception ase ) { n logger log = logger_factory . get_logger ( filter . class ) n log . warn ( codstr , ase ) n } n return ( t [ ] ) filtered . to_array ( ) n }	1
Q_70	filter array	C_70_5	public filter_reply get_filter_chain_decision ( e event ) { n final filter < e > [ ] filter_arrray = filter_list . as_typed_array ( ) n final int len = filter_arrray . length n n for ( int i = codint i < len i + + ) { n final filter_reply r = filter_arrray [ i ] . decide ( event ) n if ( r = = filter_reply . deny r = = filter_reply . accept ) { n return r n } n } n n / / no decision n return filter_reply . neutral n }	0
Q_70	filter array	C_70_6	public static filter and ( filter . filter ) { n if ( filter . length = = codint ) return filter [ codint ] n and_filter result = new and_filter ( ) n for ( int i = codint i < filter . length i + + ) { n result . and ( filter [ i ] ) n } n return result n }	0
Q_70	filter array	C_70_7	override n public filter [ ] filter_chain_to_array ( ) { n int length = chain_length ( ) n filter [ ] array = new filter [ length ] n filter this_filter = this n for ( int i = codint i < length i + + ) { n array [ i ] = this_filter n this_filter = this_filter . get_and ( ) n } n return array n }	0
Q_70	filter array	C_70_8	public static filter filter_array_to_chain ( filter [ ] filter_array ) { n for ( int i = codint i < ( filter_array . length _ codint ) i + + ) { n abstract_filter this_filter = ( abstract_filter ) filter_array [ i ] n this_filter . set_and ( filter_array [ i + codint ] ) n } n abstract_filter last_filter = ( abstract_filter ) filter_array [ filter_array . length _ codint ] n last_filter . set_and ( null ) n return filter_array [ codint ] n }	0
Q_70	filter array	C_70_9	public static filter or ( filter . filter ) { n if ( filter . length = = codint ) return filter [ codint ] n or_filter result = new or_filter ( ) n for ( int i = codint i < filter . length i + + ) { n result . or ( filter [ i ] ) n } n return result n }	0
Q_71	extract data from a text file	C_71_0	"private static string get_text_from_stream ( input_stream input_stream ) throws io_exception { n buffered_reader file_check n file_check = new buffered_reader ( new input_stream_reader ( input_stream ) ) n string_builder file_text = new string_builder ( ) n string line n while ( null = ( line = file_check . read_line ( ) ) ) { n file_text . append ( line ) . append ( codstr ) n } n try { n file_check . close ( ) n } catch ( io_exception e ) { n / / doesn "" t matter . n } n return file_text . to_string ( ) n }"	1
Q_71	extract data from a text file	C_71_1	private static data_set < string > get_text_data_set ( execution_environment env ) { n if ( file_output ) { n / / read the text file from given input path n return env . read_text_file ( text_path ) n } else { n / / get default test text data n return word_count_data . get_default_text_line_data_set ( env ) n } n }	1
Q_71	extract data from a text file	C_71_2	"private package_data parse_data_from_source_file ( input_file file ) throws io_exception { n package_data_builder builder = new package_data_builder ( ) n string pkg_info = file_util . read_file ( file ) n n / / objective_c_name n int i = pkg_info . index_of ( codstr ) n if ( i = = _ codint ) { n i = pkg_info . index_of ( codstr ) n } n if ( i > _ codint ) { n / / extract annotation codstr codstr , i + codint ) n if ( i > _ codint ) { n int j = pkg_info . index_of ( codstr codstr parameters_are_nonnull_by_default codstr javax . annotation . parameters_are_nonnull_by_default codstr com . google . j2objc . annotations . reflection_support codstr invalid reflection_support level in "" + file . get_unit_name ( ) ) n } n } n return builder . build ( ) n }"	1
Q_71	extract data from a text file	C_71_3	private file extract_file ( string file_name , jar_file containing_jar , file dst_dir ) n throws deployment_exception { n n zip_entry zip_file_entry = containing_jar . get_entry ( file_name ) n logger . trace ( codstr + file_name + codstr n + containing_jar . get_name ( ) ) n if ( zip_file_entry = = null ) { n throw new deployment_exception ( codstr n + file_name + codstr + containing_jar . get_name ( ) ) n } n file extracted_file = new file ( dst_dir , new file ( zip_file_entry . get_name ( ) ) n . get_name ( ) ) n try { n pipe_stream ( containing_jar . get_input_stream ( zip_file_entry ) , n new file_output_stream ( extracted_file ) ) n } catch ( file_not_found_exception e ) { n throw new deployment_exception ( codstr + file_name + codstr n + containing_jar . get_name ( ) , e ) n } catch ( io_exception e ) { n throw new deployment_exception ( codstr + file_name n + codstr + containing_jar . get_name ( ) , e ) n } n logger . debug ( codstr + extracted_file . get_name ( ) ) n return extracted_file n }	0
Q_71	extract data from a text file	C_71_4	private static texture_data read_texture ( java . net . url url , boolean use_mip_maps ) { n try { n return ogl_util . new_texture_data ( configuration . get_max_compatible_gl_profile ( ) , url , use_mip_maps ) n } catch ( exception e ) { n / / string msg = logging . get_message ( codstr , url . to_string ( ) ) n / / logging . logger ( ) . log ( java . util . logging . level . severe , msg , e ) n return null n } n }	0
Q_71	extract data from a text file	C_71_5	public static void extract_text_from_single_property ( object property_value , type_factory < string > type , n binary_store binaries , string_builder full_text_string ) { n if ( property_value instanceof binary binaries = null ) { n / / try extracting the text from the binary value . n try { n property_value = binaries . get_text ( ( binary_value ) property_value ) n } catch ( binary_store_exception e ) { n node_sequence . logger . debug ( codstr , property_value ) n } n } n if ( property_value = null ) { n / / convert all other types to a string . n full_text_string . append ( codstr ) . append ( type . create ( property_value ) ) n } n }	0
Q_71	extract data from a text file	C_71_6	private texture_data load_texture ( gl2 gl , gl_profile profile , final string filename ) { n try ( input_stream stream = scatter_plot . class . get_resource_as_stream ( filename ) ) { n return texture_io . new_texture_data ( profile , stream , false , codstr ) n } n catch ( io_exception exc ) { n throw new runtime_exception ( codstr + filename , exc ) n } n }	0
Q_72	extract latitude and longitude from give input	C_72_0	static double extract_longitude ( ais_extractor extractor ) { n int val = extractor . get_signed_value ( codint , codint ) n if ( val = = longitude_not_available ) { n return null n } else { n util . check_long ( val / number ) n return val / number n } n n }	1
Q_72	extract latitude and longitude from give input	C_72_1	private string get_latitude_field ( ) throws generator_exception { n string lat = latitude . get_text ( ) n if ( lat . matches ( lat_regexp ) ) { n throw new generator_exception ( codstr ) n } n double val = double . parse_double ( lat ) n if ( val < _ number val > number ) { n throw new generator_exception ( codstr ) n } n return lat n }	1
Q_72	extract latitude and longitude from give input	C_72_2	procedure n description ( codstr ) n public stream < geo_code_result > reverse_geocode ( name ( codstr ) double latitude , name ( codstr ) double longitude , name ( value = codstr , default_value = codstr ) boolean quota_exception ) { n try { n return get_supplier ( ) . reverse_geocode ( latitude , longitude ) n } catch ( illegal_state_exception re ) { n if ( quota_exception re . get_message ( ) . starts_with ( codstr ) ) return stream . empty ( ) n throw re n } n }	0
Q_72	extract latitude and longitude from give input	C_72_3	public query around_latitude_longitude ( float latitude , float longitude , int radius ) { n around_lat_long = codstr + latitude + codstr + longitude n around_radius = radius n return this n }	0
Q_72	extract latitude and longitude from give input	C_72_4	given ( codstr ) n public void the_current_authorization_policy_requires_a_geofence_of ( double radius , double latitude , double longitude ) n throws throwable { n this . locations . add ( new auth_policy . location ( radius , latitude , longitude ) ) n }	0
Q_72	extract latitude and longitude from give input	C_72_5	implementation n protected list < address > get_from_location ( double latitude , double longitude , int max_results ) n throws io_exception { n preconditions . check_argument ( n _ codint < = latitude latitude < = codint , codstr , latitude ) n preconditions . check_argument ( n _ codint < = longitude longitude < = codint , n codstr , n longitude ) n return from_location . sub_list ( codint , math . min ( max_results , from_location . size ( ) ) ) n }	0
Q_72	extract latitude and longitude from give input	C_72_6	public void add_coordinates ( double latitude , double longitude ) { n if ( latitude < minimum_latitude ) { n minimum_latitude = latitude n } n if ( latitude > maximum_latitude ) { n maximum_latitude = latitude n } n if ( longitude < minimum_longitude ) { n minimum_longitude = longitude n } n if ( longitude > maximum_longitude ) { n maximum_longitude = longitude n } n }	0
Q_72	extract latitude and longitude from give input	C_72_7	public static local_longitude get_instance ( double longitude , double latitude ) n { n if ( math . abs ( longitude ) < codint ) n { n return new local_longitude ( latitude ) n } n else n { n return new pacific_longitude ( latitude ) n } n }	0
Q_72	extract latitude and longitude from give input	C_72_8	static double extract_latitude ( ais_extractor extractor ) { n int val = extractor . get_signed_value ( codint , codint ) n if ( val = = latitude_not_available ) { n return null n } else { n util . check_lat ( val / number ) n return val / number n } n }	0
Q_73	extract data from html content	C_73_0	public string extract ( string html , cetr . parameters parameters ) { n html = clear_text ( html ) / / preprocess the document by removing irrelevant html tags and empty lines and break the document to its lines n list < string > rows = extract_rows ( html ) / / n n list < integer > selected_row_ids = select_rows ( rows , parameters ) n n string_builder sb = new string_builder ( html . length ( ) ) n for ( integer row_id selected_row_ids ) { n string row = rows . get ( row_id ) n n / / extract the clear text from the selected row n row = string_cleaner . remove_extra_spaces ( html_parser . extract_text ( row ) ) n if ( row . is_empty ( ) ) { n continue n } n sb . append ( row ) . append ( codstr ) n } n n return sb . to_string ( ) . trim ( ) n }	1
Q_73	extract data from html content	C_73_1	private string extract_document_content ( string html_content ) { n org . jsoup . nodes . document doc = jsoup . parse ( html_content ) n n string content = doc . body ( ) . text ( ) n n return content n }	1
Q_73	extract data from html content	C_73_2	private void extract ( string html_doc ) { n n / / now extract the contents of < body > . n int body_start = html_doc . index_of ( body_begin ) + body_begin . length ( ) n n / / scan for end of the < body > start tag ( beginning of body content ) n char quote = not_in_quote n for ( int body = body_start body < html_doc . length ( ) body + + ) { n final char c = html_doc . char_at ( body ) n if ( is_quote_char ( c ) ) { n if ( quote = = not_in_quote ) n quote = c n else if ( quote = = c ) n quote = not_in_quote n } n n if ( codstr = = c not_in_quote = = quote ) { n body_start = body + codint n break n } n } n n int body_end = html_doc . index_of ( body_end , body_start ) n n / / if there was no body tag , just embed whatever was rendered directly n if ( _ codint = = body_end ) { n embedded_respond . this . body = html_doc n } else n embedded_respond . this . body = html_doc . substring ( body_start , body_end ) n }	1
Q_73	extract data from html content	C_73_3	public static map < string , list < string extract_htm_lheaders ( string html ) { n map < string , list < string hxtags_map = new hash_map < > ( ) n for ( int i = codint i < = codint + + i ) { n hxtags_map . put ( codstr + i , new array_list < > ( ) ) n } n n matcher m = hx_pattern . matcher ( html ) n while ( m . find ( ) ) { n if ( m . group_count ( ) = = codint ) { n string tag_type = m . group ( codint ) . to_upper_case ( locale . english ) n string content = m . group ( codint ) n hxtags_map . get ( tag_type ) . add ( clear ( content ) ) n } n } n return hxtags_map n }	1
Q_73	extract data from html content	C_73_4	nonnull n private static string extract_note ( nonnull final element topic ) { n final string_builder result = new string_builder ( ) n n for ( final element note utils . find_direct_children_for_name ( topic , codstr ) ) { n final string plain = extract_text_content_from ( note , codstr ) n final string html = extract_text_content_from ( note , codstr ) n n if ( result . length ( ) > codint ) { n result . append ( codstr ) n } n n if ( plain . is_empty ( ) ) { n result . append ( plain ) n } else if ( html . is_empty ( ) ) { n result . append ( html ) n } n } n n return result . to_string ( ) n }	1
Q_73	extract data from html content	C_73_5	public extract_result extract ( string content , string selector , int amount ) { n n list < element > extracted = extract_elements ( content , selector , amount ) n n if ( extracted . size ( ) > codint ) { n n / / first element is the remaining body , the rest are extracted n element body = extracted . get ( codint ) n list < element > elements = extracted . sub_list ( codint , extracted . size ( ) ) n n / / convert to html n list < string > element_str = new array_list < string > ( ) n for ( element el elements ) { n element_str . add ( el . outer_html ( ) ) n } n n return new default_extract_result ( element_str , body . html ( ) ) n } else { n / / nothing to extract n return new default_extract_result ( collections . < string > empty_list ( ) , content ) n } n }	1
Q_73	extract data from html content	C_73_6	private string extract_html_robots ( meta_data m ) { n json_array metas = json_utils . extract_array ( m , codstr ) n if ( metas = null ) { n int count = metas . length ( ) n for ( int i = codint i < count i + + ) { n json_object meta = metas . opt_json_object ( i ) n if ( meta = null ) { n string name = scan_headers_lc ( meta , codstr , null ) n if ( name = null ) { n if ( name . to_lower_case ( ) . equals ( codstr ) ) { n / / alright _ some robot instructions n string content = scan_headers_lc ( meta , codstr , null ) n if ( content = null ) { n return parse_robot_instructions ( content ) n } n } n } n } n } n } n return codstr n }	0
Q_73	extract data from html content	C_73_7	public string to_html ( object content , object extra ) { n byte_array_output_stream out = new byte_array_output_stream ( ) n str ( content , extra , out ) n return out . to_string ( ) n }	0
Q_73	extract data from html content	C_73_8	private void pattern_css_extract ( html_meta_data data , pattern pattern , string content ) { n matcher m = pattern . matcher ( content ) n int idx = codint n int content_len = content . length ( ) n if ( content_len > codint ) n / / extract ur_ls only from the first codint k_b n content_len = codint n while ( ( idx < content_len ) m . find ( ) ) { n idx = m . end ( ) n string url = m . group ( codint ) n url = css_url_trim_pattern . matcher ( url ) . replace_all ( codstr ) n if ( url . is_empty ( ) ) { n data . add_href ( codstr , codstr , codstr , url ) n } n } n }	0
Q_74	export to excel	C_74_0	public void write_excel_file ( ) throws io_exception , write_exception { n writable_workbook excel_wrk_book = null n int cur_ds_pointer = codint n n try { n final string [ ] column_names = ds . get_columns ( ) n final list < string > export_only_columns_list = get_export_only_columns ( ) = null ? arrays . as_list ( export_only_columns ) null n final list < string > exclude_from_export_columns_list = get_exclude_from_export_columns ( ) = null ? arrays . as_list ( exclude_from_export_columns ) null n final list < string > numeric_column_list = get_numeric_columns ( ) = null ? arrays . as_list ( get_numeric_columns ( ) ) new array_list < > ( ) n / / get the current position of the data_set . we have to go to the top n / / to do this write , n / / and we will put the pionter back where it was after we are done n cur_ds_pointer = ds . get_index ( ) n ds . go_top ( ) n n excel_wrk_book = workbook . create_workbook ( xls_file ) n final writable_sheet wrk_sheet = excel_wrk_book . create_sheet ( codstr , codint ) n n final writable_font times10pt_bold = new writable_font ( writable_font . times , codint , writable_font . bold ) n final writable_font times10pt = new writable_font ( writable_font . times , codint , writable_font . no_bold ) n / / write the column headings in the spreadsheet n writable_cell_format cell_format = new writable_cell_format ( times10pt_bold ) n int col_offset = codint n for	1
Q_74	export to excel	C_74_1	public static file export_template ( ) throws file_not_found_exception , n io_exception , invalid_format_exception { n file template = new file ( codstr ) n template . create_new_file ( ) n org . apache . poi . ss . usermodel . workbook wb = new hssf_workbook ( ) n org . apache . poi . ss . usermodel . sheet sheet = wb . create_sheet ( ) n wb . set_sheet_name ( codint , codstr ) n int column = codint n cell_style cs = wb . create_cell_style ( ) n cs . set_data_format ( get_builtin_format ( codstr ) ) n font f = wb . create_font ( ) n f . set_font_height_in_points ( ( short ) codint ) n f . set_bold ( true ) n f . set_color ( ( short ) font . color_normal ) n cs . set_font ( f ) n row new_row = sheet . create_row ( codint ) n for ( string label columns ) { n cell new_cell = new_row . create_cell ( column ) n new_cell . set_cell_style ( cs ) n new_cell . set_cell_value ( label ) n column + + n } n n try ( file_output_stream out = new file_output_stream ( template ) ) { n wb . write ( out ) n out . close ( ) n } catch ( file_not_found_exception e ) { n log . log ( level . severe , null , e ) n } catch ( io_exception e ) { n	1
Q_74	export to excel	C_74_2	public void export_objects2_excel ( list < ? > data , class clazz , boolean is_write_header , n string sheet_name , boolean is_xssf , string target_path ) n throws excel4_j_exception , io_exception { n n try ( file_output_stream fos = new file_output_stream ( target_path ) n workbook workbook = export_excel_no_template_handler ( data , clazz , is_write_header , sheet_name , is_xssf ) ) { n workbook . write ( fos ) n } n }	1
Q_74	export to excel	C_74_3	public void export_objects2_excel ( list < ? > data , list < string > header , string sheet_name , n boolean is_xssf , output_stream os ) n throws io_exception { n n try ( workbook workbook = export_excel_by_simple_handler ( data , header , sheet_name , is_xssf ) ) { n workbook . write ( os ) n } n }	1
Q_74	export to excel	C_74_4	override n public record_reader < text , spread_sheet_cell_dao > create_record_reader ( input_split split , task_attempt_context ctx ) { n / / send configuration option to ms excel . the format of the excel ( old vs new ) is detected automaitcally n ctx . get_configuration ( ) . set ( hadoop_office_read_configuration . conf_mimetype , codstr ) n return new excel_cell_record_reader ( ctx . get_configuration ( ) , ( file_split ) split ) n }	1
Q_74	export to excel	C_74_5	public export_matrix export ( pcm_container pcm_container ) { n pcm pcm = pcm_container . get_pcm ( ) n n final pcm_metadata metadata n if ( pcm_container . get_metadata ( ) = = null ) { n metadata = new pcm_metadata ( pcm ) n } else { n metadata = pcm_container . get_metadata ( ) n } n n n export_matrix matrix = new export_matrix ( ) n n / / export name n matrix . set_name ( pcm . get_name ( ) ) n n int products_start_row = export_features ( metadata , matrix ) n n export_products ( pcm , metadata , matrix , products_start_row ) n n / / transpose matrix if necessary n if ( metadata . get_product_as_lines ( ) ) { n matrix . transpose ( ) n } n n return matrix n }	0
Q_74	export to excel	C_74_6	override n public s_exports_ir case_a_module_exports ( a_module_exports node , ir_info question ) n throws analysis_exception n { n a_module_exports_ir module_exports_cg = new a_module_exports_ir ( ) n n for ( list < p_export > export node . get_exports ( ) ) n { n list < s_export_ir > export_cg = new linked_list < s_export_ir > ( ) n n for ( p_export export_item export ) n { n s_export_ir export_item_cg = export_item . apply ( question . get_export_visitor ( ) , question ) n n if ( export_item_cg = null ) n { n export_cg . add ( export_item_cg ) n } else n { n return null n } n } n n module_exports_cg . get_exports ( ) . add ( export_cg ) n } n n return module_exports_cg n }	0
Q_74	export to excel	C_74_7	public void export_data_set ( method method ) { n export_data_set export_data_set = resolve_export_data_set ( method ) n if ( export_data_set = null ) { n data_set_export_config export_config = data_set_export_config . from ( export_data_set ) n string output_name = export_config . get_output_file_name ( ) n if ( output_name = = null codstr . equals ( output_name . trim ( ) ) ) { n output_name = method . get_name ( ) . to_lower_case ( ) + codstr + export_config . get_data_set_format ( ) . name ( ) . to_lower_case ( ) n } n export_config . output_file_name ( output_name ) n try { n data_set_exporter . get_instance ( ) . export ( data_set_executor . get_rider_data_source ( ) . get_db_unit_connection ( ) , export_config ) n } catch ( exception e ) { n log . warn ( codstr + method . get_name ( ) , e ) n } n } n }	0
Q_74	export to excel	C_74_8	public static report load_demo_report ( ) throws file_not_found_exception , load_report_exception { n string location = demo_util . nextreports_home + file . separator + codstr + n file . separator + def . get_database_name ( ) + file . separator + codstr n n string file = location + file . separator + def . get_report_name ( ) n / / use codstr to test for arabic characters n n report report = report_util . load_report ( new file_input_stream ( file ) ) n / / copy report images if any to directory where exported file is generated works for html export n / / for pdf , rtf excel export the directory where we copy images must be in the classpath n copy_images ( report , location , codstr ) n return report n }	0
Q_75	encrypt aes ctr mode	C_75_0	byte [ ] encrypt_data ( byte [ ] plaintext , password_key encryption_key , password_key hmac_key , byte [ ] iv ) throws cryptor_exception { n try { n cipher cipher = cipher . get_instance ( aes_cipher_algorithm ) n cipher . init ( cipher . encrypt_mode , encryption_key . get_key ( ) , new iv_parameter_spec ( iv ) ) n byte [ ] ciphertext = cipher . do_final ( plaintext ) n n aes256v3_ciphertext output = new aes256v3_ciphertext ( encryption_key . get_salt ( ) , n hmac_key . get_salt ( ) , iv , ciphertext ) n n mac mac = mac . get_instance ( hmac_algorithm ) n mac . init ( hmac_key . get_key ( ) ) n byte [ ] hmac = mac . do_final ( output . get_data_to_hmac ( ) ) n output . set_hmac ( hmac ) n return output . get_raw_data ( ) n n } catch ( invalid_key_exception e ) { n throw new cryptor_exception ( n codstr , n e ) n } catch ( general_security_exception e ) { n throw new cryptor_exception ( codstr , e ) n } n }	1
Q_75	encrypt aes ctr mode	C_75_1	override n public string encrypt ( string plain_text ) throws crypto_exception { n try { n byte [ ] initialization_vector = get_iv_provider_instance ( ) . create_iv ( ) n cipher encrypt_cipher = cipher . get_instance ( codstr ) n encrypt_cipher . init ( cipher . encrypt_mode , create_secret_key_spec ( ) , new iv_parameter_spec ( initialization_vector ) ) n n byte [ ] bytes_to_encrypt = plain_text . get_bytes ( standard_charsets . utf_8 ) n byte [ ] encrypted_bytes = encrypt_cipher . do_final ( bytes_to_encrypt ) n n return string . join ( codstr , codstr , encoder . encode_to_string ( initialization_vector ) , encoder . encode_to_string ( encrypted_bytes ) ) n } catch ( exception e ) { n throw new crypto_exception ( e ) n } n }	1
Q_75	encrypt aes ctr mode	C_75_2	public void do_aes_decryption ( byte [ ] salt , byte [ ] iv ) throws exception { n set_salt ( salt ) n if ( init_aes_done ) n init_aes ( ) n cipher cipher = cipher . get_instance ( codstr ) n cipher . init ( cipher . decrypt_mode , secret_key , new iv_parameter_spec ( iv ) ) n secret_plain = cipher . do_final ( secret_cipher ) n }	1
Q_75	encrypt aes ctr mode	C_75_3	private byte [ ] encrypt ( byte [ ] secret_key , string data ) throws invalid_key_exception { n byte [ ] encrypted_data = null n try { n / / encrypt data using the secret key n cipher aescf = cipher . get_instance ( codstr ) n iv_parameter_spec ivspec = new iv_parameter_spec ( new byte [ codint ] ) n aescf . init ( cipher . encrypt_mode , n new secret_key_spec ( secret_key , codstr ) , ivspec ) n encrypted_data = aescf . do_final ( data . get_bytes ( utf8 ) ) n } catch ( exception e ) { n log . log ( level . severe , codstr , e ) n } n return encrypted_data n }	0
Q_75	encrypt aes ctr mode	C_75_4	public static encryption_mode get_encryption_mode_cipher ( string encryption_mode ) { n if ( encryption_mode = = null ) { n return null n } n switch ( encryption_mode ) { n case codstr return encryption_mode . agile n case codstr return encryption_mode . binary_rc4 n case codstr return encryption_mode . crypto_api n case codstr return encryption_mode . standard n default n log . error ( codstr codstr codstr ) n break n / / case codstr return encryption_mode . xor / / does not seem to be supported anymore n } n return null n }	0
Q_76	encode url	C_76_0	public static string urlencode ( string value ) { n try { n return url_encoder . encode ( value , utf_8 ) n } catch ( unsupported_encoding_exception e ) { n throw new runtime_exception ( codstr , e ) n } n }	1
Q_76	encode url	C_76_1	private static string encode ( string str ) { n try { n return url_encoded_format . invoke ( str , codstr , false ) n } n catch ( page_exception e ) { n return url_encoder . encode ( str ) n } n }	1
Q_76	encode url	C_76_2	public static string encode_url ( string url ) { n try { n return url_encoder . encode ( url , default_encoding ) n } catch ( unsupported_encoding_exception ignore ) { n return url n } n }	1
Q_76	encode url	C_76_3	public static http_request head ( final char_sequence base_url , n final map < ? , ? > params , final boolean encode ) { n string url = append ( base_url , params ) n return head ( encode ? encode ( url ) url ) n }	1
Q_76	encode url	C_76_4	private string encode_send_url ( string encoded_channel_url ) { n n if ( utilities . is_session_encoded_in_url ( encoded_channel_url , http_constants . get_http_session_id_name ( ) ) ) { n string channel_url_without_session_id = utilities . get_url_without_session_id ( encoded_channel_url , n http_constants . get_http_session_id_name ( ) ) n string session_id = utilities . get_session_id ( encoded_channel_url , http_constants . get_http_session_id_name ( ) ) n n return utilities . get_session_encoded_url ( channel_url_without_session_id + codstr , n http_constants . get_http_session_id_name ( ) , n session_id ) n n } else { n return encoded_channel_url + codstr n } n }	1
Q_76	encode url	C_76_5	private string encode ( string value ) { n try { n / / return url_encoder . encode ( value , codstr ) n return uri_utils . encode_query_param ( value , codstr ) n } catch ( unsupported_encoding_exception x ) { n throw new illegal_argument_exception ( x ) n } n }	1
Q_77	deserialize json	C_77_0	override n public resource_specification deserialize ( json_element json , type type_of_t , n json_deserialization_context context ) throws json_parse_exception { n json_object json_obj = json . get_as_json_object ( ) n n int cores = json_obj . get ( codstr ) . get_as_int ( ) n int memory_size = json_obj . get ( codstr ) . get_as_int ( ) n n return new resources ( memory_size , cores ) n }	1
Q_77	deserialize json	C_77_1	override n public typed_object deserialize ( json_parser jp , deserialization_context ctxt ) n throws io_exception n { n try { n json_node json_node = jp . read_value_as_tree ( ) n return deserialize_object ( json_node ) n } n catch ( exception e ) { n throw new json_mapping_exception ( codstr , e ) n } n }	1
Q_77	deserialize json	C_77_2	override n public event_request deserialize ( json_element json , type type_of_t , n json_deserialization_context context ) n throws json_parse_exception { n gson gson = new gson_builder ( ) n . set_field_naming_policy ( field_naming_policy . lower_case_with_underscores ) n . create ( ) n n / / api versions codint _ codint _ codint and earlier render request as a string n / / instead of a json object n if ( json . is_json_primitive ( ) ) { n event_request request = new event_request ( ) n request . set_id ( json . get_as_string ( ) ) n return request n } else { n return gson . from_json ( json , type_of_t ) n } n }	1
Q_77	deserialize json	C_77_3	public static object deserialize ( string json , type_reference < ? > type_reference ) throws serialization_exception { n try { n logger . debug ( codstr , json ) n return mapper . read_value ( json , type_reference ) n } catch ( io_exception e ) { n logger . error ( codstr , e . get_message ( ) ) n serialization_exception serialization_exception = new serialization_exception ( e ) n throw serialization_exception n } n }	1
Q_77	deserialize json	C_77_4	public static < t > t deserialize ( byte [ ] input , class < t > class_type ) n throws json_parse_exception , json_mapping_exception , io_exception { n return mapper . read_value ( input , class_type ) n }	1
Q_77	deserialize json	C_77_5	public wx_cp_tag deserialize ( json_element json , type type_of_t , json_deserialization_context context ) n throws json_parse_exception { n json_object json_object = json . get_as_json_object ( ) n return new wx_cp_tag ( gson_helper . get_string ( json_object , codstr ) , gson_helper . get_string ( json_object , codstr ) ) n }	0
Q_78	deduct the median from each column	C_78_0	private list < row_processing_consumer > extract_consumers ( analysis_job analysis_job , n analyzer_beans_configuration analyzer_beans_configuration , configuration configuration ) { n final injection_manager injection_manager = analyzer_beans_configuration . get_injection_manager ( analysis_job ) n final reference_data_activation_manager reference_data_activation_manager = new reference_data_activation_manager ( ) n n final life_cycle_helper life_cycle_helper = new life_cycle_helper ( injection_manager , reference_data_activation_manager , n configuration . include_non_distributed_tasks ) n source_column_finder source_column_finder = new source_column_finder ( ) n source_column_finder . add_sources ( analysis_job ) n n / * * n * use a single threaded task runner since this handler is invoked in a n * blocking way _ the calling code may itself be multithreaded without n * issues . n * / n final single_threaded_task_runner task_runner = new single_threaded_task_runner ( ) n n final analysis_listener analysis_listener = configuration . analysis_listener n final row_processing_publishers row_processing_publishers = new row_processing_publishers ( analysis_job , n analysis_listener , task_runner , life_cycle_helper , source_column_finder ) n n final row_processing_publisher publisher n if ( configuration . table = null ) { n publisher = row_processing_publishers . get_row_processing_publisher ( configuration . table ) n if ( publisher = = null ) { n throw new illegal_argument_exception ( codstr + configuration . table ) n } n } else { n final collection < row_processing_publisher > publisher_collection = row_processing_publishers n . get_row_processing_publishers ( ) n if ( publisher_collection . size ( ) > codint ) { n throw new illegal_argument_exception ( n codstr s components . please specify a table constructor argument . codstr exception thrown while initializing consumers	0
Q_78	deduct the median from each column	C_78_1	private void calc_median ( list < double > data ) { n if ( ( data . size ( ) codint ) = = codint ) { n median = data . get ( data . size ( ) / codint ) n } else { n median = data . get ( data . size ( ) / codint _ codint ) n median + = data . get ( data . size ( ) / codint ) n median / = number n } n }	0
Q_78	deduct the median from each column	C_78_2	public sql_builder except ( final collection < string > column_names ) { n op = operation_type . query n n this . column_names = null n this . column_name_list = column_names n this . column_aliases = null n n sb . append ( _space_except_space ) n n return this n }	0
Q_78	deduct the median from each column	C_78_3	public static int [ ] active_columns ( d_histogram [ ] hist ) { n int [ ] cols = new int [ hist . length ] n int len = codint n for ( int i = codint i < hist . length i + + ) { n if ( hist [ i ] = = null ) continue n assert hist [ i ] . _min < hist [ i ] . _max_ex hist [ i ] . nbins ( ) > codint codstr + hist [ i ] n cols [ len + + ] = i / / gather active column n } n / / cols = arrays . copy_of_range ( cols , len , hist . length ) n return cols n }	0
Q_78	deduct the median from each column	C_78_4	override n public list < assignment > assign ( collection < string > suite_names , int slaves , long seed ) { n / / read hints first . n final map < string , list < long hints = execution_times_report . merge_hints ( resources , suite_names ) n n / / preprocess and sort costs . take the median for each suite codstr s measurements as the weight n / / to avoid extreme measurements from screwing up the average . n collections . sort ( suite_hint ) n final long median = suite_hint . get ( suite_hint . size ( ) / codint ) n costs . add ( new suite_hint ( suite_name , median ) ) n } n } n collections . sort ( costs , suite_hint . descending_by_weight ) n n / / apply the assignment heuristic . n final priority_queue < slave_load > pq = new priority_queue < slave_load > ( n slaves , slave_load . ascending_by_estimated_finish ) n for ( int i = codint i < slaves i + + ) { n pq . add ( new slave_load ( i ) ) n } n n final list < assignment > assignments = new array_list < > ( ) n for ( suite_hint hint costs ) { n slave_load slave = pq . remove ( ) n slave . estimated_finish + = hint . cost n pq . add ( slave ) n n owner . log ( codstr + hint	0
Q_79	custom http error response	C_79_0	override n public < resp > void response ( http_adapter < ? , resp > adapter , resp res , throwable error , n span_customizer customizer ) { n if ( res = = null ) { n error ( null , error , customizer ) n return n } n integer http_status = adapter . status_code ( res ) n if ( http_status = = null ) { n error ( http_status , error , customizer ) n return n } n if ( http_status = = http_servlet_response . sc_ok error = null ) { n / / filter chain threw exception but the response status may not have been set n / / yet , so we have to guess . n customizer . tag ( status_code_key , n string . value_of ( http_servlet_response . sc_internal_server_error ) ) n } n / / only tag valid http statuses n else if ( http_status > = codint ( http_status < codint ) ( http_status > codint ) ) { n customizer . tag ( status_code_key , string . value_of ( http_status ) ) n } n error ( http_status , error , customizer ) n }	1
Q_79	custom http error response	C_79_1	public static void read_error_response ( url_connection c ) n { n if ( c = = null ) n { n return n } n input_stream in = null n try n { n int error = ( ( http_url_connection ) c ) . get_response_code ( ) n in = ( ( http_url_connection ) c ) . get_error_stream ( ) n if ( in = = null ) n { n return n } n log . warn ( codstr + ( ( http_url_connection ) c ) . get_response_message ( ) ) n / / read the response body n byte_array_output_stream out = new byte_array_output_stream ( codint ) n int count n byte [ ] bytes = new byte [ codint ] n while ( ( count = in . read ( bytes ) ) = _ codint ) n { n out . write ( bytes , codint , count ) n } n log . warn ( codstr + error ) n } n catch ( connect_exception e ) n { n log . error ( codstr , e ) n } n catch ( io_exception e ) n { n log . error ( codstr , e ) n } n catch ( exception e ) n { n log . error ( codstr , e ) n } n finally n { n io_utilities . close ( in ) n } n }	1
Q_79	custom http error response	C_79_2	response_override ( n description = codstr , n block_request = true ) n public static void http_200_empty_response ( plugin_arguments args ) throws exception { n http_servlet_response response = args . get_response ( ) n response . set_status ( constants . status_ok ) n response . set_content_type ( constants . content_type ) n plugin_helper . write_response_content ( response , create_error_message ( constants . status_ok , codstr codstr ) ) n }	1
Q_79	custom http error response	C_79_3	private void send_error ( channel_handler_context ctx , http_response_status status ) { n full_http_response response = new default_full_http_response ( n http_1_1 , status , unpooled . copied_buffer ( codstr + status + codstr , charset_util . utf_8 ) ) n response . headers ( ) . set ( http_header_names . content_type , codstr ) n n this . send_and_cleanup_connection ( ctx , response ) n }	0
Q_79	custom http error response	C_79_4	protected boolean set_custom ( boolean is_response , string path_name , string custom ) { n / / first remove the custom entry for this path if it is the custom request n if ( is_response ) { n this . remove_custom_request ( path_name ) n } n n / / now add it ( _ codint is the custom response identifier ) n if ( is_response ) { n this . add_method_to_response_override ( path_name , codstr ) n } else { n this . add_method_to_response_override ( path_name , codstr ) n } n n / / now set the string n string command = codstr n if ( is_response ) { n command = codstr n } n n try { n basic_name_value_pair [ ] params = { n new basic_name_value_pair ( command , custom ) , n new basic_name_value_pair ( codstr , this . _profile_name ) n } n n json_object response = new json_object ( do_post ( base_path + uri_encode ( path_name ) , params ) ) n n return true n } catch ( exception e ) { n e . print_stack_trace ( ) n } n n return false n }	0
Q_79	custom http error response	C_79_5	override n public void handle_error_response ( http_servlet_response response , int http_error_code ) { n if ( response . is_committed ( ) ) { n response . set_status ( http_error_code ) n } n n string error_header = codstr n if ( http_error_code = codint ) { n error_header = codstr + http_error_code n } n n string error_message = tr . format_message ( tc , codstr ) / / cwwks5489_e n write_error_html ( response , error_header , error_message ) n }	0
Q_79	custom http error response	C_79_6	public object process_security_pre_invoke_exception ( security_violation_exception sve , request_processor request_processor , http_servlet_request request , n http_servlet_response response , web_app_dispatcher_context dispatch_context , web_app context , string name ) throws servlet_error_report { n n object sec_object = null n n / / begin pq56177 n n sec_object = sve . get_web_security_context ( ) n int sc = sve . get_status_code ( ) / / access status code directly . is n / / sc_forbidden the default ? n / / if ( sc = = null ) { n / / if n / / ( com . ibm . ejs . ras . trace_component . is_any_tracing_enabled ( ) logger . is_loggable n / / ( level . fine ) = = true ) n / / { n / / logger . logp ( level . fine , n / / class_name , codstr , n / / codstr ) n / / } n / / sc = http_servlet_response . sc_forbidden n / / } n throwable cause = sve . get_cause ( ) n n if ( com . ibm . ejs . ras . trace_component . is_any_tracing_enabled ( ) logger . is_loggable ( level . fine ) = = true ) { n logger . entering ( class_name , codstr ) n logger . logp ( level . fine , class_name , codstr , n codstr + sve . to_string ( ) n + codstr + sc + codstr + name ) n n } / / end	0
Q_79	custom http error response	C_79_7	public static boolean is_response_http_error_status ( http_response_message response ) { n boolean is_http_error = false n if ( response = null ) { n int status = response . get_status ( ) n is_http_error = is_response_http_error_status ( status ) n } n return is_http_error n }	0
Q_80	create cookie	C_80_0	private cookie create_cookie ( string str ) throws unsupported_encoding_exception { n if ( log . is_debug_enabled ( ) ) { n log . debug ( codstr + auth_cookie + codstr + str ) n } n cookie cookie = new cookie ( auth_cookie , str ) n n cookie . set_max_age ( cookie_max_age ) n if ( cookie_domain = null ) { n cookie . set_domain ( cookie_domain ) n } n if ( cookie_path = null ) { n cookie . set_path ( cookie_path ) n } n cookie . set_secure ( is_cookie_secure ) n return cookie n }	1
Q_80	create cookie	C_80_1	private void deal_with_cookie ( boolean create ) { n if ( request_config . is_disable_cookie ( ) ) { n string cookie_header = header . get ( codstr ) n if ( cookie_header = null ) { n cookies = cookie . sax_to_cookie ( cookie_header ) n string jsessionid = cookie . get_j_session_id ( cookie_header ) n if ( jsessionid = null ) { n session = session_util . get_session_by_id ( jsessionid ) n } n } n if ( create session = = null ) { n if ( cookies = = null ) { n cookies = new cookie [ codint ] n } else { n cookies = new cookie [ cookies . length + codint ] n } n cookie cookie = new cookie ( true ) n string jsessionid = uuid . random_uuid ( ) . to_string ( ) n cookie . set_name ( cookie . jsessionid ) n cookie . set_path ( codstr ) n cookie . set_value ( jsessionid ) n cookies [ cookies . length _ codint ] = cookie n session = new http_session ( jsessionid ) n session_util . session_map . put ( jsessionid , session ) n logger . info ( codstr + cookie . to_string ( ) ) n } n } n }	1
Q_80	create cookie	C_80_2	private static string get_http_only_cookie_header ( cookie cookie ) { n new_cookie new_cookie = new new_cookie ( cookie . get_name ( ) , cookie . get_value ( ) , n cookie . get_path ( ) , cookie . get_domain ( ) , cookie . get_version ( ) , n cookie . get_comment ( ) , cookie . get_max_age ( ) , cookie . get_secure ( ) ) n return new_cookie + codstr n }	1
Q_80	create cookie	C_80_3	public void create_cookie ( string name , string value , string domain , string path ) { n basic_client_cookie cookie = new basic_client_cookie ( name , value ) n cookie . set_domain ( domain ) n if ( path = null ) { n cookie . set_path ( path ) n } n http_client . get_cookie_store ( ) . add_cookie ( cookie ) n }	1
Q_80	create cookie	C_80_4	private static int create_cookie ( final string name , final string value , int max_cookies , int cookie_count , n final map < string , string > cookies , final map < string , string > additional ) { n if ( name . is_empty ( ) name . char_at ( codint ) = = codstr ) { n if ( additional . contains_key ( name ) ) { n return cookie_count n } n additional . put ( name , value ) n return cookie_count n } else { n if ( cookie_count = = max_cookies ) { n throw undertow_messages . messages . too_many_cookies ( max_cookies ) n } n if ( cookies . contains_key ( name ) ) { n return cookie_count n } n cookies . put ( name , value ) n return + + cookie_count n } n }	0
Q_81	copy a file to a path	C_81_0	void copy_file ( boolean deletesrc , byte [ ] src , byte [ ] dst , copy_option . options ) n throws io_exception n { n check_writable ( ) n if ( arrays . equals ( src , dst ) ) n return / / do nothing , src and dst are the same n n begin_write ( ) n try { n ensure_open ( ) n org . apache . hadoop . fs . path e_src_path = new hadoop_path ( this , src ) . get_raw_resolved_path ( ) n file_status e_src = this . fs . get_file_status ( e_src_path ) n if ( this . fs . exists ( e_src_path ) ) n throw new no_such_file_exception ( get_string ( src ) ) n if ( e_src . is_directory ( ) ) { / / specification says to create dst directory n create_directory ( dst ) n return n } n boolean has_replace = false n boolean has_copy_attrs = false n for ( copy_option opt options ) { n if ( opt = = replace_existing ) n has_replace = true n else if ( opt = = copy_attributes ) n has_copy_attrs = true n } n org . apache . hadoop . fs . path e_dst_path = new hadoop_path ( this , dst ) . get_raw_resolved_path ( ) n / / file_status e_dst = this . fs . get_file_status ( e_dst_path ) / / if e_dst_path not exist , it will throw an error n n if ( fs	1
Q_81	copy a file to a path	C_81_1	public void copy_single_file ( file asset ) { n try { n if ( asset . is_directory ( ) ) { n string target_path = config . get_destination_folder ( ) . get_canonical_path ( ) + file . separator_char + asset_sub_path ( asset ) n logger . info ( codstr , target_path ) n copy_file ( asset , new file ( target_path ) ) n } else { n logger . info ( codstr , asset . get_path ( ) ) n } n } catch ( io_exception io ) { n logger . error ( codstr , io ) n } n }	1
Q_81	copy a file to a path	C_81_2	public final void file_copy ( file in , file out ) throws io_exception { n assert in = null n assert out = null n get_log ( ) . debug ( codstr + in . to_string ( ) + codstr + out . to_string ( ) ) / / non _ nls _ codint / / non _ nls _ codint n try ( file_input_stream fis = new file_input_stream ( in ) ) { n try ( file_channel in_channel = fis . get_channel ( ) ) { n try ( file_output_stream fos = new file_output_stream ( out ) ) { n try ( file_channel out_channel = fos . get_channel ( ) ) { n in_channel . transfer_to ( codint , in_channel . size ( ) , out_channel ) n } n } n } n } finally { n get_build_context ( ) . refresh ( out ) n } n }	1
Q_81	copy a file to a path	C_81_3	public static void copy_file ( file source , file dest ) throws io_exception { n log . debug ( codstr , source . get_absolute_file ( ) , dest . get_absolute_file ( ) ) n file_input_stream fi = new file_input_stream ( source ) n file_channel fic = fi . get_channel ( ) n mapped_byte_buffer mbuf = fic . map ( file_channel . map_mode . read_only , codint , source . length ( ) ) n fic . close ( ) n fi . close ( ) n fi = null n n / / ensure the destination directory exists n if ( dest . exists ( ) ) { n string dest_path = dest . get_path ( ) n log . debug ( codstr , dest_path ) n string dest_dir = dest_path . substring ( codint , dest_path . last_index_of ( file . separator_char ) ) n log . debug ( codstr , dest_dir ) n file dir = new file ( dest_dir ) n if ( dir . exists ( ) ) { n if ( dir . mkdirs ( ) ) { n log . debug ( codstr ) n } else { n log . warn ( codstr ) n } n } n dir = null n } n n file_output_stream fo = new file_output_stream ( dest ) n file_channel foc = fo . get_channel ( ) n foc . write ( mbuf ) n foc . close ( ) n fo . close ( )	1
Q_81	copy a file to a path	C_81_4	public static void copy_file ( string origin_file_path , string target_file_path ) { n file origin_file = new file ( origin_file_path ) n file target_file = new file ( target_file_path ) n copy_file ( origin_file , target_file ) n }	1
Q_81	copy a file to a path	C_81_5	nonnull n private static e_success _copy_file_via_channel ( nonnull final file a_src_file , nonnull final file a_dest_file ) n { n final file_channel a_src_channel = file_channel_helper . get_file_read_channel ( a_src_file ) n if ( a_src_channel = = null ) n return e_success . failure n n try n { n final file_channel a_dst_channel = file_channel_helper . get_file_write_channel ( a_dest_file , e_append . truncate ) n if ( a_dst_channel = = null ) n return e_success . failure n n try n { n file_lock a_src_lock = null n file_lock a_dest_lock = null n try n { n final long n_bytes_to_read = a_src_channel . size ( ) n n / / shared read lock and exclusive write lock n a_src_lock = a_src_channel . lock ( codint , n_bytes_to_read , true ) n a_dest_lock = a_dst_channel . lock ( ) n n / / main copying _ the loop version is much quicker than then n / / transfer_to with full size n long n_bytes_written = codint n final long n_chunk_size = codint * c_global . bytes_per_megabyte n while ( n_bytes_written < n_bytes_to_read ) n n_bytes_written + = a_src_channel . transfer_to ( n_bytes_written , n_chunk_size , a_dst_channel ) n n if ( n_bytes_to_read = n_bytes_written ) n { n if ( logger . is_error_enabled ( ) ) n logger . error ( codstr + n_bytes_to_read + codstr + n_bytes_written ) n return e_success . failure n } n return e_success . success n } n catch ( final io_exception ex ) n	0
Q_81	copy a file to a path	C_81_6	public path with_file ( final string file ) { n final path result = new path ( this ) n result . set_file ( file ) n return result n }	0
Q_82	copy to clipboard	C_82_0	private void handle_context_menu ( j_tree tree , int x , int y ) { n tree_path path = tree . get_path_for_location ( x , y ) n tree . set_selection_path ( path ) n default_mutable_tree_node node = ( default_mutable_tree_node ) tree . get_last_selected_path_component ( ) n n if ( node = = null ) n return n if ( node . is_leaf ( ) ) { n tree . set_selection_path ( null ) n return n } n final app_info info = ( app_info ) node . get_user_object ( ) n n j_menu_item copyname = new j_menu_item ( codstr ) n copyname . add_action_listener ( e _ > { n clipboard clipboard = toolkit . get_default_toolkit ( ) . get_system_clipboard ( ) n clipboard . set_contents ( new string_selection ( info . app . get_simple_name ( ) ) , null ) n } ) n n j_menu_item copypath = new j_menu_item ( codstr ) n copypath . add_action_listener ( e _ > { n string path1 = util_io . get_source_path ( info . app . get_package ( ) . get_name ( ) , info . app . get_simple_name ( ) ) n clipboard clipboard = toolkit . get_default_toolkit ( ) . get_system_clipboard ( ) n clipboard . set_contents ( new string_selection ( path1 ) , null ) n } ) n n j_menu_item github = new j_menu_item ( codstr ) n github . add_action_listener ( e _ > open_in_git_hub ( info ) ) n n j_popup_menu submenu = new	1
Q_82	copy to clipboard	C_82_1	public static void copy_to_clipboard ( string text ) { n string_selection selection = new string_selection ( text ) n clipboard clipboard = toolkit . get_default_toolkit ( ) . get_system_clipboard ( ) n clipboard . set_contents ( selection , selection ) n }	1
Q_82	copy to clipboard	C_82_2	private void copy_to_clipboard ( context context ) { n clipboard_manager clipboard_manager = ( clipboard_manager ) context . get_system_service ( context . clipboard_service ) n clip_data clip_data = clip_data . new_plain_text ( button_text , inbox_message . get_inbox_message_contents ( ) . get ( codint ) . get_link_copy_text ( button_object ) ) n if ( clipboard_manager = null ) { n clipboard_manager . set_primary_clip ( clip_data ) n toast . make_text ( context , codstr , toast . length_short ) . show ( ) n } n }	1
Q_82	copy to clipboard	C_82_3	public boolean copy_topics_to_clipboard ( final boolean cut , nonnull must_not_contain_null final topic . topics ) { n boolean result = false n n if ( this . lock_if_not_disposed ( ) ) { n try { n if ( topics . length > codint ) { n final clipboard clipboard = toolkit . get_default_toolkit ( ) . get_system_clipboard ( ) n clipboard . set_contents ( new mmd_topics_transferable ( topics ) , this ) n n if ( cut ) { n delete_topics ( true , ensure_no_root_in_array ( topics ) ) n } n n result = true n } n } finally { n this . unlock ( ) n } n } n n return result n }	1
Q_82	copy to clipboard	C_82_4	public static void copy_to_clipboard ( string string ) { n clipboard_content content = new clipboard_content ( ) n content . put_string ( string ) n clipboard . get_system_clipboard ( ) . set_content ( content ) n logger . info ( codstr codstr codstr ) n }	1
Q_82	copy to clipboard	C_82_5	protected void copy_to_clipboard ( string tool_tip ) { n object [ ] data = new object [ ] { tool_tip } n transfer [ ] transfer = new transfer [ ] { text_transfer . get_instance ( ) } n clipboard clipboard = new clipboard ( display . get_current ( ) ) n clipboard . set_contents ( data , transfer ) n clipboard . dispose ( ) n }	1
Q_82	copy to clipboard	C_82_6	public static string get_from_clipboard ( ) throws exception { n clipboard clipboard = toolkit . get_default_toolkit ( ) . get_system_clipboard ( ) n string string = ( string ) clipboard . get_data ( data_flavor . string_flavor ) n return string n }	1
Q_82	copy to clipboard	C_82_7	public static string get_clipboard_text ( final context context ) { n final clipboard_manager clipboard = ( clipboard_manager ) context . get_system_service ( context . clipboard_service ) n final clip_data clip_data = clipboard . get_primary_clip ( ) n if ( clip_data = null clip_data . get_item_count ( ) > codint ) { n final char_sequence clipboard_text = clip_data . get_item_at ( codint ) . get_text ( ) n if ( clipboard_text = null ) { n return clipboard_text . to_string ( ) n } n } n return null n }	1
Q_83	convert uint8 array to image	C_83_0	private buffered_image to16_bit1_component_gray_scale ( int [ ] [ ] decoded , int precision , int width , int height ) { n buffered_image image n if ( precision = = codint ) { n image = new buffered_image ( width , height , buffered_image . type_ushort_gray ) n } n else { n color_model color_model = new component_color_model ( color_space . get_instance ( color_space . cs_gray ) , new int [ ] { precision } , false , false , transparency . opaque , data_buffer . type_ushort ) n image = new buffered_image ( color_model , color_model . create_compatible_writable_raster ( width , height ) , color_model . is_alpha_premultiplied ( ) , null ) n } n n short [ ] image_buffer = ( ( data_buffer_u_short ) image . get_raster ( ) . get_data_buffer ( ) ) . get_data ( ) n n for ( int i = codint i < image_buffer . length i + + ) { n image_buffer [ i ] = ( short ) decoded [ codint ] [ i ] n } n n return image n }	0
Q_83	convert uint8 array to image	C_83_1	suppress_warnings ( { codstr , codstr } ) n protected object transform ( object result , query_result_mapper result_mapper ) { n object actual_result = null n if ( result instanceof collection ) { n n if ( process_instance_custom_desc . class . is_assignable_from ( result_mapper . get_type ( ) ) ) { n n logger . debug ( codstr ) n actual_result = convert_to_process_instance_custom_vars_list ( ( collection < process_instance_custom_desc > ) result ) n } else if ( process_instance_with_vars_desc . class . is_assignable_from ( result_mapper . get_type ( ) ) ) { n n logger . debug ( codstr ) n actual_result = convert_to_process_instance_with_vars_list ( ( collection < process_instance_with_vars_desc > ) result ) n } else if ( process_instance_desc . class . is_assignable_from ( result_mapper . get_type ( ) ) ) { n n logger . debug ( codstr ) n actual_result = convert_to_process_instance_list ( ( collection < process_instance_desc > ) result ) n } else if ( user_task_instance_with_vars_desc . class . is_assignable_from ( result_mapper . get_type ( ) ) ) { n n logger . debug ( codstr ) n actual_result = convert_to_task_instance_with_vars_list ( ( collection < user_task_instance_with_vars_desc > ) result ) n } else if ( user_task_instance_with_pot_owner_desc . class . is_assignable_from ( result_mapper . get_type ( ) ) ) { n n logger . debug ( codstr ) n actual_result = convert_to_task_instance_list_po ( ( collection < user_task_instance_with_pot_owner_desc > ) result ) n } else if ( user_task_instance_desc . class . is_assignable_from ( result_mapper . get_type ( ) )	0
Q_83	convert uint8 array to image	C_83_2	override n public void set_legend_image_service_url ( string legend_image_service_url_as_string ) { n this . image = null / / remove the cached image n this . legend_image_service_url = null / / clear the cached value n n url absolute_url = null n n if ( legend_image_service_url_as_string . starts_with ( codstr ) legend_image_service_url_as_string . starts_with ( codstr ) ) { n n try { n string base_url_as_string = dispatcher_url_service . get_local_dispatcher_url ( ) n log . debug ( codstr , base_url_as_string ) n url base_url = new url ( base_url_as_string ) n absolute_url = new url ( base_url , codstr + legend_image_service_url_as_string ) n log . debug ( codstr , absolute_url ) n } catch ( malformed_url_exception e ) { n / / should never happen . n log . error ( codstr + legend_image_service_url_as_string + codstr , e ) n e . print_stack_trace ( ) n } n } else { n try { n absolute_url = new url ( legend_image_service_url_as_string ) n } catch ( malformed_url_exception e ) { n / / should never happen . n log . error ( codstr + legend_image_service_url_as_string + codstr , e ) n } n } n this . legend_image_service_url_as_string = absolute_url . to_external_form ( ) n }	0
Q_83	convert uint8 array to image	C_83_3	public static byte [ ] convert_abgr_to_yuv220_sp ( buffered_image image ) { n byte [ ] one_frame = new byte [ ( int ) ( image . get_width ( ) * image . get_height ( ) * number ) ] n writable_raster wr = image . get_raster ( ) n data_buffer_byte db = ( data_buffer_byte ) wr . get_data_buffer ( ) n n byte [ ] in_array = db . get_data ( ) n n int width = wr . get_width ( ) n int height = wr . get_height ( ) n n int i = codint n int numpixels = width * height n int r , g , b , y , u , v n int ui = numpixels n int vi = numpixels + numpixels / codint n int color n n for ( int y = codint y < height y + + ) { n for ( int x = codint x < width x + + ) { n int in_ptr = ( y * width + x ) * codint n color = image . get_rgb ( x , y ) n r = in_array [ in_ptr + codint ] n g = in_array [ in_ptr + codint ] n b = in_array [ in_ptr + codint ] n n y = ( int ) ( ( number * r ) + ( number * g ) + ( number * b ) + codint ) n one_frame [ i ]	0
Q_83	convert uint8 array to image	C_83_4	public static buffered_image convert_image ( raw_image raw_image ) { n switch ( raw_image . bpp ) { n case codint n return raw_image16to_argb ( raw_image ) n case codint n return raw_image32to_argb ( raw_image ) n } n return null n }	0
Q_83	convert uint8 array to image	C_83_5	override n public void set_image ( t image ) { n if ( ii = null ) { n ii . reshape ( image . width , image . height ) n } n n / / compute integral image n ii = g_integral_image_ops . transform ( image , ii ) n surf . set_image ( ii ) n }	0
Q_83	convert uint8 array to image	C_83_6	"public static void main ( string args [ ] ) { n / / load and convert the image into a usable format n buffered_image image = util_image_io . load_image ( util_io . path_example ( codstr ) ) n n / / convert into a usable format n gray_f32 input = convert_buffered_image . convert_from_single ( image , null , gray_f32 . class ) n gray_u8 binary = new gray_u8 ( input . width , input . height ) n gray_s32 label = new gray_s32 ( input . width , input . height ) n n / / select a global threshold using otsu codstr binary original codstr binary filtered codstr labeled blobs codstr contours codstr binary operations "" , true ) n }"	0
Q_84	convert string to number	C_84_0	public static int convert_to_int ( object value ) n { n if ( value instanceof number ) n { n return ( ( number ) value ) . int_value ( ) n } n else if ( value instanceof string ) n { n try n { n return integer . parse_int ( ( string ) value ) n } n catch ( number_format_exception e ) n { n throw new illegal_argument_exception ( codstr + value . to_string ( ) + codstr ) n } n } n else n { n throw new illegal_argument_exception ( codstr + value . to_string ( ) + codstr ) n } n }	1
Q_84	convert string to number	C_84_1	public object do_convert ( conversion_context context , object source_object , type_reference < ? > destination_type ) throws converter_exception { n if ( source_object = = null ) { n if ( destination_type . is_primitive ( ) ) { n throw new converter_exception ( codstr ) n } n return null n } n n string source_string = ( string ) source_object n n parse_position pos = new parse_position ( codint ) n number number n synchronized ( this ) { n number = number_format . parse ( source_string , pos ) n } n if ( pos . get_index ( ) < source_string . length ( ) ) { n number = null n } n n if ( number = = null ) { n throw new converter_exception ( message_format . format ( n codstr codstr codstr , source_string ) ) n } n n return number_to_number_converter . convert ( context , number , destination_type ) n }	0
Q_84	convert string to number	C_84_2	"public string convert_to_sql_string ( object a ) { n n if ( a = = null ) { n return codstr n } n n string s = convert_to_string ( a ) n n return string_converter . to_quoted_string ( s , codstr "" , true ) n }"	0
Q_84	convert string to number	C_84_3	public string value_number_to_string ( value_number vn , flow_value value ) { n string_builder buf = new string_builder ( ) n n buf . append ( vn . get_number ( ) ) n buf . append ( codstr ) n n buf . append ( value ) n if ( value = flow_value . top ) { n set < ? extends source_sink_info > always = get_source_sink_info_set ( where_always , vn ) n set < ? extends source_sink_info > never = get_source_sink_info_set ( where_never , vn ) n if ( value = flow_value . unknown always . equals ( never ) ) { n buf . append ( codstr ) n if ( always . is_empty ( ) ) { n append_source_sink_infos ( buf , codstr , always ) n } n if ( always . is_empty ( ) never . is_empty ( ) ) { n buf . append ( codstr ) n } n if ( never . is_empty ( ) ) { n append_source_sink_infos ( buf , codstr , never ) n } n buf . append ( codstr ) n } n } n n return buf . to_string ( ) n }	0
Q_84	convert string to number	C_84_4	private static string num_to_string ( int num , int width ) { n string str = integer . to_string ( num ) n int len = str . length ( ) n if ( len > = width ) { n return str . substring ( len _ width , len ) n } n string_builder sb = new string_builder ( width ) n for ( int i = len i < width i + + ) { n sb . append ( codstr ) n } n sb . append ( str ) n return sb . to_string ( ) n }	0
Q_84	convert string to number	C_84_5	private static string convert_number ( string signature , number number ) { n long val = number . long_value ( ) n switch ( signature ) { n case codstr n if ( val = = codint ) { n return codstr n } n return codstr n case codstr n if ( val = = codstr ) { n return codstr n codstr n } n if ( val = = codstr ) { n return codstr r codstr n } n if ( val = = codstr ) { n return codstr b codstr n } n if ( val = = codstr ) { n return codstr t codstr n } n if ( val = = codstr codstr codstr codstr n } n if ( val = = codstr ) { n return codstr codstr n } n if ( val > = codint val < codint ) { n return codstr codstr codstr n } n return convert_number ( val ) n case codstr n if ( val > = codint val < codint ) { n return val + codstr codstr codstr n } n return convert_number ( val ) n default n return convert_number ( val ) n } n }	0
Q_85	convert json to csv	C_85_0	public string get_csv ( ) { n n string_writer writer = new string_writer ( ) n try ( csv_writer csv = new csv_writer ( writer ) ) { n list < string > headers = new array_list < > ( ) n for ( string col m_columns ) { n headers . add ( col ) n } n csv . write_next ( headers . to_array ( new string [ ] { } ) ) n for ( list < object > row m_data ) { n list < string > col_csv = new array_list < > ( ) n for ( object col row ) { n col_csv . add ( string . value_of ( col ) ) n } n csv . write_next ( col_csv . to_array ( new string [ ] { } ) ) n } n return writer . to_string ( ) n } catch ( io_exception e ) { n return null n } n }	1
Q_85	convert json to csv	C_85_1	private set < string > convert_csv_to_set ( string csv ) { n / / a null line in the file indicates an empty file so return an empty n / / set as it means no apa_rs were found n if ( csv = = null ) { n return collections . empty_set ( ) n } n n / / if we got this far then we must of found the csv file so process it n / / to find the apar i_ds n set < string > fix_pack_apar_ids = new hash_set < string > ( ) n string [ ] apar_ids = csv . split ( codstr ) n for ( string id apar_ids ) { n fix_pack_apar_ids . add ( id ) n } n return fix_pack_apar_ids n }	1
Q_85	convert json to csv	C_85_2	private csv_settings parse_csv_settings ( json_object head_record ) throws exception { n json_object csv = head_record . get_json_object ( codstr ) n n csv_settings csv_settings = new csv_settings ( ) n n json_array column_arr = csv . get_json_array ( codstr ) n for ( int i = codint , e = column_arr . length ( ) i < e + + i ) { n object column_obj = column_arr . get ( i ) n if ( column_obj instanceof json_object ) { n json_object json_column_def = ( json_object ) column_obj n string name = json_column_def . opt_string ( codstr , null ) n string label = json_column_def . opt_string ( codstr , null ) n n if ( null = = name ) { n throw new exception ( codstr ) n } n if ( null = = label ) { n label = name n } n n csv_column csv_column = new csv_column ( ) n csv_column . set_name ( name ) n csv_column . set_label ( label ) n n csv_settings . add_column ( csv_column ) n n } else { n throw new exception ( codstr ) n } n } n n return csv_settings n }	0
Q_85	convert json to csv	C_85_3	private string convert_to_json ( map < string , ? > map ) throws movie_db_exception { n try { n return mapper . write_value_as_string ( map ) n } catch ( json_processing_exception ex ) { n throw new movie_db_exception ( api_exception_type . mapping_failed , codstr , codstr , ex ) n } n }	0
Q_85	convert json to csv	C_85_4	private string list_to_csv ( list < string > list ) { n string csv_str = codstr n for ( string item list ) { n csv_str + = codstr + item n } n n return csv_str . length ( ) > codint ? csv_str . substring ( codint ) csv_str n }	0
Q_85	convert json to csv	C_85_5	public static json_object csv_to_json_object ( list < string > bulk_record_header , list < string > record , int column_count ) { n object_mapper mapper = new object_mapper ( ) n map < string , string > result_info = new hash_map < > ( ) n for ( int i = codint i < column_count i + + ) { n result_info . put ( bulk_record_header . get ( i ) , record . get ( i ) ) n } n n json_node json = mapper . value_to_tree ( result_info ) n json_element element = gson . from_json ( json . to_string ( ) , json_object . class ) n return element . get_as_json_object ( ) n }	0
Q_85	convert json to csv	C_85_6	public static void main ( string args [ ] ) throws exception { n try { n sheet_js sjs = new sheet_js ( ) n n / * open file * / n sheet_js_file xl = sjs . read_file ( args [ codint ] ) n n / * get sheetnames * / n string [ ] sheetnames = xl . get_sheet_names ( ) n system . err . println ( sheetnames [ codint ] ) n n / * convert to csv * / n sheet_js_sheet sheet = xl . get_sheet ( codint ) n string csv = sheet . get_csv ( ) n n system . out . println ( csv ) n n } catch ( exception e ) { n throw e n } finally { n sheet_js . close ( ) n } n }	0
Q_85	convert json to csv	C_85_7	public static list < string > parse_csv_list ( string csv ) { n if ( csv = = null csv . is_empty ( ) ) { n return collections . empty_list ( ) n } n n return new array_list < string > ( arrays . as_list ( csv . split ( codstr ) ) ) n }	0
Q_85	convert json to csv	C_85_8	public string to_csv ( csv . records ) { n if ( records = null records . length > codint ) { n string [ ] header = records [ codint ] . get_csv_header ( ) n string_writer writer = new string_writer ( ) n try ( csv_printer printer = get_csv_format ( ) . with_header ( header ) . print ( writer ) ) { n for ( csv record records ) { n object [ ] data = record . get_csv_data ( ) n if ( data = = null data . length = = codint ) { n log . debug ( codstr ) n continue n } n n for ( object column data ) { n printer . print ( object_to_string ( column ) ) n } n printer . println ( ) n } n } catch ( io_exception e ) { n log . error ( codstr , e ) n } n n return writer . to_string ( ) n } n n return null n }	0
Q_85	convert json to csv	C_85_9	private string get_output_filename ( file pdf_file ) { n string extension = codstr n switch ( output_format ) { n case csv n extension = codstr n break n case json n extension = codstr n break n case tsv n extension = codstr n break n } n return pdf_file . get_path ( ) . replace_first ( codstr , extension ) n }	0
Q_86	convert int to string	C_86_0	public int get_frequency ( string from , string to ) n { n return get_frequency ( convert ( from ) , convert ( to ) ) n }	0
Q_86	convert int to string	C_86_1	private static int to_int ( string str , int default_val ) { n try { n return integer . parse_int ( str . trim ( ) ) n } catch ( exception e ) { n return default_val n } n }	0
Q_86	convert int to string	C_86_2	static integer to_int ( string s ) { n if ( s . is_empty ( ) ) return null n try { n return integer . parse_int ( s ) n } catch ( number_format_exception e ) { n logger . warn ( s + codstr , e ) n } n return null n }	0
Q_86	convert int to string	C_86_3	public integer convert_to_int ( string value ) { n integer result = null n if ( value = null ) { n result = integer . value_of ( value ) n } n return result n }	0
Q_86	convert int to string	C_86_4	public static int convert_to_int ( object value ) n { n if ( value instanceof number ) n { n return ( ( number ) value ) . int_value ( ) n } n else if ( value instanceof string ) n { n try n { n return integer . parse_int ( ( string ) value ) n } n catch ( number_format_exception e ) n { n throw new illegal_argument_exception ( codstr + value . to_string ( ) + codstr ) n } n } n else n { n throw new illegal_argument_exception ( codstr + value . to_string ( ) + codstr ) n } n }	0
Q_87	convert int to bool	C_87_0	private boolean convert_to_boolean ( object o ) { n if ( o . get_class ( ) = = boolean . class ) { n return ( boolean ) o n } n else { n return boolean . parse_boolean ( o . to_string ( ) ) n } n }	1
Q_87	convert int to bool	C_87_1	public static boolean convert_to_boolean ( object o ) n { n if ( o = = null ) n return false n n if ( o instanceof boolean ) n { n return ( boolean ) o n } n n return convert_to_boolean ( o . to_string ( ) ) n }	1
Q_87	convert int to bool	C_87_2	public int get_frequency ( string from , string to ) n { n return get_frequency ( convert ( from ) , convert ( to ) ) n }	0
Q_87	convert int to bool	C_87_3	public static int convert_to_int ( object value ) n { n if ( value instanceof number ) n { n return ( ( number ) value ) . int_value ( ) n } n else if ( value instanceof string ) n { n try n { n return integer . parse_int ( ( string ) value ) n } n catch ( number_format_exception e ) n { n throw new illegal_argument_exception ( codstr + value . to_string ( ) + codstr ) n } n } n else n { n throw new illegal_argument_exception ( codstr + value . to_string ( ) + codstr ) n } n }	0
Q_87	convert int to bool	C_87_4	private static int to_int ( long l ) { n if ( l < = integer . max_value ) { n return l . int_value ( ) n } else { n return integer . max_value n } n }	0
Q_87	convert int to bool	C_87_5	public static boolean convert_to_boolean ( object value ) n { n if ( value instanceof boolean ) n { n return ( ( boolean ) value ) n } n else if ( value instanceof string ) n { n try n { n return boolean . parse_boolean ( ( string ) value ) n } n catch ( exception e ) n { n throw new illegal_argument_exception ( codstr + value . to_string ( ) + codstr ) n } n } n else n { n throw new illegal_argument_exception ( codstr + value . to_string ( ) + codstr ) n } n }	0
Q_87	convert int to bool	C_87_6	private model_node convert_boolean ( xml configuration ) { n string v = get_value . apply ( configuration ) n boolean bool_val = codstr . equals_ignore_case ( v ) n ? boolean . true n ( codstr . equals_ignore_case ( v ) ? boolean . false null ) n if ( bool_val = = null ) { n throw new illegal_argument_exception ( codstr true codstr false codstr ) n } n return new model_node ( bool_val ) n }	0
Q_87	convert int to bool	C_87_7	public static int to_integer ( final boolean bool , final int true_value , final int false_value , final int null_value ) { n if ( bool = = null ) { n return null_value n } n return bool . boolean_value ( ) ? true_value false_value n }	0
Q_88	convert html to pdf	C_88_0	public byte [ ] render ( string html ) throws render_exception { n try { n log . debug ( codstr + html . length ( ) ) n byte_array_output_stream baos = new byte_array_output_stream ( ) n pdf_saucer_renderer renderer = provider . get_renderer ( html ) n n log . debug ( codstr ) n n renderer . create_pdf ( baos ) n renderer . finish_pdf ( ) n n log . debug ( codstr ) n return baos . to_byte_array ( ) n } catch ( io_exception document_exception e ) { n throw new render_exception ( codstr , e , codstr ) n } n }	1
Q_88	convert html to pdf	C_88_1	private void generate_pdf ( ) { n file pdf_file = new file ( directory , filename + codstr ) n try ( output_stream os = new file_output_stream ( pdf_file ) ) { n pdf_renderer_builder builder = new pdf_renderer_builder ( ) n builder . with_html_content ( get_html_for_pdf_conversion ( ) , codstr + pdf_file . get_absolute_path ( ) n . replace_all ( codstr , codstr ) ) n builder . to_stream ( os ) n builder . run ( ) n } catch ( exception e ) { n log . error ( e ) n } n }	1
Q_88	convert html to pdf	C_88_2	private cms_search_index_source create_dummy_index_source ( ) { n n cms_search_index_source result = new cms_search_index_source ( ) n result . set_name ( codstr ) n result . set_indexer_class_name ( codstr ) n result . add_document_type ( codstr ) n result . add_document_type ( codstr ) n result . add_document_type ( codstr ) n / / add search index source to config n m_search_manager . add_search_index_source ( result ) n return result n }	0
Q_88	convert html to pdf	C_88_3	public static file convert_pdf2_tiff ( file input_pdf_file ) throws io_exception { n if ( pdfbox . equals ( system . get_property ( pdf_library ) ) ) { n return pdf_box_utilities . convert_pdf2_tiff ( input_pdf_file ) n } else { n try { n return pdf_gs_utilities . convert_pdf2_tiff ( input_pdf_file ) n } catch ( exception e ) { n system . set_property ( pdf_library , pdfbox ) n return convert_pdf2_tiff ( input_pdf_file ) n } n } n }	0
Q_88	convert html to pdf	C_88_4	private string convert_page_to_pdf ( pdf pdf , byte_array_output_stream baos ) { n try { n baos . write ( pdf . get_pdf ( ) ) n return baos . to_string ( codstr ) n } catch ( io_exception e ) { n n logger . warn ( codstr , e ) n n } catch ( interrupted_exception e ) { n n logger . warn ( codstr , e ) n n } n return codstr n }	0
Q_88	convert html to pdf	C_88_5	private void convert_html_code ( array_list < array_list < text_piece words_by_page ) { n doc_info doc_info = new doc_info ( ) n string [ ] html2_char = doc_info . get_html2_char_mapping ( ) / / only define this n / / mapping string n / / when we detect n / / the files in html n / / codes n int page_num = codint n n for ( array_list < text_piece > words_of_a_page words_by_page ) { n page_num + + n for ( int i = codint i < words_of_a_page . size ( ) i + + ) { n text_piece current_word = words_of_a_page . get ( i ) n string real_text = codstr n string textin_html_code = current_word . get_text ( ) n n } n } n }	0
Q_89	convert decimal to hex	C_89_0	public static byte [ ] from_hex ( string hex ) { n try { n return hex . decode_hex ( hex . to_char_array ( ) ) n } catch ( decoder_exception e ) { n return null n } n }	1
Q_89	convert decimal to hex	C_89_1	public static big_integer unscaled_decimal_to_big_integer ( slice decimal ) n { n byte [ ] bytes = decimal . get_bytes ( codint , unscaled_decimal_128_slice_length ) n / / convert to big _ endian order n reverse ( bytes ) n bytes [ codint ] = sign_byte_mask n return new big_integer ( is_negative ( decimal ) ? _ codint codint , bytes ) n }	1
Q_89	convert decimal to hex	C_89_2	private static string encode_as_hex ( byte [ ] input ) { n string_builder hex_string = new string_builder ( ) n for ( int i = codint i < input . length i + + ) { n string hex = integer . to_hex_string ( codint input [ i ] ) n if ( hex . length ( ) = = codint ) { n hex_string . append ( codstr ) n } n hex_string . append ( hex ) n } n return hex_string . to_string ( ) n }	1
Q_89	convert decimal to hex	C_89_3	public static string to_decimal_string ( string in_binary_ip_address ) { n string_builder decimalip = new string_builder ( ) n string [ ] binary = new string [ codint ] n n for ( int i = codint , c = codint i < codint i = i + codint , c + + ) { n binary [ c ] = in_binary_ip_address . substring ( i , i + codint ) n int octet = integer . parse_int ( binary [ c ] , codint ) n decimalip . append ( octet ) n if ( c < codint ) { n n decimalip . append ( codstr ) n } n } n return decimalip . to_string ( ) n }	0
Q_89	convert decimal to hex	C_89_4	gwt_incompatible / / regular expressions n private static pattern fp_pattern ( ) { n string decimal = codstr n string complete_dec = decimal + codstr n string hex = codstr n string complete_hex = codstr + hex + codstr n string fp_pattern = codstr + complete_dec + codstr + complete_hex + codstr n return pattern . compile ( fp_pattern ) n }	0
Q_89	convert decimal to hex	C_89_5	private static int decode ( final int hex ) { n if ( hex > = cc_hex . back . length ) { n throw new decoding_exception ( n string . format ( codstr , hex ) n ) n } n final int dec = cc_hex . back [ hex ] n if ( dec < codint ) { n throw new decoding_exception ( n string . format ( codstr , hex ) n ) n } n return dec n }	0
Q_89	convert decimal to hex	C_89_6	public static long convert_long_array_from_hex ( char [ ] hex ) { n int hex_len = hex . length n if ( hex_len < codint ) throw new illegal_argument_exception ( codstr + hex_len ) n int h = ( get_hex ( hex [ codint ] ) < < codint ) n ( get_hex ( hex [ codint ] ) < < codint ) n ( get_hex ( hex [ codint ] ) < < codint ) n ( get_hex ( hex [ codint ] ) < < codint ) n ( get_hex ( hex [ codint ] ) < < codint ) n ( get_hex ( hex [ codint ] ) < < codint ) n ( get_hex ( hex [ codint ] ) < < codint ) n ( get_hex ( hex [ codint ] ) ) n n int l = ( get_hex ( hex [ codint ] ) < < codint ) n ( get_hex ( hex [ codint ] ) < < codint ) n ( get_hex ( hex [ codint ] ) < < codint ) n ( get_hex ( hex [ codint ] ) < < codint ) n ( get_hex ( hex [ codint ] ) < < codint ) n ( get_hex ( hex [ codint ] ) < < codint ) n ( get_hex ( hex [ codint ] ) < < codint ) n ( get_hex ( hex [ codint ] ) ) n n return ( ( ( long	0
Q_89	convert decimal to hex	C_89_7	"private decimal to_decimal_slow ( int precision , int scale ) { n / / as data in decimal is currently stored by big_decimal if precision > decimal . max_long_digits , n / / and big_decimal only supports string or char [ ] for its constructor , n / / we can codstr codstr n codstr t codstr codstr n codstr t "" ) { n end = i + codint n break n } n } n try { n big_decimal bd = new big_decimal ( chars , start , end _ start ) n return decimal . from_big_decimal ( bd , precision , scale ) n } catch ( number_format_exception nfe ) { n return null n } n } n }"	0
Q_89	convert decimal to hex	C_89_8	static big_decimal to_big_decimal ( oid oid , string value ) { n switch ( oid ) { n case unspecified / / fallthrough n case int2 / / fallthrough n case int4 / / fallthrough n case int8 / / fallthrough n case numeric / / fallthrough n case float4 / / fallthrough n case float8 n return new big_decimal ( value ) n default n throw new sql_exception ( codstr + oid . name ( ) + codstr ) n } n }	0
Q_90	convert a utc time to epoch	C_90_0	private static date_time_value convert ( date_time_value time , time_zone zone , int sense ) { n if ( zone = = null zone . has_same_rules ( zulu ) time . year ( ) = = codint ) { n return time n } n n time_zone epoch_tz , date_time_value_tz n if ( sense > codint ) { n / / time is in utc convert to time in zone provided n epoch_tz = zulu n date_time_value_tz = zone n } else { n / / time is in local time convert to utc n epoch_tz = zone n date_time_value_tz = zulu n } n n long epoch_seconds = secs_since_epoch ( time ) n long timet_millis = timet_millis_from_epoch_secs ( epoch_seconds , epoch_tz ) n return to_date_time_value ( timet_millis , date_time_value_tz ) n }	1
Q_90	convert a utc time to epoch	C_90_1	public static long to_epoch ( date date_time , string time_zone ) { n / / epoch of midnight in local time zone n calendar time_offset = calendar . get_instance ( time_zone . get_time_zone ( time_zone ) ) n time_offset . set ( calendar . millisecond , codint ) n time_offset . set ( calendar . second , codint ) n time_offset . set ( calendar . minute , codint ) n time_offset . set ( calendar . hour_of_day , codint ) n n long midnight_off_set = time_offset . get_time ( ) . get_time ( ) n long local_timestamp = date_time . get_time ( ) n n return time_offset = = null ? null midnight_off_set + local_timestamp n }	1
Q_90	convert a utc time to epoch	C_90_2	private static string coerce_to_epoch ( string s ) { n long epoch = parse_epoch_second ( s ) n if ( epoch = null ) { n return string . value_of ( epoch ) n } n simple_date_format format = new simple_date_format ( codstr t codstr ) n try { n return string . value_of ( format . parse ( s ) . get_time ( ) ) n } n catch ( parse_exception ex ) { n return s n } n }	1
Q_90	convert a utc time to epoch	C_90_3	synchronized private static long to_epoch ( string date_time ) { n date date = null n final simple_date_format input_format = new simple_date_format ( inputformat ) n try { n date = input_format . parse ( date_time ) n } catch ( parse_exception e ) { n throw new runtime_exception ( e . get_message ( ) , e ) n } n return date . get_time ( ) n }	1
Q_90	convert a utc time to epoch	C_90_4	private void read_object ( java . io . object_input_stream in ) n throws io_exception , class_not_found_exception n { n this . timezone_sensitive = in . read_boolean ( ) n long time = in . read_long ( ) n if ( this . timezone_sensitive ) n { n / / convert the time from utc to local n int offset = get_default_offset ( this ) n time _ = offset n } n this . set_time ( time ) n this . set_nanos ( in . read_int ( ) ) n }	0
Q_90	convert a utc time to epoch	C_90_5	private static final base_calendar get_calendar_system ( long utc ) { n / / quickly check if the time stamp given by utc codstr s before codint , we convert the cutover to n / / local time to compare . n if ( utc > = codint n utc > = gregorian_calendar . default_gregorian_cutover n _ time_zone . get_default_ref ( ) . get_offset ( utc ) ) { n return gcal n } n return get_julian_calendar ( ) n }	0
Q_90	convert a utc time to epoch	C_90_6	public static date_time epoch ( ) { n mutable_date_time epoch = new mutable_date_time ( ) n n epoch . set_date ( codint ) n epoch . set_time ( codint ) n n return epoch . to_date_time ( ) n }	0
Q_91	convert a date string into yyyymmdd	C_91_0	protected string to_date_string ( object date ) { n string return_value = null n if ( date instanceof date ) { n simple_date_format sdf_date = new simple_date_format ( codstr ) n date d = ( date ) date n return_value = sdf_date . format ( d ) n } n return return_value n }	1
Q_91	convert a date string into yyyymmdd	C_91_1	public static date get_day ( string string ) { n if ( string = = null ) { n return null n } n date date = null n try { n date = ( new simple_date_format ( codstr ) . parse ( string ) ) n } n catch ( parse_exception ex ) { n return null n } n return date n }	1
Q_91	convert a date string into yyyymmdd	C_91_2	public static string string_to_string ( string date_string , string desfmt ) { n / / iso_date_format = codstr n if ( date_string . trim ( ) . length ( ) = = codint ) { n return string_to_string ( date_string , iso_date_format , desfmt ) n } else if ( date_string . trim ( ) . length ( ) = = codint ) { n / / iso_expanded_date_format = codstr n return string_to_string ( date_string , iso_expanded_date_format , desfmt ) n } else if ( date_string . trim ( ) . length ( ) = = codint ) { n / / datetime_pattern = codstr n return string_to_string ( date_string . substring ( codint , codint ) , n iso_expanded_date_format , desfmt ) n } else if ( date_string . trim ( ) . length ( ) = = codint ) { n / / chinese_expanded_date_format = codstr n return string_to_string ( date_string , chinese_expanded_date_format , n desfmt ) n } n return null n }	1
Q_91	convert a date string into yyyymmdd	C_91_3	override n public string get_request_value ( final request request ) { n if ( is_present ( request ) ) { n / / user entered a valid date n string date_param = request . get_parameter ( get_id ( ) + codstr ) n if ( date_param = = null ) { n return null n } n n / / validate transfer date format _ yyyy _ mm _ dd n if ( date_param . length ( ) = internal_date_total_chars date_param . char_at ( n internal_dash1_pos ) = codstr n date_param . char_at ( internal_dash2_pos ) = codstr ) { n log . warn ( codstr + date_param n + codstr ) n return null n } n n / / transform yyyy _ mm _ dd to yyyymmdd n string_buffer buf = new string_buffer ( date_total_chars ) n buf . append ( date_param . substring ( internal_year_start , internal_year_end ) ) n buf . append ( date_param . substring ( internal_month_start , internal_month_end ) ) n buf . append ( date_param . substring ( internal_day_start , internal_day_end ) ) n n string date_format = buf . to_string ( ) n n / / validate the date n if ( is_valid_partial_date_string_format ( date_format , theme_padding_char ) ) { n log . warn ( codstr n + date_param n + codstr ) n return null n } n n / / convert from theme padding character to the correct padding character n return date_format . replace ( theme_padding_char , get_padding_char	1
Q_91	convert a date string into yyyymmdd	C_91_4	private date to_date ( final string p_string_date ) { n n / / weird manipulation to parse the date . remove codstr from the timezone n / / before codint _ codint _ codint t22 codint number + codint codint n / / after codint _ codint _ codint t22 codint number + codint n final string_builder _date = new string_builder ( ) n _date . append ( p_string_date . substring ( codint , p_string_date . length ( ) _ codint ) ) n _date . append ( p_string_date . substring ( p_string_date . length ( ) _ codint ) ) n try { n return new simple_date_format ( rfc_339_date_format ) . parse ( _date . to_string ( ) ) n } catch ( final parse_exception e ) { n throw new illegal_argument_exception ( n codstr , e ) n } n }	1
Q_91	convert a date string into yyyymmdd	C_91_5	private static date to_date ( string date_string ) { n try { n return new simple_date_format ( local_trend_date_format ) . parse ( date_string ) n } catch ( parse_exception e ) { n return null n } n }	0
Q_92	connect to sql	C_92_0	public void connect_to_postgre_sql_database ( string database , string host , string port , string user , string password , boolean secure , string ca , string crt , string key ) throws sql_exception { n n if ( port . starts_with ( codstr ) ) { n port = port . substring ( codint , port . length ( ) _ codint ) n } n if ( secure ) { n if ( password = = null ) { n password = codstr n } n try { n my_connection = driver_manager . get_connection ( codstr + host + codstr + port + codstr + database , user , password ) n } catch ( sql_exception se ) { n / / log the exception n this . get_logger ( ) . error ( se . get_message ( ) ) n / / re _ throw the exception n throw se n } n n } else { n properties props = new properties ( ) n if ( user = null ) { n props . set_property ( codstr , user ) n } n if ( ca = null ) { n props . set_property ( codstr , ca ) n } n if ( crt = null ) { n props . set_property ( codstr , crt ) n } n if ( key = null ) { n props . set_property ( codstr , key ) n } n props . set_property ( codstr	1
Q_92	connect to sql	C_92_1	private java . sql . connection connect_to_db ( string str_jdbc_driver , string str_jdbcurl , n string str_username , string str_password ) n { n try n { n class . for_name ( str_jdbc_driver ) / / codstr n java . sql . connection conn = n java . sql . driver_manager . get_connection ( str_jdbcurl , n str_username , str_password ) / / codstr , codstr , codstr n return conn n } n catch ( java . sql . sql_exception sql_ex ) n { n java . sql . sql_exception current_sql_ex = sql_ex n system . out . println ( sql_ex . get_error_code ( ) + codstr + sql_ex . get_message ( ) ) n while ( current_sql_ex . get_next_exception ( ) = null ) n { n current_sql_ex = current_sql_ex . get_next_exception ( ) n system . out . println ( sql_ex . get_error_code ( ) + codstr + sql_ex . get_message ( ) ) n } n j_option_pane . show_message_dialog ( main_frame , codstr + sql_ex . get_message ( ) , codstr , j_option_pane . error_message ) n return null n } n catch ( java . lang . class_not_found_exception cl_not_found_ex ) n { n cl_not_found_ex . print_stack_trace ( ) n j_option_pane . show_message_dialog ( main_frame , codstr + cl_not_found_ex . get_message ( ) , codstr , j_option_pane . error_message ) n return null n } n catch ( throwable t ) n { n t . print_stack_trace ( ) n j_option_pane . show_message_dialog ( main_frame	1
Q_92	connect to sql	C_92_2	override n public synchronized db_connect get_db_connect ( ) { n try { n db_connect connect = thread_connect . get ( ) n if ( connect = = null ) { n connect = new druid_connect ( ds . get_connection ( ) ) n logger . info ( codstr , connect ) n thread_connect . set ( connect ) n } else { n if ( connect . get_connect ( ) . is_valid ( codint ) connect . get_connect ( ) . is_closed ( ) ) { n connect = new druid_connect ( ds . get_connection ( ) ) n logger . info ( codstr , connect ) n thread_connect . set ( connect ) n } n } n return connect n } catch ( sql_exception e ) { n logger . error ( e , codstr ) n return null n } n }	1
Q_92	connect to sql	C_92_3	private void restore_connect ( db_connect connect ) { n try { n connect . get_connect ( ) . set_auto_commit ( true ) n connect . get_connect ( ) . set_transaction_isolation ( source . get_config ( ) . get_default_transcation_level ( ) ) n } catch ( sql_exception e ) { n e . print_stack_trace ( ) n } n connects . push ( ( jdbc_connect ) connect ) n }	1
Q_92	connect to sql	C_92_4	public void connect ( string line , dispatch_callback callback ) throws exception { n string example = codstr n + sql_line . get_separator ( ) n n string [ ] parts = sql_line . split ( line ) n if ( parts = = null ) { n callback . set_to_failure ( ) n return n } n n properties connect_props = new properties ( ) n int offset = codint n for ( int i = codint i < parts . length i + + ) { n if ( codstr . equals ( parts [ i ] ) ) { n if ( parts . length _ i > codint ) { n connect_props . set_property ( parts [ i + codint ] , parts [ i + codint ] ) n i = i + codint n offset + = codint n } else { n callback . set_to_failure ( ) n sql_line . error ( example ) n return n } n } n } n if ( parts . length _ offset < codint ) { n callback . set_to_failure ( ) n sql_line . error ( example ) n return n } n n string url = parts . length < offset + codint ? null parts [ offset ] n string user = parts . length < offset + codint ? null parts [ offset + codint ] n string pass = parts . length < offset + codint ? null parts	1
Q_92	connect to sql	C_92_5	override n public synchronized db_connect get_db_connect ( ) { n db_connect connect = thread_connect . get ( ) n if ( connect = = null ) { n connect = use_connect ( ) n thread_connect . set ( connect ) n } n return connect n }	1
Q_92	connect to sql	C_92_6	private object excute_query ( string sql , object [ ] objects , db_connect connect , dao_method dao_method ) throws sql_exception { n if ( dao_method . is_list ( ) ) { n if ( dao_method . is_array ( ) ) { n return silent_go_orm . query_array_list ( connect , sql , dao_method . get_type ( ) , objects ) n } else { n return silent_go_orm . query_list ( connect , sql , dao_method . get_type ( ) , objects ) n } n } else if ( dao_method . is_array ( ) ) { n return silent_go_orm . query_array ( connect , sql , dao_method . get_type ( ) , objects ) n } else { n return silent_go_orm . query ( connect , sql , dao_method . get_type ( ) , objects ) n } n }	0
Q_92	connect to sql	C_92_7	private jdbc_connect use_connect ( ) { n jdbc_connect connect = null n try { n connect = connects . pop ( ) n if ( connect = null ) { n if ( connect . get_end ( ) . get_time ( ) < = new date ( ) . get_time ( ) connect . get_connect ( ) . is_valid ( codint ) ) { n connect . close ( ) n connect = null n } n } n } catch ( empty_stack_exception sql_exception e ) { n connect = null n / / try create connect n create_connect ( ) n } n return connect = = null ? use_connect ( ) connect n }	0
Q_93	confusion matrix	C_93_0	public static confusion_matrix create_cumulative_matrix ( confusion_matrix . matrices ) n { n confusion_matrix result = new confusion_matrix ( ) n n for ( confusion_matrix matrix matrices ) { n for ( map . entry < string , map < string , integer gold matrix . map . entry_set ( ) ) { n for ( map . entry < string , integer > actual gold . get_value ( ) . entry_set ( ) ) { n result . increase_value ( gold . get_key ( ) , actual . get_key ( ) , actual . get_value ( ) ) n } n } n } n n return result n }	1
Q_93	confusion matrix	C_93_1	private void make_confusion_matrix ( map < string , string > actual , map < string , string > predicted ) { n confusion = new int [ categories . size ( ) ] [ categories . size ( ) ] n for ( string k predicted . key_set ( ) ) { n for ( int i = codint i < categories . size ( ) + + i ) { n string ci = categories . get ( i ) n for ( int j = codint j < categories . size ( ) + + j ) { n string cj = categories . get ( j ) n if ( ci . equals ( actual . get ( k ) ) cj . equals ( predicted . get ( k ) ) ) { n confusion [ i ] [ j ] + + n } n } n } n } n }	1
Q_93	confusion matrix	C_93_2	private string stats ( boolean suppress_warnings , boolean include_confusion , boolean log_confusion_size_warning ) { n string actual , predicted n string_builder builder = new string_builder ( ) . append ( codstr ) n string_builder warnings = new string_builder ( ) n confusion_matrix < integer > confusion = confusion ( ) n if ( confusion = = null ) { n confusion = new confusion_matrix < > ( ) / / empty n } n list < integer > classes = confusion . get_classes ( ) n n list < integer > false_positives_warning_classes = new array_list < > ( ) n list < integer > false_negatives_warning_classes = new array_list < > ( ) n for ( integer clazz classes ) { n / / output possible warnings regarding precision / recall calculation n if ( suppress_warnings true_positives . get_count ( clazz ) = = codint ) { n if ( false_positives . get_count ( clazz ) = = codint ) { n false_positives_warning_classes . add ( clazz ) n } n if ( false_negatives . get_count ( clazz ) = = codint ) { n false_negatives_warning_classes . add ( clazz ) n } n } n } n n if ( false_positives_warning_classes . is_empty ( ) ) { n warning_helper ( warnings , false_positives_warning_classes , codstr ) n } n if ( false_negatives_warning_classes . is_empty ( ) ) { n warning_helper ( warnings , false_negatives_warning_classes , codstr ) n } n n int n_classes = confusion . get_classes ( )	1
Q_93	confusion matrix	C_93_3	protected void print_general_confusion_table ( ) { n print_header ( codstr ) n n sorted_set < string > labels = get_confusion_matrix_tagset ( ) n n double [ ] [ ] confusion_matrix = get_confusion_matrix ( ) n n print_stream . append ( codstr ) n int line = codint n for ( string label labels ) { n if ( confusion_matrix [ line ] [ confusion_matrix [ codint ] . length _ codint ] = = codint ) { n print_stream . append ( label ) . append ( codstr ) n . append ( integer . to_string ( ( int ) confusion_matrix [ line ] [ line ] ) ) n . append ( codstr ) n } n line + + n } n n print_stream . append ( codstr ) n n print_stream . append ( matrix_to_string ( labels , confusion_matrix , true ) ) n n print_footer ( codstr ) n }	1
Q_93	confusion matrix	C_93_4	public matrix predict_one ( matrix input ) { n / / transpose and add bias unit n / / matrix input_with_bias = matrix . zeros ( input . get_column_count ( ) + codint , n / / input . get_row_count ( ) ) n / / for ( long i = input . get_column_count ( ) _ codint i = _ codint i _ ) { n / / input_with_bias . set_double ( input . get_double ( codint , i ) , i , codint ) n / / } n / / input_with_bias . set_double ( number , input_with_bias . get_row_count ( ) _ codint , codint ) n add_input_matrix ( input ) n n for ( network_layer network_layer get_network_layer_list ( ) ) { n network_layer . calculate_forward ( ) n } n n matrix actual_output = get_output_matrix ( ) . transpose ( ) n return actual_output n }	0
Q_93	confusion matrix	C_93_5	public confusion_matrix get_transposed_matrix ( ) n { n confusion_matrix result = new confusion_matrix ( ) n n for ( map . entry < string , map < string , integer gold this . map . entry_set ( ) ) { n for ( map . entry < string , integer > predicted gold . get_value ( ) . entry_set ( ) ) { n int value = predicted . get_value ( ) n n / / add reverted values n result . increase_value ( predicted . get_key ( ) , gold . get_key ( ) , value ) n } n } n n return result n }	0
Q_94	concatenate several file remove header line	C_94_0	public static void concatenate ( list < file > files , file concatenated_file ) { n n buffered_writer writer n try { n writer = new buffered_writer ( new output_stream_writer ( new file_output_stream ( concatenated_file . get_absolute_file ( ) , n false ) , data_util_defaults . char_set ) ) n n file_input_stream input_stream n for ( file input files ) { n input_stream = new file_input_stream ( input ) n buffered_reader reader = new buffered_reader ( new input_stream_reader ( input_stream , codstr ) ) n string line n while ( ( line = reader . read_line ( ) ) = null ) { n writer . write ( line + data_util_defaults . line_terminator ) n } n input_stream . close ( ) n } n writer . flush ( ) n writer . close ( ) n } catch ( unsupported_encoding_exception e ) { n throw new data_util_exception ( e ) n } catch ( file_not_found_exception e ) { n throw new data_util_exception ( e ) n } catch ( io_exception e ) { n throw new data_util_exception ( e ) n } n }	1
Q_94	concatenate several file remove header line	C_94_1	protected string read_file ( file file , list < string > lines ) { n int i n n try { n lines . add_all ( files . read_all_lines ( file . to_path ( ) ) ) n i = codint n while ( i < lines . size ( ) ) { n if ( lines . get ( i ) . trim ( ) . is_empty ( ) ) { n lines . remove ( i ) n continue n } n if ( lines . get ( i ) . starts_with ( codstr ) ) { n lines . remove ( i ) n continue n } n i + + n } n } n catch ( exception e ) { n return codstr + file + codstr + e n } n n return null n }	1
Q_94	concatenate several file remove header line	C_94_2	private string multi_line_string ( string [ ] lines ) n { n string_builder sb = new string_builder ( ) n if ( lines = null lines . length > codint ) n { n sb . append ( lines [ codint ] ) n for ( int i = codint i < lines . length i + + ) n { n sb . append ( codstr ) n sb . append ( lines [ i ] ) n } n } n return sb . to_string ( ) n }	1
Q_94	concatenate several file remove header line	C_94_3	private list < string > file_to_lines ( file file ) throws io_exception { n final list < string > lines = new array_list < string > ( ) n string line n final buffered_reader in = new buffered_reader ( new file_reader ( file ) ) n while ( ( line = in . read_line ( ) ) = null ) { n lines . add ( line ) n } n n return lines n }	0
Q_94	concatenate several file remove header line	C_94_4	public static string concat_file_path ( boolean _include_trailing_delimiter , string . _parts ) { n if ( _parts = = null ) { n return null n } n string_builder all_parts = new string_builder ( ) n n for ( int i = codint i < _parts . length i + + ) { n if ( _parts [ i ] = = null ) { n continue n } n all_parts . append ( _parts [ i ] ) n n if ( _parts [ i ] . ends_with ( file . separator ) ) { n all_parts . append ( file . separator ) n } n } n n if ( _include_trailing_delimiter all_parts . length ( ) > codint ) { n return all_parts . substring ( codint , all_parts . last_index_of ( file . separator ) ) n } n n return all_parts . to_string ( ) n }	0
Q_94	concatenate several file remove header line	C_94_5	int restore_file ( string file_location ) { n int exit_code = codint n n file file = new file ( file_location ) n buffered_reader reader = null n file_writer writer = null n try { n reader = new buffered_reader ( new file_reader ( file ) ) n string file_line n list < string > lines = new linked_list < string > ( ) n n while ( ( file_line = reader . read_line ( ) ) = null ) { n if ( file_line . trim ( ) . starts_with ( comment ) ) { n lines . add ( file_line . substring ( comment . length ( ) ) ) n continue n } else if ( file_line . trim ( ) . ends_with ( comment ) ) { n continue n } n lines . add ( file_line ) n } n n writer = new file_writer ( file ) n for ( string line lines ) { n writer . write ( line ) n writer . write ( codstr ) n } n } catch ( io_exception ex ) { n exit_code = codint n } finally { n try { n if ( reader = null ) { n reader . close ( ) n } n if ( writer = null ) { n writer . close ( ) n } n } catch ( io_exception ioex ) { n / / we did all we could to close n } n	0
Q_94	concatenate several file remove header line	C_94_6	public stream < string [ ] > lines ( ) throws io_exception { n return files . lines ( path ) n . map ( line _ > line . contains ( codstr ) ? line . substring ( codint , line . index_of ( codstr ) ) line ) n . map ( line _ > line . trim ( ) ) n . filter ( line _ > line . is_empty ( ) ) n . map ( line _ > { n list < string > list = arrays . stream ( line . split ( codstr ) ) . map ( col _ > col . trim ( ) ) . collect ( collectors . to_list ( ) ) n return list . to_array ( new string [ list . size ( ) ] ) n } ) n . filter ( line _ > { n if ( line . length < codint ) { n logger . warn ( codstr , joiner . on ( codstr ) . join ( line ) , line . length ) n return false n } else n return true n } ) n . map ( line _ > { n if ( line . length > codint ) { n logger . warn ( codstr , joiner . on ( codstr ) . join ( line ) , line . length ) n return new string [ ] { line [ codint ] , line	0
Q_94	concatenate several file remove header line	C_94_7	public void replace_files_with_new_content ( list < string > lines , file file ) throws io_exception { n buffered_writer out = new buffered_writer ( new file_writer ( file ) ) n for ( int i = codint i < lines . size ( ) i + + ) { n out . write ( lines . get ( i ) ) n out . new_line ( ) n } n out . close ( ) n }	0
Q_95	buffer file reader read text	C_95_0	public string_buffer append ( reader source , string_buffer buffer ) throws io_exception n { n buffered_reader _buffered_reader = new buffered_reader ( source ) n char [ ] _buffer = new char [ get_buffer_size ( ) ] / / load by chunk of codint ko n try n { n for ( int _count_read_chars = codint _count_read_chars > = codint ) n { n buffer . append ( _buffer , codint , _count_read_chars ) n _count_read_chars = _buffered_reader . read ( _buffer ) n } n } n finally n { n _buffered_reader . close ( ) n } n return buffer n }	1
Q_95	buffer file reader read text	C_95_1	public static string get_text ( reader reader ) throws io_exception { n buffered_reader buffered_reader = new buffered_reader ( reader ) n return get_text ( buffered_reader ) n }	1
Q_95	buffer file reader read text	C_95_2	private static string read_text_file ( buffered_reader reader ) { n string_builder text = new string_builder ( ) n n try { n char [ ] buffer = new char [ codint ] / / default buffered_reader size n int read n while ( ( read = reader . read ( buffer ) ) > = codint ) { n if ( read > codint ) { n text . append ( buffer , codint , read ) n } n } n } catch ( io_exception e ) { n e . print_stack_trace ( ) n return null n } finally { n try { n reader . close ( ) n } catch ( io_exception e ) { n e . print_stack_trace ( ) n } n } n n return text . to_string ( ) n }	1
Q_95	buffer file reader read text	C_95_3	public static string read_text_file ( file file ) throws io_exception n { n / / create reader to file ( with default encoding ) n input_stream input_stream = new file_input_stream ( file ) n reader reader = io_helper . create_reader ( input_stream , null ) n n / / read text n string text = io_helper . read_text_stream ( reader ) n n return text n }	1
Q_95	buffer file reader read text	C_95_4	static public string n readtextfile ( reader rdr ) n throws io_exception n { n string_builder buf = new string_builder ( ) n for ( ) { n int c = rdr . read ( ) n if ( c < codint ) break n buf . append ( ( char ) c ) n } n return buf . to_string ( ) n }	1
Q_95	buffer file reader read text	C_95_5	public text read ( ) throws io_exception { n if ( this . m_current_reader = = null ) { n update_reader ( ) n } n text ret = this . m_current_reader . read ( ) n if ( ret = null ) n return ret n n this . m_current_index + + n if ( this . m_current_index < this . m_files . size ( ) ) { n this . update_reader ( ) n return read ( ) n } n n return null n }	0
Q_95	buffer file reader read text	C_95_6	override n public final input_stream read ( file file ) throws lowlevel_storage_exception { n / / buffered reader ? n file_input_stream file_input_stream = null n { n if ( file . exists ( ) ) { n throw new lowlevel_storage_exception ( true , codstr n + get_path ( file ) + codstr t exist for reading codstr file codstr not readable codstr file codstr couldn codstr , n e_caught_open_file ) n } n } n return file_input_stream n }	0
Q_95	buffer file reader read text	C_95_7	private void read_inner_text ( unprotected_string_buffer inner_text , async_work < unprotected_string_buffer , exception > result ) { n i_synchronization_point < exception > next = next ( ) n do { n if ( next . is_unblocked ( ) ) { n if ( check ( next , result ) ) return n if ( type . comment . equals ( event . type ) ) { n next = next ( ) n continue n } n if ( type . text . equals ( event . type ) ) { n inner_text . append ( event . text ) n next = next ( ) n continue n } n if ( type . start_element . equals ( event . type ) ) { n if ( event . is_closed ) { n next = next ( ) n continue n } n close_element ( ) . listen_async ( new parsing_task ( ( ) _ > { n read_inner_text ( inner_text , result ) n } ) , result ) n return n } n if ( type . end_element . equals ( event . type ) ) { n result . unblock_success ( inner_text ) n return n } n next = next ( ) n continue n } n break n } while ( true ) n next . listen_inline ( ( ) _ > { n if ( type . start_element . equals ( event . type ) ) { n if ( event . is_closed	0
Q_96	binomial distribution	C_96_0	public static long bin_coeff ( int n , int k ) { n if ( k > n ) { n return codint n } n if ( k = = codint k = = n ) { n return codint n } n long result = codint n for ( int i = codint i < = k i + + ) { n result * = ( n _ i + codint ) / i n } n return result n }	1
Q_96	binomial distribution	C_96_1	"public static double binomial ( int k , double p , int n ) { n if ( k < codint p < codint n < codint ) { n throw new illegal_argument_exception ( codstr ) n } n n k = math . min ( k , n ) n n / * n / / slow and can "" t handle large numbers n probability = stats_utilities combination ( n , k ) * pow ( p , k ) * pow ( codint _ p , n _ k ) n * / n n / / fast and can handle large numbers n / / cdf ( k ) _ cdf ( k _ codint ) n double probability = approx_binomial_cdf ( k , p , n ) n if ( k > codint ) { n probability _ = approx_binomial_cdf ( k _ codint , p , n ) n } n n return probability n }"	1
Q_96	binomial distribution	C_96_2	override n public distribution deserialize ( json_parser jp , deserialization_context deserialization_context ) n throws io_exception , json_processing_exception { n / / manually parse old format n json_node node = jp . get_codec ( ) . read_tree ( jp ) n n if ( node . has ( codstr ) ) { n json_node n = node . get ( codstr ) n if ( n . has ( codstr ) n . has ( codstr ) ) { n throw new json_parse_exception ( codstr normal codstr n + codstr mean codstr std codstr , jp . get_current_location ( ) ) n } n double m = n . get ( codstr ) . as_double ( ) n double s = n . get ( codstr ) . as_double ( ) n return new normal_distribution ( m , s ) n } else if ( node . has ( codstr ) ) { n json_node n = node . get ( codstr ) n if ( n . has ( codstr ) n . has ( codstr ) ) { n throw new json_parse_exception ( codstr gaussian codstr n + codstr mean codstr std codstr , jp . get_current_location ( ) ) n } n double m = n . get ( codstr ) . as_double ( ) n double s = n . get ( codstr ) . as_double ( ) n return new gaussian_distribution ( m , s ) n n } else if ( node . has	1
Q_96	binomial distribution	C_96_3	public static boolean distribution_equals ( integer_distribution a , integer_distribution b ) { n if ( a . get_class ( ) = b . get_class ( ) ) n return false n class < ? > c = a . get_class ( ) n n if ( c = = binomial_distribution . class ) { n binomial_distribution ba = ( binomial_distribution ) a n binomial_distribution bb = ( binomial_distribution ) b n return ba . get_number_of_trials ( ) = = bb . get_number_of_trials ( ) n ba . get_probability_of_success ( ) = = bb . get_probability_of_success ( ) n } else if ( c = = geometric_distribution . class ) { n geometric_distribution ga = ( geometric_distribution ) a n geometric_distribution gb = ( geometric_distribution ) b n return ga . get_probability_of_success ( ) = = gb . get_probability_of_success ( ) n } else if ( c = = hypergeometric_distribution . class ) { n hypergeometric_distribution ha = ( hypergeometric_distribution ) a n hypergeometric_distribution hb = ( hypergeometric_distribution ) b n return ha . get_population_size ( ) = = hb . get_population_size ( ) n ha . get_number_of_successes ( ) = = hb . get_number_of_successes ( ) n ha . get_sample_size ( ) = = hb . get_sample_size ( ) n } else if ( c = = pascal_distribution . class ) { n pascal_distribution pa = ( pascal_distribution ) a n pascal_distribution pb = ( pascal_distribution ) b n return pa . get_number_of_successes ( ) = = pb .	1
Q_96	binomial distribution	C_96_4	static n public double probability ( continuous_distribution distribution , number x ) { n n if ( distribution instanceof gaussian_distribution ) { n return probability ( ( gaussian_distribution ) distribution , x ) n } else n n if ( distribution instanceof poisson_distribution ) { n return probability ( ( poisson_distribution ) distribution , x ) n } n n throw new unsupported_element_exception ( distribution ) n }	1
Q_96	binomial distribution	C_96_5	private static double score_to_pvalue ( double score , int n , double p ) { n / * n if ( n < = codint ) { n / / calculate it from binomial distribution n } n * / n n double z = ( score + number _ n * p ) / math . sqrt ( n * p * ( number _ p ) ) n n return continuous_distributions . gauss_cdf ( z ) n }	0
Q_97	all permutation of a list	C_97_0	public static < t > collection < list < t permutations ( collection < t > elements ) { n collection < list < t result = new array_list < > ( ) n if ( elements . is_empty ( ) ) { n result . add ( new linked_list < > ( ) ) n return result n } n n list < t > rest = new linked_list < > ( elements ) n t head = rest . remove ( codint ) n for ( list < t > permutations permutations ( rest ) ) { n list < list < t sub_lists = new array_list < > ( ) n for ( int i = codint i < = permutations . size ( ) i + + ) { n list < t > sub_list = new array_list < > ( ) n sub_list . add_all ( permutations ) n sub_list . add ( i , head ) n sub_lists . add ( sub_list ) n } n result . add_all ( sub_lists ) n } n return result n }	1
Q_97	all permutation of a list	C_97_1	public void complete_group ( ) { n / / copy initial set to allow permutations to grow n list < list < integer gens = new array_list < list < integer ( permutations ) n / / keep hash_set version of permutations for fast lookup . n set < list < integer known = new hash_set < list < integer ( permutations ) n / / breadth _ first search through the map of all members n list < list < integer current_level = new array_list < list < integer ( permutations ) n while ( current_level . size ( ) > codint ) { n list < list < integer next_level = new array_list < list < integer ( ) n for ( list < integer > p current_level ) { n for ( list < integer > gen gens ) { n list < integer > y = combine ( p , gen ) n if ( known . contains ( y ) ) { n next_level . add ( y ) n / / bypass add_permutation ( y ) for performance n permutations . add ( y ) n known . add ( y ) n } n } n } n current_level = next_level n } n }	1
Q_97	all permutation of a list	C_97_2	public list < permutation > all ( ) { n final list < permutation > permutations = new array_list < permutation > ( ) n backtracker counter = new backtracker ( ) { n n override n public void apply_to ( permutation p ) { n permutations . add ( p ) n } n n override n public boolean is_finished ( ) { n return false n } n } n this . apply ( counter ) n return permutations n }	1
Q_97	all permutation of a list	C_97_3	private void solve ( ) { n initialize ( ) n int n = subunits . get_subunit_count ( ) n permutation_generator g = new permutation_generator ( n ) n n / / loop over all permutations n while ( g . has_more ( ) ) { n int [ ] perm = g . get_next ( ) n list < integer > permutation = new array_list < integer > ( perm . length ) n for ( int j = codint j < n j + + ) { n permutation . add ( perm [ j ] ) n } n n if ( is_valid_permutation ( permutation ) ) { n continue n } n n boolean new_permutation = evaluate_permutation ( permutation ) n if ( new_permutation ) { n complete_rotation_group ( ) n } n n if ( rotations . get_order ( ) > = subunits . get_subunit_count ( ) ) { n return n } n } n }	1
Q_97	all permutation of a list	C_97_4	public permutation multiply ( permutation other ) { n permutation new_permutation = new permutation ( values . length ) n for ( int i = codint i < values . length i + + ) { n new_permutation . values [ i ] = this . values [ other . values [ i ] ] n } n return new_permutation n }	0
Q_97	all permutation of a list	C_97_5	public void add_permutation ( list < integer > permutation ) { n if ( permutations . contains ( permutation ) ) { n permutations . add ( permutation ) n } n }	0
Q_97	all permutation of a list	C_97_6	public void remove_permutations ( list < integer > removed ) { n n int [ ] permutations = new int [ this . permutations . length ] n n int index = codint n permutations n for ( int j this . permutations ) { n for ( int i = codint i < removed . size ( ) i + + ) { n if ( removed . get ( i ) = = j ) { n / / skip this n removed . remove ( i ) n n continue permutations n } n } n n permutations [ index ] = j n n index + + n } n n int [ ] effective_permutations = new int [ index ] n system . arraycopy ( permutations , codint , effective_permutations , codint , index ) n n this . rotations = new int [ permutations . length ] n this . reset = new int [ permutations . length ] n this . permutations = effective_permutations n arrays . sort ( permutations ) / / ascending order to make the permutation logic work n }	0
Q_97	all permutation of a list	C_97_7	public list < t > next_permutation_as_list ( ) n { n list < t > permutation = new array_list < t > ( elements . length ) n return next_permutation_as_list ( permutation ) n }	0
Q_98	aes encryption	C_98_0	public void do_aes_encryption ( ) throws exception { n if ( init_aes_done ) n init_aes ( ) n cipher = cipher . get_instance ( codstr ) n / / system . out . println ( secret_key . get_encoded ( ) ) n cipher . init ( cipher . encrypt_mode , secret_key ) n algorithm_parameters params = cipher . get_parameters ( ) n iv = params . get_parameter_spec ( iv_parameter_spec . class ) . get_iv ( ) n secret_cipher = cipher . do_final ( secret_plain ) n clear_plain ( ) n }	1
Q_98	aes encryption	C_98_1	private byte [ ] aes_encrypt ( byte [ ] encryption_key , byte [ ] iv , byte [ ] message ) n throws no_such_algorithm_exception , no_such_padding_exception , invalid_key_exception , n invalid_algorithm_parameter_exception , illegal_block_size_exception , bad_padding_exception { n n cipher cipher = cipher . get_instance ( aes_cfb_no_padding_algorithm ) n cipher . init ( cipher . encrypt_mode , new secret_key_spec ( encryption_key , symmetric_key_type ) , new iv_parameter_spec ( iv ) ) n return cipher . do_final ( message ) n }	1
Q_98	aes encryption	C_98_2	public boolean test_encryption ( ) { n / / uses test data in rfc3711 to test encryption n boolean ret = true n roll_over_counter = codint n byte [ ] sess_key = { ( byte ) codint , ( byte ) codint , ( byte ) codint , ( byte ) codint , n ( byte ) codint , ( byte ) codint , ( byte ) codint , ( byte ) codint , n ( byte ) codint , ( byte ) codint , ( byte ) codint , ( byte ) codint , n ( byte ) codint , ( byte ) codint , ( byte ) codint , ( byte ) codint } n byte [ ] sess_salt = { ( byte ) codint , ( byte ) codint , ( byte ) codint , ( byte ) codint , n ( byte ) codint , ( byte ) codint , ( byte ) codint , ( byte ) codint , n ( byte ) codint , ( byte ) codint , ( byte ) codint , ( byte ) codint , n ( byte ) codint , ( byte ) codint } n n byte [ ] iv = new byte [ codint ] n initialise_iv ( iv , codint , codint , codint , sess_salt ) n byte [ ] out_array = null n try { n / / aes_key key = new aes_key ( sess_key ) n / / aes_encryptor_engine engine = new	1
Q_98	aes encryption	C_98_3	public static byte [ ] decrypt_aes ( secret_key key , byte [ ] iv , byte [ ] encrypted_bytes ) throws n no_such_padding_exception , no_such_algorithm_exception , invalid_algorithm_parameter_exception , n invalid_key_exception , bad_padding_exception , illegal_block_size_exception { n cipher aes_cipher = cipher . get_instance ( codstr ) n iv_parameter_spec iv_parameter = new iv_parameter_spec ( iv ) n / / see http / / stackoverflow . com / a / codint n key encryption_key = new secret_key_spec ( key . get_encoded ( ) , codstr ) n aes_cipher . init ( cipher . decrypt_mode , encryption_key , iv_parameter ) n return aes_cipher . do_final ( encrypted_bytes ) n }	1
Q_98	aes encryption	C_98_4	private byte [ ] do_encryption_or_decryption ( byte [ ] crypt , key key , int mode ) { n cipher rsa_cipher n try { n rsa_cipher = cipher . get_instance ( cipher ) n } catch ( no_such_algorithm_exception no_such_padding_exception e ) { n throw seed_exception . wrap ( e , crypto_error_code . unable_to_get_cipher ) n . put ( codstr , alias ) n . put ( codstr , cipher ) n } n try { n rsa_cipher . init ( mode , key ) n } catch ( invalid_key_exception e ) { n throw seed_exception . wrap ( e , crypto_error_code . invalid_key ) n . put ( codstr , alias ) n } n try { n return rsa_cipher . do_final ( crypt ) n } catch ( illegal_block_size_exception bad_padding_exception e ) { n throw seed_exception . wrap ( e , crypto_error_code . unexpected_exception ) n } n }	0
Q_98	aes encryption	C_98_5	private byte [ ] aes_decrypt ( byte [ ] encryption_key , byte [ ] iv , byte [ ] encrypted_message ) n throws no_such_algorithm_exception , no_such_padding_exception , invalid_key_exception , n invalid_algorithm_parameter_exception , illegal_block_size_exception , bad_padding_exception { n n cipher cipher = cipher . get_instance ( aes_cfb_no_padding_algorithm ) n cipher . init ( cipher . decrypt_mode , new secret_key_spec ( encryption_key , symmetric_key_type ) , new iv_parameter_spec ( iv ) ) n return cipher . do_final ( encrypted_message ) n n }	0
Q_98	aes encryption	C_98_6	cipher create_encryption_cipher ( byte [ ] key ) throws cifs_exception { n if ( this . smb2 this . negotiated = = null ) { n throw new smb_unsupported_operation_exception ( ) n } n n smb2_negotiate_response resp = ( smb2_negotiate_response ) this . negotiated n int cipher_id = _ codint n n if ( resp . get_selected_dialect ( ) . at_least ( dialect_version . smb311 ) ) { n cipher_id = resp . get_selected_cipher ( ) n } n else if ( resp . get_selected_dialect ( ) . at_least ( dialect_version . smb300 ) ) { n cipher_id = encryption_negotiate_context . cipher_aes128_ccm n } n else { n throw new smb_unsupported_operation_exception ( ) n } n n switch ( cipher_id ) { n case encryption_negotiate_context . cipher_aes128_ccm n case encryption_negotiate_context . cipher_aes128_gcm n default n throw new smb_unsupported_operation_exception ( ) n } n }	0

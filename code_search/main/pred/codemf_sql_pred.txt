Q_0	possible to do a my_sql foreign key to one of two possible table	C_0_0	create col0 popular_places ( col1 int not null , col2 int not null , col3 varchar ( codint ) _ col4 refre or refre _ foreign key is not col5 )	1
Q_0	possible to do a my_sql foreign key to one of two possible table	C_0_1	create col0 popular_states ( col1 int not null , col2 int not null , primary key ( col1 , col2 ) , foreign key ( col1 ) references states ( col1 ) , foreign key ( col2 ) references users ( col2 ) , ) create col0 popular_countries ( col3 int not null , col2 int not null , primary key ( col3 , col2 ) , foreign key ( col3 ) references countries ( col3 ) , foreign key ( col2 ) references users ( col2 ) , )	0
Q_0	possible to do a my_sql foreign key to one of two possible table	C_0_2	create col0 popular_areas ( col1 int not null , col2 int not null , primary key ( col1 , col2 ) , foreign key ( col2 ) references places ( col2 ) ) create col0 states ( col3 int not null primary key , foreign key ( col3 ) references places ( col2 ) ) create col0 countries ( col4 int not null primary key , foreign key ( col4 ) references places ( col2 ) )	0
Q_0	possible to do a my_sql foreign key to one of two possible table	C_0_3	create col0 popular_areas ( col1 serial primary key , col2 int not null , col3 int , col4 int , constraint unique ( col2 , col3 , col4 ) , _ unique col5 col6 constraint check ( col3 is not null or col4 is not null ) , foreign key ( col3 ) references places ( col1 ) , foreign key ( col4 ) references places ( col1 ) )	0
Q_0	possible to do a my_sql foreign key to one of two possible table	C_0_4	create col0 products ( col1 int primary key ) create col0 filterstype1 ( col2 int primary key , col1 int not null , foreign key ( col1 ) references products ( col1 ) ) create col0 filterstype2 ( col2 int primary key , col1 int not null , foreign key ( col1 ) references products ( col1 ) ) . and col3 col4 tab0 .	0
Q_0	possible to do a my_sql foreign key to one of two possible table	C_0_5	select * from col0 inner join col1 using ( col2 )	0
Q_0	possible to do a my_sql foreign key to one of two possible table	C_0_6	select * from col0 left outer join col1 using ( col2 ) left outer join col3 using ( col2 ) left outer join col4 using ( col2 ) .	0
Q_0	possible to do a my_sql foreign key to one of two possible table	C_0_7	select * from col0 inner join col1 using ( col2 ) union all select * from col3 inner join col4 using ( col2 ) union all select * from col3 inner join col5 using ( col2 ) .	0
Q_1	linq to sql _ grouping by hour	C_1_0	col0 col1 = tab0 . tab1 . groupby ( col2 = > tab2 . tab3 . hour ) . select ( col3 = > new { hour = tab4 . key , col4 = tab4 . sum ( col2 = > tab2 . col5 ) } )	1
Q_1	linq to sql _ grouping by hour	C_1_1	select sum ( tab0 . col0 ) as col1 , tab0 . col2 as col3 from ( select datepart ( hour , tab1 . col4 ) as col2 , tab1 . col0 from tab2 . col5 as col6 ) as col7 group by tab0 . col2	0
Q_1	linq to sql _ grouping by hour	C_1_2	col0 col1 = new datetime ( codint , codint , codint ) col2 col3 = tab0 . tab1 . groupby ( col4 = > tab2 . tab3 . tab4 . tab5 . tab6 . datediffhour ( col1 , tab7 . col5 ) ) . select ( col6 = > new { col7 = tab8 . key , col8 = tab8 . sum ( col4 = > tab7 . col9 ) } ) . select ( col4 = > new { hour = tab9 . addhours ( tab7 . col7 ) , col8 = tab7 . col8 } )	0
Q_1	linq to sql _ grouping by hour	C_1_3	select dateadd ( col0 , ( convert ( bigint , ( convert ( float , tab0 . col1 ) ) * codint ) ) codint , dateadd ( col2 , ( convert ( bigint , ( convert ( float , tab0 . col1 ) ) * codint ) ) / codint , col3 ) ) as col4 , tab0 . col5 as col6 from ( select sum ( tab1 . col7 ) as col5 , tab1 . col5 as col1 from ( select datediff ( hour , col8 , tab2 . col9 ) as col5 , tab2 . col7 from tab3 . col10 as col11 ) as col12 group by tab1 . col5 ) as col13	0
Q_1	linq to sql _ grouping by hour	C_1_4	col0 col1 = tab0 . tab1 . groupby ( col2 = > tab2 . tab3 . tab4 . tab5 . tab6 . datediffhour ( col3 , tab7 . col4 ) ) . select ( col5 = > new { col6 = tab8 . key , col7 = tab8 . sum ( col2 = > tab7 . col8 ) } ) . tolist ( ) . select ( col2 = > new { hour = tab9 . addhours ( tab7 . col6 ) , col7 = tab7 . col7 } )	0
Q_1	linq to sql _ grouping by hour	C_1_5	select sum ( tab0 . col0 ) as col1 , tab0 . col2 as col3 from ( select datediff ( hour , col4 , tab1 . col5 ) as col2 , tab1 . col0 from tab2 . col6 as col7 ) as col8 group by tab0 . col2	0
Q_1	linq to sql _ grouping by hour	C_1_6	col0 col1 = tab0 . tab1 . groupby ( col2 = > new datetime ( tab2 . tab3 . col3 , tab2 . tab3 . month , tab2 . tab3 . col4 , tab2 . tab3 . hour , codint , codint ) ) . select ( col5 = > new { hour = tab4 . key , col6 = tab4 . sum ( col2 = > tab2 . col7 ) } )	0
Q_1	linq to sql _ grouping by hour	C_1_7	select sum ( tab0 . col0 ) as col1 , tab0 . col2 as col3 from ( select convert ( col4 , ( convert ( nchar ( codint ) , datepart ( col5 , tab1 . col6 ) ) + ( refre + ( convert ( nchar ( codint ) , datepart ( month , tab1 . col6 ) ) + ( refre + convert ( nchar ( codint ) , datepart ( col7 , tab1 . col6 ) ) ) ) ) ) + ( refre + ( convert ( nchar ( codint ) , datepart ( hour , tab1 . col6 ) ) + ( refre + ( convert ( nchar ( codint ) , col8 ) + ( refre + convert ( nchar ( codint ) , col9 ) ) ) ) ) ) , codint ) as col2 , tab1 . col0 from tab2 . col10 as col11 ) as col12 group by tab0 . col2	0
Q_2	how to randomly select row in sql	C_2_0	select col0 codint col1 , col2 from col3 order by newid ( )	1
Q_2	how to randomly select row in sql	C_2_1	select column from col0 order by rand ( ) limit codint	0
Q_2	how to randomly select row in sql	C_2_2	select column from col0 order by random ( ) limit codint	0
Q_2	how to randomly select row in sql	C_2_3	select col0 codint column from col1 order by newid ( )	0
Q_2	how to randomly select row in sql	C_2_4	select column , rand ( ) as col0 from col1 order by col0 fetch first codint rows only	0
Q_2	how to randomly select row in sql	C_2_5	select column from ( select column from col0 order by tab0 . col1 ) where rownum = codint	0
Q_2	how to randomly select row in sql	C_2_6	select column from col0 order by random ( ) limit codint	0
Q_3	sql_alchemy _ dictionary of tag	C_3_0	from col0 col1 column , integer , col2 , col3 , col4 from col0 col1 col5 , col6 , column , col7 from tab0 . col5 col1 col8 , col9 , col10 from tab0 . tab1 . col11 col1 col12 from tab0 . tab2 . col13 col1 col14	1
Q_3	sql_alchemy _ dictionary of tag	C_3_1	engine = create_engine ( refre refre refre refre , col0 = true ) col1 = metadata ( col2 = engine )	0
Q_3	sql_alchemy _ dictionary of tag	C_3_2	col0 = table1 ( refre , col1 , column ( refre , integer , col2 = true ) , column ( refre , string ( codint ) ) , column ( refre , string ( codint ) ) , ) col3 = table1 ( refre , col1 , column ( refre , integer , foreignkey ( refre ) , col2 = true ) , column ( refre , string ( codint ) , col2 = true ) , column ( refre , string ( codint ) ) , ) tab0 . create_all ( )	0
Q_3	sql_alchemy _ dictionary of tag	C_3_3	class note ( object ) col0 _init_ ( self , col1 , col2 ) tab0 . col1 = col1 tab0 . col2 = col2 class item ( object ) col0 _init_ ( self , col1 , col3 = refre ) tab0 . col1 = col1 tab0 . col3 = col3 col4 = association_proxy ( refre , refre , col5 = col6 )	0
Q_3	sql_alchemy _ dictionary of tag	C_3_4	mapper ( col0 , col1 ) mapper ( col2 , col3 , col4 = { refre relation ( col0 , col5 = column_mapped_collection ( tab0 . tab1 . col6 ) ) , } )	0
Q_3	sql_alchemy _ dictionary of tag	C_3_5	session = sessionmaker ( col0 = engine ) col1 = session ( ) col2 = item ( refre , refre ) tab0 . col3 col4 = refre tab0 . col3 col5 = refre tab0 . col3 col6 = refre tab1 . add ( col2 ) tab1 . commit ( ) print tab0 . col3	0
Q_3	sql_alchemy _ dictionary of tag	C_3_6	{ col0 refre col0 refre , col0 refre col0 refre , col0 refre col0 refre }	0
Q_3	sql_alchemy _ dictionary of tag	C_3_7	print list ( tab0 . select ( ) . execute ( ) ) col0	0
Q_4	be it possible to add a logic constraint to a foreign key	C_4_0	create col0 tab0 . numbers ( col1 int not null primary key ) go declare col2 int set col2 = codint insert into tab0 . numbers ( col1 ) select codint while col2 < codint begin insert into tab0 . numbers ( col1 ) select col1 + col2 from tab0 . col3 set col2 = col2 * codint end go	1
Q_4	be it possible to add a logic constraint to a foreign key	C_4_1	create col0 tab0 . animals ( col1 int not null identity primary key , col2 tinyint not null , _ codint col3 , codint col4 , tab1 . col5 varchar ( codint ) ) go alter col0 tab0 . col6 add constraint col7 unique ( col1 , col2 ) go create function tab0 . getanimaltype ( col1 int ) returns tinyint as begin declare col8 tinyint select col8 = col2 from tab0 . col6 where col1 = col1 return col8 end go create col0 tab0 . mammals ( col1 int not null primary key , col9 varchar ( codint ) , constraint col10 check ( tab0 . getanimaltype ( col1 ) = codint ) ) go	0
Q_4	be it possible to add a logic constraint to a foreign key	C_4_2	insert into tab0 . animals ( col0 , col1 ) select codint , refre from tab0 . col2 go set statistics col3 on set statistics time on go insert into tab0 . mammals ( col4 , col5 ) select col6 , refre from tab0 . col2	0
Q_4	be it possible to add a logic constraint to a foreign key	C_4_3	sql col0 col1 and compile time col2 time = codint col3 , col4 time = codint tab0 . col5 refre . col6 count codint , col7 reads codint , col8 reads codint , read _ col9 reads codint , col10 col7 reads codint , col10 col8 reads codint , col10 read _ col9 reads codint . col5 refre . col6 count codint , col7 reads codint , col8 reads codint , read _ col9 reads codint , col10 col7 reads codint , col10 col8 reads codint , col10 read _ col9 reads codint . sql col0 col11 col12 col2 time = codint col3 , col4 time = codint tab0 . ( codint row ( col13 ) col14 )	0
Q_4	be it possible to add a logic constraint to a foreign key	C_4_4	create col0 tab0 . mammals2 ( col1 int not null primary key , col2 tinyint not null , col3 varchar ( codint ) , constraint col4 check ( col2 = codint ) , constraint col5 foreign key ( col1 , col2 ) references tab0 . animals ( col1 , col2 ) ) insert into tab0 . mammals2 ( col1 , col2 , col3 ) select col6 , codint , refre from tab0 . col7	0
Q_4	be it possible to add a logic constraint to a foreign key	C_4_5	sql col0 col1 and compile time col2 time = codint col3 , col4 time = codint tab0 . col5 refre . col6 count codint , col7 reads codint , col8 reads codint , read _ col9 reads codint , col10 col7 reads codint , col10 col8 reads codint , col10 read _ col9 reads codint . col5 refre . col6 count codint , col7 reads codint , col8 reads codint , read _ col9 reads codint , col10 col7 reads codint , col10 col8 reads codint , col10 read _ col9 reads codint . col5 refre . col6 count codint , col7 reads codint , col8 reads codint , read _ col9 reads codint , col10 col7 reads codint , col10 col8 reads codint , col10 read _ col9 reads codint . sql col0 col11 col12 col2 time = codint col3 , col4 time = codint tab0 .	0
Q_4	be it possible to add a logic constraint to a foreign key	C_4_6	create col0 tab0 . mammals3 ( col1 int not null primary key , col2 varchar ( codint ) ) insert into tab0 . mammals3 ( col1 , col2 ) select col3 , refre from tab0 . col4	0
Q_4	be it possible to add a logic constraint to a foreign key	C_4_7	sql col0 col1 col2 col3 time = codint col4 , col5 time = codint tab0 . col6 refre . col7 count codint , col8 reads codint , col9 reads codint , read _ col10 reads codint , col11 col8 reads codint , col11 col9 reads codint , col11 read _ col10 reads codint . col6 refre . col7 count codint , col8 reads codint , col9 reads codint , read _ col10 reads codint , col11 col8 reads codint , col11 col9 reads codint , col11 read _ col10 reads codint . sql col0 col1 col2 col3 time = codint col4 , col5 time = codint tab0 . ( codint row ( col12 ) col13 )	0
Q_5	joining table	C_5_0	select tab0 . col0 , tab1 . col0 from ( select ( row_number ( ) over ( order by col0 ) _ codint ) ( select count ( * ) from col1 ) as col2 , * from col3 ) col4 inner join ( select row_number ( ) over ( order by col0 ) _ codint as col2 , * from col1 ) col5 on tab0 . col2 = tab1 . col2 order by tab0 . col0	1
Q_5	joining table	C_5_1	select ( row_number ( ) over ( order by col0 ) _ codint ) as col1 , * from col2	0
Q_5	joining table	C_5_2	codint col0 codint col1 codint col2 codint col3 codint col4 codint col5 codint col6 codint col7	0
Q_5	joining table	C_5_3	select row_number ( ) over ( order by col0 ) _ codint as col1 , * from col2	0
Q_5	joining table	C_5_4	codint col0 codint col1 codint col2 codint col3 codint col4	0
Q_5	joining table	C_5_5	select ( row_number ( ) over ( order by col0 ) _ codint ) ( select count ( * ) from col1 ) as col2 , * from col3	0
Q_5	joining table	C_5_6	codint col0 codint col1 codint col2 codint col3 codint col4 codint col5 codint col6 codint col7	0
Q_6	how to separate the string value and create temp to store separate string in temp table	C_6_0	select * from col0 col1 inner join tab0 . splitfunction ( parameter ) col2 on tab1 . col3 = tab2 . col4	1
Q_6	how to separate the string value and create temp to store separate string in temp table	C_6_1	select col0 codint identity ( int , codint , codint ) as number into col1 from tab0 . col2 col3 cross join tab0 . col2 col4 alter col5 col1 add constraint col6 primary key clustered ( number )	0
Q_6	how to separate the string value and create temp to store separate string in temp table	C_6_2	create function tab0 . [ fn_listtotable ] ( col0 char ( codint ) _ col1 , col2 character to split col2 col3 col4 on , col3 varchar ( codint ) _ col1 , col2 col3 to split col5 ) returns col6 as return ( _ _ col7 col8 _ _ col9 col10 not return col11 rows _ select col12 from ( select ltrim ( rtrim ( substring ( col13 , number + codint , charindex ( col0 , col13 , number + codint ) _ number _ codint ) ) ) as col12 from ( select col0 + col3 + col0 as col13 ) as col14 inner join col15 col16 on tab1 . number < len ( tab2 . col13 ) where substring ( col13 , number , codint ) = col0 ) col17 where col12 is not null and col12 = refre ) go	0
Q_6	how to separate the string value and create temp to store separate string in temp table	C_6_3	select * from tab0 . fn_listtotable ( refre refre , refre refre refre refre refre refre refre refre refre refre refre )	0
Q_6	how to separate the string value and create temp to store separate string in temp table	C_6_4	col0 _ codint codint codint codint codint codint ( codint row ( col1 ) col2 )	0
Q_6	how to separate the string value and create temp to store separate string in temp table	C_6_5	declare col0 table1 ( rowid int , col1 varchar ( codint ) ) declare col2 table1 ( rowid int identity , col1 varchar ( codint ) ) insert into col0 values ( codint , refre refre refre ) insert into col0 values ( codint , refre ) insert into col0 values ( codint , refre refre ) insert into col0 values ( codint , refre ) insert into tbl_b ( col1 ) select distinct tab0 . col3 from col0 cross col4 tab1 . fn_listtotable ( refre refre , col1 ) as col5 order by tab0 . col3 select * from col2 order by rowid	0
Q_6	how to separate the string value and create temp to store separate string in temp table	C_6_6	rowid col0 _ _ codint tab0 . col1 codint col2 codint col3 codint java ( codint row ( col4 ) col5 )	0
Q_7	how to use dml on oracle temporary table without generate much undo log	C_7_0	col0 > insert into col1 codint select * from col2 codint / codint rows tab0 . col0 >	1
Q_7	how to use dml on oracle temporary table without generate much undo log	C_7_1	col0 > select space , col1 , col2 , col3 from col4 transaction codint / col5 col6 col2 col3 _ _ _ _ no no codint codint col0 >	0
Q_7	how to use dml on oracle temporary table without generate much undo log	C_7_2	col0 > delete from col1 codint / codint rows tab0 . col0 >	0
Q_7	how to use dml on oracle temporary table without generate much undo log	C_7_3	col0 > col1 codint * select space , col2 , col3 , col4 from col5 transaction col6 col7 col3 col4 _ _ _ _ no no codint codint col0 > col1 codint * select space , col2 , col3 , col4 from col5 transaction col6 col7 col3 col4 _ _ _ _ no no codint codint col0 > col1 codint * select space , col2 , col3 , col4 from col5 transaction col6 col7 col3 col4 _ _ _ _ no no codint codint col0 >	0
Q_7	how to use dml on oracle temporary table without generate much undo log	C_7_4	col0 > commit codint / commit tab0 . col0 >	0
Q_7	how to use dml on oracle temporary table without generate much undo log	C_7_5	col0 > col1 codint * select space , col2 , col3 , col4 from col5 transaction no rows col6 col0 >	0
Q_7	how to use dml on oracle temporary table without generate much undo log	C_7_6	col0 > insert into col1 codint select * from col2 codint / codint rows tab0 . col0 > delete from col1 codint / codint rows tab1 . col0 > insert into col1 codint select * from col2 codint / codint rows tab0 . col0 >	0
Q_7	how to use dml on oracle temporary table without generate much undo log	C_7_7	col0 > col1 codint * select space , col2 , col3 , col4 from col5 transaction col6 col7 col3 col4 _ _ _ _ no no codint codint col0 > col1 codint * select space , col2 , col3 , col4 from col5 transaction col6 col7 col3 col4 _ _ _ _ no no codint codint col0 > col1 codint * select space , col2 , col3 , col4 from col5 transaction col6 col7 col3 col4 _ _ _ _ no no codint codint col0 >	0
Q_8	comma_separated value insertion in sql server tagint	C_8_0	select * from col0 col1 inner join tab0 . yoursplitfunction ( parameter ) col2 on tab1 . col3 = tab2 . col4	1
Q_8	comma_separated value insertion in sql server tagint	C_8_1	select col0 codint identity ( int , codint , codint ) as number into col1 from tab0 . col2 col3 cross join tab0 . col2 col4 alter col5 col1 add constraint col6 primary key clustered ( number )	0
Q_8	comma_separated value insertion in sql server tagint	C_8_2	create function tab0 . [ fn_listtotablerows ] ( col0 char ( codint ) _ col1 , col2 character to split col2 col3 col4 on , col3 varchar ( codint ) _ col1 , col2 col3 to split col5 ) returns col6 as return ( _ _ col7 col8 _ _ col9 col10 return col11 rows , and row col12 _ select row_number ( ) over ( order by number ) as col13 , ltrim ( rtrim ( substring ( col14 , number + codint , charindex ( col0 , col14 , number + codint ) _ number _ codint ) ) ) as col14 from ( select col0 + col3 + col0 as col14 ) as col15 inner join col12 col16 on tab1 . number < len ( tab2 . col14 ) where substring ( col14 , number , codint ) = col0 ) go	0
Q_8	comma_separated value insertion in sql server tagint	C_8_3	create col0 yourtable ( col1 int , col2 int )	0
Q_8	comma_separated value insertion in sql server tagint	C_8_4	create procedure storedprocedurename ( col0 int , col1 varchar ( codint ) , col2 int , col3 varchar ( codint ) ) as insert into yourtable ( col4 , col5 ) select tab0 . col6 , tab1 . col6 from tab2 . fn_listtotablerows ( refre refre , col1 ) col7 inner join tab2 . fn_listtotablerows ( refre refre , col3 ) col8 on tab0 . col9 = tab1 . col9 go	0
Q_8	comma_separated value insertion in sql server tagint	C_8_5	exec col0 codint , refre refre refre refre , codint , refre refre refre refre select * from col1	0
Q_8	comma_separated value insertion in sql server tagint	C_8_6	( codint row ( col0 ) col1 ) col2 col3 _ _ codint codint codint codint codint codint codint codint ( codint row ( col0 ) col1 )	0
Q_9	distinct with count and s_ql server tagint	C_9_0	with col0 as ( select tab0 . col1 , tab0 . col2 , sum ( tab1 . col3 ) as col4 from col5 col6 join col7 col8 on tab1 . col2 = tab0 . col2 group by tab0 . col1 , tab0 . col2 ) , col9 as ( select tab2 . col1 , tab2 . col2 , tab2 . col4 from col0 col10 where col4 = ( select max ( tab3 . col4 ) from col0 col11 where tab3 . col1 = tab2 . col1 ) ) select col12 codint col1 , col2 , col4 from col9 order by col4 desc	1
Q_9	distinct with count and s_ql server tagint	C_9_1	col0 col1 codint col0 col2 codint col3 col4 col5 codint col6 col7 codint col8 col9 codint	0
Q_9	distinct with count and s_ql server tagint	C_9_2	col0 col1 codint col0 col2 codint col3 col4 col5 codint	0
Q_9	distinct with count and s_ql server tagint	C_9_3	col0 col1 codint col0 col2 codint col3 col4 col5 codint col6 col7 codint	0
Q_9	distinct with count and s_ql server tagint	C_9_4	with col0 as ( select tab0 . col1 , tab0 . col2 , sum ( tab1 . col3 ) as col4 from col5 col6 join col7 col8 on tab1 . col2 = tab0 . col2 group by tab0 . col1 , tab0 . col2 ) , col9 as ( select tab2 . col1 , tab2 . col2 , tab2 . col4 from col0 col10 where tab2 . col4 = ( select max ( tab3 . col4 ) from col0 col11 where tab3 . col1 = tab2 . col1 ) ) , col12 as ( select distinct col13 codint col4 from col9 order by col4 desc ) select col1 , col2 , col4 from col9 where col4 in ( select col4 from col12 ) order by col4 desc	0
Q_9	distinct with count and s_ql server tagint	C_9_5	col0 col1 codint col0 col2 codint col0 and col3 col4 col5 codint col6 col7 col8 codint col9 col10 codint col11 col12 codint	0
Q_9	distinct with count and s_ql server tagint	C_9_6	col0 col1 codint col0 col2 codint col3 col4 col5 codint col6 col7 codint	0
Q_10	how to calculate long streak in sql	C_10_0	select col0 , count ( * ) from col1 where col2 = codint	1
Q_10	how to calculate long streak in sql	C_10_1	select col0 , count ( * ) from col1 where col2 = codint group by col0	0
Q_10	how to calculate long streak in sql	C_10_2	create tab0 . col0 as select col1 , date , col2 as col3 from col4 where col5 = codint order by col1 , date	0
Q_10	how to calculate long streak in sql	C_10_3	update tab0 . col0 set col1 = select min ( tab1 . date ) from tab0 . col0 col2 , tab0 . col0 col3 where tab2 . col4 = tab1 . col4 and tab2 . date < tab1 . date	0
Q_10	how to calculate long streak in sql	C_10_4	create tab0 . col0 as select col1 , date from col2 where col3 = codint order by col1 , date create tab0 . col4 as select * , col5 as col6 from tab0 . col0	0
Q_10	how to calculate long streak in sql	C_10_5	insert into tab0 . col0 col1 select tab1 . col2 , min ( tab2 . date ) , col3 from col4 col5 where tab1 . col2 = tab2 . col2	0
Q_10	how to calculate long streak in sql	C_10_6	update tab0 . col0 set col1 = select min ( tab1 . date ) from tab0 . col0 col2 , tab0 . col3 col4 where tab2 . col5 = tab1 . col5 and tab2 . date < tab1 . date	0
Q_10	how to calculate long streak in sql	C_10_7	select col0 , datediff ( col1 , date ) as col2 from tab0 . col3 group by col0 , col2 order by col0 , col2	0
Q_10	how to calculate long streak in sql	C_10_8	select col0 , max ( datediff ( col1 , date ) as col2 ) from tab0 . col3 group by col0 order by col0	0
Q_10	how to calculate long streak in sql	C_10_9	create tab0 . col0 as select tab1 . col1 , tab1 . date , tab1 . col2 , count ( * ) as col3 from col4 col5 , tab0 . col6 col7 where tab2 . col1 = tab1 . col1 and tab2 . date > = tab1 . date and tab2 . date < tab1 . col2 group by tab1 . col1 , tab1 . date order by tab1 . col1 , tab1 . date	0
Q_10	how to calculate long streak in sql	C_10_10	select col0 , max ( col1 ) from tab0 . col2 group by col0	0
Q_10	how to calculate long streak in sql	C_10_11	select col0 , date , col1 , col2 from tab0 . col3 group by col0 having col2 = max ( col2 )	0
Q_11	sql how do i make a selection base on category	C_11_0	select col0 from col1 group by col0 having sum ( ( col2 in ( codint , codint ) ) int ) = codint	1
Q_11	sql how do i make a selection base on category	C_11_1	select col0 from col1 group by col0 having sum ( ( col2 = any ( array col3 ) ) int ) = codint	0
Q_11	sql how do i make a selection base on category	C_11_2	select tab0 . col0 , tab1 . col1 from col2 join col3 on tab1 . col4 = tab0 . col0 group by tab0 . col0 , tab1 . col1 having sum ( ( tab0 . col5 in ( codint , codint ) ) int ) = codint	0
Q_11	sql how do i make a selection base on category	C_11_3	select tab0 . col0 , tab1 . col1 from col2 join col3 on tab1 . col4 = tab0 . col0 group by tab0 . col0 , tab1 . col1 having count ( case when tab0 . col5 in ( codint , codint ) then codint end ) = codint	0
Q_11	sql how do i make a selection base on category	C_11_4	select col0 from col1 group by col0 having count ( case when col2 in ( codint , codint ) then codint end ) = codint	0
Q_11	sql how do i make a selection base on category	C_11_5	select col0 from col1 where col2 in ( codint , codint ) group by col0 having count ( * ) = codint	0
Q_11	sql how do i make a selection base on category	C_11_6	select col0 from col1 group by col0 having count ( case when col2 in ( codint , codint ) then codint end ) = codint or count ( case when col2 in ( codint , codint , codint ) then codint end ) = codint	0
Q_11	sql how do i make a selection base on category	C_11_7	select col0 from col1 where col2 in ( codint , codint , codint , codint ) group by col0 having count ( case when col2 in ( codint , codint ) then codint end ) = codint or count ( case when col2 in ( codint , codint , codint ) then codint end ) = codint	0
Q_11	sql how do i make a selection base on category	C_11_8	select col0 from col1 group by col0 having sum ( col2 in ( codint , codint ) ) = codint	0
Q_12	how to create a relational schema with following table	C_12_0	sql > select * from col0 codint / col1 col2 col3 _ _ _ col4 codint col5 col6 codint col7 col6 codint col8 col9 codint col10 sql > select * from col11 codint / col1 col2 col12 col13 _ _ _ _ col4 codint codint col14 col4 codint codint col15 col4 codint codint col16 col6 codint codint col17 col9 codint codint col18 sql > select * from col19 codint / col1 col2 col12 col20 col21 _ _ _ _ _ col4 codint codint codint col22 col4 codint codint codint col23 col4 codint codint codint col24 col6 codint codint codint col25 col6 codint codint codint col26 col9 codint codint codint col25 codint rows tab0 . sql >	1
Q_12	how to create a relational schema with following table	C_12_1	sql > alter col0 col1 codint add col2 number codint / col0 tab0 . sql > alter col0 col3 codint add col4 number codint add col2 number codint / col0 tab0 . sql > alter col0 col5 codint add col6 number codint add col4 number codint / col0 tab0 . sql >	0
Q_12	how to create a relational schema with following table	C_12_2	sql > update col0 codint set col1 = rownum codint / codint rows tab0 . sql > update col2 codint set col3 = rownum codint / codint rows tab0 . sql > update col4 codint set col5 = rownum codint / codint rows tab0 . sql >	0
Q_12	how to create a relational schema with following table	C_12_3	sql > update col0 col1 codint set col2 = ( select col2 codint from col3 col4 codint where tab0 . col5 = tab1 . col5 codint and tab0 . col6 = tab1 . col6 ) codint / codint rows tab2 . sql > update col7 col8 codint set col9 = ( select col9 codint from col0 col1 codint where tab1 . col5 = tab3 . col5 codint and tab1 . col6 = tab3 . col6 codint and tab1 . col10 = tab3 . col10 ) codint / codint rows tab2 . sql >	0
Q_12	how to create a relational schema with following table	C_12_4	sql > alter col0 col1 codint modify col2 not null codint add constraint col3 primary key ( col2 ) using col4 codint / col0 tab0 . sql > alter col0 col5 codint modify col6 not null codint add constraint col7 foreign key ( col2 ) codint references grandparent ( col2 ) codint add constraint col8 primary key ( col6 ) using col4 codint / col0 tab0 . sql > alter col0 col9 codint modify col10 not null codint add constraint col11 foreign key ( col6 ) codint references parent ( col6 ) codint add constraint col12 primary key ( col10 ) using col4 codint / col0 tab0 . sql >	0
Q_12	how to create a relational schema with following table	C_12_5	sql > alter col0 col1 codint add constraint col2 unique ( col3 , col4 ) using col5 codint / col0 tab0 . sql > alter col0 col6 codint add constraint col7 unique ( col8 , col9 ) using col5 codint / col0 tab0 . sql > alter col0 col6 codint drop column col3 codint / col0 tab0 . sql > alter col0 col6 codint drop column col4 codint / col0 tab0 . sql > alter col0 col10 codint drop column col3 codint / col0 tab0 . sql > alter col0 col10 codint drop column col4 codint / col0 tab0 . sql > alter col0 col10 codint drop column col9 codint / col0 tab0 . sql > alter col0 col10 codint add constraint col11 unique ( col12 , col13 ) using col5 codint / col0 tab0 . sql >	0
Q_12	how to create a relational schema with following table	C_12_6	sql > select * from col0 codint / col1 col2 col3 col4 _ _ _ _ col5 codint col6 codint col7 codint col8 codint col7 codint col9 codint col10 codint col11 codint sql > select * from col12 codint / col13 col14 col15 col4 _ _ _ _ codint col16 codint codint codint col17 codint codint codint col18 codint codint codint col19 codint codint codint col20 codint codint sql > select * from col21 codint / col22 col23 col24 col15 _ _ _ _ codint col25 codint codint codint col26 codint codint codint col27 codint codint codint col28 codint codint codint col29 codint codint codint col28 codint codint codint rows tab0 . sql >	0
Q_13	problem with trigger in oracle	C_13_0	create col0 clan_affiliati ( col1 varchar2 ( codint ) , col2 varchar2 ( codint ) , col3 varchar2 ( codint ) ) create col0 clan ( col4 varchar2 ( codint ) , col5 number ( codint ) )	1
Q_13	problem with trigger in oracle	C_13_1	create or replace package col0 as type col1 is record ( col2 varchar2 ( codint ) , operation varchar2 ( codint ) _ insert or delete ) type col3 is col4 of col1 col5 by col6 col7 col3 end col0 /	0
Q_13	problem with trigger in oracle	C_13_2	create or replace trigger col0 before insert or update of col1 on col2 for each row declare col3 number = codint begin if col4 then _ col5 col4 < > codint if tab0 . col1 < > codint then raise_application_error ( _ codint , refre ) end if else select count ( * ) into col3 from col6 where col2 = tab1 . col7 if col3 < > tab0 . col1 then raise_application_error ( _ codint , refre ) end if end if end /	0
Q_13	problem with trigger in oracle	C_13_3	create or replace trigger col0 before insert or delete on col1 declare begin tab0 . tab1 . delete end /	0
Q_13	problem with trigger in oracle	C_13_4	create or replace trigger col0 after insert or delete on col1 declare begin for col2 in tab0 . tab1 . tab2 . tab0 . tab1 . last loop if ( tab0 . g_array_nomes ( col2 ) . operation = refre ) then update col3 set col4 = col4 + codint where col5 = tab0 . g_array_nomes ( col2 ) . col5 elsif ( tab0 . g_array_nomes ( col2 ) . operation = refre ) then update col3 set col4 = col4 _ codint where col5 = tab0 . g_array_nomes ( col2 ) . col5 end if end loop end /	0
Q_13	problem with trigger in oracle	C_13_5	create or replace trigger col0 before insert or delete on col1 for each row declare col2 varchar ( codint ) begin if col3 then select col4 into col2 from col5 where col4 = tab0 . col5 tab1 . g_array_nomes ( tab1 . tab2 . count ) . col4 = tab0 . col5 tab1 . g_array_nomes ( tab1 . tab2 . last ) . operation = refre else select col4 into col2 from col5 where col4 = tab3 . col5 tab1 . g_array_nomes ( tab1 . tab2 . count ) . col4 = tab3 . col5 tab1 . g_array_nomes ( tab1 . tab2 . last ) . operation = refre end if end /	0
Q_13	problem with trigger in oracle	C_13_6	insert into clan ( col0 , col1 ) values ( refre , codint ) insert into clan_affiliati ( col2 , col3 , col4 ) values ( refre , refre , refre ) insert into clan_affiliati ( col2 , col3 , col4 ) values ( refre , refre , refre )	0
Q_14	sql compare set part ii how to join set of set	C_14_0	select tab0 . col0 as col1 , tab1 . col0 as col2 , tab0 . col3 col4 from elements col5 join col6 col7 on tab0 . col3 = tab1 . col3	1
Q_14	sql compare set part ii how to join set of set	C_14_1	col0 set col1 set col2 col3 _ _ _ codint codint col4 codint codint col5 codint codint col5 codint codint col6 codint codint col6 codint codint col6 codint codint col7 codint codint col7 codint codint col4 codint codint col5 codint codint col5 codint codint col6 codint codint col6 codint codint col6 codint codint col7 codint codint col7 codint codint col5 codint codint col5 codint codint col6 codint codint col6 codint codint col6 codint codint col7 codint codint col7 codint codint col7 codint codint col7	0
Q_14	sql compare set part ii how to join set of set	C_14_2	select tab0 . col0 as col1 , tab1 . col0 as col2 , count ( * ) as col3 from elements col4 join col5 col6 on tab0 . col7 = tab1 . col7 group by tab0 . col0 , tab1 . col0 order by tab0 . col0 , tab1 . col0	0
Q_14	sql compare set part ii how to join set of set	C_14_3	col0 set col1 set col2 col3 count _ _ _ codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_14	sql compare set part ii how to join set of set	C_14_4	select tab0 . col0 as col1 , tab1 . col0 as col2 , count ( * ) as col3 , ( select count ( * ) from elements col4 where tab2 . col0 = tab0 . col0 ) as col5 , ( select count ( * ) from col6 col7 where tab3 . col0 = tab1 . col0 ) as col8 from elements col9 join col6 col10 on tab0 . col11 = tab1 . col11 group by tab0 . col0 , tab1 . col0 order by tab0 . col0 , tab1 . col0	0
Q_14	sql compare set part ii how to join set of set	C_14_5	col0 set col1 set col2 col3 count col0 set count col1 set count _ _ _ _ _ codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_14	sql compare set part ii how to join set of set	C_14_6	select tab0 . col0 as col1 , tab1 . col0 as col2 from elements col3 join col4 col5 on tab0 . col6 = tab1 . col6 group by tab0 . col0 , tab1 . col0 having count ( * ) = ( select count ( * ) from elements col7 where tab2 . col0 = tab0 . col0 ) and ( select count ( * ) from elements col7 where tab2 . col0 = tab0 . col0 ) = ( select count ( * ) from col4 col8 where tab3 . col0 = tab1 . col0 ) order by tab0 . col0 , tab1 . col0	0
Q_14	sql compare set part ii how to join set of set	C_14_7	col0 set col1 set _ _ codint codint codint codint	0
Q_15	optimal my_sql setting for query that deliver large amount of data	C_15_0	drop col0 if exists col1 create col0 results_1mregr_c_ew_f ( col2 int unsigned not null auto_increment primary key , col3 tinyint unsigned not null , col4 int unsigned not null default codint , col5 double ( codint , codint ) not null default codint , col6 timestamp not null default now ( ) , key ( col3 , col4 ) ) engine = col7	1
Q_15	optimal my_sql setting for query that deliver large amount of data	C_15_1	show indexes from col0 col1 col2 col3 col4 column_name collation cardinality col5 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = col0 codint primary codint col6 col7 codint col8 col0 codint col9 codint col9 col7 codint col8 col0 codint col9 codint col10 col7 codint col8	0
Q_15	optimal my_sql setting for query that deliver large amount of data	C_15_2	drop procedure if exists col0 delimiter create procedure process_results_1mregr_c_ew_f ( in col1 tinyint unsigned , in col2 int unsigned ) begin declare col3 int unsigned default codint declare col4 tinyint default codint declare col5 int unsigned declare col6 cursor for select col7 from col8 where col9 = col1 and col10 > col2 declare continue handler for not found set col4 = codint open col6 col11 fetch col6 into col5 set col3 = col3 + codint _ do tab0 . until col4 end col11 close col6 select col3 as col12 end delimiter	0
Q_15	optimal my_sql setting for query that deliver large amount of data	C_15_3	call process_results_1mregr_c_ew_f ( codint , codint ) col0 codint = codint number col1 ok ( codint col2 codint col3 ) col0 codint = codint number col1 ok ( codint col2 codint col3 ) call process_results_1mregr_c_ew_f ( codint , codint ) col0 codint = codint number col1 ok ( codint col2 codint col3 ) col0 codint = codint number col1 ok ( codint col2 codint col3 ) col4 = = = = = = = = codint ( codint col5 rows col6 in each case )	0
Q_15	optimal my_sql setting for query that deliver large amount of data	C_15_4	drop col0 if exists col1 create col0 results_innodb ( col2 tinyint unsigned not null , col3 int unsigned not null default codint , col4 int unsigned not null , _ col5 col6 col7 col8 double ( codint , codint ) not null default codint , col9 timestamp not null default now ( ) , primary key ( col2 , col3 , col4 ) _ col10 clustered ( col11 only ) col12 col13 ) engine = col11	0
Q_15	optimal my_sql setting for query that deliver large amount of data	C_15_5	show indexes from col0 col1 col2 col3 col4 column_name collation cardinality col5 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = col0 codint primary codint col6 col7 codint col8 col0 codint primary codint col9 col7 codint col8 col0 codint primary codint col10 col7 codint col8	0
Q_15	optimal my_sql setting for query that deliver large amount of data	C_15_6	declare col0 cursor for select col1 from col2 where col3 = col4 and col5 > col6	0
Q_15	optimal my_sql setting for query that deliver large amount of data	C_15_7	call process_results_innodb ( codint , codint ) col0 codint = codint number col1 ok ( codint col2 codint col3 ) col0 codint = codint number col1 ok ( codint col2 codint col3 ) call process_results_innodb ( codint , codint ) col0 codint = codint number col1 ok ( codint col2 codint col3 ) col0 codint = codint number col1 ok ( codint col2 codint col3 ) col4 = = = = = = = = codint ( codint col5 rows col6 in each case )	0
Q_15	optimal my_sql setting for query that deliver large amount of data	C_15_8	call list_results_innodb ( codint , codint , codint ) _ col0 codint call list_results_innodb ( codint , codint , codint ) _ col0 between codint and codint call list_results_innodb ( codint , codint , codint ) _ col0 between codint and codint tab0 .	0
Q_15	optimal my_sql setting for query that deliver large amount of data	C_15_9	drop procedure if exists col0 delimiter create procedure list_results_innodb ( in col1 tinyint unsigned , in col2 int unsigned , in col3 int unsigned ) begin select col4 , col5 , col6 from col7 where col4 = col1 and col5 between col2 and col3 end delimiter	0
Q_15	optimal my_sql setting for query that deliver large amount of data	C_15_10	call list_results_1mregr_c_ew_f ( codint , codint , codint ) call list_results_1mregr_c_ew_f ( codint , codint , codint ) call list_results_1mregr_c_ew_f ( codint , codint , codint )	0
Q_15	optimal my_sql setting for query that deliver large amount of data	C_15_11	thread codint col0 _ codint thread codint col0 _ codint thread codint col0 _ codint thread codint col0 _ codint thread codint col0 _ codint thread codint col0 _ codint thread codint col0 _ codint thread codint col0 _ codint thread codint col0 _ codint thread codint col0 _ codint thread codint col0 _ codint thread codint col0 _ codint codint col1 col2 and col3 in codint codint number col4 col5 any key	0
Q_15	optimal my_sql setting for query that deliver large amount of data	C_15_12	codint col0 col1 and col2 in codint codint number col3	0
Q_15	optimal my_sql setting for query that deliver large amount of data	C_15_13	start transaction insert into col0 select < tab0 . > from col1 order by < col2 primary key > commit	0
Q_16	please help optimize a long running query	C_16_0	select tab0 . * from col0 col1 left join col0 col2 on tab0 . col3 = tab1 . col3 and tab0 . col4 < tab1 . col4 where tab1 . col3 is null	1
Q_16	please help optimize a long running query	C_16_1	select tab0 . * from col0 col1 left join col0 col2 on tab0 . col3 = tab1 . col3 and tab0 . col4 = tab1 . col4 where tab1 . col3 is null	0
Q_16	please help optimize a long running query	C_16_2	left join col0 col1 on tab0 . col2 = tab1 . tab2 . where tab1 . col2 is null	0
Q_16	please help optimize a long running query	C_16_3	last first col0 col1 col0 col2 col0 col3 col4 col2	0
Q_16	please help optimize a long running query	C_16_4	select tab0 . last , tab0 . first , tab1 . last , tab1 . first from names col0 left join names col1 on tab0 . last = tab1 . last and tab0 . first = tab1 . first	0
Q_16	please help optimize a long running query	C_16_5	last first last first col0 col1 col0 col2 col0 col2 col0 col1 col0 col3 col0 col2 col0 col1 col0 col3 col0 col2 col0 col3 col0 col3 col0 col1 col4 col2 null null	0
Q_16	please help optimize a long running query	C_16_6	select tab0 . last , tab0 . first , tab1 . last , tab1 . first from names col0 left join names col1 on tab0 . last = tab1 . last and tab0 . first = tab1 . first where tab1 . last is null	0
Q_17	my_sql string comparison with percent output	C_17_0	select bit_count ( conv ( tab0 . col0 , codint , codint ) conv ( tab1 . col0 , codint , codint ) ) / codint * codint as col1 from col2 col3 , col2 col4 where tab0 . col5 = codint and tab1 . col5 = codint	1
Q_17	my_sql string comparison with percent output	C_17_1	conv ( tab0 . col0 , codint , codint )	0
Q_17	my_sql string comparison with percent output	C_17_2	conv ( tab0 . col0 , codint , codint )	0
Q_17	my_sql string comparison with percent output	C_17_3	conv ( tab0 . col0 , codint , codint ) conv ( tab1 . col0 , codint , codint )	0
Q_17	my_sql string comparison with percent output	C_17_4	bit_count ( conv ( tab0 . col0 , codint , codint ) conv ( tab1 . col0 , codint , codint ) )	0
Q_17	my_sql string comparison with percent output	C_17_5	bit_count ( conv ( tab0 . col0 , codint , codint ) conv ( tab1 . col0 , codint , codint ) ) / codint * codint	0
Q_17	my_sql string comparison with percent output	C_17_6	select bit_count ( ( conv ( tab0 . col0 , codint , codint ) conv ( tab1 . col0 , codint , codint ) ) ( ( codhex ( codint _ codint ) ) ( conv ( tab0 . col0 , codint , codint ) conv ( tab1 . col0 , codint , codint ) ) ) ) / codint * codint as col1 from col2 col3 , col2 col4 where tab0 . col5 = codint and tab1 . col5 = codint	0
Q_17	my_sql string comparison with percent output	C_17_7	insert into sim ( col0 , col1 ) values ( codint , conv ( refre , codint , codint ) ) insert into sim ( col0 , col1 ) values ( codint , conv ( refre , codint , codint ) )	0
Q_17	my_sql string comparison with percent output	C_17_8	update col0 set col1 = conv ( col1 , codint , codint )	0
Q_17	my_sql string comparison with percent output	C_17_9	select bit_count ( tab0 . col0 tab1 . col0 ) / codint * codint as col1 from col2 col3 , col2 col4 where tab0 . col5 = codint and tab1 . col5 = codint	0
Q_17	my_sql string comparison with percent output	C_17_10	select bit_count ( ( tab0 . col0 tab1 . col0 ) ( ( codhex ( codint _ codint ) ) ( tab0 . col0 tab1 . col0 ) ) ) / codint * codint as col1 from col2 col3 , col2 col4 where tab0 . col5 = codint and tab1 . col5 = codint	0
Q_18	optimize mysql random query	C_18_0	col0 col1 col2 > show create col3 col4 col5 * * * * * * * * * * * * * * * * * * * * * * * * * * * codint . row * * * * * * * * * * * * * * * * * * * * * * * * * * * col3 col4 create col3 create col3 games ( col6 int ( codint ) not null auto_increment , col7 enum ( refre , refre , refre ) not null , col8 timestamp not null default current_timestamp on update current_timestamp , primary key ( col6 ) ) engine = col9 auto_increment = codint default charset = col10 codint row in set ( number col11 )	1
Q_18	optimize mysql random query	C_18_1	col0 col1 col2 > insert into col3 values ( null , floor ( rand ( ) * codint ) , now ( ) _ interval codint second ) col4 col5 , codint row col6 , codint warning ( number col7 ) note ( col8 codint ) statement col9 not col10 col11 to col12 in statement tab0 .	0
Q_18	optimize mysql random query	C_18_2	col0 col1 col2 > insert into col3 select null , floor ( rand ( ) * codint ) , now ( ) _ interval codint second from col3 col4 col5 , codint row col6 , codint warning ( number col7 ) col8 codint col9 codint col10 codint note ( col11 codint ) statement col12 not col13 col14 to col15 in statement tab0 .	0
Q_18	optimize mysql random query	C_18_3	col0 col1 col2 > select count ( * ) from col3 + _ + count ( * ) + _ + codint + _ + codint row in set ( number col4 )	0
Q_18	optimize mysql random query	C_18_4	col0 col1 col2 > create col3 col4 like col5 col6 col7 , codint rows affected ( number col8 ) col0 col1 col2 > alter col3 col4 modify column col9 integer not null , drop primary key , add column col10 integer not null auto_increment , add primary key ( col10 ) , add index1 ( col11 ) , add index1 ( col12 ) , add index1 ( col9 ) col6 col7 , codint rows affected ( number col8 ) col13 codint col14 codint col15 codint	0
Q_18	optimize mysql random query	C_18_5	col0 col1 col2 > insert into col3 select col4 , col5 , col6 , null from col7 order by rand ( ) col8 col9 , codint rows col10 , codint warning ( number col11 ) col12 codint col13 codint col14 codint note ( col15 codint ) statement col16 not col17 col18 to col19 in statement tab0 .	0
Q_18	optimize mysql random query	C_18_6	col0 col1 col2 > select min ( col3 ) as col3 from col4 where col5 = refre union all select min ( col3 ) from col4 where col5 = refre union all select min ( col3 ) from col6 where col5 = refre union all ( select col3 from col4 order by col7 limit codint ) + _ + col3 + _ + codint codint codint codint codint codint + _ + codint rows in set ( number col8 )	0
Q_18	optimize mysql random query	C_18_7	col0 col1 col2 > select col3 from col4 where col3 not in ( codint , codint , codint , codint , codint , codint ) limit codint + _ + col3 + _ + codint codint codint + _ + codint rows in set ( number col5 )	0
Q_19	need advice from mongo_db expert developer before on switch from rdbms	C_19_0	col0 { col1 , col2 , col3 , col4 , tags ( col5 of col6 names for col7 access and for col8 ) , ratings ( col9 col10 , use col11 ) , likes ( col9 col10 , use col11 ) , col12 , ( col13 col14 integer col15 , ) ratingscount ( use col16 to increment col17 col18 col19 col20 col21 for col0 ) , commentscount ( use col16 col22 when col20 col23 comment ) , likescount ( use col16 col22 when col20 col24 refre ) } comment { col1 , col25 , col26 , col27 , col28 , col29 , col30 { ( col31 of comment col30 ) col26 , col27 , col28 , col29 } } col6 { col1 , col32 , albumscount ( use col16 codint when new col0 col33 with col17 col6 and col16 _ codint _ col19 col34 ) }	1
Q_19	need advice from mongo_db expert developer before on switch from rdbms	C_19_1	tab0 . tab1 . find ( ) . skip ( codint ) . limit ( codint ) . sort ( { col0 _ codint } )	0
Q_19	need advice from mongo_db expert developer before on switch from rdbms	C_19_2	tab0 . tab1 . find ( ) . skip ( codint ) . limit ( codint ) . sort ( { col0 _ codint } )	0
Q_19	need advice from mongo_db expert developer before on switch from rdbms	C_19_3	tab0 . tab1 . find ( ) . skip ( codint ) . limit ( codint ) . sort ( { col0 _ codint } )	0
Q_19	need advice from mongo_db expert developer before on switch from rdbms	C_19_4	tab0 . tab1 . find ( ) . skip ( codint ) . limit ( codint ) . sort ( { col0 _ codint } )	0
Q_19	need advice from mongo_db expert developer before on switch from rdbms	C_19_5	tab0 . tab1 . find ( { col0 col1 } )	0
Q_19	need advice from mongo_db expert developer before on switch from rdbms	C_19_6	col0 = tab0 . tab1 . find ( { col1 col2 } ) col3 = tab0 . tab2 . find ( { col4 col2 } ) . skip ( codint ) . limit ( codint ) . sort ( { col5 _ codint , col6 _ codint } )	0
Q_19	need advice from mongo_db expert developer before on switch from rdbms	C_19_7	tab0 . tab1 . find ( { or col0 } )	0
Q_19	need advice from mongo_db expert developer before on switch from rdbms	C_19_8	tab0 . tab1 . find ( { col0 { in col1 } } ] } )	0
Q_19	need advice from mongo_db expert developer before on switch from rdbms	C_19_9	tab0 . tab1 . find ( { col0 col1 } ) . skip ( codint ) . limit ( codint ) . sort ( { col2 _ codint } )	0
Q_19	need advice from mongo_db expert developer before on switch from rdbms	C_19_10	tab0 . tab1 . skip ( codint ) . limit ( codint ) . sort ( { col0 _ codint } )	0
Q_20	how to change the character set throughout a database	C_20_0	alter database < col0 > character set col1 collate col2	1
Q_20	how to change the character set throughout a database	C_20_1	alter col0 < table_name > convert to character set col1 collate col2	0
Q_20	how to change the character set throughout a database	C_20_2	alter col0 < table_name > modify < column_name > varchar ( codint ) character set col1 collate col2	0
Q_20	how to change the character set throughout a database	C_20_3	codint col0 _ col1 codint col0 _ utf8mb4 ( new )	0
Q_20	how to change the character set throughout a database	C_20_4	col0 _ col1 col0 _ col2 col0 _ _0900_ ( new )	0
Q_20	how to change the character set throughout a database	C_20_5	"col0 _ col1 col2 col3 col4 col5 "" col6 col7 case col8 , col9 , col10 col11 _ col12 case insensitive ( col13 = col13 ) and col14 col15 insensitive ( col13 = ) col16 _ col12 case insensitive and col15 insensitive _as ( col10 ) _ col15 _ sensitive ( col10 )"	0
Q_20	how to change the character set throughout a database	C_20_6	col0 _ simple , col1 col2 _ col3 to col4 col5 col6 col7 = , col8 tab0 . _ col9 col10 _ ( number ) col11 col12 col13 of col14 col15	0
Q_21	fetch a single row from join table	C_21_0	create col0 articles ( col1 int ( codint ) unsigned not null auto_increment , col2 int ( codint ) unsigned not null , col3 col4 not null , primary key ( col1 ) ) engine = col5 create col0 article_images ( col6 int ( codint ) unsigned not null , col7 varchar ( codint ) not null , col8 col4 not null , unique index1 ( col6 , col7 ) ) engine = col5	1
Q_21	fetch a single row from join table	C_21_1	create col0 articles ( col1 int ( codint ) unsigned not null auto_increment , col2 int ( codint ) unsigned not null , col3 col4 not null , primary key ( col1 ) , index1 ( col3 desc ) ) engine = col5 create col0 article_images ( col6 int ( codint ) unsigned not null , col7 varchar ( codint ) not null , col8 col4 not null , unique index1 ( col6 , col7 ) , index1 ( col6 , col8 ) , ) engine = col5	0
Q_21	fetch a single row from join table	C_21_2	select tab0 . col0 , tab0 . col1 , ifnull ( tab1 . col2 , refre refre refre ) col2 , ifnull ( tab2 . col3 , refre refre refre ) col3 from ( select tab3 . col4 , tab3 . col5 , tab4 . col0 , tab4 . col1 from ( select tab5 . col4 , ifnull ( max ( tab6 . col5 ) , refre ) col5 from ( select col4 from col6 order by col1 desc limit codint ) col7 left join col8 col9 on tab5 . col4 = tab6 . col10 group by tab5 . col4 ) col11 inner join col6 col12 using ( col4 ) ) col13 left join col14 col15 on tab0 . col4 = tab1 . col10 left join col8 col16 on ( tab0 . col4 = tab2 . col10 and tab0 . col5 = tab2 . col5 ) order by tab0 . col1 desc	0
Q_21	fetch a single row from join table	C_21_3	delimiter drop procedure if exists tab0 . col0 create procedure tab0 . maketables ( ) begin drop col1 if exists col2 drop col1 if exists col3 drop col1 if exists col4 create col1 articles ( col5 int ( codint ) unsigned not null auto_increment , col6 int ( codint ) unsigned not null , col7 col8 not null , primary key ( col5 ) , index1 ( col7 desc ) ) engine = col9 create col1 article_contents ( col10 int ( codint ) unsigned not null , col11 varchar ( codint ) not null , col12 col13 not null , primary key ( col10 ) ) engine = col9 create col1 article_images ( col10 int ( codint ) unsigned not null , col14 varchar ( codint ) not null , col15 col8 not null , unique index1 ( col10 , col14 ) , index1 ( col10 , col15 ) ) engine = col9 end delimiter	0
Q_21	fetch a single row from join table	C_21_4	delimiter drop procedure if exists tab0 . col0 create procedure tab0 . showlast40 ( ) begin select tab1 . col1 , tab1 . col2 , ifnull ( tab2 . col3 , refre refre refre ) col3 , ifnull ( tab3 . col4 , refre refre refre ) col4 from ( select tab4 . col5 , tab4 . col6 , tab5 . col1 , tab5 . col2 from ( select tab6 . col5 , ifnull ( max ( tab7 . col6 ) , refre ) col6 from ( select col5 from col7 order by col2 desc limit codint ) col8 left join col9 col10 on tab6 . col5 = tab7 . col11 group by tab6 . col5 ) col12 inner join col7 col13 using ( col5 ) ) col14 left join col15 col16 on tab1 . col5 = tab2 . col11 left join col9 col17 on ( tab1 . col5 = tab3 . col11 and tab1 . col6 = tab3 . col6 ) order by tab1 . col2 desc end delimiter	0
Q_21	fetch a single row from join table	C_21_5	select tab0 . col0 , tab0 . col1 , ifnull ( tab1 . col2 , refre refre refre ) col2 , ifnull ( tab2 . col3 , refre refre refre ) col3 from ( select tab3 . col4 , tab3 . col5 , tab4 . col0 , tab4 . col1 from ( select tab5 . col4 , ifnull ( max ( tab6 . col5 ) , refre ) col5 from ( select col4 from col6 order by col1 desc limit codint ) col7 left join col8 col9 on tab5 . col4 = tab6 . col10 group by tab5 . col4 ) col11 inner join col6 col12 using ( col4 ) ) col13 left join col14 col15 on tab0 . col4 = tab1 . col10 left join col8 col16 on ( tab0 . col4 = tab2 . col10 and tab0 . col5 = tab2 . col5 ) order by tab0 . col1 desc	0
Q_21	fetch a single row from join table	C_21_6	select tab0 . col0 , tab0 . col1 , ifnull ( tab1 . col2 , refre refre refre ) col2 , ifnull ( tab2 . col3 , refre refre refre ) col3 , ifnull ( tab2 . col4 , refre refre refre ) col5 from ( select tab3 . col6 , tab3 . col4 , tab4 . col0 , tab4 . col1 from ( select tab5 . col6 , ifnull ( max ( tab6 . col4 ) , refre ) col4 from ( select col6 from col7 order by col1 desc limit codint ) col8 left join col9 col10 on tab5 . col6 = tab6 . col11 group by tab5 . col6 ) col12 inner join col7 col13 using ( col6 ) ) col14 left join col15 col16 on tab0 . col6 = tab1 . col11 left join col9 col17 on ( tab0 . col6 = tab2 . col11 and tab0 . col4 = tab2 . col4 ) order by tab0 . col1 desc	0
Q_22	practical limitation of expression index in postgre_sql	C_22_0	create col0 on product_eav ( col1 ) where ( col2 = refre )	1
Q_22	practical limitation of expression index in postgre_sql	C_22_1	select col0 from col1 where col2 = refre and col3 = size	0
Q_22	practical limitation of expression index in postgre_sql	C_22_2	select col0 from col1 where col2 = refre and col3 = size and type = refre	0
Q_22	practical limitation of expression index in postgre_sql	C_22_3	create col0 on product ( ( data _ > refre ) int ) where ( data _ > refre is not null )	0
Q_22	practical limitation of expression index in postgre_sql	C_22_4	select col0 from col1 where data _ > refre is not null and data _ > refre = size	0
Q_22	practical limitation of expression index in postgre_sql	C_22_5	create unique col0 col1 on foo ( col2 ) where ( col3 )	0
Q_22	practical limitation of expression index in postgre_sql	C_22_6	alter col0 col1 add constraint col2 unique ( col3 ) where ( col4 )	0
Q_22	practical limitation of expression index in postgre_sql	C_22_7	alter col0 col1 add constraint col2 exclude ( col3 with = ) where ( col4 )	0
Q_23	how to build string query with n_hibernate	C_23_0	col0 col1 = tab0 . col2 < col3 > ( ) . setprojection ( tab1 . projectionlist ( ) . add ( tab1 . property ( refre ) , refre ) . add ( tab1 . property ( refre ) , refre ) ) . add ( tab2 . eq ( refre , refre ) ) . add ( tab2 . eq ( refre , refre ) ) . setresulttransformer ( new aliastobeanresulttransformer ( typeof ( col4 ) ) ) . col5 < col4 > ( )	1
Q_23	how to build string query with n_hibernate	C_23_1	select col0 , col1 from col2 where col0 = codint and col1 = refre	0
Q_23	how to build string query with n_hibernate	C_23_2	select ( refre col0 ) col1 as col2 from col3 col4 where ( refre col0 ) col1 = refre	0
Q_23	how to build string query with n_hibernate	C_23_3	select ( col0 col1 ) as col2 from col3 col4 where ( col0 col1 ) = refre	0
Q_23	how to build string query with n_hibernate	C_23_4	select ( col0 col1 ) as col2 from col3 col4 where col0 = codint and col1 = refre	0
Q_23	how to build string query with n_hibernate	C_23_5	registerfunction ( refre , new sqlfunctiontemplate ( tab0 . col0 , refre refre regque refre regque refre refre ) )	0
Q_23	how to build string query with n_hibernate	C_23_6	col0 col1 = tab0 . createquery ( refre refre refre refre refre refre refre codint col2 refre ) . list ( )	0
Q_24	how to make quote of the day use php and mysql in order by id	C_24_0	col0 _ col1 data col2 _ codint first col3 col4 col3 codint tab0 . col5 col5	1
Q_24	how to make quote of the day use php and mysql in order by id	C_24_1	datediff ( curdate ( ) + codint , refre ) as col0	0
Q_24	how to make quote of the day use php and mysql in order by id	C_24_2	col0 = differencebetween ( col1 + codint and col2 )	0
Q_24	how to make quote of the day use php and mysql in order by id	C_24_3	col0 = codint _ codint _ codint ( col1 is + codint ) _ codint _ codint _ codint	0
Q_24	how to make quote of the day use php and mysql in order by id	C_24_4	codint _ codint _ codint _ codint _ codint _ codint	0
Q_24	how to make quote of the day use php and mysql in order by id	C_24_5	codint _ codint _ codint _ codint _ codint _ codint	0
Q_24	how to make quote of the day use php and mysql in order by id	C_24_6	codint _ codint _ codint _ codint _ codint _ codint	0
Q_24	how to make quote of the day use php and mysql in order by id	C_24_7	codint _ codint _ codint _ codint _ codint _ codint	0
Q_24	how to make quote of the day use php and mysql in order by id	C_24_8	col0 _ col1 data _ codint col2 col3 codint ( col4 date col5 from start = = codint ) codint col2 codint col3 codint ( col6 = = codint ) codint col2 codint col3 codint ( col6 = = codint ) codint col2 codint col3 codint .	0
Q_25	sql transpose row into column	C_25_0	create or replace view col0 as select col1 as col2 , col3 , col4 from crosstab ( refre refre refre , refre ) as ( col1 integer , col3 col5 , col4 col5 )	1
Q_25	sql transpose row into column	C_25_1	select col0 , col1 , col2 , col3 from col4 join col5 using ( col0 ) order by col0	0
Q_25	sql transpose row into column	C_25_2	col0 col1 col2 col3 _ + _ + _ + _ codint col4 col5 codint codint col6 col7 brown ( codint rows )	0
Q_25	sql transpose row into column	C_25_3	tab0 . forname ( refre ) connection col0 = tab1 . getconnection ( refre refre refre refre , refre , refre ) statement col1 = tab2 . createstatement ( ) col2 col3 = tab3 . executequery ( refre ) col4 < col5 > col6 = new col7 < col5 > ( ) while ( tab4 . next ( ) ) tab5 . add ( tab4 . getstring ( codint ) ) tab6 . tab7 . println ( refre refre ) tab6 . tab7 . println ( refre refre ) for ( int col8 = codint col8 < tab5 . size ( ) + + col8 ) { tab6 . tab7 . print ( refre + tab5 . get ( col8 ) + refre ) if ( col8 = tab5 . size ( ) _ codint ) tab6 . tab7 . print ( refre refre ) tab6 . tab7 . println ( ) } tab6 . tab7 . println ( refre refre )	0
Q_25	sql transpose row into column	C_25_4	create type col0 as ( col1 integer , col2 col3 , col4 col3 )	0
Q_25	sql transpose row into column	C_25_5	create or replace function crosstabpersonattribute ( col0 , col0 ) returns setof col1 as refre refre , refre language col2 stable strict	0
Q_25	sql transpose row into column	C_25_6	create or replace view col0 as select * from crosstabpersonattribute ( refre refre refre , refre )	0
Q_25	sql transpose row into column	C_25_7	table col0 col1 col2 col3 _ + _ + _ codint codint codint brown ( codint rows )	0
Q_26	get data from datagrid c entity framework wpf	C_26_0	public class col0 { public int col1 { get set } public col2 col3 { get set } }	1
Q_26	get data from datagrid c entity framework wpf	C_26_1	public col0 < col1 > col2 = new col0 < col1 > { new col1 { col3 = codint , col4 = refre } , new col1 { col3 = codint , col4 = refre } , new col1 { col3 = codint , col4 = refre } , new col1 { col3 = codint , col4 = refre } , new col1 { col3 = codint , col4 = refre } }	0
Q_26	get data from datagrid c entity framework wpf	C_26_2	tab0 . col0 = true tab0 . col1 = col2	0
Q_26	get data from datagrid c entity framework wpf	C_26_3	if ( tab0 . col0 = _ codint ) { col1 col2 = ( col1 ) tab0 . col3 col4 tab1 . show ( tab2 . col5 ) }	0
Q_26	get data from datagrid c entity framework wpf	C_26_4	public class col0 { public col1 col2 { get set } public col1 col3 { get set } public int col4 { get set } }	0
Q_26	get data from datagrid c entity framework wpf	C_26_5	col0 col1 = ( col0 ) tab0 . col2 col3	0
Q_26	get data from datagrid c entity framework wpf	C_26_6	user col0 = ( col1 ) tab0 . col2 col3	0
Q_26	get data from datagrid c entity framework wpf	C_26_7	col0 col1 = from col2 in tab0 . col3 select col2 tab1 . col4 = col5	0
Q_27	sql server table result to array in sql server tagint	C_27_0	create col0 p ( col1 int primary key , col2 varchar ( codint ) ) create col0 c ( col1 int primary key , col3 int , col2 varchar ( codint ) , constraint col4 foreign key ( col3 ) references p ( col1 ) )	1
Q_27	sql server table result to array in sql server tagint	C_27_1	insert into col0 values ( codint , refre ) insert into col0 values ( codint , refre ) insert into col1 values ( codint , codint , refre ) insert into col1 values ( codint , codint , refre ) insert into col1 values ( codint , codint , refre ) insert into col1 values ( codint , codint , refre ) insert into col1 values ( codint , codint , refre )	0
Q_27	sql server table result to array in sql server tagint	C_27_2	col0 col1 col2 _ _ _ codint col3 col3 col4 , col5 codint col6 col6 col7 , col8 , col9	0
Q_27	sql server table result to array in sql server tagint	C_27_3	firstitems ( col0 , col1 ) as ( select tab0 . col0 , min ( tab0 . col2 ) from col3 group by tab0 . col0 )	0
Q_27	sql server table result to array in sql server tagint	C_27_4	subitemlist ( col0 , col1 , col2 ) as ( select tab0 . col0 , tab0 . col3 , codint from col4 join col5 col6 on ( tab0 . col3 = tab1 . col7 ) union all select tab0 . col0 , tab0 . col3 , tab2 . col2 + codint from col4 join col8 col9 on tab0 . col0 = tab2 . col0 and tab0 . col3 > col1 )	0
Q_27	sql server table result to array in sql server tagint	C_27_5	itemlist ( col0 , col1 , col2 ) as ( select col0 , col1 , max ( col2 ) from col3 group by col0 , col1 )	0
Q_27	sql server table result to array in sql server tagint	C_27_6	col0 col1 col2 _ _ _ codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_27	sql server table result to array in sql server tagint	C_27_7	subarraylist ( col0 , col1 , array , col2 ) as ( select tab0 . col0 , tab0 . col1 , cast ( tab1 . col3 as varchar ( max ) ) , tab0 . col2 from col4 col5 join col6 on tab0 . col1 = tab1 . col7 where tab0 . col2 = codint union all select tab0 . col0 , tab0 . col1 , tab2 . array + refre refre + cast ( tab1 . col3 as varchar ( max ) ) , tab0 . col2 from col4 col5 join col8 col9 on ( tab0 . col0 = tab2 . col0 and tab0 . col2 = tab2 . col2 + codint ) join col6 on ( tab0 . col1 = tab1 . col7 ) )	0
Q_27	sql server table result to array in sql server tagint	C_27_8	col0 col1 array col2 _ _ _ _ codint codint col3 codint codint codint col4 codint codint codint col4 , col5 codint codint codint col3 , col6 codint codint codint col3 , col6 , col7 codint	0
Q_27	sql server table result to array in sql server tagint	C_27_9	maxitems ( col0 , col1 ) as ( select col0 , max ( col2 ) from col3 group by col0 )	0
Q_27	sql server table result to array in sql server tagint	C_27_10	arraylist ( col0 , col1 ) as ( select tab0 . col0 , tab0 . array from col2 col3 join col4 col5 on ( tab0 . col0 = tab1 . col0 and tab0 . col6 = tab1 . col7 ) )	0
Q_27	sql server table result to array in sql server tagint	C_27_11	select tab0 . col0 , tab0 . col1 , tab1 . col2 from col3 col4 join col5 on tab0 . col0 = tab1 . col6 order by tab0 . col0	0
Q_28	drop a global temporary table	C_28_0	sql > drop col0 col1 drop col0 col1 * col2 at line codint col3 _ codint col0 or view col4 not col5	1
Q_28	drop a global temporary table	C_28_1	sql > create global temporary col0 t ( data varchar2 ( codint ) ) col0 tab0 .	0
Q_28	drop a global temporary table	C_28_2	sql > insert into col0 values ( refre ) codint row tab0 .	0
Q_28	drop a global temporary table	C_28_3	sql > drop col0 col1 drop col0 col1 * col2 at line codint col3 _ codint col4 to create , alter or drop col5 col6 on temporary col0 col7 in use	0
Q_28	drop a global temporary table	C_28_4	create or replace procedure col0 as col1 exception col2 exception_init ( col1 , _ codint ) col3 exception col2 exception_init ( col3 , _ codint ) begin execute immediate refre exception when col1 then tab0 . put_line ( refre ) when col3 then tab0 . put_line ( refre ) tab0 . put_line ( refre ) raise end col0	0
Q_28	drop a global temporary table	C_28_5	sql > drop col0 col1 col0 tab0 . sql > exec col2 col0 col1 col3 not col4 at time of tab1 . tab2 . col5 / sql procedure col6 tab3 .	0
Q_28	drop a global temporary table	C_28_6	sql > create global temporary col0 t ( data varchar2 ( codint ) ) col0 tab0 .	0
Q_28	drop a global temporary table	C_28_7	sql > insert into col0 values ( null ) codint row tab0 .	0
Q_28	drop a global temporary table	C_28_8	sql > exec col0 col1 col2 is col3 from col4 col5 col6 col7 col8 col9 begin col0 end * col10 at line codint col11 _ codint col12 to create , alter or drop col13 col14 on temporary col15 col16 in use col11 _ codint at refre , line codint col11 _ codint at line codint	0
Q_29	db architecture for retrieve item store in child category from parent category	C_29_0	create col0 categories ( col1 int unsigned not null auto_increment , col2 varchar ( codint ) not null , left int unsigned not null , right int unsigned not null , primary key ( col1 ) )	1
Q_29	db architecture for retrieve item store in child category from parent category	C_29_1	create col0 products ( col1 int unsigned not null auto_increment , col2 varchar ( codint ) not null , primary key ( col1 ) )	0
Q_29	db architecture for retrieve item store in child category from parent category	C_29_2	create col0 product_categories ( col1 int unsigned not null , col2 int unsigned not null , primary key ( col1 , col2 ) )	0
Q_29	db architecture for retrieve item store in child category from parent category	C_29_3	select tab0 . * from col0 as col1 left join col0 as col2 on tab1 . left < = tab2 . left and tab2 . right < = tab1 . right left join col3 as col4 on tab3 . col5 = tab2 . col6 left join col7 as col8 on tab3 . col9 = tab0 . col6 where tab1 . col6 = col6	0
Q_29	db architecture for retrieve item store in child category from parent category	C_29_4	update col0 set right = right + codint , left = if ( left > right , left + codint , left ) where right > = right	0
Q_29	db architecture for retrieve item store in child category from parent category	C_29_5	insert into col0 set left = right , right = right + codint , col1 = col1	0
Q_29	db architecture for retrieve item store in child category from parent category	C_29_6	delete from col0 where left > = left and right < = right	0
Q_29	db architecture for retrieve item store in child category from parent category	C_29_7	update col0 set left = if ( left > left , left ( right _ left + codint ) , left ) , right = right ( right _ left + codint ) where right > right	0
Q_30	get record from two table	C_30_0	select tab0 . col0 as col1 , tab0 . col2 as col3 , tab0 . col4 as col4 , dayofweek ( tab1 . col5 ) as col6 , time ( tab1 . col5 ) as col7 , time ( tab2 . col5 ) as col8 from col9 as col10 join col11 as col12 on tab0 . col0 = tab1 . col13 and tab1 . col14 = refre join col11 as col15 on tab0 . col0 = tab2 . col13 and tab2 . col14 = refre where tab1 . col16 = tab2 . col16	1
Q_30	get record from two table	C_30_1	select tab0 . col0 as col1 , tab0 . col2 as col3 , tab1 . col2 as col4 from col5 as col6 join col5 as col7 on tab1 . col0 = tab0 . col0 and tab0 . col8 = tab1 . col8 where tab0 . col9 = refre and tab1 . col9 = refre	0
Q_30	get record from two table	C_30_2	col0 col1 col2 codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint	0
Q_30	get record from two table	C_30_3	select tab0 . col0 as col1 , tab0 . col2 as col3 , cast ( null as col4 col5 to second ) as col6 from col7 as col8 where not exists ( select * from col7 as col9 where tab1 . col0 = tab0 . col0 and tab1 . col10 = tab0 . col10 and tab1 . col11 = refre ) and tab0 . col11 = refre	0
Q_30	get record from two table	C_30_4	col0 col1 col2 codint codint _ codint _ codint codint codint codint	0
Q_30	get record from two table	C_30_5	select tab0 . col0 as col1 , cast ( null as col2 col3 to second ) as col4 , tab0 . col5 as col6 from col7 as col8 where not exists ( select * from col7 as col9 where tab1 . col0 = tab0 . col0 and tab1 . col10 = tab0 . col10 and tab1 . col11 = refre ) and tab0 . col11 = refre	0
Q_30	get record from two table	C_30_6	col0 col1 col2 codint codint _ codint _ codint codint codint codint	0
Q_30	get record from two table	C_30_7	col0 col1 col2 codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint _ codint _ codint codint codint codint	0
Q_30	get record from two table	C_30_8	col0 col1 col2 col3 col4 col5 codint col6 col7 col8 codint codint codint codint codint codint codint col9 col7 col8 codint codint codint codint codint codint codint col10 is col8 codint codint codint codint col11 is codint codint codint	0
Q_30	get record from two table	C_30_9	create col0 fingerprints ( serial serial not null primary key , col1 integer not null unique , col2 char ( codint ) not null , col3 integer not null unique , col4 integer not null unique , col5 char ( codint ) not null , col6 char ( codint ) not null , col7 char ( codint ) not null check ( col7 in ( refre , refre ) ) ) insert into col8 values ( codint , codint , refre , codint , codint , refre , refre , refre ) insert into col8 values ( codint , codint , refre , codint , codint , refre , refre , refre ) insert into col8 values ( codint , codint , refre , codint , codint , refre , refre , refre ) insert into col8 values ( codint , codint , refre , codint , codint , refre , refre , refre )	0
Q_30	get record from two table	C_30_10	create col0 tblemployeepunch ( col1 serial not null primary key , col2 integer not null , col3 integer not null references fingerprints ( col4 ) , col5 char ( codint ) not null , col6 col7 col8 to second not null ) insert into col9 values ( codint , codint , codint , refre , refre ) insert into col9 values ( codint , codint , codint , refre , refre ) insert into col9 values ( codint , codint , codint , refre , refre ) insert into col9 values ( codint , codint , codint , refre , refre ) insert into col9 values ( codint , codint , codint , refre , refre ) insert into col9 values ( codint , codint , codint , refre , refre )	0
Q_30	get record from two table	C_30_11	create procedure dayofweek ( col0 date ) returning char ( codint ) col1 col2 integer col3 col2 = weekday ( col0 ) if col2 = codint then return refre end if if col2 = codint then return refre end if if col2 = codint then return refre end if if col2 = codint then return refre end if if col2 = codint then return refre end if if col2 = codint then return refre end if if col2 = codint then return refre end if return null end procedure	0
Q_30	get record from two table	C_30_12	create procedure time ( col0 col1 col2 to second ) returning col1 hour to second return extend ( col0 , hour to second ) end procedure	0
Q_31	how to implement temporal upward compatibility in my_sql	C_31_0	create col0 temporal ( col1 number not null , col2 timestamp not null , col3 timestamp , col4 char ( codint ) , unique ( col1 , col3 ) )	1
Q_31	how to implement temporal upward compatibility in my_sql	C_31_1	create view legacy ( col0 , col1 ) as select col0 , col1 from col2 where col3 is null	0
Q_31	how to implement temporal upward compatibility in my_sql	C_31_2	create trigger col0 instead of insert on col1 for each row begin insert into temporal ( col2 , col3 , col4 , col5 ) values ( tab0 . col2 , current_timestamp , null , tab0 . col5 ) end	0
Q_31	how to implement temporal upward compatibility in my_sql	C_31_3	create trigger col0 instead of update on col1 for each row begin update col2 set col3 = current_timestamp where col4 = tab0 . col4 insert into temporal ( col4 , col5 , col3 , col6 ) values ( tab0 . col4 , current_timestamp , null , tab0 . col6 ) end	0
Q_31	how to implement temporal upward compatibility in my_sql	C_31_4	create trigger col0 instead of delete on col1 for each row begin update col2 set col3 = current_timestamp where col4 = tab0 . col4 and col3 is null end	0
Q_31	how to implement temporal upward compatibility in my_sql	C_31_5	insert into legacy ( col0 , col1 ) values ( codint , refre ) select * from col2 select * from col3	0
Q_31	how to implement temporal upward compatibility in my_sql	C_31_6	update col0 set col1 = refre where col2 = codint select * from col0 select * from col3	0
Q_31	how to implement temporal upward compatibility in my_sql	C_31_7	delete from col0 where col1 = codint select * from col0 select * from col2	0
Q_32	database design _ efficient text search	C_32_0	+ _ + _ + col0 col1 + _ + _ + col2 codint col3 codint col4 codint col5 codint col6 codint col7 codint col8 codint + _ + _ +	1
Q_32	database design _ efficient text search	C_32_1	+ _ + _ + _ + col0 col1 col2 + _ + _ + _ + codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint + _ + _ + _ +	0
Q_32	database design _ efficient text search	C_32_2	select string_agg ( tab0 . col0 , refre refre order by tab1 . col1 ) as col2 from col3 as col4 join col5 col6 on tab0 . col7 = tab1 . col7 group by tab1 . col8	0
Q_32	database design _ efficient text search	C_32_3	+ _ + col0 + _ + col1 / col2 / col3 col4 / col2 / col1 / col5 col3 / col6 + _ +	0
Q_32	database design _ efficient text search	C_32_4	select string_agg ( tab0 . col0 , refre refre order by tab1 . col1 ) as col2 from col3 as col4 join col5 col6 on tab0 . col7 = tab1 . col7 group by col8 having count ( case when tab1 . col7 in ( codint , codint ) then codint end ) > codint	0
Q_32	database design _ efficient text search	C_32_5	+ _ + col0 + _ + col1 / col2 / col3 = > col4 col5 both col2 and col3 col6 / col2 / col1 / col7 = > col4 col5 only col2 col3 / col8 = > col4 col5 only col3 + _ +	0
Q_32	database design _ efficient text search	C_32_6	select string_agg ( tab0 . col0 , refre refre order by tab1 . col1 ) as col2 from col3 as col4 join col5 col6 on tab0 . col7 = tab1 . col7 group by col8 having count ( distinct case when tab1 . col7 in ( codint , codint ) then tab1 . col7 end ) = codint	0
Q_32	database design _ efficient text search	C_32_7	+ _ + col0 + _ + col1 / col2 / col3 = > col4 col5 both col2 and col3 + _ +	0
Q_33	compare date_time structs to find free slot	C_33_0	use col0 go create col1 tab0 . users ( col2 int identity ( codint , codint ) , col3 varchar ( codint ) ) create col1 tab0 . groups ( col4 int identity ( codint , codint ) , col5 varchar ( codint ) ) create col1 tab0 . membership ( col2 int , col4 int ) create col1 tab0 . [ event ] ( col6 int identity ( codint , codint ) , col7 col8 , col9 col8 , col10 int , col11 bit )	1
Q_33	compare date_time structs to find free slot	C_33_1	insert tab0 . users ( col0 ) select refre union all select refre insert tab0 . groups ( col1 ) select refre union all select refre insert tab0 . membership ( col2 , col3 ) select codint , codint union all select codint , codint insert tab0 . [ event ] ( col4 , col5 , col6 , col7 ) _ col8 col9 , col10 all col11 col12 on col9 specific date select refre , refre , codint , codint _ col8 col9 , col7 col12 every col13 union all select refre , refre , codint , codint _ col8 col9 , col7 col12 every tuesday ( col14 ) union all select refre , refre , codint , codint go	0
Q_33	compare date_time structs to find free slot	C_33_2	_ case codint col0 col1 col2 to col3 with col0 col4 on col1 col5 where _ both col6 are tab0 . exec tab1 . col7 col8 = codint , col9 = codint , col10 = codint , col11 = refre , _ no events for col12 col0 col13 = refre	0
Q_33	compare date_time structs to find free slot	C_33_3	_ case codint col0 col1 col2 to col3 with col0 col4 for col5 hour , on _ col1 col6 where col0 col1 col7 col8 from codint col9 to codint tab0 . exec tab1 . col10 col11 = codint , col12 = codint , col13 = codint , col14 = refre , _ col0 col1 col7 col5 col15 all _ col6 col16 col17 = refre	0
Q_33	compare date_time structs to find free slot	C_33_4	_ case codint col0 col1 col2 to col3 with col0 col4 for col5 col6 , on _ col1 col7 where col0 col1 col8 col1 col9 col10 from codint _ codint col11 exec tab0 . col12 col13 = codint , col14 = codint , col15 = codint , col16 = refre , _ col0 col1 col8 col1 col9 col10 col17 = refre	0
Q_33	compare date_time structs to find free slot	C_33_5	create function tab0 . splitints ( col0 varchar ( max ) ) returns col1 as return ( select col2 = convert ( int , col2 ) from ( select col2 = tab1 . tab2 . value ( refre refre refre refre refre refre [ 1 ] refre , refre ) from ( select col3 = convert ( xml , refre refre refre + replace ( col0 , refre refre , refre refre refre refre refre refre ) + refre refre refre refre ) . query ( refre ) ) as col4 cross col5 tab3 . nodes ( refre ) as x ( col6 ) ) as col7 where col2 is not null )	0
Q_33	compare date_time structs to find free slot	C_33_6	alter procedure tab0 . col0 col1 varchar ( max ) , _ col2 col3 col4 parameters col5 int , col6 col7 , col8 col7 as . where tab1 . col9 in _ col10 col11 col12 col13 col14 subquery ( select col15 from tab0 . col16 as col17 inner join tab0 . splitints ( col1 ) as col18 on tab2 . col19 = tab3 . col20 where ( tab4 . col21 > tab1 . col22 and tab4 . col23 < tab1 . col24 ) ) .	0
Q_33	compare date_time structs to find free slot	C_33_7	exec tab0 . col0 col1 = refre refre refre refre refre , col2 = codint , col3 = refre , col4 = refre	0
Q_34	how to apply tagint _valued_logic to sql query	C_34_0	col0 col1 = refre col2 col3 < codint col4 col3 > = codint	1
Q_34	how to apply tagint _valued_logic to sql query	C_34_1	true , if any col0 is true false , if all col1 are false unknown , in all col2 col3 col4	0
Q_34	how to apply tagint _valued_logic to sql query	C_34_2	col0 col1 col2 col0 = refre col3 col1 col2 col3 < > refre col4 col1 col2 col4 = null col5 col1 col2 col5 < codint col6 col1 col2 col6 > = codint col7 col1 col2 col7 = null	0
Q_34	how to apply tagint _valued_logic to sql query	C_34_3	col0 _ > col1 = codint col2 _ > col1 = codint col3 _ > col1 = codint / codint col4 _ > col5 = codint , col6 = codint col7 _ > col5 = codint , col6 = codint col8 _ > col5 = col6 = codint / codint	0
Q_34	how to apply tagint _valued_logic to sql query	C_34_4	col0 col1 col2 = codint , col3 = codint , col4 = codint _ > max ( codint , codint , codint ) = codint _ > true col0 col5 col2 = codint , col3 = codint , col4 = codint _ > max ( codint , codint , codint ) = codint _ > true col0 col6 col2 = codint , col3 = codint / codint , col4 = codint / codint _ > max ( codint , codint / codint , codint / codint ) = codint _ > true col7 col1 col2 = codint , col3 = codint , col4 = codint _ > max ( codint , codint , codint ) = codint _ > true col7 col5 col2 = codint , col3 = codint , col4 = codint _ > max ( codint , codint , codint ) = codint _ > true col7 col6 col2 = codint , col3 = codint / codint , col4 = codint / codint _ > max ( codint , codint / codint , codint / codint ) = codint / codint _ > unknown col8 col1 col2 = codint / codint , col3 = codint , col4 = codint _ > max ( codint / codint , codint , codint ) = codint _ > true col8 col5 col2 = codint / codint , col3 = codint , col4 = codint _ > max ( codint / codint , codint , codint ) = codint _ > true col8 col6 col2 = codint / codint , col3 = codint / codint , col4 = codint / codint _ > max ( codint / codint , codint / codint , codint / codint ) = codint / codint _ > unknown	0
Q_34	how to apply tagint _valued_logic to sql query	C_34_5	tab0 . col0 > tab0 . col1 or tab0 . col0 < = codint or tab0 . col1 > = codint	0
Q_34	how to apply tagint _valued_logic to sql query	C_34_6	tab0 . col0 < = codint , tab0 . col0 > codint , tab0 . col0 = unknown tab0 . col1 > = codint , tab0 . col1 < codint , tab0 . col1 = unknown tab0 . col0 _ tab0 . col1 > codint , tab0 . col0 _ tab0 . col1 < = codint , tab0 . col0 _ tab0 . col1 = unknown	0
Q_35	how can i rewrite a multi_column in clause to work on sq_lite	C_35_0	create temporary col0 pair ( col1 integer , col2 integer ) insert into pair ( col1 , col2 ) values ( codint , codint ) insert into pair ( col1 , col2 ) values ( codint , codint ) .	1
Q_35	how can i rewrite a multi_column in clause to work on sq_lite	C_35_1	select * from data where exists ( select null from col0 where tab0 . col1 = tab1 . col1 and tab0 . col2 = tab1 . col2 )	0
Q_35	how can i rewrite a multi_column in clause to work on sq_lite	C_35_2	select tab0 . * from data inner join col0 on tab1 . col1 = tab0 . col1 and tab1 . col2 = tab0 . col2	0
Q_35	how can i rewrite a multi_column in clause to work on sq_lite	C_35_3	select tab0 . * from data left join col0 on tab1 . col1 = tab0 . col1 and tab1 . col2 = tab0 . col2 where tab1 . col1 is null or tab1 . col2 is null	0
Q_35	how can i rewrite a multi_column in clause to work on sq_lite	C_35_4	select * from data where exists ( select null from ( select codint as col0 , codint as col1 union all select codint as col0 , codint as col1 union all select codint as col0 , codint as col1 ) as col2 where tab0 . col0 = tab1 . col0 and tab0 . col1 = tab1 . col1 )	0
Q_35	how can i rewrite a multi_column in clause to work on sq_lite	C_35_5	select tab0 . * from data inner join ( select codint as col0 , codint as col1 union all select codint as col0 , codint as col1 union all select codint as col0 , codint as col1 ) as col2 on tab1 . col0 = tab0 . col0 and tab1 . col1 = tab0 . col1	0
Q_35	how can i rewrite a multi_column in clause to work on sq_lite	C_35_6	select tab0 . * from data left join ( select codint as col0 , codint as col1 union all select codint as col0 , codint as col1 union all select codint as col0 , codint as col1 ) as col2 on tab1 . col0 = tab0 . col0 and tab1 . col1 = tab0 . col1 where tab1 . col0 is null or tab1 . col1 is null	0
Q_36	order by multiple column	C_36_0	with grp ( col0 , col1 , col2 , col3 ) as ( select cast ( null as varchar ( codint ) ) , col1 , max ( col3 ) as col2 , max ( col3 ) as col3 from col4 group by col1 ) select * from col5 order by col2 desc	1
Q_36	order by multiple column	C_36_1	col0 col1 col2 imptime ( null ) col3 codint _ codint _ codint codint codint number codint _ codint _ codint codint codint number ( null ) col4 codint _ codint _ codint codint codint number codint _ codint _ codint codint codint number	0
Q_36	order by multiple column	C_36_2	with grp ( col0 , col1 , col2 , col3 ) as ( select cast ( null as varchar ( codint ) ) , col1 , max ( col3 ) as col2 , max ( col3 ) as col3 from col4 group by col1 union all select tab0 . col0 , tab0 . col1 , tab1 . col2 , tab0 . col3 from col4 col5 inner join col6 col7 _ col8 on tab1 . col0 is null and tab1 . col1 = tab0 . col1 ) select col0 , col1 , col3 from col6 order by col2 desc , col0	0
Q_36	order by multiple column	C_36_3	col0 col1 imptime ( null ) col2 codint _ codint _ codint codint codint number col3 col2 codint _ codint _ codint codint codint number col4 col2 codint _ codint _ codint codint codint number col5 col2 codint _ codint _ codint codint codint number ( null ) col6 codint _ codint _ codint codint codint number col7 col6 codint _ codint _ codint codint codint number col8 col6 codint _ codint _ codint codint codint number col9 col6 codint _ codint _ codint codint codint number	0
Q_36	order by multiple column	C_36_4	with grp ( col0 , col1 , col2 , col3 ) as ( select cast ( null as varchar ( codint ) ) , col1 , max ( col3 ) as col2 , max ( col3 ) as col3 from col4 group by col1 union all select tab0 . col0 , tab0 . col1 , tab1 . col2 , tab0 . col3 from col4 col5 inner join col6 col7 _ col8 on tab1 . col0 is null and tab1 . col1 = tab0 . col1 ) select col0 , col1 , col3 from col6 order by col2 desc , case when col0 is null then codint _ col8 last else codint _ col9 first end , col0	0
Q_36	order by multiple column	C_36_5	col0 col1 col2 col3 col4 codint _ codint _ codint codint codint number col5 col4 codint _ codint _ codint codint codint number col6 col4 codint _ codint _ codint codint codint number ( null ) col4 codint _ codint _ codint codint codint number col7 col8 codint _ codint _ codint codint codint number col9 col8 codint _ codint _ codint codint codint number col10 col8 codint _ codint _ codint codint codint number ( null ) col8 codint _ codint _ codint codint codint number	0
Q_36	order by multiple column	C_36_6	with grp ( col0 , col1 , col2 , col3 ) as ( select cast ( null as varchar ( codint ) ) , col1 , max ( col3 ) as col2 , max ( col3 ) as col3 from col4 group by col1 union all select tab0 . col0 , tab0 . col1 , tab1 . col2 , tab0 . col3 from col4 col5 inner join col6 col7 _ col8 on tab1 . col0 is null and tab1 . col1 = tab0 . col1 ) select * from col6 order by col2 desc , col0	0
Q_36	order by multiple column	C_36_7	col0 col1 col2 timegroup ( null ) col3 codint _ codint _ codint codint codint number codint _ codint _ codint codint codint number col4 col3 codint _ codint _ codint codint codint number codint _ codint _ codint codint codint number col5 col3 codint _ codint _ codint codint codint number codint _ codint _ codint codint codint number col6 col3 codint _ codint _ codint codint codint number codint _ codint _ codint codint codint number ( null ) col7 codint _ codint _ codint codint codint number codint _ codint _ codint codint codint number col8 col7 codint _ codint _ codint codint codint number codint _ codint _ codint codint codint number col9 col7 codint _ codint _ codint codint codint number codint _ codint _ codint codint codint number col10 col7 codint _ codint _ codint codint codint number codint _ codint _ codint codint codint number	0
Q_37	join two my_sql table but with additional condition	C_37_0	select tab0 . col0 , tab0 . col1 , tab0 . col2 , tab0 . col3 , tab1 . col4 as col5 from col6 col7 left join ( select tab2 . col8 , tab2 . col4 from ( select col0 , min ( col9 ) as col10 from col11 group by col8 ) col12 left join col11 col13 on tab3 . col0 = tab2 . col0 ) col14 on tab0 . col0 = tab1 . col8 where tab0 . col2 in ( codint , codint , codint )	1
Q_37	join two my_sql table but with additional condition	C_37_1	select col0 , min ( col1 ) as col2 from col3 group by col4	0
Q_37	join two my_sql table but with additional condition	C_37_2	+ _ + _ + col0 col1 + _ + _ + codint codint codint codint codint codint codint codint + _ + _ + codint rows in set ( number col2 )	0
Q_37	join two my_sql table but with additional condition	C_37_3	select tab0 . col0 , tab0 . col1 from ( select col2 , min ( col3 ) as col4 from col5 group by col0 ) col6 left join col5 col7 on tab1 . col2 = tab0 . col2	0
Q_37	join two my_sql table but with additional condition	C_37_4	+ _ + _ + col0 col1 + _ + _ + codint col2 codint col3 codint col4 codint col5 + _ + _ + codint rows in set ( number col6 )	0
Q_37	join two my_sql table but with additional condition	C_37_5	select tab0 . col0 , tab0 . col1 , tab0 . col2 , tab0 . col3 , tab1 . col4 as col5 from col6 col7 left join ( select tab2 . col8 , tab2 . col4 from ( select col0 , min ( col9 ) as col10 from col11 group by col8 ) col12 left join col11 col13 on tab3 . col0 = tab2 . col0 ) col14 on tab0 . col0 = tab1 . col8 where tab0 . col2 in ( codint , codint , codint )	0
Q_37	join two my_sql table but with additional condition	C_37_6	+ _ + _ + _ + _ + _ + col0 col1 col2 col3 col4 + _ + _ + _ + _ + _ + codint col5 codint number col6 codint col7 codint number col8 codint col9 codint number col10 + _ + _ + _ + _ + _ + codint rows in set ( number col11 )	0
Q_38	how to use unique column value as input into another select statement	C_38_0	create col0 sentai ( col1 varchar ( codint ) , col2 varchar ( codint ) , col3 int not null ) insert into sentai ( col1 , col2 , col3 ) values ( refre , refre , codint ) , ( refre , refre , codint ) , ( refre , refre , codint ) , ( refre , refre , codint ) , ( refre , refre , codint ) , ( refre , refre , codint ) , ( refre , refre , codint ) , ( refre , refre , codint ) , ( refre , refre , codint ) , ( refre , refre , codint ) , ( refre , refre , codint ) , ( refre , refre , codint ) , ( refre , refre , codint )	1
Q_38	how to use unique column value as input into another select statement	C_38_1	select * , col0 = col0 + codint as col0 from ( col1 col2 , ( select col0 = codint ) as col3 ) order by tab0 . col4 , tab0 . col5 desc	0
Q_38	how to use unique column value as input into another select statement	C_38_2	col0 col1 col2 col3 = codint col3 _ _ _ _ _ col4 col5 codint codint codint col4 col6 codint codint codint col4 col7 codint codint codint col4 col8 codint codint codint col9 col10 codint codint codint col9 col11 codint codint codint col9 col12 codint codint codint col9 col13 codint codint codint col14 col15 col16 col8 codint codint codint col14 col15 col17 col18 codint codint codint col14 col15 col19 codint codint codint col14 col15 col20 codint codint codint col14 col15 col21 codint codint codint	0
Q_38	how to use unique column value as input into another select statement	C_38_3	select * , col0 = if ( col1 = tab0 . col2 , col0 + codint , codint ) as col0 , col1 = tab0 . col2 from ( col3 col4 , ( select col1 = null , col0 = codint ) as col5 ) order by tab0 . col2 , tab0 . col6 desc	0
Q_38	how to use unique column value as input into another select statement	C_38_4	select tab0 . col0 , tab0 . col1 , tab0 . col2 from ( select * , col3 = if ( col4 = tab1 . col0 , col3 + codint , codint ) as col3 , col4 = tab1 . col0 from ( col5 col6 , ( select col4 = null , col3 = codint ) as col7 ) order by tab1 . col0 , tab1 . col2 desc ) as col8 where tab0 . col3 < = codint order by tab0 . col0 , tab0 . col2 desc	0
Q_38	how to use unique column value as input into another select statement	C_38_5	col0 col1 col2 _ _ _ col3 col4 codint col3 col5 codint col3 col6 codint col7 col8 codint col7 col9 codint col7 col10 codint col11 col12 col13 col14 codint col11 col12 col15 col16 codint col11 col12 col17 codint	0
Q_38	how to use unique column value as input into another select statement	C_38_6	with col0 as ( select row_number ( ) over col1 as col2 , * from col3 window col1 as ( partition by col4 order by col5 desc ) ) select * from col0 where col2 < = codint	0
Q_38	how to use unique column value as input into another select statement	C_38_7	col0 col1 col2 col3 _ _ _ _ codint col4 col5 codint codint col4 col6 codint codint col4 col7 codint codint col8 col9 codint codint col8 col10 codint codint col8 col11 codint codint col12 col13 col14 col15 codint codint col12 col13 col16 col17 codint codint col12 col13 col18 codint	0
Q_39	method of find gap in time series data in my_sql	C_39_0	select cast ( date_format ( col0 , refre ) as col1 ) hour , count ( * ) col2 from col3 group by cast ( date_format ( col0 , refre ) as col1 )	1
Q_39	method of find gap in time series data in my_sql	C_39_1	cast ( date_format ( col0 , refre ) as col1 )	0
Q_39	method of find gap in time series data in my_sql	C_39_2	select cast ( date_format ( col0 , refre ) as col1 ) hour , count ( * ) col2 from col3 where col0 > = current_date _ interval codint col4 and col0 < current_date group by cast ( date_format ( col0 , refre ) as col1 )	0
Q_39	method of find gap in time series data in my_sql	C_39_3	select col0 = col0 + codint as col1 , tab0 . col2 , tab0 . col3 from ( select col2 , col3 from col4 order by col2 ) col5 , ( select col0 = codint ) col6	0
Q_39	method of find gap in time series data in my_sql	C_39_4	select tab0 . col0 , tab0 . col1 , tab0 . col2 , timediff ( tab1 . col2 , tab0 . col2 ) interval from ( / * col3 col4 * / ) col5 join ( / * col6 col3 col4 * / ) col7 on ( tab1 . col0 _ codint = tab0 . col0 )	0
Q_39	method of find gap in time series data in my_sql	C_39_5	select tab0 . col0 , tab0 . col1 , tab0 . col2 , timediff ( tab1 . col2 , tab0 . col2 ) interval from ( select col3 = col3 + codint as col0 , tab2 . col1 , tab2 . col2 from ( select col1 , col2 from col4 order by col1 ) col5 , ( select col3 = codint ) col6 ) col7 join ( select col8 = col8 + codint as col0 , tab2 . col1 , tab2 . col2 from ( select col1 , col2 from col4 order by col1 ) col5 , ( select col8 = codint ) col6 ) col9 on ( tab1 . col0 _ codint = tab0 . col0 )	0
Q_39	method of find gap in time series data in my_sql	C_39_6	select col0 = col0 + codint as col1 , tab0 . col2 , tab0 . col3 from ( select col2 , col3 from col4 order by col2 where col2 > = current_date _ interval codint col5 and col2 < current_date / * col6 col7 not col8 * / ) col9 , ( select col0 = codint ) col10	0
Q_40	use my_sql function to format column name	C_40_0	select col0 , sum ( if ( col1 = date ( now ( ) ) _ interval codint col2 , col3 , codint ) ) col4 , sum ( if ( col1 = date ( now ( ) ) _ interval codint col2 , col3 , codint ) ) col5 , sum ( if ( col1 = date ( now ( ) ) _ interval codint col2 , col3 , codint ) ) col6 from col7 group by col0	1
Q_40	use my_sql function to format column name	C_40_1	select * from ( select col0 , date_format ( col0 , refre ) col1 from ( select distinct col2 col0 from col3 ) col4 ) col5	0
Q_40	use my_sql function to format column name	C_40_2	col0 > select * from col1 + _ + _ + _ + _ + col2 col3 col4 col5 + _ + _ + _ + _ + codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint + _ + _ + _ + _ + codint rows in set ( number col6 ) col0 >	0
Q_40	use my_sql function to format column name	C_40_3	col0 > select col1 , _ > sum ( if ( col2 = date ( now ( ) ) _ interval codint col3 , col4 , codint ) ) col5 , _ > sum ( if ( col2 = date ( now ( ) ) _ interval codint col3 , col4 , codint ) ) col6 , _ > sum ( if ( col2 = date ( now ( ) ) _ interval codint col3 , col4 , codint ) ) col7 _ > from col8 _ > group by col1 + _ + _ + _ + _ + col1 col5 col6 col7 + _ + _ + _ + _ + codint codint codint codint codint codint codint codint codint codint codint codint + _ + _ + _ + _ + codint rows in set ( number col9 ) col0 >	0
Q_40	use my_sql function to format column name	C_40_4	col0 > select * from _ > ( select col1 , date_format ( col1 , refre ) col2 from _ > ( select distinct col3 col1 from col4 ) col5 ) col6 + _ + _ + col1 col2 + _ + _ + codint _ codint _ codint col7 codint _ codint codint _ codint _ codint col8 codint _ codint codint _ codint _ codint col9 codint _ codint codint _ codint _ codint col10 codint _ codint + _ + _ + codint rows in set ( number col11 ) col0 >	0
Q_40	use my_sql function to format column name	C_40_5	col0 > select concat ( refre refre , col1 , refre ) _ > into col2 from _ > ( select group_concat ( concat ( refre refre refre refre , col3 , refre refre refre refre refre refre refre refre refre refre ) ) col1 _ > from ( select col3 , date_format ( col3 , refre ) col4 from _ > ( select distinct col5 col3 from col6 ) col7 ) col8 ) col9 col10 col11 , codint row affected ( number col12 ) col0 > select col2 col13 * * * * * * * * * * * * * * * * * * * * * * * * * * * codint . row * * * * * * * * * * * * * * * * * * * * * * * * * * * col2 select col14 , sum ( if ( col5 = refre , col15 , codint ) ) as refre , sum ( if ( col5 = refre , col15 , codint ) ) as refre , sum ( if ( col5 = refre , col15 , codint ) ) as refre , sum ( if ( col5 = refre , col15 , codint ) ) as refre from col6 group by col14 codint row in set ( number col12 ) col0 >	0
Q_40	use my_sql function to format column name	C_40_6	col0 > prepare col1 from col2 col3 col4 , codint rows affected ( number col5 ) statement col6 col0 > execute col1 + _ + _ + _ + _ + _ + col7 col8 codint _ codint col9 codint _ codint col10 codint _ codint col11 codint _ codint + _ + _ + _ + _ + _ + codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint + _ + _ + _ + _ + _ + codint rows in set ( number col5 ) col0 > deallocate prepare col1 col3 col4 , codint rows affected ( number col5 ) col0 >	0
Q_41	my_sql_ query with repetitive fix id range	C_41_0	create col0 cc ( col1 int , col2 int ) insert into col3 values ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) select tab0 . * from col3 order by codint , codint	1
Q_41	my_sql_ query with repetitive fix id range	C_41_1	select col0 from col1 group by col0 order by col0	0
Q_41	my_sql_ query with repetitive fix id range	C_41_2	select tab0 . col0 , tab1 . col1 from ( select codint as col1 union all select codint union all select codint union all select codint ) col2 join ( select tab2 . col0 from col3 col3 group by tab2 . col0 order by tab2 . col0 ) col4 order by tab0 . col0 , tab1 . col1	0
Q_41	my_sql_ query with repetitive fix id range	C_41_3	select tab0 . col0 , tab0 . col1 from col2 col3 order by tab0 . col4 , tab0 . col1	0
Q_41	my_sql_ query with repetitive fix id range	C_41_4	select col0 = if ( tab0 . col1 = col2 , col0 + codint , codint ) as col0 , col2 = tab0 . col1 as col1 , tab0 . col3 from ( select col0 = codint , col2 = null ) col4 join ( select tab1 . col1 , tab1 . col3 from col5 col6 order by tab1 . col1 , tab1 . col3 ) col7	0
Q_41	my_sql_ query with repetitive fix id range	C_41_5	select tab0 . * , tab1 . * from ( ) col0 left join ( ) col1 on tab1 . col2 = tab0 . col2 and tab1 . col3 = tab0 . col4	0
Q_41	my_sql_ query with repetitive fix id range	C_41_6	select tab0 . col0 , tab1 . col1 from ( select tab2 . col0 , tab3 . col2 from ( select codint as col2 union all select codint union all select codint union all select codint ) col3 join ( select tab4 . col0 from col4 col4 group by tab4 . col0 order by tab4 . col0 ) col5 order by tab2 . col0 , tab3 . col2 ) col6 left join ( select col7 = if ( tab5 . col0 = col8 , col7 + codint , codint ) as col7 , col8 = tab5 . col0 as col0 , tab5 . col1 from ( select col7 = codint , col8 = null ) col9 join ( select tab6 . col0 , tab6 . col1 from col4 col10 order by tab6 . col0 , tab6 . col1 ) col11 ) col12 on tab1 . col0 = tab0 . col0 and tab1 . col7 = tab0 . col2 order by tab0 . col0 , tab0 . col2	0
Q_41	my_sql_ query with repetitive fix id range	C_41_7	select tab0 . col0 as col1 , tab0 . col2 , tab1 . col3 from ( select col0 = col0 + codint as col0 , tab2 . col2 , tab3 . col4 from ( select col0 = codint ) col5 join ( select codint as col4 union all select codint union all select codint union all select codint ) col6 join ( select tab4 . col2 from col7 col7 group by tab4 . col2 order by tab4 . col2 ) col8 order by tab2 . col2 , tab3 . col4 ) col9 left join ( select col10 = if ( tab5 . col2 = col11 , col10 + codint , codint ) as col10 , col11 = tab5 . col2 as col2 , tab5 . col3 from ( select col10 = codint , col11 = null ) col12 join ( select tab6 . col2 , tab6 . col3 from col7 col13 order by tab6 . col2 , tab6 . col3 ) col14 ) col15 on tab1 . col2 = tab0 . col2 and tab1 . col10 = tab0 . col4 order by tab0 . col2 , tab0 . col4	0
Q_42	how to select recursively from query result	C_42_0	update col0 set col1 = codint where col2 = codint	1
Q_42	how to select recursively from query result	C_42_1	{ col0 codint , col1 codint , col2 col3 }	0
Q_42	how to select recursively from query result	C_42_2	{ col0 codint , col1 codint , col2 col3 }	0
Q_42	how to select recursively from query result	C_42_3	{ col0 codint , col1 codint , col2 col3 }	0
Q_42	how to select recursively from query result	C_42_4	with col0 as ( select col1 , col2 , col3 , class , col4 , col5 , codint col6 from col7 left join col8 on col1 = col9 and col2 = col10 where col3 like refre union all select tab0 . col1 , tab0 . col2 , tab0 . col3 , tab0 . class , tab1 . col4 , tab1 . col5 , col11 + codint from col0 col12 inner join col8 col13 on tab0 . col4 = tab1 . col9 and tab0 . col5 = tab1 . col10 ) select distinct tab2 . col1 , tab2 . col2 , tab0 . col3 , tab0 . class from col0 col14 inner join col7 col12 on coalesce ( tab2 . col4 , tab2 . col1 ) = tab0 . col1 and coalesce ( tab2 . col5 , tab2 . col2 ) = tab0 . col2	0
Q_42	how to select recursively from query result	C_42_5	with col0 as ( select col1 , col2 , col3 , class , col4 , col5 , codint col6 from col7 left join col8 on col1 = col9 and col2 = col10 where col3 like refre union all select tab0 . col1 , tab0 . col2 , tab0 . col3 , tab0 . class , tab1 . col4 , tab1 . col5 , col11 + codint from col0 col12 inner join col8 col13 on tab0 . col4 = tab1 . col9 and tab0 . col5 = tab1 . col10 ) , col14 as ( select tab2 . col1 , tab2 . col2 , tab0 . col3 , tab0 . class , col11 , max ( col11 ) over ( partition by tab2 . col1 , tab2 . col2 ) col15 from col0 col16 inner join col7 col12 on coalesce ( tab2 . col4 , tab2 . col1 ) = tab0 . col1 and coalesce ( tab2 . col5 , tab2 . col2 ) = tab0 . col2 ) select col1 , col2 , col3 , class from col14 where col11 = col17	0
Q_42	how to select recursively from query result	C_42_6	{ col0 codint , col1 codint , col2 col3 }	0
Q_42	how to select recursively from query result	C_42_7	{ col0 codint , col1 codint , col2 col3 }	0
Q_43	mysql select all row from table base on last update	C_43_0	select * from col0 where ( select if ( col1 < > col2 , codint , codint ) from col0 where col3 = codint )	1
Q_43	mysql select all row from table base on last update	C_43_1	select tab0 . * from col0 col1 inner join col0 col2 on tab1 . col3 = codint and tab1 . col4 < > col5	0
Q_43	mysql select all row from table base on last update	C_43_2	select count ( * ) from col0 where ( select if ( col1 < > col2 , codint , codint ) from col0 where col3 = codint )	0
Q_43	mysql select all row from table base on last update	C_43_3	select col0 from col1 where ( select if ( col2 < > col3 , codint , codint ) from col1 where col0 = codint ) limit codint	0
Q_43	mysql select all row from table base on last update	C_43_4	select if ( col0 < > col1 , codint , codint ) from col2 where col3 = codint	0
Q_43	mysql select all row from table base on last update	C_43_5	select if ( col0 < > col1 , codint , codint ) from col2	0
Q_43	mysql select all row from table base on last update	C_43_6	select col0 from col1 where col0 > col2 limit codint	0
Q_44	delete duplicate with no primary key	C_44_0	create col0 col1 as select max ( col2 ) as date , col3 , count ( * ) as col4 from col5 tab0 . group by col3 having col4 > codint	1
Q_44	delete duplicate with no primary key	C_44_1	"_ create col0 col1 col2 create col2 col3 as select * from col4 where false create unique col5 col6 on deduped ( col7 ) _ drop col8 rows , col9 col10 col11 "" col12 col13 insert ignore into col3 select * from col4 alter col2 col4 rename to col14 alter col2 col3 rename to col4 _ col15 copy all indexes from col4 on tab0 ."	0
Q_44	delete duplicate with no primary key	C_44_2	select * from col0 order by col1 , col2 is null	0
Q_44	delete duplicate with no primary key	C_44_3	create col0 producttable ( col1 varchar ( codint ) , col2 varchar ( codint ) ) insert into col3 values ( refre , refre ) insert into col3 values ( refre , refre ) insert into col3 values ( refre , refre )	0
Q_44	delete duplicate with no primary key	C_44_4	insert into col0 values ( refre , null ) insert into col0 values ( refre , null )	0
Q_44	delete duplicate with no primary key	C_44_5	select col0 , count ( * ) as col1 from col2 group by col0 having col1 > codint	0
Q_44	delete duplicate with no primary key	C_44_6	select tab0 . col0 from col1 right join ( select col0 , count ( * ) as col2 from col1 group by col0 having col2 > codint ) as col2 on ( tab1 . col0 = tab0 . col0 and tab1 . col3 is not null ) where tab1 . col3 is null	0
Q_44	delete duplicate with no primary key	C_44_7	insert into col0 values ( refre , null ) , ( refre , null )	0
Q_44	delete duplicate with no primary key	C_44_8	create temporary col0 col1 as select col2 , count ( * ) as col3 from col4 group by col2 having col3 > codint delete col4 from col4 join col1 using ( col2 ) where col5 is null	0
Q_45	average over a timeframe with miss data	C_45_0	select tab0 . col0 , avg ( tab0 . col1 ) col2 from ( select tab1 . uid , max ( tab2 . col3 ) col4 from ( select distinct uid from col5 ) col6 cross join ( select refre col7 union all select refre union all select refre union all select refre ) col8 join col5 col9 on tab1 . uid = tab2 . uid and time ( tab0 . col7 ) > = time ( tab2 . col3 ) group by tab1 . uid , tab0 . col7 ) col6 join col5 col8 on tab1 . uid = tab0 . uid and tab1 . col4 = tab0 . col3 group by tab0 . uid , tab0 . col0	1
Q_45	average over a timeframe with miss data	C_45_1	select tab0 . uid , tab1 . col0 from ( select distinct uid from col1 ) col2 cross join ( select refre col0 union all select refre union all select refre union all select refre ) col3 order by tab1 . col0 , tab0 . uid desc _ col4 for col5 col6	0
Q_45	average over a timeframe with miss data	C_45_2	uid col0 _ codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_45	average over a timeframe with miss data	C_45_3	select tab0 . uid , tab1 . col0 , tab2 . * from ( select distinct uid from col1 ) col2 cross join ( select refre col0 union all select refre union all select refre union all select refre ) col3 join col1 col4 on tab0 . uid = tab2 . uid and time ( tab1 . col0 ) > = time ( tab2 . col5 ) order by tab1 . col0 , tab0 . uid desc , tab2 . col5 _ col6 for col7 col8	0
Q_45	average over a timeframe with miss data	C_45_4	select tab0 . uid , tab1 . col0 , max ( tab2 . col1 ) col2 from ( select distinct uid from col3 ) col4 cross join ( select refre col0 union all select refre union all select refre union all select refre ) col5 join col3 col6 on tab0 . uid = tab2 . uid and time ( tab1 . col0 ) > = time ( tab2 . col1 ) group by tab0 . uid , tab1 . col0 order by tab1 . col0 , tab0 . uid desc _ col7 , for col8 col9	0
Q_45	average over a timeframe with miss data	C_45_5	uid col0 col1 _ codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint codint codint _ codint _ codint codint codint codint	0
Q_45	average over a timeframe with miss data	C_45_6	select tab0 . uid , tab0 . col0 , tab1 . col1 from ( select tab0 . uid , max ( tab2 . col2 ) col0 from ( select distinct uid from col3 ) col4 cross join ( select refre col5 union all select refre union all select refre union all select refre ) col6 join col3 col7 on tab0 . uid = tab2 . uid and time ( tab1 . col5 ) > = time ( tab2 . col2 ) group by tab0 . uid , tab1 . col5 ) col4 join col3 col6 on tab0 . uid = tab1 . uid and tab0 . col0 = tab1 . col2 order by tab0 . uid desc _ col8 col9 col10	0
Q_45	average over a timeframe with miss data	C_45_7	uid col0 col1 _ codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint	0
Q_45	average over a timeframe with miss data	C_45_8	select tab0 . col0 , avg ( tab0 . col1 ) col2 from ( select tab1 . uid , max ( tab2 . col3 ) col4 from ( select distinct uid from col5 ) col6 cross join ( select refre col7 union all select refre union all select refre union all select refre ) col8 join col5 col9 on tab1 . uid = tab2 . uid and time ( tab0 . col7 ) > = time ( tab2 . col3 ) group by tab1 . uid , tab0 . col7 ) col6 join col5 col8 on tab1 . uid = tab0 . uid and tab1 . col4 = tab0 . col3 group by tab0 . uid , tab0 . col0	0
Q_45	average over a timeframe with miss data	C_45_9	col0 col1 _ col2 codint number col2 codint number col2 codint number col2 codint number	0
Q_46	create query that return id if condition be match in row from two table	C_46_0	database col0 col1 > create col2 carpet ( col3 int ( codint ) , col4 varchar ( codint ) , col5 varchar ( codint ) ) col6 col7 , codint rows affected ( number col8 ) col1 > create col2 curtain ( col3 int ( codint ) , col4 varchar ( codint ) , col5 varchar ( codint ) ) col6 col7 , codint rows affected ( number col8 )	1
Q_46	create query that return id if condition be match in row from two table	C_46_1	col0 > select * from col1 + _ + _ + _ + col2 col3 col4 + _ + _ + _ + codint col5 col6 col7 codint col5 col8 codint col9 col6 col7 codint col9 col6 col10 + _ + _ + _ + codint rows in set ( number col11 ) col0 > select * from col12 + _ + _ + _ + col2 col3 col4 + _ + _ + _ + codint col13 col14 codint col15 col16 codint col15 col6 col7 codint col15 col6 col17 + _ + _ + _ + codint rows in set ( number col11 )	0
Q_46	create query that return id if condition be match in row from two table	C_46_2	col0 > select col1 , col2 , col3 from col4 _ > union _ > select col1 , col2 , col3 from col5 + _ + _ + _ + col1 col2 col3 + _ + _ + _ + codint col6 col7 col8 codint col6 col9 codint col10 col7 col8 codint col10 col7 col11 codint col12 col13 codint col14 col15 codint col14 col7 col8 codint col14 col7 col16 + _ + _ + _ + codint rows in set ( number col17 )	0
Q_46	create query that return id if condition be match in row from two table	C_46_3	col0 > select col1 , col2 , col3 from col4 where col3 = refre _ > union _ > select col1 , col2 , col3 from col5 where col3 = refre + _ + _ + _ + col1 col2 col3 + _ + _ + _ + codint col6 col7 col8 codint col9 col7 col8 codint col10 col7 col8 + _ + _ + _ + codint rows in set ( number col11 )	0
Q_46	create query that return id if condition be match in row from two table	C_46_4	col0 > select tab0 . col1 , tab0 . col2 , tab0 . col3 , tab1 . col1 , tab1 . col2 _ > from col4 col5 join col6 col7 on tab0 . col3 = tab1 . col3 + _ + _ + _ + _ + _ + col1 col2 col3 col1 col2 + _ + _ + _ + _ + _ + codint col8 col9 col10 codint col11 codint col8 col9 col10 codint col12 + _ + _ + _ + _ + _ + codint rows in set ( number col13 )	0
Q_46	create query that return id if condition be match in row from two table	C_46_5	col0 > select * from col1 + _ + _ + _ + col2 col3 col4 + _ + _ + _ + codint col5 col6 codint col7 col8 codint col7 col9 col10 codint col7 col9 col11 codint col12 col8 codint col13 col14 + _ + _ + _ + codint rows in set ( number col15 ) col0 > select * from col16 + _ + _ + _ + col2 col3 col4 + _ + _ + _ + codint col12 col9 col10 codint col12 col14 codint col17 col9 col10 codint col17 col9 col18 codint col13 col9 col11 + _ + _ + _ + codint rows in set ( number col15 )	0
Q_46	create query that return id if condition be match in row from two table	C_46_6	col0 > select tab0 . col1 , tab0 . col2 , tab0 . col3 , tab1 . col1 , tab1 . col2 _ > from col4 col5 join col6 col7 on tab0 . col3 = tab1 . col3 + _ + _ + _ + _ + _ + col1 col2 col3 col1 col2 + _ + _ + _ + _ + _ + codint col8 col9 col10 codint col11 codint col8 col9 col10 codint col12 codint col8 col9 col13 codint col14 codint col14 col15 codint col11 + _ + _ + _ + _ + _ + codint rows in set ( number col16 )	0
Q_46	create query that return id if condition be match in row from two table	C_46_7	col0 > select tab0 . col1 , tab0 . col2 , tab0 . col3 , tab1 . col1 , tab1 . col2 _ > from col4 col5 join col6 col7 on tab0 . col3 = tab1 . col3 _ > where tab0 . col3 = refre + _ + _ + _ + _ + _ + col1 col2 col3 col1 col2 + _ + _ + _ + _ + _ + codint col8 col9 col10 codint col11 codint col8 col9 col10 codint col12 + _ + _ + _ + _ + _ + codint rows in set ( number col13 )	0
Q_46	create query that return id if condition be match in row from two table	C_46_8	col0 > select tab0 . col1 , tab0 . col2 , tab0 . col3 , tab1 . col1 , tab1 . col2 _ > from col4 col5 _ > join col6 col7 on tab0 . col3 = tab1 . col3 _ > and tab0 . col1 = tab1 . col1 _ > where tab0 . col3 = refre + _ + _ + _ + _ + _ + col1 col2 col3 col1 col2 + _ + _ + _ + _ + _ + codint col8 col9 col10 codint col11 + _ + _ + _ + _ + _ + codint row in set ( number col12 )	0
Q_46	create query that return id if condition be match in row from two table	C_46_9	col0 > select tab0 . col1 , tab0 . col2 , tab0 . col3 , tab1 . col1 , tab1 . col2 _ > from col4 col5 _ > join col6 col7 on tab0 . col3 = tab1 . col3 _ > and tab0 . col1 = tab1 . col1 _ > and tab0 . col2 = tab1 . col2 _ > where tab0 . col3 = refre col8 set ( number col9 )	0
Q_47	in sql_alchemy how to access a reference property in a query when have multiple relationship	C_47_0	tab0 . query ( col0 ) . filter ( tab1 . tab2 . col1 > number )	1
Q_47	in sql_alchemy how to access a reference property in a query when have multiple relationship	C_47_1	tab0 . query ( col0 ) . join ( tab1 . col1 ) . filter ( tab2 . col2 > number )	0
Q_47	in sql_alchemy how to access a reference property in a query when have multiple relationship	C_47_2	col0 = tab0 . query ( tab1 . col1 ) . where ( tab1 . col2 = = tab2 . col3 ) . correlate ( col4 ) . as_scalar ( ) tab0 . query ( col4 ) . filter ( col0 > number )	0
Q_47	in sql_alchemy how to access a reference property in a query when have multiple relationship	C_47_3	tab0 . query ( col0 ) . filter ( tab1 . tab2 . has ( tab2 . col1 > number ) )	0
Q_47	in sql_alchemy how to access a reference property in a query when have multiple relationship	C_47_4	from col0 col1 exists tab0 . query ( col2 ) . filter ( exists ( ) . where ( tab1 . col3 = = tab2 . col4 , tab2 . col5 > number ) )	0
Q_47	in sql_alchemy how to access a reference property in a query when have multiple relationship	C_47_5	tab0 . query ( tab1 . col0 , tab2 . abs ( tab3 . col1 _ tab4 . tab3 . col1 ) ) . filter ( tab4 . tab3 . col1 > number )	0
Q_47	in sql_alchemy how to access a reference property in a query when have multiple relationship	C_47_6	from tab0 . col0 col1 col2 col3 = aliased ( col4 ) tab1 . query ( tab2 . col5 , tab3 . abs ( tab4 . col6 _ tab5 . col6 ) ) . join ( tab2 . col4 ) . join ( tab2 . col7 ) . join ( col3 , tab6 . col4 ) . filter ( tab5 . col6 > number )	0
Q_47	in sql_alchemy how to access a reference property in a query when have multiple relationship	C_47_7	select tab0 . col0 as col1 , abs ( tab1 . col2 _ tab2 . col2 ) as col3 from col4 join col5 on tab1 . col6 = tab0 . col7 join col8 on tab3 . col6 = tab0 . col9 join col5 as col10 on tab2 . col6 = tab3 . col7 where tab2 . col2 > col11	0
Q_47	in sql_alchemy how to access a reference property in a query when have multiple relationship	C_47_8	class association ( col0 ) col1 = refre col2 = column ( integer , foreignkey ( refre ) , col3 = true ) col4 = column ( integer , foreignkey ( refre ) , col3 = true ) col5 = column ( float ) tab0 . col6 col7 a_property_special ( self ) return tab1 . tab2 . col8 tab3 . col9 col7 a_property_special ( col10 ) return select ( col11 ) . where ( tab2 . col12 = = tab4 . col2 ) . as_scalar ( ) tab0 . col6 col7 b_a_property_special ( self ) return tab1 . tab5 . tab2 . col8 tab6 . col9 col7 b_a_property_special ( col10 ) return select ( col11 ) . where ( tab2 . col12 = = tab5 . col2 ) . where ( tab5 . col12 = = tab4 . col4 ) . as_scalar ( ) tab7 . query ( tab8 . col5 , tab9 . abs ( tab8 . col8 _ tab8 . col13 ) )	0
Q_47	in sql_alchemy how to access a reference property in a query when have multiple relationship	C_47_9	select tab0 . col0 as col1 , abs ( ( select tab1 . col2 from col3 where tab1 . col4 = tab0 . col5 ) _ ( select tab1 . col2 from col3 , col6 where tab1 . col4 = tab2 . col5 and tab2 . col4 = tab0 . col7 ) ) as col8 from col9	0
Q_48	how to select similar set in sql	C_48_0	select distinct tab0 . col0 as col1 from col2 as col3 join col2 as col4 on tab1 . col5 = tab0 . col5 and tab1 . col0 = < col6 order col1 > where tab0 . col0 = < col6 order col1 >	1
Q_48	how to select similar set in sql	C_48_1	select tab0 . col0 as col1 , count ( * ) as col2 from col3 as col4 join col3 as col5 on tab1 . col6 = tab0 . col6 and tab1 . col0 = < col7 order col1 > where tab0 . col0 = < col7 order col1 > group by tab0 . col0	0
Q_48	how to select similar set in sql	C_48_2	select col0 as col1 , count ( * ) as col2 from col3 group by col0	0
Q_48	how to select similar set in sql	C_48_3	select tab0 . col0 from ( select col1 as col0 , count ( * ) as col2 from col3 group by col1 ) as col4 join ( select tab1 . col1 as col0 , count ( * ) as col5 from col3 as col6 join col3 as col7 on tab2 . col8 = tab1 . col8 and tab2 . col1 = < col9 order col0 > where tab1 . col1 = < col9 order col0 > group by tab1 . col1 ) as col10 on tab0 . col0 = tab3 . col0 and tab0 . col2 = tab3 . col5	0
Q_48	how to select similar set in sql	C_48_4	select tab0 . col0 , tab0 . col1 , tab1 . col0 , tab1 . col2 , tab2 . col0 , tab2 . col1 from ( select col3 as col0 , count ( * ) as col1 from col4 group by col3 ) as col5 join ( select tab3 . col3 as col0 , count ( * ) as col2 from col4 as col6 join col4 as col7 on tab4 . col8 = tab3 . col8 and tab4 . col3 = < col9 order col0 > where tab3 . col3 = < col9 order col0 > group by tab3 . col3 ) as col10 on tab0 . col0 = tab1 . col0 and tab0 . col1 = tab1 . col2 join ( select col3 as col0 , count ( * ) as col1 from col4 where col3 = < col9 order col0 > group by col3 ) as col11 on tab1 . col2 = tab2 . col1	0
Q_48	how to select similar set in sql	C_48_5	select col0 as col1 , count ( * ) as col2 from col3 where col0 = < col4 order col1 > group by col0 select col0 as col1 , count ( * ) as col5 from col3 where col0 = < col4 order col1 > group by col0 select tab0 . col0 as col1 , count ( * ) as col6 from col3 as col7 join col3 as col8 on tab1 . col9 = tab0 . col9 and tab1 . col0 = < col4 order col1 > where tab0 . col0 = < col4 order col1 > group by tab0 . col0	0
Q_48	how to select similar set in sql	C_48_6	select tab0 . col0 as col1 , tab0 . col2 as col3 , tab1 . col0 as col4 , tab1 . col5 as col6 from ( select col7 as col0 , count ( * ) as col2 from col8 where col7 = < col9 order col0 > group by col7 ) as col10 join ( select col7 as col0 , count ( * ) as col5 from col8 where col7 = < col9 order col0 > group by col7 ) as col11 on tab0 . col2 < = tab1 . col5 union select tab1 . col0 as col1 , tab1 . col5 as col3 , tab0 . col0 as col4 , tab0 . col2 as col6 from ( select col7 as col0 , count ( * ) as col2 from col8 where col7 = < col9 order col0 > group by col7 ) as col10 join ( select col7 as col0 , count ( * ) as col5 from col8 where col7 = < col9 order col0 > group by col7 ) as col11 on tab0 . col2 > tab1 . col5	0
Q_48	how to select similar set in sql	C_48_7	col0 / ( col1 + ( col2 _ col0 ) ) col3	0
Q_49	cumulative number of file in subfolders	C_49_0	with recursive col0 as ( select col1 col2 , array col3 col4 from col5 col6 where not exists ( select codint from col5 col7 where tab0 . col8 = tab1 . col1 ) union all select tab1 . col1 , tab2 . col4 tab1 . col1 from col0 col9 join col5 col6 on tab1 . col1 in ( select col8 from col5 where col1 = tab2 . col2 ) ) , col10 as ( select distinct col2 , unnest ( col4 ) col11 from col0 ) , col12 as ( select col1 col2 , count ( * ) col13 from col5 group by codint ) select tab3 . col2 , sum ( tab4 . col13 ) from col10 join col12 on tab3 . col11 = tab4 . col2 group by codint order by codint	1
Q_49	cumulative number of file in subfolders	C_49_1	insert into col0 values ( codint , codint , codint ) insert into col0 values ( codint , codint , codint ) insert into col0 values ( codint , codint , codint ) insert into col0 values ( codint , codint , codint )	0
Q_49	cumulative number of file in subfolders	C_49_2	create col0 fs_file ( col1 bigserial , col2 col3 , type char ( codint ) , level col4 ) create col0 fs_tree ( col1 int8 , col5 int8 , size int8 )	0
Q_49	cumulative number of file in subfolders	C_49_3	create col0 col1 on fs_tree ( col2 ) create col0 col3 on fs_tree ( col4 ) vacuum analyze col5 vacuum analyze col6	0
Q_49	cumulative number of file in subfolders	C_49_4	with recursive col0 as ( select tab0 . col1 col2 , tab0 . col1 , tab0 . size , codint col3 , codint as col4 from col5 col6 where tab0 . col7 = ( select col1 from col8 where col9 = refre refre ) union all select distinct case when tab1 . col3 = codint then tab2 . col2 else tab0 . col1 end as col2 , tab0 . col1 , tab0 . size , tab1 . col3 , tab2 . col4 + codint from col0 col10 join col5 col6 on tab2 . col1 = tab0 . col7 cross join generate_series ( codint , codint ) k ( col3 ) ) / * col11 col12 * / select col2 , col1 , size , col3 , col4 from col0 order by codint , codint , codint	0
Q_49	cumulative number of file in subfolders	C_49_5	select col0 as col1 , count ( * ) , sum ( size ) from col2 group by codint	0
Q_49	cumulative number of file in subfolders	C_49_6	with recursive col0 as ( select col1 col2 , col3 col4 , sum ( size ) as size , count ( * ) as col5 from col6 group by codint , codint ) , col7 as ( select tab0 . col2 col8 , tab0 . col2 , tab0 . size , tab0 . col5 , codint col9 , codint as col10 from col0 col11 where tab0 . col4 = codint union all select distinct case when tab1 . col9 = codint then tab2 . col8 else tab0 . col2 end as col8 , tab0 . col2 , tab0 . size , tab0 . col5 , tab1 . col9 , tab2 . col10 + codint from col7 col12 join col0 col11 on tab2 . col2 = tab0 . col4 cross join generate_series ( codint , codint ) k ( col9 ) ) / * col13 col14 * / select col8 col2 , sum ( size ) size , sum ( col5 ) col5 from col7 group by codint order by codint , codint , codint	0
Q_49	cumulative number of file in subfolders	C_49_7	insert into col0 values ( codint , refre refre refre refre refre , refre , codint ) , ( codint , refre , refre , codint ) , ( codint , refre , refre , codint ) , ( codint , refre , refre , codint ) , ( codint , refre , refre , codint ) , ( codint , refre , refre , codint ) , ( codint , refre , refre , codint ) , ( codint , refre , refre , codint ) , ( codint , refre , refre , codint ) insert into col1 values ( codint , null , codint ) , ( codint , codint , codint ) , ( codint , codint , codint ) , ( codint , codint , codint ) , ( codint , codint , codint ) , ( codint , codint , codint ) , ( codint , codint , codint ) , ( codint , codint , codint ) , ( codint , codint , codint )	0
Q_50	my_sql store procedure how get result from both query update solve	C_50_0	if ( row_count ( ) < codint ) then select col0 from col1 where col2 = codint limit col3 , codint end if	1
Q_50	my_sql store procedure how get result from both query update solve	C_50_1	if ( found_rows ( ) < codint ) then select col0 from col1 where col2 = codint limit col3 , codint end if	0
Q_50	my_sql store procedure how get result from both query update solve	C_50_2	drop procedure if exists col0 delimiter / / create procedure test ( out col1 int ) begin declare col2 int default codint set col3 = codint select floor ( count ( col4 ) * rand ( ) ) into col2 from col5 where col6 = codint and col7 = codint and time > = unix_timestamp ( ) select col3 = col3 + codint , col4 from col5 where col8 = codint limit col2 , codint if col3 < codint then set col2 = col2 + codint select col4 from col5 limit col2 , codint end if set col1 = col3 end / / delimiter	0
Q_50	my_sql store procedure how get result from both query update solve	C_50_3	col0 > call test ( col1 ) select col1 + _ + _ + col2 = col2 + codint col3 + _ + _ + codint codint codint codint + _ + _ + codint rows in set ( number col4 ) + _ + col3 + _ + codint + _ + codint row in set ( number col4 ) col5 col6 , codint rows affected ( number col4 ) + _ + col1 + _ + codint + _ + codint row in set ( number col4 )	0
Q_50	my_sql store procedure how get result from both query update solve	C_50_4	drop procedure if exists col0 delimiter / / create procedure test ( out col1 int ) begin declare col2 int default codint set col3 = codint select floor ( count ( col4 ) * rand ( ) ) into col2 from col5 where col6 = codint and col7 = codint and time > = unix_timestamp ( ) select col4 from col5 where col3 = col3 + codint and col8 = codint limit col2 , codint if col3 < codint then set col2 = col2 + codint select col4 from col5 limit col2 , codint end if set col1 = col3 end / / delimiter	0
Q_50	my_sql store procedure how get result from both query update solve	C_50_5	col0 > call test ( col1 ) select col1 + _ + col2 + _ + codint codint + _ + codint rows in set ( number col3 ) + _ + col2 + _ + codint + _ + codint row in set ( number col3 ) col4 col5 , codint rows affected ( number col3 ) + _ + col1 + _ + codint + _ + codint row in set ( number col3 )	0
Q_50	my_sql store procedure how get result from both query update solve	C_50_6	col0 where col1 = col1 + codint and col2 > codint limit codint , codint	0
Q_50	my_sql store procedure how get result from both query update solve	C_50_7	col0 where col1 > codint and col2 and col3 = col3 + codint limit codint , codint	0
Q_51	sql_alchemy many_to_many performance	C_51_0	col0 = tab0 . query ( col1 ) . all ( ) for col2 in col3 col4 col5 col6 col7 for col8 in tab1 . col9 col4 col5 col6 col7 do_something_with ( tab2 . col1 ) no sql col10 col11 col12	1
Q_51	sql_alchemy many_to_many performance	C_51_1	col0 = tab0 . query ( col1 ) . filter ( tab1 . tab2 . in_ ( tab0 . query ( tab3 . col2 ) ) ) . all ( )	0
Q_51	sql_alchemy many_to_many performance	C_51_2	col0 = tab0 . query ( col1 ) . join ( tab1 . col2 ) . all ( )	0
Q_51	sql_alchemy many_to_many performance	C_51_3	col0 = tab0 . query ( col1 ) . distinct ( ) . join ( tab1 . col2 ) . all ( )	0
Q_51	sql_alchemy many_to_many performance	C_51_4	col0 = tab0 . query ( col1 ) . options ( subqueryload_all ( tab1 . col2 , tab2 . col3 ) ) . all ( )	0
Q_51	sql_alchemy many_to_many performance	C_51_5	col0 = tab0 . query ( col1 ) . options ( subqueryload ( tab1 . col2 ) , joinedload ( tab2 . col3 ) ) . all ( )	0
Q_51	sql_alchemy many_to_many performance	C_51_6	col0 = tab0 . query ( col1 ) . options ( joinedload ( tab1 . col2 ) ) . all ( )	0
Q_52	convert linq with all to sql	C_52_0	col0 = > tab0 . all ( col1 = > predicate ( col1 ) )	1
Q_52	convert linq with all to sql	C_52_1	col0 = > tab0 . any ( col1 = > predicate ( col1 ) )	0
Q_52	convert linq with all to sql	C_52_2	from col0 in col0 where tab0 . any ( col1 = > tab1 . tab2 . any ( col2 = > somecondition ( col2 , col1 ) ) ) select col0	0
Q_52	convert linq with all to sql	C_52_3	tab0 . tab1 . any ( col0 = > somecondition ( col0 , col1 ) )	0
Q_52	convert linq with all to sql	C_52_4	not exists ( select codint from col0 col0 where tab0 . col1 = tab1 . col1 _ col2 col3 col4 col5 col6 and tab2 . col7 = tab1 . col7 _ col8 col3 col4 col5 col6 )	0
Q_52	convert linq with all to sql	C_52_5	tab0 . any ( col0 = > tab1 . tab2 . any ( col1 = > somecondition ( col1 , col0 ) ) )	0
Q_52	convert linq with all to sql	C_52_6	not exists ( select codint from col0 col0 where not exists ( select codint from col1 col1 where tab0 . col2 = tab1 . col2 _ col3 col4 col5 col6 col7 and tab2 . col8 = tab1 . col8 ) )	0
Q_52	convert linq with all to sql	C_52_7	select * from col0 col0 where not exists ( select codint from col1 col1 where not exists ( select codint from col2 col2 where tab0 . col3 = tab1 . col3 and tab2 . col4 = tab1 . col4 ) )	0
Q_53	sql join with a buffer time	C_53_0	create col0 mba ( col1 int , col2 col3 , col4 col3 ) insert into col5 select codint , refre , refre insert into col5 select codint , refre , refre create col0 map ( col6 int , col7 col3 ) insert into map select codint , refre insert into map select codint , refre insert into map select codint , refre insert into map select codint , refre	1
Q_53	sql join with a buffer time	C_53_1	select * from col0 inner join map on tab0 . col1 < = case when datediff ( col2 , tab0 . col1 , tab0 . col3 ) < = codint then dateadd ( col2 , codint , tab1 . col4 ) else tab1 . col4 end and tab0 . col3 > = case when datediff ( col2 , tab0 . col1 , tab0 . col3 ) < = codint then dateadd ( col2 , _ codint , tab1 . col4 ) else tab1 . col4 end	0
Q_53	sql join with a buffer time	C_53_2	create col0 mba ( col1 int , col2 col3 , col4 col3 ) insert into col5 select codint , refre , refre create col0 map ( col6 int , col7 col3 ) insert into map select codint , refre insert into map select codint , refre	0
Q_53	sql join with a buffer time	C_53_3	create col0 mba ( col1 int , col2 col3 , col4 col3 ) insert into col5 select codint , refre , refre create col0 map ( col6 int , col7 col3 ) insert into map select codint , refre	0
Q_53	sql join with a buffer time	C_53_4	create col0 mba ( col1 int , col2 col3 , col4 col3 ) insert into col5 select codint , refre , refre insert into col5 select codint , refre , refre insert into col5 select codint , refre , refre insert into col5 select codint , refre , refre insert into col5 select codint , refre , refre create col0 map ( col6 int , col7 col3 ) insert into map select codint , refre insert into map select codint , refre insert into map select codint , refre insert into map select codint , refre insert into map select codint , refre insert into map select codint , refre insert into map select codint , refre insert into map select codint , refre insert into map select codint , refre insert into map select codint , refre	0
Q_53	sql join with a buffer time	C_53_5	select * from col0 inner join map on ( tab0 . col1 < tab0 . col2 and tab0 . col1 < = case when datediff ( col3 , tab0 . col1 , tab0 . col2 ) < = codint then dateadd ( col3 , codint , tab1 . col4 ) else tab1 . col4 end and tab0 . col2 > = case when datediff ( col3 , tab0 . col1 , tab0 . col2 ) < = codint then dateadd ( col3 , _ codint , tab1 . col4 ) else tab1 . col4 end ) or ( tab0 . col1 > tab0 . col2 and ( tab0 . col1 < = case when codint _ datediff ( col3 , tab0 . col2 , tab0 . col1 ) < = codint then dateadd ( col3 , codint , tab1 . col4 ) else tab1 . col4 end or tab0 . col2 > = case when codint _ datediff ( col3 , tab0 . col2 , tab0 . col1 ) < = codint then dateadd ( col3 , _ codint , tab1 . col4 ) else tab1 . col4 end ) )	0
Q_53	sql join with a buffer time	C_53_6	col0 col1 col2 codint codint , codint , codint codint codint , codint codint codint , codint codint codint , codint , codint codint codint , codint , codint , codint	0
Q_54	build group use relate data point	C_54_0	create col0 tab0 . [ state ] ( col1 int identity , col2 varchar ( codint ) ) create unique col3 col4 col5 on tab0 . [ state ] ( col1 ) create unique col6 col4 col7 on tab0 . [ state ] ( col2 )	1
Q_54	build group use relate data point	C_54_1	create col0 tab0 . [ zipcode ] ( col1 int identity , col2 int , col3 varchar ( codint ) ) create unique col4 col5 col6 on tab0 . [ zipcode ] ( col1 ) create unique col7 col5 col8 on tab0 . [ zipcode ] ( col2 , col3 )	0
Q_54	build group use relate data point	C_54_2	create col0 tab0 . [ city ] ( col1 int identity , col2 int , col3 varchar ( codint ) ) create unique col4 col5 col6 on tab0 . [ city ] ( col1 ) create unique col7 col5 col8 on tab0 . [ city ] ( col2 , col9 )	0
Q_54	build group use relate data point	C_54_3	create col0 tab0 . [ streetaddress ] ( col1 int identity , col2 int , col3 varchar ( codint ) ) create unique col4 col5 col6 on tab0 . [ streetaddress ] ( col1 ) create unique col7 col5 col8 on tab0 . [ streetaddress ] ( col2 , col3 )	0
Q_54	build group use relate data point	C_54_4	create col0 tab0 . [ areacode ] ( col1 int identity , col2 int ) create unique col3 col4 col5 on tab0 . [ areacode ] ( col1 ) create unique col6 col4 col7 on tab0 . [ areacode ] ( col2 ) create col0 tab0 . [ phonenumber ] ( col8 int identity , col1 int , col9 int ) create unique col3 col4 col10 on tab0 . [ phonenumber ] ( col8 ) create unique col6 col4 col11 on tab0 . [ phonenumber ] ( col1 , col9 )	0
Q_54	build group use relate data point	C_54_5	create col0 tab0 . [ characteristic ] ( col1 int identity , col2 col3 ) create unique col4 col5 col6 on tab0 . [ characteristic ] ( col1 ) create unique col7 col5 col8 on tab0 . [ characteristic ] ( col2 )	0
Q_54	build group use relate data point	C_54_6	create col0 tab0 . [ letter ] ( col1 int identity , col2 col3 , col4 int , col5 int , tab1 . )	0
Q_55	informix group by alias	C_55_0	select col0 , col1 from ( select month ( col2 ) as col0 , count ( col3 ) as col1 from col4 where year1 ( col2 ) = codint and col5 = codint group by col2 ) as col6 _ group by col1	1
Q_55	informix group by alias	C_55_1	create temp col0 mytable ( col1 date not null , col2 integer not null , col3 varchar ( codint ) ) insert into col4 values ( refre , codint , null ) insert into col4 values ( refre , codint , refre ) insert into col4 values ( refre , codint , refre ) insert into col4 values ( refre , codint , refre ) insert into col4 values ( refre , codint , refre )	0
Q_55	informix group by alias	C_55_2	col0 col1 smallint decimal ( codint , codint ) codint codint codint codint codint codint	0
Q_55	informix group by alias	C_55_3	select col0 , col1 from ( select month ( col2 ) as col0 , count ( case when tab0 . col3 = codint then col4 end ) as col1 from col5 where year1 ( col2 ) = codint group by col0 ) as col6	0
Q_55	informix group by alias	C_55_4	col0 col1 smallint decimal ( codint , codint ) codint codint	0
Q_55	informix group by alias	C_55_5	select col0 , count ( col1 ) as col1 from ( select month ( col2 ) as col0 , case when tab0 . col3 = codint then col4 end as col1 from col5 where year1 ( col2 ) = codint ) col6 group by col0	0
Q_55	informix group by alias	C_55_6	col0 col1 smallint decimal ( codint , codint ) codint codint	0
Q_56	how do i count field value from a single row	C_56_0	select col0 , sum ( case when codint = refre then codint else codint end ) as col1 , sum ( case when codint = refre then codint else codint end ) as col2 , sum ( case when codint = refre then codint else codint end ) as col3 from col4 group by col0 order by col0	1
Q_56	how do i count field value from a single row	C_56_1	select sum ( case when col0 = refre then codint else codint end ) as col1 , sum ( case when col0 = refre then codint else codint end ) as col2 , sum ( case when col0 = refre then codint else codint end ) as col3 , sum ( case when col4 = refre then codint else codint end ) as col5 , sum ( case when col4 = refre then codint else codint end ) as col6 , sum ( case when col4 = refre then codint else codint end ) as col7 , sum ( case when col8 = refre then codint else codint end ) as col9 , sum ( case when col8 = refre then codint else codint end ) as col10 , sum ( case when col8 = refre then codint else codint end ) as col11 , sum ( case when col12 = refre then codint else codint end ) as col13 , sum ( case when col12 = refre then codint else codint end ) as col14 , sum ( case when col12 = refre then codint else codint end ) as col15 , sum ( case when col16 = refre then codint else codint end ) as col17 , sum ( case when col16 = refre then codint else codint end ) as col18 , sum ( case when col16 = refre then codint else codint end ) as col19 from col20	0
Q_56	how do i count field value from a single row	C_56_2	select col0 , sum ( case when col1 = refre then codint else codint end ) as col2 , sum ( case when col1 = refre then codint else codint end ) as col3 , sum ( case when col1 = refre then codint else codint end ) as col4 from ( select refre as col0 , col5 as col1 from col6 union all select refre , col7 from col6 union all select refre , col8 from col6 union all select refre , col9 from col6 union all select refre , col10 from col6 ) col11 group by col0	0
Q_56	how do i count field value from a single row	C_56_3	concat ( col0 , col1 , col2 , col3 , col4 ) _ result for col5 = codint in col6 col7 data refre	0
Q_56	how do i count field value from a single row	C_56_4	replace ( concat ( col0 , col1 , col2 , col3 , col4 ) , refre , refre ) _ result for col5 = codint refre	0
Q_56	how do i count field value from a single row	C_56_5	select col0 , codint _ length ( replace ( concat ( col1 , col2 , col3 , col4 , col5 ) , refre , refre ) ) as col6 , codint _ length ( replace ( concat ( col1 , col2 , col3 , col4 , col5 ) , refre , refre ) ) as col7 , codint _ length ( replace ( concat ( col1 , col2 , col3 , col4 , col5 ) , refre , refre ) ) as col8 from col9	0
Q_56	how do i count field value from a single row	C_56_6	select col0 , concat ( refre . and col1 of col2 col3 using col4 , col5 ) from ( select col0 , codint _ length ( replace ( concat ( col6 , col7 , col8 , col9 , col10 ) , refre , refre ) ) as col4 , codint _ length ( replace ( concat ( col6 , col7 , col8 , col9 , col10 ) , refre , refre ) ) as col11 , codint _ length ( replace ( concat ( col6 , col7 , col8 , col9 , col10 ) , refre , refre ) ) as col12 from col13 ) col14	0
Q_57	confuse with result of join the same table multiple time	C_57_0	select * from col0 as col1 right outer join col2 as col3 on tab0 . col4 = tab1 . col5 left outer join col2 col6 on tab2 . col7 = tab0 . col4	1
Q_57	confuse with result of join the same table multiple time	C_57_1	select * from col0 as col1 left outer join col2 as col3 on tab0 . col4 = tab1 . col5 left outer join col0 col6 on tab2 . col7 = tab0 . col4	0
Q_57	confuse with result of join the same table multiple time	C_57_2	tableb ( get all col0 ) and col1 col2 col0 = call col3 result set as col4	0
Q_57	confuse with result of join the same table multiple time	C_57_3	t ( get all col0 ) and col1 col2 col0	0
Q_57	confuse with result of join the same table multiple time	C_57_4	select * from col0 as col1 right outer join col2 as col3 on tab0 . col4 = tab1 . col5	0
Q_57	confuse with result of join the same table multiple time	C_57_5	select * from col0 as col1 left outer join col2 as col3 on tab0 . col4 = tab1 . col5	0
Q_57	confuse with result of join the same table multiple time	C_57_6	tableb ( get all col0 ) and col1 col2 col0	0
Q_58	how to properly create the sql query for display number of product in each refine criterion of the specify result	C_58_0	select tab0 . col0 as col0 , count ( * ) as col1 from col2 cross join ( / * search col3 * / ) as col4 where / * col5 col6 col7 of col8 col9 col10 col11 col6 system to col12 col13 row col14 * / group by col0 order by col1	1
Q_58	how to properly create the sql query for display number of product in each refine criterion of the specify result	C_58_1	col0 , col1 col2 col3 , col4 , col5 , col6	0
Q_58	how to properly create the sql query for display number of product in each refine criterion of the specify result	C_58_2	cross join col0 col1 , col2 col1 , col3 col1 , col4 col1 , col5 col6 , col2 col6 , col3 col6 , col4 col6 , col5	0
Q_58	how to properly create the sql query for display number of product in each refine criterion of the specify result	C_58_3	cross join col0 after where col1 col2 , col3 col2 , col4 col5 , col3 col5 , col6 col5 , col4	0
Q_58	how to properly create the sql query for display number of product in each refine criterion of the specify result	C_58_4	cross join col0 after count col1 , codint col2 , codint	0
Q_58	how to properly create the sql query for display number of product in each refine criterion of the specify result	C_58_5	select refre as col0 , count ( * ) as col1 from / * col2 * / as col3 where / * col4 * / group by col0 union select refre as col0 , count ( * ) as col1 from / * col2 * / as col3 where / * col4 * / group by col0 union select refre as col0 , count ( * ) as col1 from / * col2 * / as col3 where / * col4 * / group by col0	0
Q_58	how to properly create the sql query for display number of product in each refine criterion of the specify result	C_58_6	col0 / col1 col2 / codint col3 / codint col4 / codint	0
Q_58	how to properly create the sql query for display number of product in each refine criterion of the specify result	C_58_7	select * from ( / * col0 * / ) as col1 order by col2	0
Q_59	sql_ pad result with extra row	C_59_0	set statistics col0 on if object_id ( col1 refre ) is not null drop col2 temp create col2 temp ( col3 char ( codint ) , col4 varchar ( codint ) ) insert into temp ( col3 , col4 ) values ( refre , refre ) , ( refre , refre ) , ( refre , refre ) , ( refre , refre ) , ( refre , refre ) , ( refre , refre ) , ( refre , refre ) , ( refre , refre )	1
Q_59	sql_ pad result with extra row	C_59_1	with col0 as ( select col1 , col2 , col3 = row_number ( ) over ( partition by col1 order by ( select codint ) ) from temp ) select tab0 . col1 , col2 = isnull ( tab1 . col2 , refre ) from ( select distinct col1 from col0 ) col4 cross join ( select col3 = codint union all select codint union all select codint ) col5 left join col0 col6 on tab2 . col3 = tab1 . col3 and tab0 . col1 = tab1 . col1	0
Q_59	sql_ pad result with extra row	C_59_2	select tab0 . col0 , col1 = isnull ( tab1 . col1 , refre ) from ( select * from ( select col0 , col2 = count ( codint ) from temp group by col0 ) col3 cross apply ( values ( col2 ) , ( col2 + codint ) , ( col2 + codint ) ) t2 ( col4 ) ) col5 left join temp col6 on tab0 . col0 = tab1 . col0 and tab0 . col4 = tab0 . col2 where tab0 . col4 < codint	0
Q_59	sql_ pad result with extra row	C_59_3	with col0 as ( select distinct col1 from temp ) select tab0 . col1 , tab0 . col2 from col0 col3 cross apply ( select col4 codint tab1 . col1 , tab1 . col2 from ( select tab2 . col1 , tab2 . col2 from temp col5 where tab3 . col1 = tab2 . col1 union all select tab3 . col1 , refre union all select tab3 . col1 , refre ) col6 ) col7	0
Q_59	sql_ pad result with extra row	C_59_4	select col0 , col1 from ( select tab0 . col0 , tab0 . col1 , col2 = row_number ( ) over ( partition by tab0 . col0 order by tab0 . col2 ) from temp col3 cross apply ( values ( col0 , col1 , codint ) , ( col0 , refre , codint ) , ( col0 , refre , codint ) ) x ( col0 , col1 , col2 ) ) col4 where col2 < = codint order by col0	0
Q_59	sql_ pad result with extra row	C_59_5	select tab0 . col0 , col1 = coalesce ( ( select col1 from ( select col2 = row_number ( ) over ( partition by col0 order by col0 ) , * from temp ) col3 where tab0 . col4 = tab1 . col2 and tab0 . col0 = tab1 . col0 ) , refre ) from ( select col4 = row_number ( ) over ( partition by tab2 . col0 order by tab2 . col0 ) , tab2 . col0 from ( select col0 from temp group by col0 ) col5 , ( select col6 codint col0 from temp ) col7 ) col8	0
Q_59	sql_ pad result with extra row	C_59_6	with col0 as ( select col1 , col2 , col3 = row_number ( ) over ( partition by col1 order by codint / codint ) from temp ) , col4 as ( select col1 , col5 = isnull ( col5 , refre ) , col6 = isnull ( col6 , refre ) , col7 = isnull ( col7 , refre ) from col0 pivot ( max ( col2 ) for col3 in ( col5 , col6 , col7 ) ) col8 ) , col9 as ( select col1 , col2 from col4 unpivot ( col2 for col3 in ( col5 , col6 , col7 ) ) col10 ) select * from col9	0
Q_59	sql_ pad result with extra row	C_59_7	with col0 as ( select col1 , col2 , col3 = row_number ( ) over ( partition by col1 order by codint / codint ) from temp ) , col4 as ( select col1 , col2 from col0 pivot ( max ( col2 ) for col3 in ( col5 , col6 , col7 ) ) col8 cross apply ( values ( isnull ( col5 , refre ) ) , ( isnull ( col6 , refre ) ) , ( isnull ( col7 , refre ) ) ) x ( col2 ) ) select * from col4	0
Q_59	sql_ pad result with extra row	C_59_8	col0 col1 _ _ col2 col3 col2 col4 col2 col5 col6 col5 col5 col7 col8 col7 col9 col7 col10 col11 col12 col11 col13 col11	0
Q_59	sql_ pad result with extra row	C_59_9	col0 col1 col2 col3 reads _ _ _ col4 codint codint codint col4 codint codint codint col5 col6 codint codint col7 codint codint col8 codint codint col9 col10 codint codint codint col9 col10 codint codint codint	0
Q_60	multiple column reference with a parent code	C_60_0	select if ( tab0 . col0 is not null , tab0 . col0 , tab0 . col1 ) as match , if ( tab0 . col2 is not null , tab0 . col2 , tab0 . col1 ) as map from col3 col4 left join col3 col5 on tab1 . col0 = tab0 . col1 where tab1 . col0 is null union all select tab2 . col1 , tab2 . col1 from col3 col6 where tab2 . col0 is not null	1
Q_60	multiple column reference with a parent code	C_60_1	+ _ + _ + match map + _ + _ + codint codint col0 codint col1 codint codint codint codint codint codint codint + _ + _ +	0
Q_60	multiple column reference with a parent code	C_60_2	select ifnull ( tab0 . col0 , tab0 . col1 ) as match , ifnull ( tab0 . col2 , tab0 . col1 ) as map from col3 col4 left join col3 col5 on tab1 . col0 = tab0 . col1 where tab1 . col0 is null union all select tab2 . col1 , tab2 . col1 from col3 col6 where tab2 . col0 is not null	0
Q_60	multiple column reference with a parent code	C_60_3	select tab0 . map as col0 , sum ( tab1 . col1 ) as col1 from col2 col3 join ( select ifnull ( tab2 . col4 , tab2 . col0 ) as match , ifnull ( tab2 . col5 , tab2 . col0 ) as map from col6 col7 left join col6 col8 on tab3 . col4 = tab2 . col0 where tab3 . col4 is null union all select tab4 . col0 , tab4 . col0 from col6 col9 where tab4 . col4 is not null ) col10 on tab0 . match = tab1 . col0 group by tab0 . map	0
Q_60	multiple column reference with a parent code	C_60_4	_ rows with col0 , match = col1 map = col0 select tab0 . col1 as col2 , tab0 . col0 as col3 from col4 col5 where tab0 . col0 is not null _ rows with col0 and col6 , match = col6 map = col0 select tab1 . col6 , tab1 . col0 from col4 col7 where tab1 . col0 is not null and tab1 . col6 is not null _ rows with no col0 , match = col1 map = col1 select tab2 . col1 , tab2 . col1 from col4 col8 where tab2 . col0 is null _ rows with col6 and no col0 , match = col6 map = col1 select tab3 . col6 , tab3 . col1 from col4 col9 where tab3 . col0 is null and tab3 . col6 is not null	0
Q_60	multiple column reference with a parent code	C_60_5	+ _ + _ + _ + col0 col1 col2 + _ + _ + _ + codint col3 codint col3 null codint col3 codint col4 codint col3 codint codint codint col3 codint codint col3 null + _ + _ + _ +	0
Q_60	multiple column reference with a parent code	C_60_6	select tab0 . match , min ( tab0 . map ) as map from ( _ col0 to get match / map col1 col2 ) col3 group by tab0 . match	0
Q_60	multiple column reference with a parent code	C_60_7	select tab0 . map as col0 , sum ( tab1 . col1 ) as col1 from col2 col3 join ( select tab2 . match , min ( tab2 . map ) as map from ( _ col4 to get match / map col5 col6 ) col7 group by tab2 . match ) col8 on tab0 . match = tab1 . col0 group by tab0 . map	0
Q_60	multiple column reference with a parent code	C_60_8	select ifnull ( tab0 . col0 , tab0 . col1 ) as col2 , sum ( tab1 . col3 ) as col3 from col4 col5 join col6 col7 on tab0 . col1 = tab1 . col2 group by ifnull ( tab0 . col0 , tab0 . col1 )	0
Q_61	bare minimum of a pagination	C_61_0	select * from col0 where col1 = codint limit codint , codint	1
Q_61	bare minimum of a pagination	C_61_1	col0 col1 col2 col3 codint _ codint , tab0 . tab1 . col2 first codint col3	0
Q_61	bare minimum of a pagination	C_61_2	offset = ( current col0 * limit ) _ limit tab0 . tab1 . ( codint * codint ) _ codint = codint	0
Q_61	bare minimum of a pagination	C_61_3	select * from col0 where col1 = codint limit col2 , col3 tab0 . tab1 . select * from col0 where col1 = codint limit codint , codint	0
Q_61	bare minimum of a pagination	C_61_4	offset = ( current col0 * limit ) _ limit tab0 . tab1 . ( codint * codint ) _ codint = codint	0
Q_61	bare minimum of a pagination	C_61_5	select * from col0 where col1 = codint limit col2 , col3 tab0 . tab1 . select * from col0 where col1 = codint limit codint , codint	0
Q_61	bare minimum of a pagination	C_61_6	col0 col1 col2 col3 codint _ codint , tab0 . tab1 . col2 next codint col3 col4 from col5 codint	0
Q_62	transpose and compare column value in oracle	C_62_0	create col0 t42 ( col1 number , col2 varchar2 ( codint ) , col3 varchar2 ( codint ) , col4 varchar2 ( codint ) , col5 varchar2 ( codint ) )	1
Q_62	transpose and compare column value in oracle	C_62_1	select * from ( select col0 , to_char ( col0 ) as col1 , col2 , col3 , col4 , col5 from col6 ) unpivot ( col7 for col8 in ( col1 , col2 , col3 , col4 , col5 ) ) col0 col8 col7 _ _ _ codint col1 codint codint col2 col9 codint col3 col10 codint col4 col11 codint col5 col12 codint col1 codint codint col2 col12 codint col3 col10 codint col4 col13 codint col5 col12	0
Q_62	transpose and compare column value in oracle	C_62_2	select col0 , max ( case when col1 = codint then col2 end ) as col3 , max ( case when col1 = codint then col2 end ) as col4 from ( select tab0 . * , row_number ( ) over ( partition by tab0 . col0 order by tab0 . col5 ) as col1 from ( select col5 , to_char ( col5 ) as col6 , col7 , col8 , col9 , col10 from col11 ) unpivot ( col2 for col0 in ( col6 , col7 , col8 , col9 , col10 ) ) col12 ) group by col0 col0 col3 col4 _ _ _ col6 codint codint col7 col13 col14 col8 col15 col15 col9 col16 col17 col10 col14 col14	0
Q_62	transpose and compare column value in oracle	C_62_3	select col0 , col1 , case when col0 = col1 then refre else refre end as col2 from ( select col3 , max ( case when col4 = codint then col5 end ) as col0 , max ( case when col4 = codint then col5 end ) as col1 from ( select tab0 . * , row_number ( ) over ( partition by tab0 . col3 order by tab0 . col6 ) as col4 from ( select col6 , to_char ( col6 ) as col7 , col8 , col9 , col10 , col11 from col12 ) unpivot ( col5 for col3 in ( col7 , col8 , col9 , col10 , col11 ) ) col13 ) group by col3 ) col0 col1 col2 _ _ _ codint codint col14 col15 col16 col14 col17 col17 col18 col19 col20 col14 col16 col16 col18	0
Q_62	transpose and compare column value in oracle	C_62_4	select col0 , col1 , case when col0 = col1 then refre else refre end as col2 from ( select * from ( select col3 , col4 , col5 from ( select tab0 . * , row_number ( ) over ( partition by tab0 . col3 order by tab0 . col6 ) as col5 from ( select col6 , to_char ( col6 ) as col7 , col8 , col9 , col10 , col11 from col12 ) unpivot ( col4 for col3 in ( col7 , col8 , col9 , col10 , col11 ) ) col13 ) ) pivot ( max ( col4 ) as col4 for ( col5 ) in ( codint as col14 , codint as col15 ) ) ) col0 col1 col2 _ _ _ codint codint col16 col17 col18 col16 col19 col19 col20 col21 col22 col16 col18 col18 col20	0
Q_62	transpose and compare column value in oracle	C_62_5	insert into col0 values ( codint , refre , refre , refre , refre ) insert into col0 values ( codint , refre , refre , refre , refre )	0
Q_62	transpose and compare column value in oracle	C_62_6	select col0 , col1 , case when col0 = col1 then refre else refre end as col2 from ( select col3 , max ( case when col4 = codint then col5 end ) as col0 , max ( case when col4 = codint then col5 end ) as col1 from ( select tab0 . * , row_number ( ) over ( partition by tab0 . col6 order by tab0 . col7 ) as col4 , rank ( ) over ( order by case when tab0 . col6 = refre then null else tab0 . col5 end ) as col3 from ( select col7 , to_char ( col7 ) as col8 , col9 , col10 , col11 , col12 from col13 ) unpivot ( col5 for col6 in ( col8 , col9 , col10 , col11 , col12 ) ) col14 ) group by col3 ) order by col0 col0 col1 col2 _ _ _ codint codint col15 col16 col15 col17 col17 col18 col19 col19 col18 col20 col20 col18 col21 col15	0
Q_63	database table for each customer or database design with link table	C_63_0	col0 col1 unsigned int ( col2 ) col3 varchar ( codint ) / / codint col4 col5 col6 , tab0 . col7 varchar ( codint ) / / col8 col9 , tab0 . col10 unsigned int ( col11 tab1 . col1 ) col12 varchar ( codint ) / / codint , col13 col14 , tab0 . ( col15 , col16 and col17 )	1
Q_63	database table for each customer or database design with link table	C_63_1	col0 col1 unsigned int ( col2 ) col3 unsigned int ( col4 tab0 . col1 ) col5 varchar ( codint ) / / col6 , col7 , col8 , tab1 .	0
Q_63	database table for each customer or database design with link table	C_63_2	col0 / / col1 char ( codint ) ( col2 ) / / col3 , col4 , col5 , tab0 . col6 char ( codint ) ( col7 ) / / col8 , col9 , col10 , tab0 . col11 char ( codint ) ( col7 ) col12 varchar ( codint ) ( col7 ) / / col13 , col14 , col15 col16 , tab0 .	0
Q_63	database table for each customer or database design with link table	C_63_3	col0 col1 unsigned int ( col2 ) col3 varchar ( codint ) / / col4 , col5 , tab0 . col6 varchar ( codint ) / / col7 , col8 , tab0 . col9 varchar ( codint ) / / col10 , public , tab0 . col11 varchar ( codint ) / / col12 tab1 . col13 , tab0 . col14 varchar ( codint ) / / col15 , tab0 . col16 varbinary ( codint ) / / tab2 .	0
Q_63	database table for each customer or database design with link table	C_63_4	col0 col1 unsigned int ( col2 ) col3 unsigned int ( col4 tab0 . col1 ) col5 unsigned int ( col4 tab1 . col1 )	0
Q_63	database table for each customer or database design with link table	C_63_5	col0 col1 unsigned int ( col2 ) col3 col4 / / codint _ codint _ codint codint codint codint , tab0 . col5 col4 / / codint _ codint _ codint codint codint codint , tab0 . col6 unsigned int ( col7 tab1 . col1 ) col8 unsigned int ( col7 tab2 . col1 ) col9 unsigned int ( col7 tab2 . col1 )	0
Q_63	database table for each customer or database design with link table	C_63_6	col0 col1 unsigned int ( col2 ) col3 unsigned int ( col4 tab0 . col1 ) col5 unsigned int ( col4 tab1 . col1 )	0
Q_63	database table for each customer or database design with link table	C_63_7	col0 col1 unsigned int ( col2 ) col3 varchar ( codint ) / / col4 col5 , col4 col6 , tab0 . col7 unsigned int / / col7 in col8 , col9 , tab1 . col10 unsigned int / / col10 in col8 , col9 , tab1 . col11 unsigned int / / col11 in col8 , col9 , tab1 . col12 double / / col12 in col13 , col14 , col15 , col16 , tab1 .	0
Q_63	database table for each customer or database design with link table	C_63_8	col0 col1 unsigned int ( col2 ) col3 char ( codint ) ( col4 tab0 . col1 ) col5 char ( codint ) / / col6 , col7 , col8 , tab1 . col9 varchar ( codint ) / / col10 , col11 , col12 col13 col14 , tab1 .	0
Q_64	cassandra migration from mysql	C_64_0	create col0 image_by_size ( col1 col2 , / / col3 col2 , col4 col5 col6 refre for col7 size int , col8 col2 , primary key ( col1 , size , col8 ) )	1
Q_64	cassandra migration from mysql	C_64_1	select col0 from col1 where col2 = refre order by size desc	0
Q_64	cassandra migration from mysql	C_64_2	create col0 image_by_view ( col1 col2 , / / col3 col2 , col4 col5 col6 refre for col7 view int , col8 col2 , primary key ( col1 , view , col8 ) )	0
Q_64	cassandra migration from mysql	C_64_3	select col0 from col1 where col2 = refre order by size desc	0
Q_64	cassandra migration from mysql	C_64_4	create col0 image_by_create ( col1 col2 , / / col3 col2 , col4 col5 col6 refre for col7 col8 timestamp , col9 col2 , primary key ( col1 , col8 , col9 ) )	0
Q_64	cassandra migration from mysql	C_64_5	select col0 from col1 where col2 = refre order by col3 desc	0
Q_64	cassandra migration from mysql	C_64_6	create col0 image_index ( col1 col2 , / / refre , refre or refre col3 bigint , col4 col2 , primary key ( col1 , col3 , col4 ) )	0
Q_64	cassandra migration from mysql	C_64_7	insert into image_index ( col0 , col1 , col2 ) values ( refre , col3 , col2 )	0
Q_64	cassandra migration from mysql	C_64_8	insert into image_index ( col0 , col1 , col2 ) values ( refre , col3 , col2 )	0
Q_64	cassandra migration from mysql	C_64_9	insert into image_index ( col0 , col1 , col2 ) values ( refre , col3 , col2 )	0
Q_65	firebird cte result dataset with insert statement	C_65_0	insert into < col0 > ( < column > col1 * )	1
Q_65	firebird cte result dataset with insert statement	C_65_1	with col0 as ( select codint as col1 , refre as col2 from col3 database ) select col1 , col2 from col0	0
Q_65	firebird cte result dataset with insert statement	C_65_2	insert into items ( col0 , col1 ) with col2 as ( select codint as col0 , refre as col1 from col3 database ) select col0 , col1 from col2	0
Q_65	firebird cte result dataset with insert statement	C_65_3	insert into ntm ( col0 , col1 , codint , codint , codint , codint , codint , codint , codint , codint , codint , codint , codint , codint )	0
Q_65	firebird cte result dataset with insert statement	C_65_4	insert into < object > [ ( col0 col1 ) ] { values ( < col2 > col3 ) < col4 > }	0
Q_65	firebird cte result dataset with insert statement	C_65_5	insert into < object > ( < col0 > col1 ) < col2 >	0
Q_65	firebird cte result dataset with insert statement	C_65_6	trim ( trim ( col0 ) refre regplu refre trim ( tab0 . col1 ) )	0
Q_65	firebird cte result dataset with insert statement	C_65_7	insert into ntm ( col0 , col1 ) with col2 as ( select tab0 . col0 as col3 , tab0 . col4 as col5 , trim ( refre regast refre tab0 . col1 ) refre regplu refre refre regast refre tab1 . col1 as col6 , tab1 . col0 as col7 from col8 col9 cross join col8 col10 where ( tab0 . col1 = refre and tab1 . col1 = refre or tab0 . col1 = refre and tab1 . col1 = refre ) and tab0 . col0 = tab1 . col0 ) select col3 , trim ( trim ( col6 ) refre regplu refre trim ( tab2 . col1 ) ) from col2 cross join col8 col11 where tab2 . col0 = tab3 . col3 and ( position ( refre , col1 ) > codint or position ( refre , col1 ) > codint )	0
Q_66	create table with both foreign key and a composite primary key	C_66_0	create col0 outcome ( col1 int references col2 , col3 int references col4 , col5 varchar ( codint ) , primary key ( col1 , col3 ) )	1
Q_66	create table with both foreign key and a composite primary key	C_66_1	select count ( * ) as col0 from col1 where col2 = refre	0
Q_66	create table with both foreign key and a composite primary key	C_66_2	select count ( * ) as col0 from col1 where col2 = refre	0
Q_66	create table with both foreign key and a composite primary key	C_66_3	select tab0 . col0 , count ( * ) as col1 from col2 as col3 join col4 as col5 on tab0 . col6 = tab1 . col6 where tab1 . col7 = refre	0
Q_66	create table with both foreign key and a composite primary key	C_66_4	select tab0 . col0 , count ( * ) as col1 from col2 as col3 join col4 as col5 on tab0 . col6 = tab1 . col6 where tab1 . col7 = refre	0
Q_66	create table with both foreign key and a composite primary key	C_66_5	select tab0 . col0 from ( select tab1 . col0 , count ( * ) as col1 from col2 as col3 join col4 as col5 on tab1 . col6 = tab2 . col6 where tab2 . col7 = refre ) as col8 join ( select count ( * ) as col9 from col4 where col7 = refre ) as col10 on tab0 . col1 = tab3 . col9	0
Q_66	create table with both foreign key and a composite primary key	C_66_6	select tab0 . col0 from ( select tab1 . col0 , count ( * ) as col1 from col2 as col3 join col4 as col5 on tab1 . col6 = tab2 . col6 where tab2 . col7 = refre ) as col8 join ( select count ( * ) as col9 from col4 where col7 = refre ) as col10 on tab0 . col1 = tab3 . col9	0
Q_66	create table with both foreign key and a composite primary key	C_66_7	select tab0 . col0 from ( select tab1 . col0 , count ( * ) as col1 from col2 as col3 join col4 as col5 on tab1 . col6 = tab2 . col6 where tab2 . col7 = refre ) as col8 join ( select count ( * ) as col9 from col4 where col7 = refre ) as col10 on tab0 . col1 = tab3 . col9 union select tab0 . col0 from ( select tab1 . col0 , count ( * ) as col11 from col2 as col3 join col4 as col5 on tab1 . col6 = tab2 . col6 where tab2 . col7 = refre ) as col8 join ( select count ( * ) as col12 from col4 where col7 = refre ) as col10 on tab0 . col11 = tab3 . col12	0
Q_67	automatically load sql table by read data from text file	C_67_0	col0 , col1 , location , col2 col3 _ col4 col5 col6 , col7 col8 , col9 , col3 col10 col11 col12 col6 , col13 col14 , col15 col16 , col17 col18 , col19 col20 , col21 col22 , col23	1
Q_67	automatically load sql table by read data from text file	C_67_1	col0 col1 col0 col2 col3 = tab0 . connect ( refre ) cursor = tab1 . cursor ( ) tab2 . execute ( refre refre refre refre refre ) tab2 . execute ( refre refre refre refre refre refre refre refre refre refre refre ) with open ( refre ) as col4 for row in tab3 . dictreader ( col4 ) tab2 . execute ( refre refre refre refre refre refre refre , row ) tab2 . execute ( refre refre refre refre refre refre , row ) tab1 . commit ( ) tab1 . close ( )	0
Q_67	automatically load sql table by read data from text file	C_67_2	insert = refre refre refre refre refre refre refre refre refre [ 4 ] refre refre [ 5 ] refre refre [ 6 ] refre refre refre refre tab0 . execute ( insert )	0
Q_67	automatically load sql table by read data from text file	C_67_3	insert = refre refre refre refre refre refre refre ( col0 col1 , col0 col2 , col0 col3 ) tab0 . execute ( insert )	0
Q_67	automatically load sql table by read data from text file	C_67_4	insert = refre refre refre regque refre refre regque refre refre regque refre refre refre tab0 . execute ( insert , ( col0 col1 , col0 col2 , col0 col3 ) )	0
Q_67	automatically load sql table by read data from text file	C_67_5	insert into col0 values ( col1 , col1 , col1 )	0
Q_67	automatically load sql table by read data from text file	C_67_6	insert into col0 values ( codint , number , codint )	0
Q_67	automatically load sql table by read data from text file	C_67_7	insert into col0 values ( codint , number , codint )	0
Q_68	d_sum with date criterion and group by	C_68_0	col0 col1 col2 col3 _ _ _ _ codint col4 codint _ codint _ codint codint codint col4 codint _ codint _ codint codint codint col4 codint _ codint _ codint codint codint col5 codint _ codint _ codint codint codint col5 codint _ codint _ codint codint codint col5 codint _ codint _ codint codint codint col5 codint _ codint _ codint codint codint col6 codint _ codint _ codint codint codint col6 codint _ codint _ codint codint	1
Q_68	d_sum with date criterion and group by	C_68_1	select col0 , min ( col1 ) as col2 from col3 group by col0	0
Q_68	d_sum with date criterion and group by	C_68_2	col0 col1 _ _ col2 codint _ codint _ codint col3 codint _ codint _ codint col4 codint _ codint _ codint	0
Q_68	d_sum with date criterion and group by	C_68_3	select tab0 . col0 , tab0 . col1 , tab0 . col2 from col3 inner join ( select col0 , min ( col1 ) as col4 from col3 group by col0 ) as col5 on tab0 . col0 = tab1 . col0 and tab0 . col1 = tab1 . col4	0
Q_68	d_sum with date criterion and group by	C_68_4	col0 col1 col2 _ _ _ col3 codint _ codint _ codint codint col4 codint _ codint _ codint codint col4 codint _ codint _ codint codint col4 codint _ codint _ codint codint col5 codint _ codint _ codint codint	0
Q_68	d_sum with date criterion and group by	C_68_5	select col0 , col1 , sum ( col2 ) as col3 from ( select tab0 . col0 , tab0 . col1 , tab0 . col2 from col4 inner join ( select col0 , min ( col1 ) as col5 from col4 group by col0 ) as col6 on tab0 . col0 = tab1 . col0 and tab0 . col1 = tab1 . col5 ) group by col0 , col1	0
Q_68	d_sum with date criterion and group by	C_68_6	col0 col1 col2 _ _ _ col3 codint _ codint _ codint codint col4 codint _ codint _ codint codint col5 codint _ codint _ codint codint	0
Q_68	d_sum with date criterion and group by	C_68_7	col0 col1 col2 col3 _ _ _ _ codint col4 codint _ codint _ codint codint codint col4 codint _ codint _ codint codint codint col4 codint _ codint _ codint codint codint col5 codint _ codint _ codint codint	0
Q_68	d_sum with date criterion and group by	C_68_8	select tab0 . col0 , tab0 . col1 , sum ( tab0 . col2 ) as col3 from col4 group by tab0 . col0 , tab0 . col1 having ( ( ( tab0 . col1 ) in ( select min ( tab0 . col1 ) as col5 from col4 group by tab0 . col0 ) ) )	0
Q_68	d_sum with date criterion and group by	C_68_9	col0 col1 col2 _ _ _ col3 codint _ codint _ codint codint col3 codint _ codint _ codint codint col4 codint _ codint _ codint codint	0
Q_68	d_sum with date criterion and group by	C_68_10	col0 col1 col2 _ _ _ col3 codint _ codint _ codint codint col4 codint _ codint _ codint codint	0
Q_69	add value from the previous row of one column to another column in current row	C_69_0	create col0 t ( col1 int ) insert t ( col1 ) values ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) select tab0 . col1 , tab1 . col1 from col2 col2 outer apply ( select col1 = sum ( col1 ) from col2 col3 where tab1 . col1 < = tab0 . col1 ) col3 drop col0 col2	1
Q_69	add value from the previous row of one column to another column in current row	C_69_1	create col0 t ( col1 int ) insert t ( col1 ) values ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) select tab0 . col1 , ( select col1 = sum ( col1 ) from col2 col3 where tab1 . col1 < = tab0 . col1 ) from col2 col2 drop col0 col2	0
Q_69	add value from the previous row of one column to another column in current row	C_69_2	f ( col0 ) = col0 _ f ( col0 _ codint )	0
Q_69	add value from the previous row of one column to another column in current row	C_69_3	select col0 = codint , col1 = codint _ codint , col2 = codint _ ( codint _ codint ) , col3 = codint _ ( codint _ ( codint _ codint ) ) , col4 = codint _ ( codint _ ( codint _ ( codint _ codint ) ) ) , col5 = codint _ ( codint _ ( codint _ ( codint _ ( codint _ codint ) ) ) ) , col6 = codint _ ( codint _ ( codint _ ( codint _ ( codint _ ( codint _ codint ) ) ) ) )	0
Q_69	add value from the previous row of one column to another column in current row	C_69_4	select col0 = codint , col1 = codint _ codint , col2 = codint _ codint + codint , col3 = codint _ codint + codint _ codint , col4 = codint _ codint + codint _ codint + codint , col5 = codint _ codint + codint _ codint + codint _ codint , col6 = codint _ codint + codint _ codint + codint _ codint + codint	0
Q_69	add value from the previous row of one column to another column in current row	C_69_5	select tab0 . col0 , tab1 . rownum , tab1 . col0 from col1 col1 outer apply ( select col0 , rownum = row_number ( ) over ( order by col0 desc ) from col1 col2 where tab1 . col0 < tab0 . col0 ) col2 where tab0 . col0 in ( codint , codint )	0
Q_69	add value from the previous row of one column to another column in current row	C_69_6	col0 rownum col0 _ codint codint codint codint codint codint codint codint codint _ codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_69	add value from the previous row of one column to another column in current row	C_69_7	col0 = codint _ codint + codint _ codint , col1 = codint _ codint + codint _ codint + codint ,	0
Q_69	add value from the previous row of one column to another column in current row	C_69_8	select tab0 . col0 , col1 = tab0 . col0 _ sum ( isnull ( tab1 . col0 , codint ) ) from col2 col2 outer apply ( select col0 = case when row_number ( ) over ( order by col0 desc ) codint = codint then _ col0 else col0 end from col2 col3 where tab1 . col0 < tab0 . col0 ) col3 group by tab0 . col0	0
Q_70	return unicode character when search with nomal character in datatable	C_70_0	using tab0 . col0 using tab0 . data static class col1 { static col2 main ( ) { col3 col4 = new datatable ( ) tab1 . tab2 . add ( refre ) tab1 . tab3 . add ( refre ) tab1 . tab3 . add ( refre ) tab1 . tab3 . add ( refre ) tab1 . tab3 . add ( refre ) tab1 . tab3 . add ( refre ) tab1 . tab3 . add ( refre ) col3 result = tab1 . asenumerable ( ) . where ( row = > tab4 . match ( tab5 . col5 < col6 > ( refre ) , refre [ i ] refre ) . col7 ) . tolist ( ) } }	1
Q_70	return unicode character when search with nomal character in datatable	C_70_1	public static col0 col1 regexsearch ( col2 col3 col4 , col5 column , col5 col6 ) { col7 col8 = new regex ( col6 ) return tab0 . asenumerable ( ) . where ( row = > tab1 . match ( tab2 . col9 < col5 > ( column ) ) . col10 ) . toarray ( ) }	0
Q_70	return unicode character when search with nomal character in datatable	C_70_2	col0 result = tab0 . regexsearch ( refre , refre [ i ] refre )	0
Q_70	return unicode character when search with nomal character in datatable	C_70_3	public static class col0 { public static dictionary < col1 , col2 > col3 static normalizationmapping ( ) { if ( col3 = = null ) { col3 = new dictionary < col1 , col2 > ( ) col1 col4 = refre [ i ] refre tab0 . add ( refre , new regex ( col4 , tab1 . col5 tab1 . col6 ) ) col4 = refre [ a ] refre tab0 . add ( refre , new regex ( col4 , tab1 . col5 tab1 . col6 ) ) col4 = refre [ e ] refre tab0 . add ( refre , new regex ( col4 , tab1 . col5 tab1 . col6 ) ) col4 = refre [ u ] refre tab0 . add ( refre , new regex ( col4 , tab1 . col5 tab1 . col6 ) ) / / col7 add all col8 col9 } } }	0
Q_70	return unicode character when search with nomal character in datatable	C_70_4	col0 col1 = new datatable ( ) tab0 . col2 + = col3 tab0 . tab1 . add ( refre ) tab0 . tab1 . add ( refre )	0
Q_70	return unicode character when search with nomal character in datatable	C_70_5	static col0 dt_rowchanged ( object col1 , col2 col3 ) { tab0 . tab1 . tab2 . col4 _ = col5 tab0 . row col6 = tab0 . row tab3 . tostring ( ) . tolower ( ) foreach ( col7 col8 in tab4 . col9 ) { tab0 . row col6 = tab5 . tab6 . replace ( tab0 . row tab7 . tostring ( ) , tab5 . key ) } tab0 . tab1 . acceptchanges ( ) tab0 . tab1 . tab2 . col4 + = col5 }	0
Q_70	return unicode character when search with nomal character in datatable	C_70_6	public static col0 customnormalize ( col1 col0 col2 ) { foreach ( col3 col4 in tab0 . col5 ) { col2 = tab1 . tab2 . replace ( col2 , tab1 . key ) } return col2 }	0
Q_70	return unicode character when search with nomal character in datatable	C_70_7	col0 col1 = refre col0 result = tab0 . select ( refre refre regplu refre refre refre regplu refre refre )	0
Q_71	result base on user skill	C_71_0	select col0 , col1 from col2 inner join col3 on tab0 . col0 = tab1 . col0 where tab2 . col4 = codint	1
Q_71	result base on user skill	C_71_1	select col0 , col1 from col2 inner join col3 on tab0 . col0 = tab1 . col0 where tab1 . col4 = codint	0
Q_71	result base on user skill	C_71_2	col0 col1 + _ + _ + + _ + _ + col2 col3 col2 col4 + _ + _ + + _ + _ + codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint + _ + _ + _ + _ +	0
Q_71	result base on user skill	C_71_3	+ _ + _ + col0 col1 + _ + _ + codint codint codint codint + _ + _ +	0
Q_71	result base on user skill	C_71_4	select col0 , ( count ( col1 ) * codint / ( select count ( * ) from col2 where col3 = codint ) ) as col4 from col5 where col1 in ( select col1 from col2 where col3 = codint ) group by col0 order by col4 desc	0
Q_71	result base on user skill	C_71_5	select col0 , count ( col1 ) as col2 from col3 where col1 in ( select col1 from col4 where col5 = codint ) group by col0 order by col2 desc	0
Q_71	result base on user skill	C_71_6	select col0 , ( count ( col1 ) * codint / ( select count ( * ) from col2 where col3 = codint ) ) as col4 from col5 where col1 in ( select col1 from col2 where col3 = codint ) and col0 = codint	0
Q_72	avoid duplicate value in a column	C_72_0	select no , string_agg ( case when col0 like refre escape refre then col0 end , refre refre ) , string_agg ( case when col0 like refre escape refre then col0 end , refre refre ) , string_agg ( case when ( col0 not like refre and col0 not like refre escape refre ) then col0 end , refre refre ) from ( select no , ( string_to_array ( col0 , refre refre ) ) col1 as col0 from col2 union select no , ( string_to_array ( col0 , refre refre ) ) col3 as col0 from col2 union select no , ( string_to_array ( col0 , refre refre ) ) col4 as col0 from col2 ) col5 where no in ( codint , codint , codint , codint , codint ) group by no order by no	1
Q_72	avoid duplicate value in a column	C_72_1	no col0 col1 col2 codint col3 col4 col5 _ codint , col6 _ codint codint col7 col8 col9 _ codint , col10 _ codint codint col11 col12 col13 _ codint , col14 _ codint codint col11 col15 col16 _ codint codint col17 col8 col18 _ codint	0
Q_72	avoid duplicate value in a column	C_72_2	( select no , ( string_to_array ( col0 , refre refre ) ) col1 as col0 from col2 union select no , ( string_to_array ( col0 , refre refre ) ) col3 as col0 from col2 union select no , ( string_to_array ( col0 , refre refre ) ) col4 as col0 from col2 )	0
Q_72	avoid duplicate value in a column	C_72_3	codint col0 codint col1 codint col2 codint col3 _ codint codint col4 codint col5 codint col6 _ codint .	0
Q_72	avoid duplicate value in a column	C_72_4	case when col0 like refre escape refre then col0 end _ col1 case when col0 like refre escape refre then col0 end _ col2 case when ( col0 not like refre and col0 not like refre escape refre ) then col0 end _ col3	0
Q_72	avoid duplicate value in a column	C_72_5	codint col0 codint col1 _ codint codint col2 codint col3 _ codint codint col4 _ codint .	0
Q_72	avoid duplicate value in a column	C_72_6	string_agg ( case when col0 like refre escape refre then col0 end , refre refre )	0
Q_73	calculate a field base on total from query in ms access tagint	C_73_0	col0 col1 _ _ codint codint codint codint codint codint codint codint tab0 .	1
Q_73	calculate a field base on total from query in ms access tagint	C_73_1	col0 col1 col2 _ _ _ codint col3 codint codint tab0 .	0
Q_73	calculate a field base on total from query in ms access tagint	C_73_2	col0 col1 col2 _ _ _ codint col3 codint codint codint col3 codint codint tab0 .	0
Q_73	calculate a field base on total from query in ms access tagint	C_73_3	col0 col1 _ _ codint col2 col3 codint codint col2 col3 codint tab0 .	0
Q_73	calculate a field base on total from query in ms access tagint	C_73_4	select col0 , col1 , col2 , col3 , col4 , col5 , col3 _ col4 as col6 , ( col3 _ col4 ) / col5 as result from ( select tab0 . col2 , tab1 . col0 , tab1 . col1 , ( select count ( * ) from col7 where col8 = tab0 . col8 and col6 < codint ) as col4 , ( select count ( * ) from col7 where col8 = tab0 . col8 and col6 > codint ) as col3 , ( select count ( * ) from col7 where col8 = tab0 . col8 ) as col5 from col9 col10 left join col11 col12 on tab0 . col13 = tab1 . col13 )	0
Q_73	calculate a field base on total from query in ms access tagint	C_73_5	select col0 , col1 , col2 , col3 , col4 , ( col2 _ col3 ) / col4 from ( select col0 , col1 , sum ( col5 ) as col2 , sum ( col6 ) as col3 , sum ( col7 ) as col4 from col8 group by col0 , col1 )	0
Q_73	calculate a field base on total from query in ms access tagint	C_73_6	select col0 , col1 , col2 , col3 , col1 _ col2 as col4 , ( col1 _ col2 ) / col3 as result from ( select tab0 . col0 , tab1 . col5 , sum ( tab1 . col6 ) as col1 , sum ( tab1 . col7 ) as col2 , sum ( tab1 . col8 ) as col3 from col9 col10 left join col11 col12 on tab0 . col5 = tab1 . col5 group by tab0 . col0 , tab1 . col5 )	0
Q_74	sql server transpose data _ pivot possibly	C_74_0	select col0 , col1 , col2 , col3 , col4 from ( select col0 , cast ( col5 as nvarchar ( max ) ) as col5 , cast ( col6 as nvarchar ( max ) ) as col6 , cast ( col7 as nvarchar ( max ) ) as col7 from col8 ) as col9 unpivot ( col10 for col11 in ( col5 , col6 , col7 ) ) as col12 left join col13 as col14 on tab0 . col11 = tab1 . column_name pivot ( max ( col10 ) for col15 in ( col16 , col17 , col18 ) ) as col19	1
Q_74	sql server transpose data _ pivot possibly	C_74_1	select * from ( _ col0 tab0 . col1 col2 to cast col3 , _ col4 col1 get col5 col6 select col7 , cast ( col8 as nvarchar ( max ) ) as col8 , cast ( col9 as nvarchar ( max ) ) as col9 , cast ( col10 as nvarchar ( max ) ) as col10 from col11 ) as col12 unpivot ( col13 for col14 in ( col8 , col9 , col10 ) ) as col15	0
Q_74	sql server transpose data _ pivot possibly	C_74_2	col0 , col1 , col2 codint , codint , col3 codint , col4 , col5 codint , codint _ codint _ codint , date codint , codint , col3 codint , col6 , col5 codint , codint _ codint _ codint , date codint , codint , col3 codint , col7 , col5 codint , codint _ codint _ codint , date	0
Q_74	sql server transpose data _ pivot possibly	C_74_3	left join col0 as col1 on tab0 . col2 = tab1 . column_name	0
Q_74	sql server transpose data _ pivot possibly	C_74_4	col0 , col1 , col2 , col3 , column_name , col4 codint , codint , col5 , codint , col5 , col6 codint , col7 , col8 , codint , col8 , col9 codint , codint _ codint _ codint , date , codint , date , col10 codint , codint , col5 , codint , col5 , col6 codint , col11 , col8 , codint , col8 , col9 codint , codint _ codint _ codint , date , codint , date , col10 codint , codint , col5 , codint , col5 , col6 codint , col12 , col8 , codint , col8 , col9 codint , codint _ codint _ codint , date , codint , date , col10	0
Q_74	sql server transpose data _ pivot possibly	C_74_5	pivot ( max ( col0 ) for col1 in ( col2 , col3 , col4 ) ) as col5	0
Q_74	sql server transpose data _ pivot possibly	C_74_6	col0 , col1 , col2 , column_name , col3 , col4 , col5 codint , col6 , codint , col6 , codint , null , null codint , col7 , codint , col7 , null , col8 , null codint , date , codint , date , null , null , codint _ codint _ codint codint , col6 , codint , col6 , codint , null , null codint , col7 , codint , col7 , null , col9 , null codint , date , codint , date , null , null , codint _ codint _ codint codint , col6 , codint , col6 , codint , null , null codint , col7 , codint , col7 , null , col10 , null codint , date , codint , date , null , null , codint _ codint _ codint	0
Q_74	sql server transpose data _ pivot possibly	C_74_7	select col0 , col1 , col2 , col3 , col4	0
Q_75	mysql count multiple occurrence of multiplexed entry	C_75_0	select tab0 . col0 , count ( tab1 . col0 ) from col1 col2 left outer join col3 col4 on find_in_set ( tab0 . col0 , tab1 . col5 ) group by tab0 . col0	1
Q_75	mysql count multiple occurrence of multiplexed entry	C_75_1	select tab0 . col0 , count ( tab1 . col0 ) from col1 col2 left outer join col3 col4 on find_in_set ( tab0 . col0 , replace ( tab1 . col5 , refre , refre ) ) group by tab0 . col0	0
Q_75	mysql count multiple occurrence of multiplexed entry	C_75_2	col0 col1 col2 col3 codint col3 col4 codint col3 col5 codint col3 col6 codint col3 col7 codint col3 col8 col9 col1 col2 col10 codint codint , codint codint codint codint codint , codint , codint codint codint codint codint , codint	0
Q_75	mysql count multiple occurrence of multiplexed entry	C_75_3	select tab0 . col0 , tab1 . col0 from col1 col2 left outer join col3 col4 on find_in_set ( tab0 . col0 , tab1 . col5 )	0
Q_75	mysql count multiple occurrence of multiplexed entry	C_75_4	tab0 . col0 tab1 . col0 codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint null	0
Q_75	mysql count multiple occurrence of multiplexed entry	C_75_5	select tab0 . col0 , count ( tab1 . col0 ) from col1 col2 left outer join col3 col4 on find_in_set ( tab0 . col0 , tab1 . col5 ) group by tab0 . col0	0
Q_75	mysql count multiple occurrence of multiplexed entry	C_75_6	tab0 . col0 count ( tab1 . col0 ) codint codint codint codint codint codint codint codint codint codint	0
Q_75	mysql count multiple occurrence of multiplexed entry	C_75_7	select tab0 . col0 , tab0 . col1 , count ( tab1 . col0 ) from col2 col3 left outer join col4 col5 on find_in_set ( tab0 . col0 , tab1 . col6 ) group by tab0 . col0 , tab0 . col1	0
Q_75	mysql count multiple occurrence of multiplexed entry	C_75_8	tab0 . col0 tab0 . col1 count ( tab1 . col0 ) codint col1 col2 codint codint col1 col3 codint codint col1 col4 codint codint col1 col5 codint codint col1 col6 codint	0
Q_76	r _ join data frame in an rdb_style and convert multiple entry from one frame to a single entry in the other	C_76_0	library ( col0 ) col1 < _ sqldf ( refre regast refre refre ) col2 < _ sqldf ( refre refre refre refre ) sqldf ( refre regast refre refre refre )	1
Q_76	r _ join data frame in an rdb_style and convert multiple entry from one frame to a single entry in the other	C_76_1	sqldf ( refre regast refre refre refre refre refre refre regast refre refre refre refre refre refre )	0
Q_76	r _ join data frame in an rdb_style and convert multiple entry from one frame to a single entry in the other	C_76_2	col0 col1 col2 codint col3 codint col4 , col5 , col6 codint col7 codint col6 codint col8 codint < col9 > codint col10 codint col11 , col12	0
Q_76	r _ join data frame in an rdb_style and convert multiple entry from one frame to a single entry in the other	C_76_3	col0 < _ unique ( col1 ) col2 col3 < _ aggregate ( col4 col5 , col0 , col6 ) merge ( col7 , col3 , tab0 . col8 = true , by = refre )	0
Q_76	r _ join data frame in an rdb_style and convert multiple entry from one frame to a single entry in the other	C_76_4	library ( tab0 . col0 ) unique ( tab0 . table1 ( col1 , key = refre refre ) ) col2 col3	0
Q_76	r _ join data frame in an rdb_style and convert multiple entry from one frame to a single entry in the other	C_76_5	col0 col1 col2 codint col3 col4 , col5 , col6 codint codint col7 col6 codint codint col8 col9 codint codint col10 col11 , col12 codint	0
Q_76	r _ join data frame in an rdb_style and convert multiple entry from one frame to a single entry in the other	C_76_6	tab0 . left_join ( tab1 . unique ( ) . arrange ( col0 , col1 ) . group_by ( col0 ) . summarise ( col1 = tostring ( col1 ) ) )	0
Q_77	get the number user belong to a group	C_77_0	select tab0 . col0 , count ( codint ) from col1 col2 inner join col3 col4 on tab1 . col5 = tab2 . col5 inner join col6 col7 on tab0 . col8 < = tab1 . col9 and tab0 . col10 > tab1 . col9 where col11 > = refre and col11 < = refre group by tab0 . col0	1
Q_77	get the number user belong to a group	C_77_1	select count ( codint ) from col0 col1 inner join col2 col3 on tab0 . col4 = tab1 . col4 _ inner join col5 col6 on tab2 . col7 < = tab0 . col8 and tab2 . col9 > tab0 . col8 where col10 > = refre and col10 < = refre	0
Q_77	get the number user belong to a group	C_77_2	select count ( codint ) from col0 col1 inner join col2 col3 on tab0 . col4 = tab1 . col4 inner join col5 col6 on tab2 . col7 < = tab0 . col8 and tab2 . col9 > tab0 . col8 where col10 > = refre and col10 < = refre	0
Q_77	get the number user belong to a group	C_77_3	select isnull ( tab0 . col0 , refre ) as col0 , count ( codint ) as refre from col1 col2 inner join col3 col4 on tab1 . col5 = tab2 . col5 left join col6 col7 on tab0 . col8 < = tab1 . col9 and tab0 . col10 > tab1 . col9 where col11 > = refre and col11 < = refre group by isnull ( tab0 . col0 , refre ) order by codint	0
Q_77	get the number user belong to a group	C_77_4	create col0 tblmembers ( col1 int , col2 date , col3 int ) create col0 tblagegroup ( col4 int , col5 varchar ( codint ) , col6 int , col7 int , col8 float ) create col0 tbllog ( col1 int , col9 date ) insert into tblmembers ( col1 , col2 , col3 ) select codint , refre , codint union all select codint , refre , codint union all select codint , refre , codint union all select codint , null , null insert into tblagegroup ( col4 , col5 , col6 , col7 , col8 ) select codint , refre , codint , codint , null union all select codint , refre , codint , codint , null union all select codint , refre , codint , codint , null insert into tbllog ( col1 , col9 ) select codint , getdate ( ) union all select codint , getdate ( ) union all select codint , refre union all select codint , refre union all select codint , refre union all select codint , refre union all select codint , refre	0
Q_77	get the number user belong to a group	C_77_5	select tab0 . col0 , count ( tab1 . col1 ) as col2 , count ( distinct tab1 . col1 ) as col3 from col4 col5 left join col6 col7 on tab0 . col8 < = tab2 . col9 and tab0 . col10 > tab2 . col9 left join col11 col12 on tab1 . col1 = tab2 . col1 group by isnull ( tab0 . col0 , refre ) order by codint	0
Q_77	get the number user belong to a group	C_77_6	col0 col1 col2 col3 col1 distinct col4 codint _ codint codint codint codint _ codint codint codint codint _ codint codint codint codint _ codint codint codint	0
Q_77	get the number user belong to a group	C_77_7	select isnull ( tab0 . col0 , refre ) as col0 , count ( tab1 . col1 ) as col2 , count ( distinct tab1 . col1 ) as col3 from col4 col5 full outer join col6 col7 on tab0 . col8 < = tab2 . col9 and tab0 . col10 > tab2 . col9 full outer join col11 col12 on tab1 . col1 = tab2 . col1 group by isnull ( tab0 . col0 , refre ) order by codint	0
Q_77	get the number user belong to a group	C_77_8	col0 col1 col2 col3 col1 distinct col4 codint _ codint codint codint codint _ codint codint codint codint _ codint codint codint codint _ codint codint codint no group found codint codint	0
Q_78	my_sql _ join with sum on mix colmns	C_78_0	select tab0 . * from col0 col1 where tab0 . col2 = codint	1
Q_78	my_sql _ join with sum on mix colmns	C_78_1	select tab0 . * , tab1 . * from col0 col1 join col2 col3 on tab0 . col4 = tab1 . col5 where tab1 . col6 = codint	0
Q_78	my_sql _ join with sum on mix colmns	C_78_2	select tab0 . * , tab1 . * , tab2 . * from col0 col1 join col2 col3 on tab1 . col4 = tab2 . col5 join col6 col7 on tab0 . col8 = tab1 . col5 where tab2 . col9 = codint	0
Q_78	my_sql _ join with sum on mix colmns	C_78_3	select sum ( tab0 . col0 ) as col1 , sum ( tab1 . col2 ) as col3 from col4 col5 join col6 col7 on tab1 . col8 = tab2 . col9 join col10 col11 on tab0 . col12 = tab1 . col9 where tab2 . col13 = codint group by tab1 . col9	0
Q_78	my_sql _ join with sum on mix colmns	C_78_4	select sum ( tab0 . col0 ) as col0 , sum ( tab0 . col1 ) as col1 from ( select sum ( tab1 . col2 ) as col0 , sum ( tab2 . col3 ) as col1 from col4 col5 join col6 col7 on tab2 . col8 = tab3 . col9 join col10 col11 on tab1 . col12 = tab2 . col9 where tab3 . col13 = codint group by tab2 . col9 ) col14	0
Q_78	my_sql _ join with sum on mix colmns	C_78_5	tab0 . col0 * count ( tab1 . col1 ) as col2	0
Q_78	my_sql _ join with sum on mix colmns	C_78_6	select ifnull ( sum ( tab0 . col0 ) , codint ) as col0 , ifnull ( sum ( tab0 . col1 ) , codint ) as col1 from ( select sum ( tab1 . col2 ) as col0 , tab2 . col3 * count ( tab1 . col4 ) as col1 from col5 col6 join col7 col8 on tab2 . col9 = tab3 . col10 left join col11 col12 on tab1 . col4 = tab2 . col10 where tab3 . col13 = codint group by tab2 . col10 ) col14	0
Q_79	ssrs sql tagstr logic base on multiple value parameter	C_79_0	select col0 = refre , col1 , col2 , col3 from tab0 . tab1 . col4 where refre in ( col0 ) union all select col0 = refre , col1 , col2 , col3 from tab2 . tab1 . col4 where refre in ( col0 ) union all select col0 = refre , col1 , col2 , col3 from tab3 . tab1 . col4 where refre in ( col0 )	1
Q_79	ssrs sql tagstr logic base on multiple value parameter	C_79_1	create col0 t1 ( col1 int identity , col2 char ( codint ) ) insert t1 ( col2 ) select null from tab0 . col3	0
Q_79	ssrs sql tagstr logic base on multiple value parameter	C_79_2	declare col0 table1 ( col0 int ) insert brand ( col0 ) values ( codint ) , ( codint ) select col0 = codint , col1 , col2 from col3 where codint in ( select col0 from col0 ) union all select col0 = codint , col1 , col2 from col4 where codint in ( select col0 from col0 ) union all select col0 = codint , col1 , col2 from col5 where codint in ( select col0 from col0 ) select * from col3 where codint = codint	0
Q_79	ssrs sql tagstr logic base on multiple value parameter	C_79_3	select col0 = codint , col1 , col2 from col3 where codint in ( codint , codint )	0
Q_79	ssrs sql tagstr logic base on multiple value parameter	C_79_4	set statistics col0 on declare col1 table1 ( col1 int ) insert brand ( col1 ) values ( codint ) , ( codint ) select col1 = codint , col2 , col3 from openquery ( col4 , refre refre ) where codint in ( select col1 from col1 ) select col1 = codint , col2 , col3 from openquery ( col4 , refre refre ) where codint in ( select col1 from col1 ) select col1 = codint , col2 , col3 from openquery ( col4 , refre refre ) where codint in ( select col1 from col1 )	0
Q_79	ssrs sql tagstr logic base on multiple value parameter	C_79_5	select col0 = codint , col1 , col2 from openquery ( col3 , refre refre ) where codint in ( codint , codint )	0
Q_79	ssrs sql tagstr logic base on multiple value parameter	C_79_6	if refre in ( col0 ) begin select < col1 > from tab0 . tab1 . col2 end if refre in ( col0 ) begin select < col1 > from tab0 . tab1 . col2 end if refre in ( col0 ) begin select < col1 > from tab2 . tab1 . col2 end	0
Q_79	ssrs sql tagstr logic base on multiple value parameter	C_79_7	if refre in ( col0 ) and refre in ( col0 ) and refre in ( col0 ) begin _ union all col1 col2 end else if refre in ( col0 ) and refre in ( col0 ) begin _ union all col3 and col4 col2 end else if refre in ( col0 ) and refre in ( col0 ) begin _ union all col3 and col5 col2 end else if refre in ( col0 ) begin _ col6 col3 end else if refre in ( col0 ) and refre in ( col0 ) begin _ union all col4 and col5 col2 end else if refre in ( col0 ) begin _ col6 col4 end else if refre in ( col0 ) begin _ col6 col5 end	0
Q_79	ssrs sql tagstr logic base on multiple value parameter	C_79_8	set col0 on create col1 t ( < col2 > ) if refre in ( col3 ) begin insert t ( < col2 > ) select < col2 > from tab0 . tab1 . col1 end if refre in ( col3 ) begin insert t ( < col2 > ) select < col2 > from tab0 . tab1 . col1 end if refre in ( col3 ) begin insert t ( < col2 > ) select < col2 > from tab2 . tab1 . col1 end select * from col4	0
Q_80	improve performance for large table order top query	C_80_0	create view col0 with col1 as select tab0 . col2 , tab1 . col3 , tab1 . col4 as col5 from tab2 . col6 col7 join tab2 . col8 col9 on tab1 . col2 = tab0 . col2 and tab1 . col3 = tab0 . col3 go create unique col10 col11 col12 on userfeeditem ( col2 , col5 ) go	1
Q_80	improve performance for large table order top query	C_80_1	create view col0 with col1 as select tab0 . col2 , tab1 . col3 , tab2 . col4 , tab2 . col5 as col6 from tab3 . col7 col8 join tab3 . col9 col10 on tab0 . col4 = tab2 . col4 join tab3 . col11 col12 on tab1 . col4 = tab2 . col4 and tab1 . col2 = tab0 . col2 go create unique col13 col14 col15 on userfeeditem ( col2 , col3 , col6 ) go	0
Q_80	improve performance for large table order top query	C_80_2	select col0 codint tab0 . * , tab1 . * from col1 col2 with ( col3 ) join col4 col2 on tab1 . col5 = tab2 . col5 and tab1 . col6 = tab2 . col7 join col8 col9 on tab0 . col6 = tab1 . col5 where tab2 . col10 = col10 order by tab2 . col7 desc	0
Q_80	improve performance for large table order top query	C_80_3	select col0 codint tab0 . * , tab1 . * from col1 col2 with ( col3 ) join col4 col2 on tab1 . col5 = tab2 . col5 and tab1 . col6 = tab2 . col7 join col8 col9 on tab0 . col6 = tab1 . col5 where tab2 . col10 = col10 and col11 = col11 order by tab2 . col7 desc	0
Q_80	improve performance for large table order top query	C_80_4	select col0 codint tab0 . * , tab1 . * from col1 col2 join col3 col4 on tab0 . col5 = tab2 . col6 cross apply ( select col0 codint * from col7 col8 where tab1 . col6 = tab0 . col5 order by tab1 . col5 desc ) col8 where tab2 . col9 = col9 order by tab1 . col5 desc	0
Q_80	improve performance for large table order top query	C_80_5	select col0 codint tab0 . * , tab1 . * from col1 col2 join col3 col4 on tab2 . col5 = tab3 . col5 join col6 col7 on tab0 . col8 = tab3 . col9 cross apply ( select col0 codint * from col10 col11 where tab1 . col9 = tab0 . col8 order by tab1 . col8 desc ) col11 where tab3 . col5 = col5 and tab2 . col12 = col12 order by tab1 . col8 desc	0
Q_80	improve performance for large table order top query	C_80_6	usersubscription ( col0 , col1 ) _ unique feedtag ( col0 , col2 , col1 ) _ unique	0
Q_81	delete duplicate value from concatenate string	C_81_0	alter function tab0 . [ split ] ( col0 nvarchar ( max ) , delimiter nchar ( codint ) ) returns col1 as return ( select col2 = row_number ( ) over ( order by tab1 . number ) , position = number , col3 = substring ( col0 , number , charindex ( delimiter , col0 + delimiter , number ) _ number ) from ( select top ( len ( col0 ) + codint ) number = row_number ( ) over ( order by tab2 . col4 ) from tab3 . col5 col6 cross join tab3 . col5 col7 ) col8 where substring ( delimiter + col0 + delimiter , tab1 . number , codint ) = delimiter )	1
Q_81	delete duplicate value from concatenate string	C_81_1	select tab0 . object , tab0 . col0 , tab1 . col1 from col2 cross col3 tab2 . split ( tab0 . col4 , refre ) as col5	0
Q_81	delete duplicate value from concatenate string	C_81_2	object col0 values _ codint codint col1 col1 col1 col2 col1 col1	0
Q_81	delete duplicate value from concatenate string	C_81_3	object col0 values _ codint codint col1 codint codint col1 codint codint col1 codint codint col2 codint codint col1 codint codint col1	0
Q_81	delete duplicate value from concatenate string	C_81_4	select distinct tab0 . object , tab0 . col0 , tab1 . col1 from col2 cross col3 tab2 . split ( tab0 . col4 , refre ) as col5	0
Q_81	delete duplicate value from concatenate string	C_81_5	object col0 values _ codint codint col1 codint codint col2	0
Q_81	delete duplicate value from concatenate string	C_81_6	select tab0 . object , tab0 . col0 , col1 = stuff ( tab1 . value ( refre , refre refre refre ) , codint , codint , refre ) from col2 cross apply ( select distinct refre + tab2 . col3 from tab3 . split ( tab0 . col1 , refre ) as col4 for xml path ( refre ) , type ) as s ( col5 )	0
Q_81	delete duplicate value from concatenate string	C_81_7	create col0 t ( object int , col1 int , col2 varchar ( max ) ) insert col3 values ( codint , codint , refre ) , ( codint , codint , refre ) , ( codint , codint , refre ) , ( codint , codint , refre ) , ( codint , codint , refre ) select tab0 . object , tab0 . col1 , col2 = stuff ( tab1 . value ( refre , refre refre refre ) , codint , codint , refre ) from col3 as col3 cross apply ( select distinct refre + tab2 . col4 from tab3 . split ( tab0 . col2 , refre ) as col5 for xml path ( refre ) , type ) as s ( col6 )	0
Q_81	delete duplicate value from concatenate string	C_81_8	create col0 t ( object int , col1 int , col2 varchar ( max ) ) insert col3 values ( codint , codint , refre ) , ( codint , codint , refre ) , ( codint , codint , refre ) , ( codint , codint , refre ) , ( codint , codint , refre ) select tab0 . object , tab0 . col1 , col2 = stuff ( tab1 . value ( refre , refre refre refre ) , codint , codint , refre ) from col3 as col3 cross apply ( select distinct refre + substring ( tab0 . col2 , number , charindex ( refre , tab0 . col2 + refre , number ) _ number ) from ( select top ( len ( tab0 . col2 ) + codint ) number = row_number ( ) over ( order by tab2 . col4 ) from tab3 . col5 col6 cross join tab3 . col5 col7 ) col8 where substring ( refre + tab0 . col2 + refre , tab4 . number , codint ) = refre for xml path ( refre ) , type ) as s ( col9 )	0
Q_82	different output for each condition get together group by all value _ single mysql query	C_82_0	select if ( col0 = codint , col1 , col2 ) as col3 from col4 group by col3	1
Q_82	different output for each condition get together group by all value _ single mysql query	C_82_1	select if ( col0 < > codint , if ( col1 = codint , col2 , col1 ) , if ( col2 = codint , col1 , col2 ) ) as col3 from col4 group by col3	0
Q_82	different output for each condition get together group by all value _ single mysql query	C_82_2	if col0 col1 is not codint , _ codint check to col2 if col0 col3 is codint , if col3 = codint _ codint then col4 in col5 _ codint else col3 is not codint and col6 col4 in col3 _ codint	0
Q_82	different output for each condition get together group by all value _ single mysql query	C_82_3	if ( col0 < > codint , if ( col1 < > codint , col1 , col2 ) , some condition for when col0 is codint )	0
Q_82	different output for each condition get together group by all value _ single mysql query	C_82_4	if col0 col1 is codint col2 in user_id ( col3 ) if col4 = codint _ codint then col2 in col5 _ codint else col4 is not codint and col2 in col4 _ codint	0
Q_82	different output for each condition get together group by all value _ single mysql query	C_82_5	_ codint codint codint codint codint codint codint if ( col0 < > codint , if ( col1 = codint , col2 , col1 ) , if ( col2 = codint , col1 , col2 ) )	0
Q_82	different output for each condition get together group by all value _ single mysql query	C_82_6	if ( col0 < > codint , _ if col1 not codint if ( col2 = codint , col3 , col2 ) , _ true condition if ( col3 = codint , col2 , col3 ) _ false condition )	0
Q_83	best way to do a case where clause sql server	C_83_0	where isnull ( col0 , location ) = location and isnull ( col1 , col2 ) = col2	1
Q_83	best way to do a case where clause sql server	C_83_1	declare col0 varchar ( codint ) = refre select * from tab0 . tables where isnull ( col0 , col1 ) = col1	0
Q_83	best way to do a case where clause sql server	C_83_2	select * from tab0 . tables where coalesce ( col0 , col1 ) = col1	0
Q_83	best way to do a case where clause sql server	C_83_3	select * from tab0 . tables where ( col0 is null or col0 = col1 )	0
Q_83	best way to do a case where clause sql server	C_83_4	select * from tab0 . col0 where isnull ( col1 , col2 ) = col2	0
Q_83	best way to do a case where clause sql server	C_83_5	select * from tab0 . col0 where coalesce ( col1 , col2 ) = col2	0
Q_83	best way to do a case where clause sql server	C_83_6	select * from tab0 . col0 where ( col1 is null or col1 = col2 )	0
Q_84	sql server tagint _ multiple order for the same customer split dupe into a separate table	C_84_0	create col0 testdata ( col1 char ( codint ) , col2 int , col3 col4 , col5 char ( codint ) , col6 char ( codint ) , col7 col4 ) insert into col8 values ( refre , codint , number , refre , refre , number ) insert into col8 values ( refre , codint , number , refre , refre , number ) insert into col8 values ( refre , codint , number , refre , refre , number ) insert into col8 values ( refre , codint , number , refre , refre , number ) insert into col8 values ( refre , codint , number , refre , refre , number )	1
Q_84	sql server tagint _ multiple order for the same customer split dupe into a separate table	C_84_1	select col0 , col1 , col2 , col3 , col4 , col5 , row_number ( ) over ( partition by col1 order by col3 desc , col2 , col4 , col5 , col0 ) as col6 from col7	0
Q_84	sql server tagint _ multiple order for the same customer split dupe into a separate table	C_84_2	col0 col1 col2 col3 col4 col5 col6 _ _ _ _ _ _ _ col7 codint number codint col8 number codint col7 codint number codint col9 number codint col7 codint number codint col8 number codint col7 codint number codint col8 number codint col7 codint number codint col8 number codint ( codint row ( col10 ) col11 )	0
Q_84	sql server tagint _ multiple order for the same customer split dupe into a separate table	C_84_3	select tab0 . col0 , tab0 . col1 , tab0 . col2 , tab0 . col3 , tab0 . col4 , tab0 . col5 from ( select col0 , col1 , col2 , col3 , col4 , col5 , row_number ( ) over ( partition by col1 order by col3 desc , col2 , col4 , col5 , col0 ) as col6 from col7 ) col8 where tab0 . col6 = codint	0
Q_84	sql server tagint _ multiple order for the same customer split dupe into a separate table	C_84_4	col0 col1 col2 col3 col4 col5 _ _ _ _ _ _ col6 codint number codint col7 number col6 codint number codint col7 number ( codint row ( col8 ) col9 )	0
Q_84	sql server tagint _ multiple order for the same customer split dupe into a separate table	C_84_5	select tab0 . col0 , tab0 . col1 , tab0 . col2 , tab0 . col3 , tab0 . col4 , tab0 . col5 from ( select col0 , col1 , col2 , col3 , col4 , col5 , row_number ( ) over ( partition by col1 order by col3 desc , col2 , col4 , col5 , col0 ) as col6 from col7 ) col8 where tab0 . col6 > codint	0
Q_84	sql server tagint _ multiple order for the same customer split dupe into a separate table	C_84_6	col0 col1 col2 col3 col4 col5 _ _ _ _ _ _ col6 codint number codint col7 number col6 codint number codint col8 number col6 codint number codint col8 number ( codint row ( col9 ) col10 )	0
Q_85	summarize count by date	C_85_0	codint / codint / codint codint / codint / codint codint / codint / codint codint / codint / codint	1
Q_85	summarize count by date	C_85_1	select * from ( select to_char ( col0 , refre refre ) col0 , count ( * ) from col1 group by to_char ( col0 , refre refre ) ) order by to_date ( col0 , refre refre )	0
Q_85	summarize count by date	C_85_2	codint / codint codint codint / codint codint codint / codint codint	0
Q_85	summarize count by date	C_85_3	select col0 , sum ( col1 ) over ( order by codint rows unbounded col2 ) col3 from ( select to_char ( col0 , refre refre ) col0 , count ( * ) col1 from col4 group by to_char ( col0 , refre refre ) ) order by to_date ( col0 , refre refre )	0
Q_85	summarize count by date	C_85_4	codint / codint codint codint / codint codint codint / codint codint	0
Q_85	summarize count by date	C_85_5	select tab0 . col0 , nvl ( col1 , codint ) col1 from ( select to_char ( col2 , refre refre ) col2 , count ( * ) col1 from col3 group by to_char ( col2 , refre refre ) ) col4 , ( select to_char ( add_months ( to_date ( refre refre refre , refre refre refre ) _ codint , level ) , refre refre ) col0 from col5 connect by level < = codint ) col6 where tab1 . my_date ( + ) = tab0 . col0 order by to_date ( tab0 . col0 , refre refre )	0
Q_85	summarize count by date	C_85_6	codint / codint codint codint / codint codint codint / codint codint codint / codint codint codint / codint codint codint / codint codint codint / codint codint codint / codint codint codint / codint codint codint / codint codint codint / codint codint codint / codint codint	0
Q_86	order table numerically and get the list number	C_86_0	select tab0 . * from col0 col1 join col2 col3 on ( tab0 . col4 = tab1 . col5 ) where tab1 . col6 = refre order by tab1 . col7 * codint desc	1
Q_86	order table numerically and get the list number	C_86_1	global col0 col1 = refre regast refre refre refre refre refre refre col2 refre regast refre col3 = col0 _ > get_results ( col1 , object )	0
Q_86	order table numerically and get the list number	C_86_2	foreach ( col0 as col1 ) { col2 col1 _ > col3 / / col3 of col4 }	0
Q_86	order table numerically and get the list number	C_86_3	function getreputationbyuser ( col0 ) { if ( is_numeric ( col0 ) ) { return false } global col1 col2 = refre refre col3 refre refre refre result = col1 _ > get_row ( col2 ) if ( empty ( result ) ) { return result _ > col4 } return false } col5 getreputationbyuser ( codint )	0
Q_86	order table numerically and get the list number	C_86_4	select tab0 . col0 from ( select tab1 . col1 , rownum = rownum + codint col0 from col2 col3 cross join ( select rownum = codint ) col4 where tab1 . col5 = refre order by tab1 . col6 * codint desc ) col7 where tab0 . col1 = codint	0
Q_86	order table numerically and get the list number	C_86_5	function getreputationbyuser ( col0 ) { if ( is_numeric ( col0 ) ) { return false } global col1 col2 = refre refre refre regplu refre refre refre refre col3 refre regast refre refre refre refre result = col1 _ > get_row ( col2 ) if ( empty ( result ) ) { return result _ > col4 } return false } col5 getreputationbyuser ( codint )	0
Q_86	order table numerically and get the list number	C_86_6	select col0 , find_in_set ( col0 , ( select group_concat ( col0 order by col1 * codint desc ) from col2 where col3 = refre ) ) as col4 from col2 where col3 = refre and col0 = codint function getreputationbyuser ( col0 ) { if ( is_numeric ( col0 ) ) { return false } global col5 col6 = refre refre refre refre refre refre regast refre refre refre col7 refre refre refre refre col7 refre refre refre result = col5 _ > get_row ( col6 ) if ( empty ( result ) ) { return result _ > col4 } return false } col8 getreputationbyuser ( codint )	0
Q_87	how to concatenate rdd string with array string to produce string	C_87_0	col0 prefix = refre refre refre refre col0 col1 = array ( refre , refre , refre , refre ) col0 col2 = tab0 . parallelize ( col1 , codint )	1
Q_87	how to concatenate rdd string with array string to produce string	C_87_1	col0 col1 = tab0 . map ( col2 = > prefix + col2 ) tab1 . foreach ( col3 )	0
Q_87	how to concatenate rdd string with array string to produce string	C_87_2	/ col0 / col1 / date = codint / col0 / col1 / date = codint / col0 / col1 / date = codint / col0 / col1 / date = codint	0
Q_87	how to concatenate rdd string with array string to produce string	C_87_3	col0 col1 = tab0 . fold ( refre ) ( ( col2 , col3 ) = > col2 + refre refre + col3 ) println ( col1 )	0
Q_87	how to concatenate rdd string with array string to produce string	C_87_4	, , / col0 / col1 / date = codint , / col0 / col1 / date = codint , , / col0 / col1 / date = codint , / col0 / col1 / date = codint	0
Q_87	how to concatenate rdd string with array string to produce string	C_87_5	col0 col1 = tab0 . fold ( refre ) ( ( col2 , col3 ) = > col2 match { case refre = > col3 case col4 = > col4 + refre refre + col3 } ) println ( col1 )	0
Q_87	how to concatenate rdd string with array string to produce string	C_87_6	/ col0 / col1 / date = codint , / col0 / col1 / date = codint , / col0 / col1 / date = codint , / col0 / col1 / date = codint	0
Q_87	how to concatenate rdd string with array string to produce string	C_87_7	col0 col1 = tab0 . reduce ( ( col2 , col3 ) = > col2 + refre refre + col3 ) println ( col1 )	0
Q_87	how to concatenate rdd string with array string to produce string	C_87_8	/ col0 / col1 / date = codint , / col0 / col1 / date = codint , / col0 / col1 / date = codint , / col0 / col1 / date = codint	0
Q_88	how to get has_many through across server work	C_88_0	class col0 < col1 col2 col3 col4 col5 col6 tab0 . map { col7 tab1 . find_by ( col8 tab2 . col8 ) } end end	1
Q_88	how to get has_many through across server work	C_88_1	class col0 < col1 col2 col3 col4 col3 col5 , col6 col7 , col8 col7 end	0
Q_88	how to get has_many through across server work	C_88_2	class col0 < col1 col2 col3 refre . col4 col5 col6 tab0 . table_name = refre tab0 . col7 = refre col8 col9 tab1 . where ( col10 tab0 . col10 ) end col8 col11 tab2 . map { col12 tab3 . find ( tab4 . col13 ) } end end	0
Q_88	how to get has_many through across server work	C_88_3	col0 = tab0 . first col1 load ( col2 ) select refre . * from refre order by refre . refre asc limit codint = > < col1 codhex > { col3 = > codint , col4 = > refre , col5 = > col6 , codint col7 codint codint codint codint col8 + codint codint , col9 = > col6 , codint col7 codint codint codint codint col8 + codint codint }	0
Q_88	how to get has_many through across server work	C_88_4	tab0 . col0 = > < col1 col2 col3 col4 >	0
Q_88	how to get has_many through across server work	C_88_5	tab0 . col0 col1 load ( col2 ) select refre . * from refre where refre . refre = codint [ col3 ] col4 load ( col2 ) select refre . * from refre where refre . refre = codint limit codint col4 load ( col2 ) select refre . * from refre where refre . refre = codint limit codint = > [ col5 < col4 codhex > { col6 = > codint , col7 = > codint , col8 = > col9 , codint col10 codint codint codint codint col11 + codint codint , col12 = > col9 , codint col10 codint codint codint codint col11 + codint codint } , col13 < col4 codhex > { col6 = > codint , col7 = > codint , col8 = > col9 , codint col10 codint codint codint codint col11 + codint codint , col12 = > col9 , codint col10 codint codint codint codint col11 + codint codint } ]	0
Q_88	how to get has_many through across server work	C_88_6	col0 = tab0 . first col1 load ( col2 ) select refre . * from refre order by refre . refre asc limit codint = > < col1 codhex > { col3 = > codint , col4 = > codint , col5 = > col6 , codint col7 codint codint codint codint col8 + codint codint , col9 = > col6 , codint col7 codint codint codint codint col8 + codint codint }	0
Q_88	how to get has_many through across server work	C_88_7	tab0 . col0 col1 load ( col2 ) select refre . * from refre where refre . refre = codint = > < col3 col4 col5 >	0
Q_88	how to get has_many through across server work	C_88_8	tab0 . col0 col1 load ( col2 ) select refre . * from refre where refre . refre = codint col3 load ( col2 ) select refre . * from refre where refre . refre = codint limit codint [ col4 ] = > [ col5 < col3 codhex > { col6 = > codint , col7 = > refre , col8 = > col9 , codint col10 codint codint codint codint col11 + codint codint , col12 = > col9 , codint col10 codint codint codint codint col11 + codint codint } ]	0
Q_88	how to get has_many through across server work	C_88_9	col0 col1 tab0 . find_by ( col2 tab1 . col2 ) end	0
Q_88	how to get has_many through across server work	C_88_10	class col0 < col1 col2 col3 col4 col5 col6 col7 = tab0 . map { col8 tab1 . col9 } tab2 . where ( col9 col7 ) end end	0
Q_89	my_sql php select count of distinct value from comma separate data	C_89_0	select substring_index ( substring_index ( col0 , refre refre , col1 ) , refre refre , _ codint ) as col2 , count ( * ) as col3 from ( select group_concat ( col4 col5 refre refre ) as col0 , length ( group_concat ( col4 col5 refre refre ) ) _ length ( replace ( group_concat ( col4 col5 refre refre ) , refre refre , refre ) ) + codint as col6 from col7 ) col8 join col9 col10 on tab0 . col1 < = tab1 . col6 group by col2 order by col3 desc	1
Q_89	my_sql php select count of distinct value from comma separate data	C_89_1	+ _ + _ + col0 col1 + _ + _ + col2 codint col3 codint col4 codint col5 _ col6 codint col7 codint col8 codint col2 _ col9 codint col10 codint col11 codint col12 _ col13 codint col14 _ col15 codint col16 _ col17 codint col2 _ col18 codint col3 _ col18 codint col19 _ and _ col20 _ col3 codint col21 _ col22 codint col22 codint + _ + _ + codint rows in set ( number col23 )	0
Q_89	my_sql php select count of distinct value from comma separate data	C_89_2	create col0 test ( col1 int primary key , col2 varchar ( codint ) ) insert into col3 values ( refre , refre refre ) , ( refre , refre refre ) , ( refre , refre refre ) , ( refre , refre refre ) , ( refre , refre refre ) , ( refre , refre refre ) , ( refre , refre refre ) , ( refre , refre refre ) , ( refre , refre ) , ( refre , refre ) , ( refre , refre refre refre ) , ( refre , refre refre refre ) , ( refre , refre refre ) , ( refre , refre refre )	0
Q_89	my_sql php select count of distinct value from comma separate data	C_89_3	select group_concat ( col0 col1 refre refre ) from col2	0
Q_89	my_sql php select count of distinct value from comma separate data	C_89_4	select length ( group_concat ( col0 col1 refre refre ) ) _ length ( replace ( group_concat ( col0 col1 refre refre ) , refre refre , refre ) ) + codint as col2 from col3	0
Q_89	my_sql php select count of distinct value from comma separate data	C_89_5	+ _ + col0 + _ + codint + _ + codint row in set ( number col1 )	0
Q_89	my_sql php select count of distinct value from comma separate data	C_89_6	"_ returns col0 col1 until col0 col2 delimiter refre refre refre col3 , col4 , col5 refre refre , refre refre refre refre refre col3 , col4 , col5 refre refre , refre refre refre refre refre refre refre col3 , col4 , col5 refre refre , refre refre refre refre , "" , _ codint )"	0
Q_89	my_sql php select count of distinct value from comma separate data	C_89_7	select substring_index ( substring_index ( group_concat ( col0 col1 refre refre ) , refre refre , codint ) , refre refre , _ codint ) from col2	0
Q_89	my_sql php select count of distinct value from comma separate data	C_89_8	+ _ + substring_index ( substring_index ( group_concat ( col0 col1 refre refre ) , refre refre , codint ) , refre refre , _ codint ) + _ + col2 _ col3 + _ + codint row in set ( number col4 )	0
Q_89	my_sql php select count of distinct value from comma separate data	C_89_9	create col0 numbers ( col1 int primary key ) insert into col2 values ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint )	0
Q_89	my_sql php select count of distinct value from comma separate data	C_89_10	select tab0 . col0 , substring_index ( substring_index ( col1 , refre refre , col0 ) , refre refre , _ codint ) as col2 from ( select group_concat ( col3 col4 refre refre ) as col1 , length ( group_concat ( col3 col4 refre refre ) ) _ length ( replace ( group_concat ( col3 col4 refre refre ) , refre refre , refre ) ) + codint as col5 from col6 ) col7 join col8 col9 on tab0 . col0 < = tab1 . col5	0
Q_89	my_sql php select count of distinct value from comma separate data	C_89_11	+ _ + _ + col0 col1 + _ + _ + codint col2 codint col3 codint col4 _ col5 codint col6 codint col4 _ col5 codint col3 codint col6 _ col7 codint col6 codint col8 codint col6 codint col9 codint col6 codint col9 codint col10 codint col9 codint col11 _ col12 codint col13 _ col14 codint col15 _ col16 codint col6 _ col17 codint col6 codint col18 codint col3 _ col17 codint col3 codint col18 codint col19 _ and _ col20 _ col3 codint col3 codint col21 _ col22 codint col22 + _ + _ + codint rows in set ( number col23 )	0
Q_90	combine two table by join on the same date or close prior date	C_90_0	col0 col1 col2 _ _ _ codint codint _ codint _ codint col3 codint codint _ codint _ codint col4 codint codint _ codint _ codint col5 codint codint _ codint _ codint col6	1
Q_90	combine two table by join on the same date or close prior date	C_90_1	col0 col1 col2 _ _ _ codint codint _ codint _ codint col3 codint codint _ codint _ codint col4 codint codint _ codint _ codint col5 codint codint _ codint _ codint col6	0
Q_90	combine two table by join on the same date or close prior date	C_90_2	select tab0 . col0 , tab0 . col1 , tab1 . col2 from col3 col4 inner join col5 col6 on tab0 . col0 = tab1 . col0 and tab0 . col1 > = tab1 . col2	0
Q_90	combine two table by join on the same date or close prior date	C_90_3	col0 col1 col2 _ _ _ codint codint _ codint _ codint codint _ codint _ codint codint codint _ codint _ codint codint _ codint _ codint codint codint _ codint _ codint codint _ codint _ codint codint codint _ codint _ codint codint _ codint _ codint codint codint _ codint _ codint codint _ codint _ codint codint codint _ codint _ codint codint _ codint _ codint codint codint _ codint _ codint codint _ codint _ codint	0
Q_90	combine two table by join on the same date or close prior date	C_90_4	select tab0 . col0 , tab0 . col1 , max ( tab1 . col2 ) as col3 from col4 col5 inner join col6 col7 on tab0 . col0 = tab1 . col0 and tab0 . col1 > = tab1 . col2 group by tab0 . col0 , tab0 . col1	0
Q_90	combine two table by join on the same date or close prior date	C_90_5	col0 col1 col2 _ _ _ codint codint _ codint _ codint codint _ codint _ codint codint codint _ codint _ codint codint _ codint _ codint codint codint _ codint _ codint codint _ codint _ codint codint codint _ codint _ codint codint _ codint _ codint	0
Q_90	combine two table by join on the same date or close prior date	C_90_6	select tab0 . col0 , tab0 . col1 , tab0 . col2 , tab1 . col3 , tab1 . col4 from ( col5 inner join ( select tab2 . col0 , tab2 . col1 , max ( tab3 . col3 ) as col6 from col5 col7 inner join col8 col9 on tab2 . col0 = tab3 . col0 and tab2 . col1 > = tab3 . col3 group by tab2 . col0 , tab2 . col1 ) col10 on tab0 . col0 = tab4 . col0 and tab0 . col1 = tab4 . col1 ) inner join col8 on tab1 . col0 = tab4 . col0 and tab1 . col3 = tab4 . col6	0
Q_90	combine two table by join on the same date or close prior date	C_90_7	col0 col1 col2 col3 col4 _ _ _ _ _ codint codint _ codint _ codint col5 codint _ codint _ codint col6 codint codint _ codint _ codint col7 codint _ codint _ codint col6 codint codint _ codint _ codint col8 codint _ codint _ codint col9 codint codint _ codint _ codint col10 codint _ codint _ codint col11	0
Q_91	optimize table that already have duplicate entry	C_91_0	_ col0 number col1 col2 col3 codint _ codint _ codint codint col4 col5 codint _ codint _ codint codint _	1
Q_91	optimize table that already have duplicate entry	C_91_1	_ order col0 col1 codint col2 codint codint col3 codint codint col4 col5 codint codint col6 codint _	0
Q_91	optimize table that already have duplicate entry	C_91_2	_ col0 order codint codint codint codint codint codint codint codint _	0
Q_91	optimize table that already have duplicate entry	C_91_3	_ col0 col1 number col2 codint col3 col4 codint _ codint _ codint codint codint col5 col6 codint _ codint _ codint codint _	0
Q_91	optimize table that already have duplicate entry	C_91_4	_ order col0 col1 codint col2 codint codint col3 codint codint col4 col5 codint codint col6 codint _	0
Q_91	optimize table that already have duplicate entry	C_91_5	_ col0 order codint codint codint codint codint codint codint codint _	0
Q_91	optimize table that already have duplicate entry	C_91_6	codint . check for col0 codint . col1 col0 exists , get col2 col3 codint . col4 col0 col5 not tab0 . insert col6 and get col2 tab1 . codint . create new order col7 codint . create col8 col7	0
Q_91	optimize table that already have duplicate entry	C_91_7	user number col0 col1 col2 codint _ codint _ codint codint col1 col2 codint _ codint _ codint codint col1 col2 codint _ codint _ codint codint	0
Q_92	write a complex my_sql query	C_92_0	col0 , null , codint col1 , refre , codint col2 , refre refre , codint	1
Q_92	write a complex my_sql query	C_92_1	select tab0 . col0 , group_concat ( tab1 . col0 ) as col1 , count ( tab1 . col0 ) as col2 from col3 col4 left outer join col3 col5 on tab0 . col6 = tab1 . col6 and tab0 . col7 < tab1 . col7 where tab0 . col6 = codint group by tab0 . col0	0
Q_92	write a complex my_sql query	C_92_2	col0 col1 col2 codint null codint codint codint codint codint codint , codint codint	0
Q_92	write a complex my_sql query	C_92_3	select tab0 . col0 , tab1 . idarticle ( select tab2 . col0 , substring_index ( group_concat ( tab3 . col0 ) , refre refre , codint ) as col1 , count ( tab3 . col0 ) as col2 from col3 col4 left outer join col3 col5 on tab2 . col6 = tab3 . col6 and tab2 . col7 < tab3 . col7 where tab2 . col6 = codint group by tab2 . col0 ) col8 inner join col9 col10 on tab0 . col0 = tab1 . col0 left outer join col9 col11 on tab1 . col12 = tab4 . col12 and find_in_set ( tab4 . col0 , tab0 . col1 ) where tab4 . col0 is null order by col2 limit codint	0
Q_92	write a complex my_sql query	C_92_4	select tab0 . col0 , tab1 . col1 , tab2 . col1 , tab2 . count , tab2 . col2 from	0
Q_92	write a complex my_sql query	C_92_5	( select tab0 . col0 , group_concat ( tab1 . col0 ) as col1 , count ( tab1 . col0 ) as col2 from col3 col4 left outer join col3 col5 on tab0 . col6 = tab1 . col6 and tab0 . col7 < tab1 . col7 where tab0 . col6 = codint group by tab0 . col0 ) col8	0
Q_92	write a complex my_sql query	C_92_6	inner join col0 col1 on tab0 . col2 = tab1 . col2	0
Q_92	write a complex my_sql query	C_92_7	inner join ( select tab0 . col0 , tab0 . count , tab0 . col1 , sum ( if ( tab1 . col2 is null , codint , codint ) ) as col3 from col4 col5 inner join col6 col7 on tab0 . col0 = tab2 . col0 left outer join col8 col9 on tab2 . col10 = tab1 . col10 and tab1 . col11 = codint group by tab0 . col0 , tab0 . count , tab0 . col1 having col3 < codint ) col12 on tab3 . col0 = tab4 . col0	0
Q_92	write a complex my_sql query	C_92_8	left outer join col0 col1 on tab0 . col2 = tab1 . col2 and find_in_set ( tab1 . col3 , tab2 . col4 ) where tab1 . col3 is null order by col5 limit codint	0
Q_93	get new customer every week in sql server	C_93_0	col0 col1 codint col2 _ col3 codint and codint codint col4 _ col3 codint codint col5 _ col3 codint and codint _ option col6 codint col7 _ col3 codint is new and codint col8 not col9 _ or option col10 codint col7 _ col3 codint and codint _ col11 col3 codint col12 not order col13 in col5	1
Q_93	get new customer every week in sql server	C_93_1	select col0 , datepart ( week , col1 ) as col2 from col3 order by col0	0
Q_93	get new customer every week in sql server	C_93_2	col0 col1 codint codint _ col2 codint codint _ col3 not count , col4 col5 col6 col7 col8 codint codint _ col2 codint codint _ col2 codint codint _ col3 not count codint codint _ col2 codint codint _ col2 codint codint _ col3 not count	0
Q_93	get new customer every week in sql server	C_93_3	select distinct col0 , min ( col1 ) as col2 from col3 group by col0	0
Q_93	get new customer every week in sql server	C_93_4	select count ( col0 ) as col1 , datepart ( week , col2 ) as col3 from ( select distinct col0 , min ( col4 ) as col2 from col5 group by col0 ) col6 group by datepart ( week , col2 )	0
Q_93	get new customer every week in sql server	C_93_5	col0 col1 codint codint _ only col2 codint codint codint _ col2 codint and codint codint codint _ col2 codint and codint _ nothing for week codint col3 col2 codint col4 col5 col6	0
Q_93	get new customer every week in sql server	C_93_6	create col0 revenues ( col1 int , col2 col3 , col4 int ) insert into revenues ( col1 , col2 , col4 ) values ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint )	0
Q_94	how create a database organize by tag	C_94_0	create col0 if not exists platforms ( col1 mediumint ( codint ) unsigned not null auto_increment , col2 varchar ( codint ) not null , primary key ( col1 ) ) create col0 if not exists games ( col1 mediumint ( codint ) unsigned not null auto_increment , col2 varchar ( codint ) not null , primary key ( col1 ) ) create col0 if not exists games_platforms ( col3 mediumint ( codint ) not null , col4 mediumint ( codint ) not null , unique key unique pair ( col3 , col4 ) )	1
Q_94	how create a database organize by tag	C_94_1	insert into platforms ( col0 , col1 ) values ( codint , refre ) , ( codint , refre ) , ( codint , refre ) insert into games ( col0 , col1 ) values ( codint , refre ) , ( codint , refre ) , ( codint , refre ) insert into games_platforms ( col2 , col3 ) values ( codint , codint ) , ( codint , codint ) , ( codint , codint )	0
Q_94	how create a database organize by tag	C_94_2	select tab0 . col0 as col1 , tab1 . col0 as col2 from col3 col4 left join col5 col6 on ( tab2 . col7 = tab0 . col8 ) left join col9 col10 on ( tab1 . col8 = tab2 . col11 )	0
Q_94	how create a database organize by tag	C_94_3	col0 col1 _ _ col2 codint col3 codint col2 codint col3 codint col2 codint col3 codint col2 codint ( null )	0
Q_94	how create a database organize by tag	C_94_4	/ / fetch col0 by col1 sql = refre refre refre refre refre col2 / col3 refre refre , refre refre refre refre refre refre refre refre refre	0
Q_94	how create a database organize by tag	C_94_5	. / / col0 col1 by col2 col3 > < col4 col5 = refre > < col6 > < col7 > < col8 > col2 < / col8 > < col8 > col1 < / col8 > < / col7 > < / col6 > < col9 > < col3 col10 while ( row = col11 _ > fetch ( col12 col13 ) ) { col3 > < col7 > < col14 > < col3 = row col15 col3 > < / col14 > < col14 > < col3 = row col16 col3 > < / col14 > < col14 > < col3 = row col17 col3 > < / col14 > < / col7 > < col3 col10 } col3 > < / col9 > < / col4 > < col3 tab0 .	0
Q_94	how create a database organize by tag	C_94_6	col0 col1 col2 count _ _ _ col0 codint col2 codint , col2 codint , col2 codint codint col0 codint col2 codint , col2 codint codint col0 codint col2 codint , col2 codint , col2 codint codint col0 codint col2 codint codint col0 codint col3 / col4 codint col0 codint col2 codint , col2 codint codint	0
Q_94	how create a database organize by tag	C_94_7	/ / fetch col0 by col1 sql = refre refre refre refre refre refre refre refre	0
Q_94	how create a database organize by tag	C_94_8	while ( row = col0 _ > fetch ( col1 col2 ) ) { / / add col3 row refre refre refre col4 refre refre refre refre col5 refre refre refre col6 refre refre refre col4 refre refre refre col7 refre refre refre col8 refre refre refre refre refre col9 col10 col11 for col3 row , add col12 to col13 col5 col14 if ( row col15 ) { col16 [ row col17 ] col18 col19 = array ( refre = > row col15 , refre = > row col20 ) } }	0
Q_94	how create a database organize by tag	C_94_9	col0 > < col1 col2 = refre > < col3 > < col4 > < col5 > col6 < / col5 > < col5 > col7 < / col5 > < col5 > col8 count < / col5 > < / col4 > < / col3 > < col9 > < col0 col10 foreach ( col11 as col12 ) { col0 > < col4 > < col13 > < col14 col15 = refre regque refre refre regque refre refre col6 refre refre refre col16 refre refre regque refre refre > < col0 = col12 col17 col18 col0 > < / col14 > < / col13 > < col13 > < col0 col10 if ( empty ( col12 col19 ) ) { col20 refre refre } else { foreach ( col12 col19 as col8 ) { col0 > < col21 > < col14 col15 = refre regque refre refre regque refre refre col16 refre refre regque refre refre > < col0 = col8 col18 col0 > < / col14 > < / col21 > < col0 col10 } } col0 > < / col13 > < col13 > < col0 = empty ( col12 col19 ) col0 count ( col12 col19 ) codint col0 > < / col13 > < / col4 > < col0 col10 } col0 > < / col9 > < / col1 > < col0 col10	0
Q_94	how create a database organize by tag	C_94_10	col0 col1 col2 count _ _ _ col0 codint col2 codint codint col2 codint col2 codint col0 codint col2 codint codint col2 codint col0 codint col2 codint codint col2 codint col2 codint col0 codint col2 codint codint col0 codint col3 / col4 codint col0 codint col2 codint codint col2 codint	0
Q_95	calculate percent difference from average value	C_95_0	select col0 , avg ( col1 ) as col2 from col3 group by col0	1
Q_95	calculate percent difference from average value	C_95_1	select tab0 . col0 , tab0 . col1 , tab0 . col2 , tab1 . col3 from col4 col5 join ( select col0 , avg ( col2 ) as col3 from col4 group by col0 ) col6 on tab1 . col0 = tab0 . col0	0
Q_95	calculate percent difference from average value	C_95_2	select tab0 . col0 , tab0 . col1 , ( codint * ( ( tab0 . col2 _ tab1 . col3 ) / tab1 . col3 ) ) as col4 from col5 col6 join ( select col0 , avg ( col2 ) as col3 from col5 group by col0 ) col7 on tab1 . col0 = tab0 . col0	0
Q_95	calculate percent difference from average value	C_95_3	select col0 , avg ( col1 ) as col2 from ( select tab0 . col3 , tab0 . col0 , ( codint * ( ( tab0 . col4 _ tab1 . col5 ) / tab1 . col5 ) ) as col1 from col6 col7 join ( select col3 , avg ( col4 ) as col5 from col6 group by col3 ) col8 on tab1 . col3 = tab0 . col3 ) col8 group by col0	0
Q_95	calculate percent difference from average value	C_95_4	select count ( distinct col0 ) as col1 from col2	0
Q_95	calculate percent difference from average value	C_95_5	select col0 , col1 from col2 group by col0 , col1 having count ( distinct col3 ) = ( select count ( distinct col3 ) from col2 )	0
Q_95	calculate percent difference from average value	C_95_6	select col0 , col1 , avg ( col2 ) as col3 from col4 group by col0 , col1 having count ( distinct col5 ) = ( select count ( distinct col5 ) from col4 )	0
Q_95	calculate percent difference from average value	C_95_7	select tab0 . col0 , tab0 . col1 , tab0 . col2 , ( codint * ( ( tab0 . col3 _ tab1 . col4 ) / tab1 . col4 ) ) as col5 from col6 col7 join ( select col1 , col2 , avg ( col3 ) as col4 from col6 group by col1 , col2 ) col8 on tab1 . col1 = tab0 . col1 and tab1 . col2 = tab0 . col2 group by tab0 . col0	0
Q_95	calculate percent difference from average value	C_95_8	select col0 , avg ( col1 ) as col2 from ( select tab0 . col0 , tab0 . col3 , tab0 . col4 , ( codint * ( ( tab0 . col5 _ tab1 . col6 ) / tab1 . col6 ) ) as col1 from col7 col8 join ( select col3 , col4 , avg ( col5 ) as col6 from col7 group by col3 , col4 ) col9 on tab1 . col3 = tab0 . col3 and tab1 . col4 = tab0 . col4 group by tab0 . col0 ) col9 group by col0	0
Q_96	refactoring a my_sql query with a number of inner select to join	C_96_0	select tab0 . col0 from col1 col2 join col1 col3 on ( tab1 . col4 = tab0 . col0 ) where tab1 . col0 = ( select tab2 . col0 from col5 col6 where tab2 . col7 = col8 )	1
Q_96	refactoring a my_sql query with a number of inner select to join	C_96_1	select tab0 . col0 from col1 col2 join col1 col3 on ( tab1 . col4 = tab0 . col0 ) join col5 col6 on tab2 . col0 = tab1 . col0 and tab2 . col7 = col8	0
Q_96	refactoring a my_sql query with a number of inner select to join	C_96_2	select tab0 . col0 as col0 from col1 col2 where tab0 . col3 = ( select tab1 . col4 from col5 col6 where col7 = ( select tab2 . col7 from col5 col6 join col5 col8 on ( tab1 . col9 = tab2 . col7 ) join col10 col11 on tab3 . col7 = tab1 . col7 and tab3 . col12 = col13 ) )	0
Q_96	refactoring a my_sql query with a number of inner select to join	C_96_3	select tab0 . col0 from col1 col2 where col3 = ( select tab1 . col3 from col1 col2 join col1 col4 on ( tab0 . col5 = tab1 . col3 ) join col6 col7 on tab2 . col3 = tab0 . col3 and tab2 . col8 = col9	0
Q_96	refactoring a my_sql query with a number of inner select to join	C_96_4	select tab0 . col0 from col1 col2 join col1 col3 on ( tab0 . col4 = tab1 . col5 ) join col6 col7 on tab2 . col5 = tab0 . col5 and tab2 . col8 = col9	0
Q_96	refactoring a my_sql query with a number of inner select to join	C_96_5	select tab0 . col0 as col0 from col1 col2 where tab0 . col3 = ( select tab1 . col4 from col5 col6 join col5 col7 on ( tab1 . col8 = tab2 . col9 ) join col10 col11 on tab3 . col9 = tab1 . col9 and tab3 . col12 = col13 )	0
Q_96	refactoring a my_sql query with a number of inner select to join	C_96_6	select tab0 . col0 as col0 from col1 col2 join col3 col4 on ( tab0 . col5 = tab1 . col6 ) join col3 col7 on ( tab2 . col8 = tab1 . col9 ) join col10 col11 on tab3 . col9 = tab2 . col9 and tab3 . col12 = col13	0
Q_97	sql when a z then set b x	C_97_0	_ col0 case col1 when col2 then col1 = col3 when col4 then col1 = tab0 . end	1
Q_97	sql when a z then set b x	C_97_1	_ col0 col1 = case when col2 then col3 when col4 then tab0 . end	0
Q_97	sql when a z then set b x	C_97_2	_ col0 case when col1 then col2 when col3 then tab0 . end as col4	0
Q_97	sql when a z then set b x	C_97_3	_ col0 case when col1 in ( codint , codint , codint ) then col2 when col1 in ( codint , codint , codint ) then tab0 . else null end	0
Q_97	sql when a z then set b x	C_97_4	select col0 , case when col1 in ( refre , refre , refre , refre , refre , refre , refre ) then refre when col1 in ( refre , refre , refre , refre , refre , refre , refre , refre , refre , refre , refre , refre , refre , refre , refre ) then refre when col1 in ( refre , refre , refre ) then null else col2 end as col2 , sum ( col3 ) as col4 , sum ( col5 ) as col6 from tab0 . col7 where col8 = codint and col9 not in ( refre , refre )	0
Q_97	sql when a z then set b x	C_97_5	select col0 , col1 , sum ( col2 ) as col3 , sum ( col4 ) as col5 from ( select col6 , case when col7 in ( refre , refre , refre , refre , refre , refre , refre ) then refre when col7 in ( refre , refre , refre , refre , refre , refre , refre , refre , refre , refre , refre , refre , refre , refre , refre ) then refre when col7 in ( refre , refre , refre ) then null else col1 end as col1 , col2 , col4 from tab0 . col8 where col9 = codint and col10 not in ( refre , refre ) ) col11 group by col6 , col1	0
Q_97	sql when a z then set b x	C_97_6	_ col0 select col1 , coalesce ( tab0 . col2 , tab1 . col3 ) as col3 sum ( col4 ) as col5 , sum ( col6 ) as col7 from tab2 . col8 col9 left join col10 col11 on tab0 . col12 = tab1 . col12 where tab1 . col13 = codint and col14 not in ( refre , refre ) group by col1 , coalesce ( tab0 . col2 , tab1 . col3 )	0
Q_98	how to design relational database for conference and workshop	C_98_0	col0 _ col0 col1 col0 col2 col0 col3 col0 col4 col5 col0 start date col0 end date col0 col4 col6 col0 col7 col6	1
Q_98	how to design relational database for conference and workshop	C_98_1	col0 _ col0 col1 col2 col1 col0 col3 col0 col4 col0 col5 col6 col0 date col0 col7	0
Q_98	how to design relational database for conference and workshop	C_98_2	col0 _ col0 col1 col0 type col0 col2 col0 col3	0
Q_98	how to design relational database for conference and workshop	C_98_3	col0 _ col0 col1 col0 col2 col0 col3 col0 col4 col0 col5 col0 col6 col0 col7 col8 col0 col9 col8	0
Q_98	how to design relational database for conference and workshop	C_98_4	col0 _ col0 col1 col2 col1 col3 col1 col0 date col4 date col5 col6 col7 col8 col3 col9 number of col10	0
Q_98	how to design relational database for conference and workshop	C_98_5	col0 _ col0 col1 col2 col1 col0 col3 col0 tab0 . col4 col0 col5	0
Q_98	how to design relational database for conference and workshop	C_98_6	col0 col1 _ col0 col1 col2 col3 col2 col0 col2 col0 col1 date	0
Q_98	how to design relational database for conference and workshop	C_98_7	col0 col1 _ col0 col1 col2 col3 col2 col0 col2 col4 col1 col2 col0 col1 date	0
Q_99	table join on column name to column value	C_99_0	create view col0 as select tab0 . col1 as col2 , tab1 . col1 as col3 , tab1 . col4 , case tab1 . col4 when refre then tab0 . col5 when refre then tab0 . col6 when refre then tab0 . col7 when refre then tab0 . col8 when refre then tab0 . col9 when refre then tab0 . col10 when refre then tab0 . col11 when refre then tab0 . col12 when refre then tab0 . col13 end as col14 , tab1 . col15 , tab0 . date from col16 col17 cross join col18 col19	1
Q_99	table join on column name to column value	C_99_1	col0 > select col1 from col2 where col3 = codint + _ + col1 + _ + col4 col5 col6 col7 col8 col9 + _ + codint rows in set ( number col10 )	0
Q_99	table join on column name to column value	C_99_2	create col0 ambro_awards ( tab0 . , tab1 . , tab2 . )	0
Q_99	table join on column name to column value	C_99_3	create col0 ambro_awards_categories ( tab0 . , tab1 . )	0
Q_99	table join on column name to column value	C_99_4	create col0 ambro_awards_and_categories ( col1 integer not null , col2 integer not null , col3 varchar ( < col4 length col5 > ) not null , primary key ( col1 , col2 ) , foreign key ( col1 ) references ambro_awards ( col6 ) , foreign_key ( col2 ) references ambro_awards_categories ( col6 ) )	0
Q_99	table join on column name to column value	C_99_5	col0 col1 col2 codint codint col3 col4 codint codint col3 col4 codint codint col3 col4 codint codint col5 col6 codint codint col5 col6 codint codint col5 col6 codint codint col5 col6 codint codint col7 col8 codint codint col9	0
Q_99	table join on column name to column value	C_99_6	select tab0 . col0 , tab1 . col1 from col2 col3 join col4 col5 on tab0 . col6 = tab1 . col7	0
Q_99	table join on column name to column value	C_99_7	select tab0 . col0 , tab0 . col1 , tab0 . date , tab1 . col2 from col3 col4 join col5 col6 on tab1 . col7 = tab0 . col0 where tab0 . col0 = codint	0
Q_100	ms access group query	C_100_0	col0 col1 col2 _ _ _ col3 col4 col5 _ _ _ col3 col6 col7 _ _ _ col3 col8 col9 _ _ _ col3 col6 col10 _ _ _ col3 col8 col11 _ _ _ col3 col4 col12 _ _ _	1
Q_100	ms access group query	C_100_1	select tab0 . col0 , refre as col1 , tab0 . col2 as col3 from col4 as col5 where not tab0 . col2 is null union all select tab0 . col0 , refre , tab0 . col6 from col4 as col5 where not tab0 . col6 is null union all select tab0 . col0 , refre , tab0 . col7 from col4 as col5 where not tab0 . col7 is null	0
Q_100	ms access group query	C_100_2	select tab0 . * into col0 from ( _ col1 col2 ) as col3	0
Q_100	ms access group query	C_100_3	row_number ( ) over ( partition by col0 , order by col1 )	0
Q_100	ms access group query	C_100_4	select tab0 . col0 , tab0 . col1 , tab0 . col2 , tab0 . col3 , ( select count ( tab1 . col2 ) from col4 as col5 where tab1 . col2 = tab0 . col2 and tab1 . col0 > = tab0 . col0 group by tab1 . col2 ) as col6 from col4 as col7	0
Q_100	ms access group query	C_100_5	col0 col1 col2 col3 col4 codint col5 col6 col7 codint codint col5 col6 col8 codint codint col5 col6 col9 codint codint col5 col10 col11 codint codint col5 col12 col13 codint codint col5 col12 col14 codint	0
Q_100	ms access group query	C_100_6	select tab0 . * insert into col0 from col1 as col2	0
Q_100	ms access group query	C_100_7	transform first ( tab0 . col0 ) as col1 select tab0 . col2 , tab0 . col3 from col4 as col5 group by tab0 . col2 , tab0 . col3 col6 tab0 . col7	0
Q_100	ms access group query	C_100_8	col0 col1 col2 col3 col4 col5 codint col6 col7 col8 col5 codint col9 col10 col5 codint col11	0
Q_101	mysql into outfile nest union with null cause a formatting issue with integer	C_101_0	"select * into col0 refre refre refre col1 col2 by refre col3 by refre refre refre "" from ( ( select col4 , col5 , col6 from col7 ) union ( select * from ( ( select col4 , col5 , null as col6 from col8 ) union ( select col4 , null as col5 , null as col6 from col9 ) ) col10 ) ) col11"	1
Q_101	mysql into outfile nest union with null cause a formatting issue with integer	C_101_1	refre refre refre refre refre refre refre refre refre refre refre refre	0
Q_101	mysql into outfile nest union with null cause a formatting issue with integer	C_101_2	refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre	0
Q_101	mysql into outfile nest union with null cause a formatting issue with integer	C_101_3	"select * into col0 refre refre refre col1 col2 by refre col3 by refre refre refre "" from ( ( select col4 , col5 , col6 from col7 ) union ( select * from ( ( select col4 , col5 , null as col6 from col8 ) union ( select col4 , null as col5 , null as col6 from col9 ) ) col10 ) ) col11"	0
Q_101	mysql into outfile nest union with null cause a formatting issue with integer	C_101_4	refre refre refre regsta refre regsta refre regsta refre refre refre refre regsta refre regsta refre regsta refre refre refre null refre refre null refre null null refre null null	0
Q_101	mysql into outfile nest union with null cause a formatting issue with integer	C_101_5	"select * into col0 refre refre refre col1 col2 by refre col3 by refre refre refre "" from ( ( select col4 , col5 , col6 from col7 ) union ( select * from ( ( select col4 , col5 , null as col6 from col8 ) union ( select col4 , null as col5 , codint as col6 from col9 ) ) col10 ) ) col11"	0
Q_101	mysql into outfile nest union with null cause a formatting issue with integer	C_101_6	refre refre refre refre refre refre refre refre null refre refre null refre null codint refre null codint	0
Q_102	normalize table data	C_102_0	create col0 people ( col1 integer primary key , col2 varchar ( codint ) not null , col3 varchar ( codint ) not null , col4 integer not null references col5 ) insert into col6 values ( codint , refre , refre , codint ) , ( codint , refre , refre , codint ) , ( codint , refre , refre , codint ) , ( codint , refre , refre , codint )	1
Q_102	normalize table data	C_102_1	create col0 instructors ( col1 integer primary key references col2 ) insert into col3 values ( codint ) , ( codint )	0
Q_102	normalize table data	C_102_2	create col0 employees ( col1 integer primary key references col2 ) insert into col3 values ( codint ) , ( codint ) , ( codint )	0
Q_102	normalize table data	C_102_3	create col0 courses ( col1 integer primary key , col2 varchar ( codint ) not null unique , col3 varchar ( codint ) not null , _ unique col4 col5 varchar ( codint ) not null _ col6 col7 col8 col9 col10 col11 own tab0 . ) insert into col12 values ( codint , refre , refre , refre ) , ( codint , refre , refre , refre )	0
Q_102	normalize table data	C_102_4	create col0 classes ( col1 integer not null references col2 , col3 integer not null references instructors ( col4 ) , col5 date not null , _ col6 col7 no col8 col9 col10 col11 , col12 col6 col13 tab0 . primary key ( col1 , col3 , col5 ) ) insert into col14 values ( codint , codint , refre ) , ( codint , codint , refre )	0
Q_102	normalize table data	C_102_5	create col0 class_rosters ( col1 integer not null , col2 integer not null , col3 date not null , col4 integer not null references employees ( col5 ) on update restrict on delete cascade , primary key ( col1 , col2 , col3 , col4 ) , foreign key ( col1 , col2 , col3 ) references classes ( col1 , col2 , col3 ) on update cascade on delete cascade ) insert into col6 values ( codint , codint , refre , codint ) , ( codint , codint , refre , codint ) , ( codint , codint , refre , codint ) , _ col7 col8 is col9 col10 tab0 . ( codint , codint , refre , codint ) , ( codint , codint , refre , codint )	0
Q_102	normalize table data	C_102_6	_ col0 col1 col2 col3 class col4 col5 col6 col7 in tab0 . select distinct tab1 . col8 from col9 col10 inner join col11 col12 on tab2 . col13 = tab1 . col14 where tab2 . col15 = refre and tab2 . col16 = refre _ col0 col1 col2 col3 class col4 col5 both col6 col7 _ and col17 mings ( col18 col19 ) in tab0 . with col20 as ( select col13 from col11 where ( col15 = refre and col16 = refre ) or ( col15 = refre and col16 = refre ) ) select col8 from col9 col10 inner join col20 col21 on tab3 . col13 = tab1 . col14 group by col22 , col8 , col23 having count ( * ) = ( select count ( * ) from col20 )	0
Q_103	cascade update to relate object	C_103_0	create col0 parent ( col1 integer primary key , col2 char ( codint ) default refre , col3 boolean not null default true , unique ( col1 , col4 ) ) insert into parent ( col1 ) values ( codint ) , ( codint ) , ( codint )	1
Q_103	cascade update to relate object	C_103_1	create col0 child ( col1 integer not null , col2 boolean not null default true , foreign key ( col1 , col2 ) references parent ( col1 , col2 ) on update cascade , col3 char ( codint ) not null default refre , primary key ( col1 , col3 ) ) insert into child ( col1 , col3 ) values ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre )	0
Q_103	cascade update to relate object	C_103_2	update col0 set col1 = false where col2 = codint select * from col3 order by col2	0
Q_103	cascade update to relate object	C_103_3	create col0 col1 _ col2 for col3 col4 of col5 _ constraint tab0 . create col6 parent ( col7 integer not null , col8 char ( codint ) not null default refre , col9 col10 not null , primary key ( col7 , col9 ) , _ no col11 date col12 for col13 col14 col15 of tab1 . col16 using gist ( col7 with = , col9 with ) ) create col6 child ( col7 integer not null , col9 col10 not null , foreign key ( col7 , col9 ) references col17 on update cascade , col18 char ( codint ) not null default refre , primary key ( col7 , col9 , col18 ) , col8 char ( codint ) not null default refre )	0
Q_103	cascade update to relate object	C_103_4	insert into col0 values ( codint , refre , daterange ( refre , refre ) ) insert into col1 values ( codint , daterange ( refre , refre ) , refre , refre ) , ( codint , daterange ( refre , refre ) , refre , refre )	0
Q_103	cascade update to relate object	C_103_5	select * from col0 col1 left join col2 col3 on tab0 . col4 = tab1 . col4 and tab0 . col5 = tab1 . col5	0
Q_103	cascade update to relate object	C_103_6	update col0 set col1 = daterange ( refre , refre ) where col2 = codint and col1 = daterange ( refre , refre )	0
Q_103	cascade update to relate object	C_103_7	insert into col0 values ( codint , refre , daterange ( current_date , refre ) ) update col1 set col2 = daterange ( current_date , refre ) where col3 = codint and col2 = daterange ( refre , refre )	0
Q_104	how can you show zero in a row use year and month dynamic in an interval	C_104_0	set col0 = refre set col1 = refre select row = row + ( case when right ( row , codint ) = refre then codint else codint end ) as col2 from ( select codint union all select codint union all select codint union all select codint union all select codint union all select codint union all select codint union all select codint union all select codint union all select codint union all select codint union all select codint ) col3 , ( select row = concat ( col0 , right ( concat ( refre , ( col1 _ codint ) ) , codint ) ) ) col4	1
Q_104	how can you show zero in a row use year and month dynamic in an interval	C_104_1	col0 _ codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_104	how can you show zero in a row use year and month dynamic in an interval	C_104_2	create col0 creations ( col1 int , col2 date ) insert into creations ( col1 , col2 ) values ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre )	0
Q_104	how can you show zero in a row use year and month dynamic in an interval	C_104_3	set col0 = refre set col1 = refre select count ( col2 ) as col3 , left ( col4 , codint ) as col5 , right ( col4 , codint ) as col6 from ( select row = row + ( case when right ( row , codint ) = refre then codint else codint end ) as col4 from ( select codint union all select codint union all select codint union all select codint union all select codint union all select codint union all select codint union all select codint union all select codint union all select codint union all select codint union all select codint ) col7 , ( select row = concat ( col0 , right ( concat ( refre , ( col1 _ codint ) ) , codint ) ) ) col8 ) as col9 left outer join col10 on concat ( year1 ( col2 ) , right ( concat ( refre , month ( col2 ) ) , codint ) ) = col4 group by col4 order by col4 asc	0
Q_104	how can you show zero in a row use year and month dynamic in an interval	C_104_4	col0 col1 col2 _ _ _ codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_104	how can you show zero in a row use year and month dynamic in an interval	C_104_5	create col0 yearmonthtable ( col1 int , col2 int ) insert into yearmonthtable ( col1 , col2 ) values ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint )	0
Q_104	how can you show zero in a row use year and month dynamic in an interval	C_104_6	set col0 = refre set col1 = refre set from = str_to_date ( concat ( col0 , refre refre , col1 , refre refre ) , refre refre refre ) set to = date_add ( date_add ( from , interval codint month ) , interval _ codint col2 ) select count ( col3 ) as col4 , col5 as col6 , col7 as col8 from col9 left outer join col10 on year1 ( col3 ) = col5 and month ( col3 ) = col7 where str_to_date ( concat ( col5 , refre refre , col7 , refre refre ) , refre refre refre ) between from and to group by col7 , col5 order by col5 , col7	0
Q_104	how can you show zero in a row use year and month dynamic in an interval	C_104_7	col0 col1 col2 _ _ _ codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_105	show each row that be a duplicate	C_105_0	with col0 as ( select col1 , col2 , right ( col1 , len ( col1 ) _ charindex ( refre refre , col1 , case when patindex ( refre refre refre refre , col1 ) > codint then patindex ( refre refre refre refre , col1 ) + codint else codint end ) + codint ) as col3 from col4 )	1
Q_105	show each row that be a duplicate	C_105_1	_ create col0 col1 and tab0 . _ col2 create col1 mytable ( col3 varchar ( codint ) , col4 varchar ( codint ) ) _ col5 insert into col6 values ( refre refre , refre refre ) , ( refre refre refre refre , refre refre refre refre ) , ( refre refre refre refre , refre refre refre refre ) , ( refre refre refre refre refre , refre refre refre refre refre )	0
Q_105	show each row that be a duplicate	C_105_2	with col0 as ( select col1 , col2 , right ( col1 , len ( col1 ) _ charindex ( refre refre , col1 , patindex ( refre refre refre , col1 ) + codint _ get col3 location right after refre refre refre ) + codint _ get col3 location right after col3 first / after col3 col4 ) as col5 from col6 )	0
Q_105	show each row that be a duplicate	C_105_3	select tab0 . col0 , tab0 . col1 , tab1 . col2 from col3 col4 inner join ( select col2 from col3 group by col2 having count ( codint ) > codint ) col5 on ( tab0 . col2 = tab1 . col2 )	0
Q_105	show each row that be a duplicate	C_105_4	col0 col1 col2 _ / col3 / col3 / col3 col4 / / tab0 . tab1 . col5 / col3 col4 / / tab0 . tab1 . col5 / col3 / col3 col4 / / tab2 . tab1 . col5 / col3 col4 / / tab2 . tab1 . col5 / col3 / col3	0
Q_105	show each row that be a duplicate	C_105_5	_ create col0 col1 and tab0 . _ col2 create col1 mytable ( col3 varchar ( codint ) , col4 varchar ( codint ) ) _ col5 insert into col6 values ( refre refre , refre refre refre ) , ( refre refre , refre refre refre ) , ( refre refre refre refre , refre refre refre refre ) , ( refre refre refre refre , refre refre refre refre ) , ( refre refre , refre refre ) , ( refre refre refre , refre refre ) , ( refre refre , refre refre ) , ( refre , refre )	0
Q_105	show each row that be a duplicate	C_105_6	with col0 as ( select col1 , col2 , right ( col1 , case when charindex ( refre refre , col1 ) > codint then charindex ( refre refre , reverse ( col1 ) ) _ codint else len ( col1 ) end ) as col3 from col4 ) select distinct tab0 . col1 , tab0 . col2 , tab0 . col3 from col0 col5 inner join col0 col6 on ( tab0 . col3 = tab1 . col3 ) where tab0 . col1 < > tab1 . col1	0
Q_105	show each row that be a duplicate	C_105_7	select tab0 . col0 , tab0 . col1 , tab1 . col2 from col3 col4 inner join ( select col2 from col3 group by col2 having count ( codint ) > codint ) col5 on ( tab0 . col2 = tab1 . col2 )	0
Q_106	mysql _ get close value to correct value return zero to many depend on result	C_106_0	create col0 multiple_picks ( col1 int , col2 int , col3 int , col4 varchar ( codint ) , col5 int ) insert into col6 values ( codint , codint , codint , refre , codint ) , ( codint , codint , codint , refre , codint ) , ( codint , codint , codint , refre , codint ) , ( codint , codint , codint , refre , codint ) , ( codint , codint , codint , refre , codint ) , ( codint , codint , codint , refre , codint ) , ( codint , codint , codint , refre , codint ) , ( codint , codint , codint , refre , codint ) , ( codint , codint , codint , refre , codint ) , ( codint , codint , codint , refre , codint ) , ( codint , codint , codint , refre , codint ) , ( codint , codint , codint , refre , codint )	1
Q_106	mysql _ get close value to correct value return zero to many depend on result	C_106_1	set col0 = codint set col1 = refre set col2 = codint _ show all col3 for col4 col5 match select * from col6 where col7 = col0 _ show col8 col3 for col4 col5 match select tab0 . * from col6 col9 where tab0 . col7 = col0 and tab0 . col10 = col1 and abs ( tab0 . col11 _ col2 ) = ( select min ( abs ( tab1 . col11 _ col2 ) ) from col6 col12 where tab1 . col7 = col0 and tab1 . col10 = col1 )	0
Q_106	mysql _ get close value to correct value return zero to many depend on result	C_106_2	_ show all col0 for col1 col2 match + _ + _ + _ + _ + _ + col3 col4 col5 col6 col7 + _ + _ + _ + _ + _ + codint codint codint col8 codint codint codint codint col8 codint codint codint codint col8 codint + _ + _ + _ + _ + _ + _ show col9 col0 for col1 col2 match + _ + _ + _ + _ + _ + col3 col4 col5 col6 col7 + _ + _ + _ + _ + _ + codint codint codint col8 codint codint codint codint col8 codint + _ + _ + _ + _ + _ +	0
Q_106	mysql _ get close value to correct value return zero to many depend on result	C_106_3	create col0 matches ( col1 int , col2 varchar ( codint ) , col3 int , col4 int ) insert into col5 values ( codint , refre , codint , codint ) , ( codint , refre , codint , codint ) , ( codint , refre , codint , codint ) , ( codint , refre , codint , codint ) , ( codint , refre , codint , codint ) , ( codint , refre , codint , codint )	0
Q_106	mysql _ get close value to correct value return zero to many depend on result	C_106_4	_ show all col0 col1 for all col2 select tab0 . * , tab1 . col3 from col4 col5 join ( select tab2 . col6 , tab2 . col7 , tab2 . col8 , tab2 . col3 , min ( abs ( tab2 . col8 _ tab3 . col8 ) ) as col9 from col2 col10 join col4 col11 on tab3 . col6 = tab2 . col6 and tab3 . col12 = tab2 . col7 group by tab2 . col6 , tab2 . col7 , tab2 . col8 , tab2 . col3 ) as col13 on tab0 . col6 = tab1 . col6 and tab0 . col12 = tab1 . col7 and abs ( tab1 . col8 _ tab0 . col8 ) = tab1 . col9 order by tab1 . col3 , tab0 . col6	0
Q_106	mysql _ get close value to correct value return zero to many depend on result	C_106_5	_ show col0 count of col1 col2 for each col3 for each col4 select tab0 . col5 , tab1 . col4 , count ( * ) as col6 from col7 col8 join ( select tab2 . col9 , tab2 . col10 , tab2 . col11 , tab2 . col4 , min ( abs ( tab2 . col11 _ tab3 . col11 ) ) as col12 from col13 col14 join col7 col15 on tab3 . col9 = tab2 . col9 and tab3 . col16 = tab2 . col10 group by tab2 . col9 , tab2 . col10 , tab2 . col11 , tab2 . col4 ) as col17 on tab0 . col9 = tab1 . col9 and tab0 . col16 = tab1 . col10 and abs ( tab1 . col11 _ tab0 . col11 ) = tab1 . col12 group by tab0 . col5 , tab1 . col4 order by tab1 . col4 , count ( * ) desc	0
Q_106	mysql _ get close value to correct value return zero to many depend on result	C_106_6	create view col0 as select tab0 . col1 , tab0 . col2 , tab0 . col3 , tab0 . col4 , min ( abs ( tab0 . col3 _ tab1 . col3 ) ) as col5 from col6 col7 join col8 col9 on tab1 . col1 = tab0 . col1 and tab1 . col10 = tab0 . col2 group by tab0 . col1 , tab0 . col2 , tab0 . col3 , tab0 . col4 create view col11 as select tab1 . * , tab0 . col4 from col8 col9 join col0 col7 on tab1 . col1 = tab0 . col1 and tab1 . col10 = tab0 . col2 and abs ( tab0 . col3 _ tab1 . col3 ) = tab0 . col5 create view col12 as select col13 , col4 , count ( * ) as col14 from col11 group by col13 , col4	0
Q_106	mysql _ get close value to correct value return zero to many depend on result	C_106_7	_ show col0 col1 with col0 col2 number of col3 col4 for each col5 select * from col6 col7 where col8 = ( select max ( tab0 . col8 ) from col6 col9 where tab0 . col5 = tab1 . col5 ) order by col5	0
Q_106	mysql _ get close value to correct value return zero to many depend on result	C_106_8	_ show col0 col1 with col0 col2 number of col3 col4 for each col5 + _ + _ + _ + col6 col5 col7 + _ + _ + _ + codint codint codint codint codint codint + _ + _ + _ +	0
Q_107	return all possible combination of value within a single column in sql	C_107_0	create col0 test ( col1 ) as select level from col2 connect by level < codint	1
Q_107	return all possible combination of value within a single column in sql	C_107_1	select substr ( sys_connect_by_path ( col0 , refre refre ) , codint ) as col1 from col2 connect by prior col0 < col0	0
Q_107	return all possible combination of value within a single column in sql	C_107_2	col0 _ codint codint , codint codint , codint , codint codint , codint , codint , codint codint , codint , codint codint , codint codint , codint , codint codint , codint codint codint , codint codint , codint , codint codint , codint codint codint , codint codint	0
Q_107	return all possible combination of value within a single column in sql	C_107_3	select substr ( sys_connect_by_path ( col0 , refre refre ) , codint ) as col1 from col2 where level = codint connect by prior col0 < col0 and level < = codint	0
Q_107	return all possible combination of value within a single column in sql	C_107_4	col0 _ codint , codint codint , codint codint , codint codint , codint codint , codint codint , codint	0
Q_107	return all possible combination of value within a single column in sql	C_107_5	create col0 test ( col1 int ) insert into col2 select codint union all select codint union all select codint union all select codint	0
Q_107	return all possible combination of value within a single column in sql	C_107_6	with cte ( col0 , col1 ) as ( select cast ( tab0 . col2 as varchar ( codint ) ) , tab0 . col2 from col3 col4 union all select cast ( tab1 . col0 + refre refre + cast ( tab0 . col2 as varchar ( codint ) ) as varchar ( codint ) ) , tab0 . col2 from col3 col4 inner join col5 col6 on ( tab1 . col1 < tab0 . col2 ) ) select col0 from col5	0
Q_107	return all possible combination of value within a single column in sql	C_107_7	col0 _ codint codint codint codint codint , codint codint , codint codint , codint codint , codint , codint codint , codint codint , codint codint , codint codint , codint , codint codint , codint , codint codint , codint , codint codint , codint , codint , codint	0
Q_108	column filter in py_spark	C_108_0	from tab0 . tab1 . col0 col1 col2 , from_unixtime , col3 , unix_timestamp from tab0 . tab1 . col4 col1 col5 col6 = tab2 . select ( ( from_unixtime ( unix_timestamp ( col7 col8 _ col9 col10 length col11 col12 codint for col13 > = number tab2 . col14 , refre ) ) ) . cast ( timestamptype ( ) ) . alias ( refre ) ) tab3 . where ( col ( refre ) > = lit ( now ) _ expr ( refre ) )	1
Q_108	column filter in py_spark	C_108_1	from tab0 . tab1 . col0 col1 current_timestamp , col2	0
Q_108	column filter in py_spark	C_108_2	from col0 col1 col0 , col2 from tab0 . tab1 . col3 col1 col4 , col5 from tab0 . tab1 . col6 col1 col7 , col8 col9 in_last_5_minutes ( now ) col9 _in_last_5_minutes ( then ) col10 = tab2 . strptime ( then , refre ) return col10 > now _ timedelta ( col11 = codint ) return udf ( col12 , booleantype ( ) )	0
Q_108	column filter in py_spark	C_108_3	col0 = tab0 . createdataframe ( col1 , ( refre , refre ) ) now = datetime ( codint , codint , codint , codint , codint ) tab1 . where ( in_last_5_minutes ( now ) ( col ( refre ) ) ) . show ( )	0
Q_108	column filter in py_spark	C_108_4	+ _ + _ + col0 col1 + _ + _ + codint codint _ col2 _ codint tab0 . codint codint _ col2 _ codint tab0 . codint codint _ col2 _ codint tab0 . + _ + _ +	0
Q_108	column filter in py_spark	C_108_5	col0 parse_dt ( ) col0 _parse ( col1 ) return tab0 . strptime ( col1 , refre ) return udf ( col2 , timestamptype ( ) ) col3 = tab1 . withcolumn ( refre , parse_dt ( ) ( tab1 . col4 ) ) col0 in_last_5_minutes ( now ) col0 _in_last_5_minutes ( then ) return then > now _ timedelta ( col5 = codint ) return udf ( col6 , booleantype ( ) ) tab2 . where ( in_last_5_minutes ( now ) ( col ( refre ) ) )	0
Q_108	column filter in py_spark	C_108_6	+ _ + _ + _ + col0 col1 timestamp + _ + _ + _ + codint codint _ col2 _ codint tab0 . codint _ codint _ codint codint codint . codint codint _ col2 _ codint tab0 . codint _ codint _ codint codint codint . codint codint _ col2 _ codint tab0 . codint _ codint _ codint codint codint . + _ + _ + _ +	0
Q_108	column filter in py_spark	C_108_7	col0 = refre refre regast refre refre refre col1 _ col2 _ col3 tab0 . tab1 . tab2 . col4 col5 refre refre refre refre . format ( tab3 . mktime ( ( now _ timedelta ( col6 = codint ) ) . timetuple ( ) ) ) tab4 . sql ( col0 )	0
Q_108	column filter in py_spark	C_108_8	from tab0 . tab1 . col0 col1 col2 tab2 . where ( tab2 . timestamp > lit ( now _ timedelta ( col3 = codint ) ) )	0
Q_109	sql join across tagint table with multiple where clause match	C_109_0	where ( tab0 . col0 = refre and tab0 . col0 = refre )	1
Q_109	sql join across tagint table with multiple where clause match	C_109_1	where ( tab0 . col0 = refre or tab0 . col0 = refre )	0
Q_109	sql join across tagint table with multiple where clause match	C_109_2	where tab0 . col0 in ( refre , refre )	0
Q_109	sql join across tagint table with multiple where clause match	C_109_3	+ _ + _ + _ + col0 col1 col2 + _ + _ + _ + codint col3 codint col4 codint col3 codint col5 codint col3 codint col4 codint col3 codint col5 + _ + _ + _ +	0
Q_109	sql join across tagint table with multiple where clause match	C_109_4	select tab0 . col0 , tab0 . col1 from col2 col3 join col4 col5 on tab1 . col6 = tab0 . col0 join col7 col8 on tab2 . col0 = tab1 . col9 where tab2 . col1 in ( refre , refre ) group by tab0 . col0 , tab0 . col1 having count ( tab0 . col0 ) < codint	0
Q_109	sql join across tagint table with multiple where clause match	C_109_5	+ _ + _ + col0 col1 + _ + _ + codint col2 codint + _ + _ +	0
Q_109	sql join across tagint table with multiple where clause match	C_109_6	select tab0 . col0 , tab0 . col1 , count ( tab0 . col0 ) from col2 col3 join col4 col5 on tab1 . col6 = tab0 . col0 join col7 col8 on tab2 . col0 = tab1 . col9 where tab2 . col1 in ( refre , refre ) group by tab0 . col0 , tab0 . col1	0
Q_109	sql join across tagint table with multiple where clause match	C_109_7	+ _ + _ + _ + col0 col1 count + _ + _ + _ + codint col2 codint codint codint col2 codint codint codint col2 codint codint + _ + _ + _ +	0
Q_110	how to add a new struct column to a data_frame	C_110_0	col0 _ col1 double ( nullable = false ) _ long double ( nullable = false ) _ key string ( nullable = false )	1
Q_110	how to add a new struct column to a data_frame	C_110_1	col0 tab0 . tab1 . tab2 . tab3 . row col0 tab0 . tab1 . tab2 . tab3 . tab4 . { col1 , col2 } col0 tab0 . tab1 . tab2 . tab3 . tab5 . col3 col4 col5 = tab6 . parallelize ( row ( number , number , refre ) row ( number , number , refre ) col6 ) col4 schema = structtype ( structfield ( refre , col7 , false ) structfield ( refre , col7 , false ) structfield ( refre , col8 , false ) col6 ) col4 col9 = tab7 . createdataframe ( col5 , schema )	0
Q_110	how to add a new struct column to a data_frame	C_110_2	case class location ( col0 double , long double ) col1 col2 = udf ( ( col0 double , long double ) = > location ( col0 , long ) ) col1 col3 = tab0 . withcolumn ( refre , makelocation ( col ( refre ) , col ( refre ) ) ) . drop ( refre ) . drop ( refre ) tab1 . col4	0
Q_110	how to add a new struct column to a data_frame	C_110_3	col0 _ key string ( nullable = false ) _ location struct ( nullable = true ) _ col1 double ( nullable = false ) _ long double ( nullable = false )	0
Q_110	how to add a new struct column to a data_frame	C_110_4	col0 col1 = tab0 . map { case row ( col2 , long , key ) = > row ( key , row ( col2 , long ) ) } col0 col3 = structtype ( structfield ( refre , col4 , false ) structfield ( refre , structtype ( structfield ( refre , col5 , false ) structfield ( refre , col5 , false ) col6 ) , true ) col6 ) tab1 . createdataframe ( col1 , col3 ) . show	0
Q_110	how to add a new struct column to a data_frame	C_110_5	+ _ + _ + key location + _ + _ + col0 col1 col2 col1 + _ + _ +	0
Q_110	how to add a new struct column to a data_frame	C_110_6	case class pin ( location location ) col0 col1 = col2 ( ( col3 double , long double ) = > pin ( location ( col3 , long ) ) tab0 . withcolumn ( refre , makepin ( col ( refre ) , col ( refre ) ) ) . drop ( refre ) . drop ( refre ) . col4	0
Q_110	how to add a new struct column to a data_frame	C_110_7	col0 _ key string ( nullable = false ) _ col1 struct ( nullable = true ) _ location struct ( nullable = true ) _ col2 double ( nullable = false ) _ long double ( nullable = false )	0
Q_110	how to add a new struct column to a data_frame	C_110_8	col0 tab0 . tab1 . tab2 . tab3 . tab4 . col1 tab5 . select ( refre , struct ( refre , refre ) . alias ( refre ) )	0
Q_111	no data_found set variable to null	C_111_0	create col0 sn_boleto ( col1 number , col2 number ) insert into col3 values ( codint , null ) insert into col3 values ( codint , codint ) insert into col3 values ( codint , codint ) insert into col3 values ( codint , codint )	1
Q_111	no data_found set variable to null	C_111_1	select col0 from col1 where col2 = codint col0 _ codint	0
Q_111	no data_found set variable to null	C_111_2	select col0 from col1 where col2 = codint col0 _ codint	0
Q_111	no data_found set variable to null	C_111_3	select col0 from col1 where col2 = codint col0 _ ( null )	0
Q_111	no data_found set variable to null	C_111_4	select col0 from col1 where col2 = null no rows col3	0
Q_111	no data_found set variable to null	C_111_5	select col0 into col1 from col2 where col3 = col4 if col1 is null then exit end if col4 = col1	0
Q_111	no data_found set variable to null	C_111_6	. exception when col0 then select col1 col2 into col3 from col4 where col2 = col3 connect by prior col2 = col5 start with col5 is null end	0
Q_112	how do this my_sql statement with assignment and auto_increment work	C_112_0	select cast ( ( col0 = col0 + codint ) as char ( codint ) ) as col1 , tab0 . * from ( . ) col2 , ( select col0 = codint ) as col3	1
Q_112	how do this my_sql statement with assignment and auto_increment work	C_112_1	select cast ( ( col0 = col0 + codint ) as char ( codint ) ) as col1 , tab0 . * from ( . ) col2 cross join ( select col0 = codint ) as col3	0
Q_112	how do this my_sql statement with assignment and auto_increment work	C_112_2	create col0 temp1 ( col1 int , col2 varchar ( codint ) , col3 varchar ( codint ) ) insert into temp1 ( col1 , col2 , col3 ) values ( codint , refre , refre ) , ( codint , refre , refre ) , ( codint , refre , refre )	0
Q_112	how do this my_sql statement with assignment and auto_increment work	C_112_3	select * from col0 cross join ( select col1 = codint ) as col2	0
Q_112	how do this my_sql statement with assignment and auto_increment work	C_112_4	col0 col1 col2 col3 = codint _ _ _ _ codint col4 col5 for col6 col7 col8 col9 codint codint col10 full _ col11 access col12 codint codint col13 col14 col15 col16 for col17 codint	0
Q_112	how do this my_sql statement with assignment and auto_increment work	C_112_5	select cast ( ( col0 = col0 + codint ) as char ( codint ) ) as col1 , tab0 . * from col2 cross join ( select col0 = codint ) as col3	0
Q_112	how do this my_sql statement with assignment and auto_increment work	C_112_6	col0 col1 col2 col3 _ _ _ _ codint codint col4 col5 for col6 col7 col8 col9 codint codint col10 full _ col11 access col12 codint codint col13 col14 col15 col16 for col17	0
Q_113	how to split the give string as per requirement use oracle	C_113_0	create col0 names ( col1 ) as select refre refre refre from col2 union all select refre refre refre from col2 union all select refre refre refre from col2	1
Q_113	how to split the give string as per requirement use oracle	C_113_1	select regexp_substr ( col0 , refre regsta refre refre regast refre regque refre refre refre regast refre refre regast refre regque refre refre refre regplu refre refre refre refre regque refre refre regast refre refre regast refre refre , codint , codint , null , codint ) as col1 , regexp_substr ( col0 , refre regsta refre refre regast refre regque refre refre refre regast refre refre regast refre regque refre refre refre regplu refre refre refre refre regque refre refre regast refre refre regast refre refre , codint , codint , null , codint ) as col2 , regexp_substr ( col0 , refre regsta refre refre regast refre regque refre refre refre regast refre refre regast refre regque refre refre refre regplu refre refre refre refre regque refre refre regast refre refre regast refre refre , codint , codint , null , codint ) as col3 , regexp_substr ( col0 , refre regsta refre refre regast refre regque refre refre refre regast refre refre regast refre regque refre refre refre regplu refre refre refre refre regque refre refre regast refre refre regast refre refre , codint , codint , null , codint ) as col4 from names	0
Q_113	how to split the give string as per requirement use oracle	C_113_2	col0 col1 col2 col3 _ _ _ _ col4 col5 col6 col7 col8 col9 b ( null ) col10 barack ( null ) col7	0
Q_113	how to split the give string as per requirement use oracle	C_113_3	select regexp_replace ( col0 , refre regsta refre refre regast refre regque refre refre refre regast refre refre regast refre regque refre refre refre regplu refre refre refre refre regque refre refre regast refre refre regast refre refre , refre ) as col1 , regexp_replace ( col0 , refre regsta refre refre regast refre regque refre refre refre regast refre refre regast refre regque refre refre refre regplu refre refre refre refre regque refre refre regast refre refre regast refre refre , refre ) as col2 , regexp_replace ( col0 , refre regsta refre refre regast refre regque refre refre refre regast refre refre regast refre regque refre refre refre regplu refre refre refre refre regque refre refre regast refre refre regast refre refre , refre ) as col3 , regexp_replace ( col0 , refre regsta refre refre regast refre regque refre refre refre regast refre refre regast refre regque refre refre refre regplu refre refre refre refre regque refre refre regast refre refre regast refre refre , refre ) as col4 from names	0
Q_113	how to split the give string as per requirement use oracle	C_113_4	col0 col1 col2 col3 _ _ _ _ col4 col5 col6 col7 col8 col9 b ( null ) col10 barack ( null ) col7	0
Q_113	how to split the give string as per requirement use oracle	C_113_5	with col0 as ( select regexp_substr ( col1 , refre regsta refre [ ^ , ] refre regplu refre ) as col2 , regexp_replace ( col1 , refre regsta refre regast refre regque refre refre regast refre regast refre refre regast refre regque refre ) as col3 , regexp_substr ( col1 , refre [ ^ s , ] refre regplu refre ) as col4 from names ) select col2 , regexp_replace ( col3 , refre regplu refre ) as col5 , trim ( regexp_substr ( col3 , refre regplu refre ) ) as col6 , col4 from col0	0
Q_113	how to split the give string as per requirement use oracle	C_113_6	col0 col1 col2 col3 _ _ _ _ col4 col5 col6 col7 col8 col9 b ( null ) col10 barack ( null ) col7	0
Q_114	how to work with sq_lite in android	C_114_0	col0 col1 = openorcreatedatabase ( refre , col2 , null )	1
Q_114	how to work with sq_lite in android	C_114_1	opendatabase ( col0 path , tab0 . col1 col2 , int col3 , col4 col5 )	0
Q_114	how to work with sq_lite in android	C_114_2	opendatabase ( col0 path , tab0 . col1 col2 , int col3 )	0
Q_114	how to work with sq_lite in android	C_114_3	openorcreatedatabase ( col0 path , tab0 . col1 col2 )	0
Q_114	how to work with sq_lite in android	C_114_4	openorcreatedatabase ( file file , tab0 . col0 col1 )	0
Q_114	how to work with sq_lite in android	C_114_5	tab0 . execsql ( refre refre refre refre ) tab0 . execsql ( refre refre admin refre refre admin refre refre )	0
Q_114	how to work with sq_lite in android	C_114_6	cursor col0 = tab0 . rawquery ( refre regast refre , null ) tab1 . movetofirst ( ) col1 col2 = tab1 . getstring ( codint ) col1 col3 = tab1 . getstring ( codint )	0
Q_114	how to work with sq_lite in android	C_114_7	public class col0 col1 col2 { public dbhelper ( ) { super ( col3 , col4 , null , codint ) } public col5 oncreate ( col6 col7 ) { } public col5 onupgrade ( col6 database , int col8 , int col9 ) { } }	0
Q_115	how to convert json data with a list into an maria_db sql insert statement that use dynamic column	C_115_0	alter col0 col1 add column col2 blob null default null	1
Q_115	how to convert json data with a list into an maria_db sql insert statement that use dynamic column	C_115_1	insert into your_table ( col0 ) values ( column_create ( refre , refre , refre , refre refre col1 refre refre col2 refre refre col3 refre refre ) )	0
Q_115	how to convert json data with a list into an maria_db sql insert statement that use dynamic column	C_115_2	update col0 set col1 = column_create ( refre , refre , refre , refre refre col2 refre refre col3 refre refre col4 refre refre ) where col5 = col6	0
Q_115	how to convert json data with a list into an maria_db sql insert statement that use dynamic column	C_115_3	select replace ( replace ( column_json ( col0 ) , refre [ refre refre col1 refre , refre refre ) from col2	0
Q_115	how to convert json data with a list into an maria_db sql insert statement that use dynamic column	C_115_4	set col0 = column_create ( refre , refre , refre , refre refre col1 refre refre col2 refre refre col3 refre refre ) select replace ( replace ( column_json ( col0 ) , refre [ refre refre col4 refre , refre refre ) col5	0
Q_115	how to convert json data with a list into an maria_db sql insert statement that use dynamic column	C_115_5	+ _ + col0 + _ + { refre col1 , refre refre } + _ +	0
Q_115	how to convert json data with a list into an maria_db sql insert statement that use dynamic column	C_115_6	select replace ( replace ( replace ( column_json ( col0 ) , refre [ refre refre col1 refre , refre refre ) , refre , refre ) col2 + _ + col2 + _ + { refre col3 , refre refre } + _ +	0
Q_116	how to find category name from category value which be in different table in laravel tagint 2	C_116_0	select tab0 . col0 , ( select col1 from col2 where col0 = tab0 . col3 ) as col1 from col4	1
Q_116	how to find category name from category value which be in different table in laravel tagint 2	C_116_1	col0 table1 ( refre ) _ > select ( col1 ) _ > selectsub ( function ( col2 ) { return col2 _ > from ( refre ) _ > where ( refre , refre , col0 raw ( refre ) ) _ > select ( refre ) } , refre ) _ > get ( )	0
Q_116	how to find category name from category value which be in different table in laravel tagint 2	C_116_2	select tab0 . col0 , tab1 . col1 from col2 left join col3 on tab0 . col4 = tab1 . col0	0
Q_116	how to find category name from category value which be in different table in laravel tagint 2	C_116_3	col0 table1 ( refre ) _ > join ( refre , refre , refre , refre ) _ > select ( col1 ) _ > get ( )	0
Q_116	how to find category name from category value which be in different table in laravel tagint 2	C_116_4	/ / col0 / col1 / tab0 . col2 col3 col0 col1 class col4 { col5 col6 = refre public function category ( ) { return col7 _ > belongsto ( refre , refre ) } } / / col0 / col1 / tab1 . col2 col3 col0 col1 class col8 { col5 col6 = refre public function content ( ) { return col7 _ > hasmany ( refre , refre ) } }	0
Q_116	how to find category name from category value which be in different table in laravel tagint 2	C_116_5	/ / some col0 col1 use col2 col3 col4 class col5 { public function index1 ( ) { col4 = col4 with ( refre ) _ > get ( ) return view make ( refre refre ) _ > with ( refre , col4 ) } } / / views / all / tab0 . tab1 . col6 < col7 > foreach ( col8 as col4 ) < col9 > { { col4 _ > col10 } } _ { { col4 _ > col11 _ > col12 } } < / col9 > col13 < / col7 >	0
Q_116	how to find category name from category value which be in different table in laravel tagint 2	C_116_6	/ / in col0 col1 col2 = col2 with ( refre ) _ > lists ( refre , refre ) / / in col0 view < col3 > foreach ( col4 as col5 = > col6 ) < col7 > { { col5 } } _ { { col6 } } < / col7 > col8 < / col3 >	0
Q_117	netezza sql convert varchar to binary string	C_117_0	drop col0 col1 if exists drop col0 create col0 test_table ( col2 varchar ( codint ) , col3 varbinary ( codint ) ) create col0 insert into col1 values ( hextoraw ( refre ) , hex_to_binary ( refre ) ) insert codint codint select * from col1 col2 col3 _ + _ col4 col5 refre ( codint row )	1
Q_117	netezza sql convert varchar to binary string	C_117_1	select firstbit ( hextoraw ( refre ) ) , bitcount ( hextoraw ( refre ) ) , chartobase2 ( hextoraw ( refre ) ) col0 col1 col2 _ + _ + _ _ codint codint codint ( codint row ) select firstbit ( hextoraw ( refre ) ) , bitcount ( hextoraw ( refre ) ) , chartobase2 ( hextoraw ( refre ) ) col0 col1 col2 _ + _ + _ codint codint codint ( codint row ) select firstbit ( hextoraw ( refre ) ) , bitcount ( hextoraw ( refre ) ) , chartobase2 ( hextoraw ( refre ) ) col0 col1 col2 _ + _ + _ codint codint codint ( codint row )	0
Q_117	netezza sql convert varchar to binary string	C_117_2	include refre include < tab0 . col0 > using col1 col2 col3 class col4 public col5 { public static col5 * instantiate ( ) col6 evaluate ( ) { col7 * str = stringarg ( codint ) col8 col9 = codint for ( int col10 = codint col10 < str _ > length col10 + + ) { for ( int col11 = codint col11 > = codint col11 _ ) { if ( ( str _ > data [ i ] ( unsigned char ) pow ( codint , col11 ) ) > codint ) { col9 + + } } } nz_udx_return_int32 ( col9 ) } } col5 * col4 instantiate ( ) { return new col4 }	0
Q_117	netezza sql convert varchar to binary string	C_117_3	include refre include < tab0 . col0 > using col1 col2 col3 class col4 public col5 { public static col5 * instantiate ( ) col6 evaluate ( ) { col7 * str = stringarg ( codint ) col8 col9 = _ codint for ( int col10 = codint col10 < str _ > length col10 + + ) { for ( int col11 = codint col11 > = codint col11 _ ) { if ( ( str _ > data [ i ] ( unsigned char ) pow ( codint , col11 ) ) > codint ) { col9 = col10 * codint + codint _ col11 } if ( col9 > _ codint ) break } if ( col9 > _ codint ) break } nz_udx_return_int32 ( col9 ) } } col5 * col4 instantiate ( ) { return new col4 }	0
Q_117	netezza sql convert varchar to binary string	C_117_4	col0 = codint if [ col1 ] then col0 = col2 col3 if [ col1 ] then print refre refre refre return codint col3 col4 col2 = refre col5 tab0 . col6 _ col7 _ col8 refre refre refre refre refre _ return refre _ class refre col9 tab0 . col10 *	0
Q_117	netezza sql convert varchar to binary string	C_117_5	col0 = codint if [ col1 ] then col0 = col2 col3 if [ col1 ] then print refre refre refre return codint col3 col4 col2 = refre col5 tab0 . col6 _ col7 _ col8 refre refre refre refre refre _ return refre _ class refre col9 tab0 . col10 *	0
Q_117	netezza sql convert varchar to binary string	C_117_6	col0 = codint if [ col1 ] then col0 = col2 col3 if [ col1 ] then print refre refre refre return codint col3 col4 col2 = refre col5 tab0 . col6 _ col7 _ col8 refre refre refre refre refre _ return refre refre refre _ class refre col9 tab0 . col10 *	0
Q_118	get number of work day from date range in sql for sqlite without extension function	C_118_0	"_ col0 refre refre refre refre codint _ codint _ codint refre refre refre codint _ codint _ codint refre refre refre codint _ codint _ codint refre refre refre codint _ codint _ codint refre refre refre codint _ codint _ codint refre refre refre codint _ codint _ codint refre refre refre refre col1 "" , col2 ) col3 from col4 where col3 between codint and codint"	1
Q_118	get number of work day from date range in sql for sqlite without extension function	C_118_1	_ col0 between col1 col2 select col3 , strftime ( refre , col3 ) col4 from col5 where col4 between codint and codint and col3 between refre and refre	0
Q_118	get number of work day from date range in sql for sqlite without extension function	C_118_2	_ count col0 select count ( * ) col1 from ( select col2 , strftime ( refre , col2 ) col3 from col4 where col3 between codint and codint and col2 between refre and refre ) col5	0
Q_118	get number of work day from date range in sql for sqlite without extension function	C_118_3	create col0 integers ( col1 integer primary key ) insert into col2 values ( codint ) insert into col2 values ( codint ) insert into col2 values ( codint ) insert into col2 values ( codint ) insert into col2 values ( codint ) insert into col2 values ( codint )	0
Q_118	get number of work day from date range in sql for sqlite without extension function	C_118_4	"create col0 test ( start date , end date ) insert into col1 values ( refre , refre ) insert into col1 values ( refre , refre ) _ col2 from date tab0 . col3 at col4 col5 tab1 . _ col6 col7 col8 col9 col10 col11 to do tab2 . col12 col13 col14 refre refre refre refre + refre col15 "" ) as col16 from col1 , col17 order by col16"	0
Q_118	get number of work day from date range in sql for sqlite without extension function	C_118_5	_ col0 view from date range drop col1 col0 create view col0 as select distinct date ( start , refre regplu refre col2 refre ) as col3 , case strftime ( refre , date ( start , refre regplu refre col2 refre ) ) when codint then refre when codint then refre when codint then refre when codint then refre when codint then refre when codint then refre when codint then refre end as col4 from col5 , col6	0
Q_118	get number of work day from date range in sql for sqlite without extension function	C_118_6	select start , end , count ( col0 ) as col1 from col2 left join col3 on col0 between start and end and col4 in ( refre , refre , refre , refre , refre ) group by start , end order by start , end	0
Q_119	mysql query select from one table such that it column value be not present in the same column value in another table	C_119_0	select tab0 . col0 from col1 where tab0 . col2 not in ( select tab1 . col2 from col3 )	1
Q_119	mysql query select from one table such that it column value be not present in the same column value in another table	C_119_1	select tab0 . col0 from col1 inner join col2 on tab0 . col0 = tab1 . col0 where tab0 . col3 = tab1 . col3	0
Q_119	mysql query select from one table such that it column value be not present in the same column value in another table	C_119_2	create col0 a ( col1 int ( codint ) not null , col2 varchar ( codint ) not null ) create col0 b ( col1 int ( codint ) not null , col2 varchar ( codint ) not null )	0
Q_119	mysql query select from one table such that it column value be not present in the same column value in another table	C_119_3	insert into col0 set col1 = codint , col2 = refre insert into col0 set col1 = codint , col2 = refre insert into col3 set col1 = codint , col2 = refre insert into col3 set col1 = codint , col2 = refre	0
Q_119	mysql query select from one table such that it column value be not present in the same column value in another table	C_119_4	+ _ + col0 + _ + codint + _ +	0
Q_119	mysql query select from one table such that it column value be not present in the same column value in another table	C_119_5	insert into col0 set col1 = codint , col2 = refre insert into col0 set col1 = codint , col2 = refre insert into col3 set col1 = codint , col2 = refre insert into col3 set col1 = codint , col2 = refre insert into col3 set col1 = codint , col2 = refre < _ col4 col5 col6 is now col0 col7 codint in col3 col8 col9 col10 col8 col11 col12 with col1 codint from col0 col9 not col13 tab0 . insert into col0 set col1 = codint , col2 = refre insert into col3 set col1 = codint , col2 = refre < _ only col1 codint col9 now col13 col14 col15 to col11 col16 col17	0
Q_119	mysql query select from one table such that it column value be not present in the same column value in another table	C_119_6	col0 + _ + _ + col1 col2 + _ + _ + codint col0 codint col3 codint col4 + _ + _ + col3 + _ + _ + col1 col2 + _ + _ + codint col0 codint col0 codint col3 codint col5 + _ + _ +	0
Q_119	mysql query select from one table such that it column value be not present in the same column value in another table	C_119_7	select tab0 . col0 from col1 where tab0 . col2 not in ( select tab1 . col2 from col3 where tab1 . col0 = tab0 . col0 )	0
Q_120	how to select the first row of each group	C_120_0	col0 tab0 . tab1 . tab2 . tab3 . tab4 . { col1 , max , col2 } col0 tab0 . tab1 . tab2 . tab3 . tab5 . window col3 col4 = tab6 . parallelize ( seq ( ( codint , refre , number ) , ( codint , refre , number ) , ( codint , refre , number ) , ( codint , refre , number ) , ( codint , refre , number ) , ( codint , refre , number ) , ( codint , refre , number ) , ( codint , refre , number ) , ( codint , refre , number ) , ( codint , refre , number ) , ( codint , refre , number ) , ( codint , refre , number ) , ( codint , refre , number ) ) ) . todf ( refre , refre , refre ) col3 col5 = tab7 . partitionby ( refre ) . orderby ( refre . desc ) col3 col6 = tab8 . withcolumn ( refre , tab9 . over ( col5 ) ) . where ( refre = = = codint ) . drop ( refre ) tab10 . show / / + _ + _ + _ + / / hour col7 col8 / / + _ + _ + _ + / / codint col9 number / / codint col10 number / / codint col11 number / / codint col12 number / / + _ + _ + _ +	1
Q_120	how to select the first row of each group	C_120_1	col0 col1 = tab0 . groupby ( refre . as ( refre ) ) . agg ( max ( refre ) . as ( refre ) ) col0 col2 = tab0 . join ( broadcast ( col1 ) , ( refre = = = refre ) ( refre = = = refre ) ) . drop ( refre ) . drop ( refre ) tab1 . show / / + _ + _ + _ + / / hour col3 col4 / / + _ + _ + _ + / / codint col5 number / / codint col6 number / / codint col7 number / / codint col8 number / / + _ + _ + _ +	0
Q_120	how to select the first row of each group	C_120_2	tab0 . groupby ( refre ) . agg ( first ( refre ) . alias ( refre ) , first ( refre ) . alias ( refre ) )	0
Q_120	how to select the first row of each group	C_120_3	col0 col1 = tab0 . select ( refre , struct ( refre , refre ) . alias ( refre ) ) . groupby ( refre ) . agg ( max ( refre ) . alias ( refre ) ) . select ( refre , refre , refre ) tab1 . show / / + _ + _ + _ + / / hour col2 col3 / / + _ + _ + _ + / / codint col4 number / / codint col5 number / / codint col6 number / / codint col7 number / / + _ + _ + _ +	0
Q_120	how to select the first row of each group	C_120_4	case class record ( hour integer , col0 col1 , col2 double ) tab0 . as tab1 . groupby ( refre ) . reduce ( ( col3 , col4 ) = > if ( tab2 . col2 > tab3 . col2 ) col3 else col4 ) . show / / + _ + _ + / / col5 col6 / / + _ + _ + / / col7 col8 / / col9 col10 / / col11 col12 / / col13 col14 / / + _ + _ +	0
Q_120	how to select the first row of each group	C_120_5	tab0 . as tab1 . groupbykey ( tab2 . hour ) . reducegroups ( ( col0 , col1 ) = > if ( tab3 . col2 > tab4 . col2 ) col0 else col1 )	0
Q_120	how to select the first row of each group	C_120_6	tab0 . orderby ( . ) . groupby ( . ) . agg ( first ( . ) , . )	0
Q_120	how to select the first row of each group	C_120_7	tab0 . orderby ( . ) . dropduplicates ( . )	0
Q_121	sql where clause with seperataed in expression to implement cnf	C_121_0	select * from col0 where col1 in ( select col2 from col3 where col4 = codint intersect select col2 from col3 where col4 = codint ) col5	1
Q_121	sql where clause with seperataed in expression to implement cnf	C_121_1	select * from col0 join ( select col1 from col2 where col3 = codint ) col4 on tab0 . col1 = tab1 . col5 join ( select col1 from col2 where col3 = codint ) col6 on tab2 . col1 = tab1 . col5	0
Q_121	sql where clause with seperataed in expression to implement cnf	C_121_2	select * from col0 join col1 col2 on tab0 . col3 = tab1 . col4 and tab0 . col5 = codint join col1 col6 on tab2 . col3 = tab1 . col4 and tab2 . col5 = codint	0
Q_121	sql where clause with seperataed in expression to implement cnf	C_121_3	select * from col0 left join col1 col2 on tab0 . col3 = tab1 . col4 and tab0 . col5 = codint left join col1 col6 on tab2 . col3 = tab1 . col4 and tab2 . col5 = codint where coalesce ( tab0 . col3 , tab2 . col3 ) is not null	0
Q_121	sql where clause with seperataed in expression to implement cnf	C_121_4	where tab0 . col0 is not null or tab1 . col0 is not null	0
Q_121	sql where clause with seperataed in expression to implement cnf	C_121_5	select * from col0 where col1 in ( select col2 from col3 where col4 = codint intersect ( select col2 from col3 where col4 = codint union all select col2 from col3 where col4 = codint ) )	0
Q_121	sql where clause with seperataed in expression to implement cnf	C_121_6	select * from col0 join col1 col2 on tab0 . col3 = tab1 . col4 and tab0 . col5 = codint	0
Q_121	sql where clause with seperataed in expression to implement cnf	C_121_7	select * from col0 left join col1 col2 on tab0 . col3 = tab1 . col4 and tab0 . col5 = codint left join col1 col6 on tab2 . col3 = tab1 . col4 and tab2 . col5 = codint where coalesce ( tab0 . col3 , tab2 . col3 ) is not null	0
Q_121	sql where clause with seperataed in expression to implement cnf	C_121_8	select * from col0 join col1 col2 on tab0 . col3 = tab1 . col4 and tab0 . col5 = codint left join col1 col6 on tab2 . col3 = tab1 . col4 and tab2 . col5 = codint left join col1 col7 on tab3 . col3 = tab1 . col4 and tab3 . col5 = codint where coalesce ( tab2 . col3 , tab3 . col3 ) is not null	0
Q_122	sq_lite _ insert into my_table select count from my_table where date tagstr syntax error	C_122_0	insert into refre . refre ( date , col0 ) values ( refre , ( select count ( * ) from col0 where date = refre )	1
Q_122	sq_lite _ insert into my_table select count from my_table where date tagstr syntax error	C_122_1	insert into refre . refre ( date , col0 ) select refre , count ( * ) from col0 where date = refre	0
Q_122	sq_lite _ insert into my_table select count from my_table where date tagstr syntax error	C_122_2	update refre set col0 = ( select count ( * ) from col0 where date = refre ) where date = refre _ or by rowid = col1 where col1 is col2 col3 rows rowid	0
Q_122	sq_lite _ insert into my_table select count from my_table where date tagstr syntax error	C_122_3	insert into refre . refre ( date , col0 , col1 ) values ( refre , ( select count ( * ) from col0 where date = refre ) , ( select count ( * ) from col1 where date = refre )	0
Q_122	sq_lite _ insert into my_table select count from my_table where date tagstr syntax error	C_122_4	col0 col1 date codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint	0
Q_122	sq_lite _ insert into my_table select count from my_table where date tagstr syntax error	C_122_5	col0 col1 col2 update col3 set col4 = ( select count ( * ) from col5 where col6 = refre ) where date = refre ( col7 col8 ) col3 col9 col10 col4 date codint codint null codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint codint _ codint _ codint codint codint codint	0
Q_122	sq_lite _ insert into my_table select count from my_table where date tagstr syntax error	C_122_6	insert into refre ( col0 ) select count ( * ) from col1 where col2 = refre	0
Q_122	sq_lite _ insert into my_table select count from my_table where date tagstr syntax error	C_122_7	not null constraint col0 tab0 . col1 insert into refre ( col2 ) select count ( * ) from col3 where col4 = refre	0
Q_123	case statement not support horizontal search with column name in query	C_123_0	select * from col0 unpivot ( col1 for col2 in ( col3 , col4 , col5 ) )	1
Q_123	case statement not support horizontal search with column name in query	C_123_1	select * from ( select tab0 . * , dense_rank ( ) over ( partition by col0 order by col1 desc ) col2 from ( select * from col3 unpivot ( col1 for col4 in ( col5 , col6 , col7 ) ) ) col8 ) where col2 < = codint	0
Q_123	case statement not support horizontal search with column name in query	C_123_2	col0 col1 col2 col3 _ _ _ _ codint col4 codint codint codint col5 codint codint codint col4 codint codint codint col5 codint codint codint col6 codint codint codint col4 codint codint	0
Q_123	case statement not support horizontal search with column name in query	C_123_3	col0 for col1 in ( col2 , col3 , col4 , col5 , col6 , col7 , col8 , . col9 , col10 )	0
Q_123	case statement not support horizontal search with column name in query	C_123_4	with col0 as ( select col1 , col2 , col3 from ( select tab0 . * , dense_rank ( ) over ( partition by col1 order by col2 desc ) col3 from ( select * from col4 unpivot ( col2 for col5 in ( col6 , col7 , col8 ) ) ) col9 ) where col3 < = codint ) select * from col0 pivot ( max ( col2 ) for col3 in ( codint as refre , codint as refre ) )	0
Q_123	case statement not support horizontal search with column name in query	C_123_5	col0 first col1 second col1 _ _ _ codint codint codint codint codint codint codint codint codint	0
Q_123	case statement not support horizontal search with column name in query	C_123_6	select col0 , max ( case when col1 = refre then col2 end ) as col3 , max ( case when col1 = refre then col2 end ) as col4 , max ( case when col1 = refre then col2 end ) as col5 from col6 group by col0	0
Q_123	case statement not support horizontal search with column name in query	C_123_7	select * from col0 pivot ( max ( col1 ) for col2 in ( refre , refre , refre ) )	0
Q_123	case statement not support horizontal search with column name in query	C_123_8	col0 col1 col2 _ _ _ codint col3 codint codint col3 codint codint col4 codint codint col5 codint	0
Q_123	case statement not support horizontal search with column name in query	C_123_9	col0 refre refre refre _ _ _ _ codint codint codint codint	0
Q_124	unable to retrieve image from sq_lite sk_image_decoder factory return null	C_124_0	public col0 displayimagebendaone ( col1 rowid ) { col2 col3 = tab0 . getreadabledatabase ( ) cursor cursor = tab1 . query ( true , tab2 . col4 , new col1 col5 { tab2 . uid , tab2 . col6 , tab2 . col7 , tab2 . col8 } , tab2 . col8 + refre + rowid , null , null , null , null , null ) / / col9 col10 = new stringbuffer ( ) col0 col11 = null if ( tab3 . movetofirst ( ) ) { { / / col12 col5 col13 = tab3 . getblob ( tab3 . getcolumnindex ( tab2 . col7 ) ) col12 col5 col13 = tab3 . getblob ( codint ) col11 = tab4 . decodebytearray ( col13 , codint , tab5 . length ) / / tab6 . append ( col13 ) } } tab1 . close ( ) return col11	1
Q_124	unable to retrieve image from sq_lite sk_image_decoder factory return null	C_124_1	col0 col1 = tab0 . displayimagebendaone ( col2 ) tab1 . e ( refre [ ] refre , col1 ) col3 col4 = new bytearrayinputstream ( tab2 . getbytes ( ) ) col5 = tab3 . decodestream ( col4 ) tab4 . reset ( ) tab5 . setimagebitmap ( col5 )	0
Q_124	unable to retrieve image from sq_lite sk_image_decoder factory return null	C_124_2	col0 col1 = tab0 . displayimagebendaone ( col2 ) tab1 . setimagebitmap ( col1 )	0
Q_124	unable to retrieve image from sq_lite sk_image_decoder factory return null	C_124_3	col0 tab0 . tab1 . col1 col0 tab2 . tab3 . col2 col0 tab2 . tab3 . tab4 . col3 col0 tab2 . tab3 . col4 col0 tab2 . tab5 . col5 public class col6 { / / convert from col2 to col7 array public static col7 col8 getbytes ( col2 col2 ) { col1 col9 = new bytearrayoutputstream ( ) tab4 . compress ( tab6 . col10 , codint , col9 ) return tab7 . tobytearray ( ) } / / convert from col7 array to col2 public static col2 getphoto ( col7 col8 col11 ) { tab8 . i ( refre , tab9 . tostring ( ) ) return tab10 . decodebytearray ( col11 , codint , tab9 . length ) }	0
Q_124	unable to retrieve image from sq_lite sk_image_decoder factory return null	C_124_4	public long insertinvdetails ( col0 col1 ) { col2 = tab0 . getwritabledatabase ( ) col3 col4 = new contentvalues ( ) tab1 . put ( col5 , tab2 . getbytes ( tab3 . getbitmap ( ) ) ) tab1 . put ( col6 , tab3 . getname ( ) ) tab1 . put ( col7 , tab3 . getpersonname ( ) ) tab1 . put ( col8 , tab3 . getdate ( ) ) tab1 . put ( refre , codint ) long count = tab4 . insert ( col9 , null , col4 ) return count }	0
Q_124	unable to retrieve image from sq_lite sk_image_decoder factory return null	C_124_5	public col0 < col1 > getselectedcontacts ( ) { col0 < col1 > col2 = new col3 < col1 > ( ) / / select all col4 col5 = tab0 . getwritabledatabase ( ) cursor cursor = tab1 . query ( true , col6 , new col7 col8 { col9 , col10 , col11 , col12 , col13 } , refre , null , null , null , null , null ) / / col14 col15 all rows and col16 to col0 if ( tab2 . movetofirst ( ) ) { do { col1 col17 = new inventory ( ) tab3 . setid ( tab2 . getint ( codint ) ) col18 col8 blob = tab2 . getblob ( tab2 . getcolumnindex ( col10 ) ) tab3 . setbitmap ( tab4 . getphoto ( blob ) ) tab3 . setname ( tab2 . getstring ( codint ) ) tab3 . setpersonname ( tab2 . getstring ( codint ) ) tab3 . setdate ( tab2 . getstring ( codint ) ) / / col16 col19 to col0 tab5 . add ( col17 ) } while ( tab2 . movetonext ( ) ) } tab1 . close ( ) / / return col19 col0 return col2 }	0
Q_124	unable to retrieve image from sq_lite sk_image_decoder factory return null	C_124_6	col0 < col1 > col2 = tab0 . getselectedcontacts ( ) col3 col4 = new linearlayout ( tab1 . col5 ) tab2 . setorientation ( tab3 . col6 ) for ( col1 col7 col2 ) { col8 col9 = new imageview ( tab1 . col5 ) tab4 . setimagebitmap ( tab5 . getbitmap ( ) ) tab2 . addview ( col9 ) } / / add col4 to col10 col11 view	0
Q_124	unable to retrieve image from sq_lite sk_image_decoder factory return null	C_124_7	package tab0 . tab1 . col0 col1 tab2 . tab3 . col2 public class col3 { private col2 col4 private col5 col6 private col5 col7 col5 col8 private int col9 public inventory ( ) { } public inventory ( col2 col10 , col5 col11 , col5 col12 , col5 col8 ) { col4 = col10 col6 = col11 col7 = col12 tab4 . col8 = col8 } public col2 getbitmap ( ) { return col4 } public col5 getname ( ) { return col6 } public col5 getdate ( ) { return tab4 . col8 } public int getid ( ) { return tab4 . col9 } public col5 getpersonname ( ) { return col7 } public col13 setbitmap ( col2 col4 ) { tab4 . col4 = col4 } public col13 setname ( col5 col6 ) { tab4 . col6 = col6 } public col13 setid ( int col9 ) { tab4 . col9 = col9 } public col13 setpersonname ( col5 col7 ) { tab4 . col7 = col7 } public col13 setdate ( col5 col8 ) { tab4 . col8 = col8 }	0
Q_125	sql server _ implicit join v explicit different result	C_125_0	+ _ + col0 + _ + codint codint codint + _ +	1
Q_125	sql server _ implicit join v explicit different result	C_125_1	+ _ + _ + col0 col1 + _ + _ + codint col2 codint col3 + _ + _ +	0
Q_125	sql server _ implicit join v explicit different result	C_125_2	select * from col0 col1 left join col2 col3 on tab0 . col4 = tab1 . col5 and tab1 . col6 < > refre	0
Q_125	sql server _ implicit join v explicit different result	C_125_3	tab0 . col0 = tab1 . col1 and tab1 . col2 < > refre	0
Q_125	sql server _ implicit join v explicit different result	C_125_4	+ _ + _ + _ + col0 col1 col2 + _ + _ + _ + codint codint col3 codint null null codint null null + _ + _ + _ +	0
Q_125	sql server _ implicit join v explicit different result	C_125_5	select * from col0 col1 left join col2 col3 on tab0 . col4 = tab1 . col5	0
Q_125	sql server _ implicit join v explicit different result	C_125_6	+ _ + _ + _ + col0 col1 col2 + _ + _ + _ + codint codint col3 codint codint col4 codint null null + _ + _ + _ +	0
Q_125	sql server _ implicit join v explicit different result	C_125_7	select * from col0 col1 left join col2 col3 on tab0 . col4 = tab1 . col5 where tab1 . col5 is null or tab1 . col6 < > refre	0
Q_125	sql server _ implicit join v explicit different result	C_125_8	"where tab0 . col0 is null or tab0 . col1 < > "" col2"	0
Q_125	sql server _ implicit join v explicit different result	C_125_9	+ _ + _ + _ + col0 col1 col2 + _ + _ + _ + codint codint col3 codint null null + _ + _ + _ +	0
Q_126	postgre_sql _ split row use regex	C_126_0	col0 col1 description ( col2 ) codint . codint codint col3 some col4 number _ codint col5 col6 number codint _ col7 codint . col8 number _ codint col9 codint . col10 codint . codint codint col11 codint col6 number col12 number _ codint opel ( col13 ) codint . col14	1
Q_126	postgre_sql _ split row use regex	C_126_1	drop col0 if exists col1 create col0 col1 as select generate_series ( codint , codint ) as col2 , generate_series ( codint , codint ) as col3 select * from col1 update col1 set col3 = codint where col2 = codint select * from col1	0
Q_126	postgre_sql _ split row use regex	C_126_2	col0 col1 _ + _ codint codint codint codint codint codint ( codint rows )	0
Q_126	postgre_sql _ split row use regex	C_126_3	col0 col1 _ + _ codint codint codint codint codint codint ( codint rows )	0
Q_126	postgre_sql _ split row use regex	C_126_4	create col0 col1 as select * from col2 col3 where codint = codint	0
Q_126	postgre_sql _ split row use regex	C_126_5	alter col0 col1 add col2 serial not null primary key	0
Q_126	postgre_sql _ split row use regex	C_126_6	do language plpgsql declare col0 col1 col2 col1 begin col0 = null for col2 in ( select * from col1 ) loop tab0 . col3 = coalesce ( tab1 . col3 , tab0 . col3 ) tab0 . col4 = coalesce ( tab1 . col4 , tab0 . col4 ) tab0 . col5 = tab1 . col5 insert into col6 values ( tab0 . col3 , tab0 . col4 , tab0 . col5 ) raise notice refre , tab1 . col3 , tab1 . col4 end loop end	0
Q_126	postgre_sql _ split row use regex	C_126_7	col0 = select * from col1 col2 col3 col4 col5 _ + _ + _ + _ codint col6 some col7 codint number _ codint col8 codint . col9 codint number _ codint col8 codint . col10 codint number _ codint col8 codint . codint codint codint col11 codint col12 number col13 codint number _ codint opel ( col14 ) codint . col15 codint number _ codint opel ( col16 ) codint . codint codint number _ codint col17 col18 number codint _ col19 codint ( codint rows )	0
Q_126	postgre_sql _ split row use regex	C_126_8	select * , substring ( col0 from refre refre regast refre refre regque refre regast refre ) as col1 , _ first number before col2 row_number ( ) over ( partition by substring ( col0 from refre refre regast refre refre regque refre regast refre ) ) as col3 _ order col4 col5 col6 from col7	0
Q_126	postgre_sql _ split row use regex	C_126_9	col0 col1 col2 col3 col4 col5 _ + _ + _ + _ + _ + _ codint col6 some col7 codint codint codint number _ codint col8 codint . col9 codint codint codint number _ codint col8 codint . col10 codint codint codint number _ codint col8 codint . codint codint codint codint codint col11 codint col12 number col13 codint codint codint number _ codint opel ( col14 ) codint . col15 codint codint codint number _ codint opel ( col16 ) codint . codint codint codint codint number _ codint col17 col18 number codint _ col19 codint codint codint ( codint rows )	0
Q_127	sql increment line number	C_127_0	select row_number ( ) over ( order by col0 ) col1 , col2 from col3 order by col0	1
Q_127	sql increment line number	C_127_1	select rownum as col0 , col1 from ( select col1 from col2 order by col3 )	0
Q_127	sql increment line number	C_127_2	create col0 your_table ( col1 , col2 , col3 ) as select refre , codint , codint from col4 union all select refre , codint , codint from col4 union all select refre , codint , codint from col4 union all select refre , codint , codint from col4	0
Q_127	sql increment line number	C_127_3	select row_number ( ) over ( order by col0 ) col1 , col2 from col3 order by col0	0
Q_127	sql increment line number	C_127_4	col0 col1 _ _ codint line codint codint line codint codint line codint codint line codint	0
Q_127	sql increment line number	C_127_5	select rownum as col0 , col1 from ( select col1 from col2 order by col3 )	0
Q_127	sql increment line number	C_127_6	col0 col1 _ _ codint line codint codint line codint codint line codint codint line codint	0
Q_127	sql increment line number	C_127_7	select row_number ( ) over ( order by col0 desc ) col1 , col2 from col3 order by col0 desc	0
Q_127	sql increment line number	C_127_8	col0 col1 _ _ codint line codint codint line codint codint line codint codint line codint	0
Q_128	sql query to find free room in hotel	C_128_0	select tab0 . col0 from col1 col2 left join ( select tab1 . col0 from col3 col4 , ( select col5 = refre , col6 = refre ) col7 where tab1 . col8 > = col5 and tab1 . col9 < = col6 and ( timestampdiff ( col10 , tab1 . col9 , col6 ) * timestampdiff ( col10 , col5 , tab1 . col8 ) ) > codint ) col11 on tab0 . col0 = tab2 . col0 where tab2 . col0 is null	1
Q_128	sql query to find free room in hotel	C_128_1	col0 col1 col2 col3 codint codint codint _ codint _ codint codint _ codint _ codint codint codint codint _ codint _ codint codint _ codint _ codint codint codint codint _ codint _ codint codint _ codint _ codint codint codint codint _ codint _ codint codint _ codint _ codint	0
Q_128	sql query to find free room in hotel	C_128_2	both col0 before col1 on tab0 . col2 col3 codint _ codint _ codint _ codint _ codint _ codint both col0 after col1 on tab0 . col2 col3 codint _ codint _ codint _ codint _ codint _ codint col4 col5 codint _ col6 start date codint _ codint _ codint _ codint _ codint _ codint col4 col5 codint _ col6 start date , col7 less than existing col4 end date codint _ codint _ codint _ codint _ codint _ codint col4 col5 codint _ col6 start , col8 end col9 date codint _ codint _ codint _ codint _ codint _ codint col4 col5 codint _ start before , col7 end date col10 existing col11 codint _ codint _ codint _ codint _ codint _ codint tab1 . col12 end date is col12 start date of col12 existing booking ( between codint codint col11 ) codint _ codint _ codint _ codint _ codint _ codint col4 col5 codint _ col13 col10 date , col7 end col14 existing col11 codint _ codint _ codint _ codint _ codint _ codint tab1 . end of existing col11 and nothing col15 on codint / codint codint _ codint _ codint _ codint _ codint _ codint col4 col5 codint _ col16 col17 col11 col18 codint _ codint _ codint _ codint _ codint _ codint col4 col5 codint _ col19 col10 col20 col18 codint _ codint _ codint _ codint _ codint _ codint	0
Q_128	sql query to find free room in hotel	C_128_3	from col0 col1 , ( select col2 = refre , col3 = refre ) col4	0
Q_128	sql query to find free room in hotel	C_128_4	where tab0 . col0 > = col1 and tab0 . col2 < = col3	0
Q_128	sql query to find free room in hotel	C_128_5	and ( timestampdiff ( col0 , tab0 . col1 , col2 ) * timestampdiff ( col0 , col3 , tab0 . col4 ) ) > codint )	0
Q_128	sql query to find free room in hotel	C_128_6	select tab0 . col0 , tab0 . col1 , tab0 . col2 , tab0 . col3 , col4 as col5 , col6 as col7 , ( timestampdiff ( col8 , tab0 . col2 , col6 ) * timestampdiff ( col8 , col4 , tab0 . col3 ) ) < = codint as col9 , ( timestampdiff ( col8 , tab0 . col2 , col6 ) * timestampdiff ( col8 , col4 , tab0 . col3 ) ) > codint as col10 from col11 col12 , ( select col4 = refre , col6 = refre ) col13	0
Q_129	connection pool with sailsjs	C_129_0	col0 _ col1 / col2 _ col3 / col4 / tab0 . col5	1
Q_129	connection pool with sailsjs	C_129_1	col0 _ col1 / col2 _ col3 / tab0 . json	0
Q_129	connection pool with sailsjs	C_129_2	/ * _ col0 _ * / col1 col2 = require ( refre refre refre ) / * _ col0 _ * / defaults { col3 true , col4 codint , col5 true } , / * _ col0 _ * /	0
Q_129	connection pool with sailsjs	C_129_3	col0 _ col1 / col2 _ col3 / col4 / col5 / tab0 . col6	0
Q_129	connection pool with sailsjs	C_129_4	/ * _ col0 _ * / / * _ col0 _ * / if ( tab0 . tab1 . col1 ) { tab0 . tab1 . tab2 . getconnection ( function ( col2 , col3 ) { afterwards ( col2 , col3 ) } ) return } / / use col4 new connection each time col5 col3 = tab3 . createconnection ( tab0 . col6 ) tab4 . connect ( function ( col2 ) { afterwards ( col2 , col3 ) } ) return / * _ col0 _ * / / * _ col0 _ * /	0
Q_129	connection pool with sailsjs	C_129_5	col0 { col1 refre , host refre , col2 refre , col3 refre , col4 false , database refre } ,	0
Q_129	connection pool with sailsjs	C_129_6	col0 { col1 refre , host refre , col2 refre , col3 refre , col4 true , col5 codint , database refre } ,	0
Q_130	implement a report card generation system	C_130_0	col0 int not null primary key col1 col2 varchar ( codint ) col3 varchar ( codint )	1
Q_130	implement a report card generation system	C_130_1	col0 int not null primary key col1 col2 varchar ( codint ) col3 varchar ( codint )	0
Q_130	implement a report card generation system	C_130_2	col0 int not null primary key col1 col2 varchar ( codint )	0
Q_130	implement a report card generation system	C_130_3	col0 int not null primary key col1 col2 int not null col3 _ > col4 col5 int not null col3 _ > col6	0
Q_130	implement a report card generation system	C_130_4	col0 int not null primary key col1 col2 varchar ( codint )	0
Q_130	implement a report card generation system	C_130_5	col0 int not null primary key col1 col2 int not null col3 _ > col4 col5 int not null col3 _ > class	0
Q_130	implement a report card generation system	C_130_6	col0 int not null primary key col1 col2 int not null col3 _ > class col4 int not null col3 _ > col5 col6 int _ type col7 col8 on col9 col10 col6 looks ( numeric tab0 . col11 , col12 , . )	0
Q_130	implement a report card generation system	C_130_7	select tab0 . * from col0 col1 inner join col2 col3 on tab1 . col4 = tab0 . col4 inner join col5 col6 on tab2 . col7 = tab1 . col7 where tab3 . col8 = < current col9 col10 >	0
Q_131	triple join unique result in each	C_131_0	from col0 inner join col1 on tab0 . col2 = tab1 . col3	1
Q_131	triple join unique result in each	C_131_1	select col0 , col1 , col2 from col3 join col4 on tab0 . col5 = tab1 . col6 where tab1 . col7 = codint or tab1 . col8 = codint union select col0 , col1 , col2 from col3 join col4 on tab0 . col5 = tab1 . col6 where tab1 . col7 = codint or tab1 . col8 = codint	0
Q_131	triple join unique result in each	C_131_2	select col0 , col1 , col2 from col3 join col4 on tab0 . col5 = tab1 . col6 where tab1 . col7 = codint or tab1 . col8 = codint or tab1 . col7 = codint or tab1 . col8 = codint	0
Q_131	triple join unique result in each	C_131_3	where tab0 . col0 in ( codint , codint ) or tab0 . col1 in ( codint , codint )	0
Q_131	triple join unique result in each	C_131_4	select col0 , col1 , col2 , case when tab0 . col3 = codint or tab0 . col4 = codint then refre when tab0 . col3 = codint or tab0 . col4 = codint then refre else refre end as col5 from col6 join col7 on tab1 . col8 = tab0 . col9 where tab0 . col3 in ( codint , codint , codint ) and tab0 . col4 in ( codint , codint , codint )	0
Q_131	triple join unique result in each	C_131_5	select col0 , col1 , col2 , case when < condition set codint > then refre when < condition set codint > then refre else refre end as col3 from col4 join col5 on tab0 . col6 = tab1 . col7 where ( < condition set codint > ) or ( < condition set codint > ) or ( < condition set codint > )	0
Q_131	triple join unique result in each	C_131_6	select col0 , col1 , col2 from col3 join col4 on tab0 . col5 = tab1 . col6 where ( < condition set codint > ) and not ( < condition set codint > ) and not ( < condition set codint > )	0
Q_132	how do i aggregate value respect to some conceptual class with sql	C_132_0	class col0 _ codint codint codint codint codint codint codint codint	1
Q_132	how do i aggregate value respect to some conceptual class with sql	C_132_1	col0 col1 _ codint codint codint codint codint codint codint codint codint codint	0
Q_132	how do i aggregate value respect to some conceptual class with sql	C_132_2	col0 = ( sum ( col1 ) / col2 ) * codint	0
Q_132	how do i aggregate value respect to some conceptual class with sql	C_132_3	select tab0 . col0 , tab0 . col1 , case when tab0 . col0 < = codint then refre else refre end col2 , case when tab0 . col0 < = codint then refre else refre end col3 , case when tab0 . col0 < = codint then refre else refre end col4 , case when tab0 . col0 < = codint then refre else refre end col5 , case when tab0 . col0 < = codint then refre else refre end col6 , case when tab0 . col0 < = codint then refre else refre end col7 , case when tab0 . col0 < = codint then refre else refre end col8 from col9 col10 is col11 result	0
Q_132	how do i aggregate value respect to some conceptual class with sql	C_132_4	col0 col1 col2 col3 col4 col5 col6 col7 col8 _ _ _ _ _ _ _ _ _ codint codint col9 col10 col11 col12 col13 col14 col15 codint codint col9 col10 col11 col12 col13 codint codint col9 col10 col11 col12 codint codint col9 col10 codint codint col9 _	0
Q_132	how do i aggregate value respect to some conceptual class with sql	C_132_5	col0 col1 col2 col3 col4 col5 col6 _ _ _ _ _ _ _ codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint _	0
Q_132	how do i aggregate value respect to some conceptual class with sql	C_132_6	col0 col1 col2 col3 col4 col5 col6 _ _ _ _ _ _ _ codint codint codint codint codint codint codint _	0
Q_132	how do i aggregate value respect to some conceptual class with sql	C_132_7	class col0 _ _ codint codint codint number codint number codint number _	0
Q_132	how do i aggregate value respect to some conceptual class with sql	C_132_8	for col0 class col1 _ codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint _ class col2 _ _ codint codint codint number codint number codint number codint number codint number codint number codint number _	0
Q_133	update multiple row in a table with different value	C_133_0	with col0 as ( select * from unnest ( array col1 , array col2 ) as xy ( col3 , col4 ) ) update col5 set col6 = tab0 . col4 from col0 col7 where col8 = tab0 . col3	1
Q_133	update multiple row in a table with different value	C_133_1	create col0 t1 ( col1 bigint , col2 bigint ) insert into t1 ( col1 , col2 ) select col3 , col3 * codint from generate_series ( codint , codint ) col3 create or replace function updatefunc1 ( bigint col4 , bigint col4 ) returns col5 as begin for col6 in array_lower ( codint , codint ) . array_upper ( codint , codint ) loop update col7 set col2 = codint col8 where col1 = codint col8 end loop end language plpgsql create or replace function updatefunc2 ( bigint col4 , bigint col4 ) returns col5 as begin with col9 as ( select * from unnest ( codint , codint ) as xy ( col3 , col10 ) ) update col7 set col2 = tab0 . col10 from col9 col11 where col1 = tab0 . col3 end language plpgsql select updatefunc1 ( array col12 , array col13 ) select updatefunc2 ( array col14 , array col15 ) select * from col7 where col1 in ( codint , codint )	0
Q_133	update multiple row in a table with different value	C_133_2	select updatefunc1 ( array ( select * from generate_series ( codint , codint ) ) , array ( select codint from generate_series ( codint , codint ) ) )	0
Q_133	update multiple row in a table with different value	C_133_3	select updatefunc2 ( array ( select * from generate_series ( codint , codint ) ) , array ( select codint from generate_series ( codint , codint ) ) )	0
Q_133	update multiple row in a table with different value	C_133_4	create or replace function updatefunc3 ( bigint col0 , bigint col0 ) returns col1 as begin with col2 as ( select col3 col4 as col5 , col6 col4 as col7 from ( select codint as col3 , codint as col6 , generate_subscripts ( codint , codint ) as col8 ) col5 ) update col9 set col10 = tab0 . col7 from col2 col11 where col12 = tab0 . col5 end language plpgsql select updatefunc3 ( array col13 , array col14 ) select * from col9 where col12 in ( codint , codint , codint )	0
Q_133	update multiple row in a table with different value	C_133_5	select updatefunc3 ( array ( select * from generate_series ( codint , codint ) ) , array ( select codint from generate_series ( codint , codint ) ) )	0
Q_133	update multiple row in a table with different value	C_133_6	create col0 col1 on t1 ( col2 ) select updatefunc1 ( array ( select * from generate_series ( codint , codint ) ) , array ( select codint from generate_series ( codint , codint ) ) ) result ( col3 = number rows = codint col4 = codint ) ( col5 time = * * number * * . number rows = codint col6 = codint ) output updatefunc1 ( ( codint ) bigint col7 , ( codint ) bigint col7 ) col8 codint ( returns codint )	0
Q_133	update multiple row in a table with different value	C_133_7	select updatefunc3 ( array ( select * from generate_series ( codint , codint ) ) , array ( select codint from generate_series ( codint , codint ) ) )	0
Q_134	end while loop miss semicolon	C_134_0	delimiter drop procedure if exists col0 create procedure testloop ( ) begin end delimiter	1
Q_134	end while loop miss semicolon	C_134_1	delimiter drop procedure if exists col0 create procedure testloop ( ) begin declare col1 int default codint declare col2 int default codint end delimiter	0
Q_134	end while loop miss semicolon	C_134_2	delimiter drop procedure if exists col0 create procedure testloop ( ) begin declare col1 int default codint declare col2 int default codint select count ( * ) from col3 into col1 set col2 = codint end delimiter	0
Q_134	end while loop miss semicolon	C_134_3	delimiter drop procedure if exists col0 create procedure testloop ( ) begin declare col1 int default codint declare col2 int default codint select count ( * ) from col3 into col1 set col2 = codint while col2 < col1 do set col2 = col2 + codint end while end delimiter	0
Q_134	end while loop miss semicolon	C_134_4	insert into test_2 ( col0 , col1 ) values ( col0 , col1 ) from col2 limit col3 , codint	0
Q_134	end while loop miss semicolon	C_134_5	delimiter drop procedure if exists col0 create procedure testloop ( ) begin declare col1 int default codint declare col2 int default codint select count ( * ) from col3 into col1 set col2 = codint while col2 < col1 do insert into test_2 ( col4 , col5 ) select col4 , col5 from col3 limit col2 , codint set col2 = col2 + codint end while end delimiter	0
Q_134	end while loop miss semicolon	C_134_6	prepare col0 from refre refre refre refre refre regque refre refre execute col0 using col1 deallocate prepare col0	0
Q_134	end while loop miss semicolon	C_134_7	delimiter drop procedure if exists col0 create procedure testloop ( ) begin declare col1 int default codint select count ( * ) from col2 into col1 set col3 = codint while col3 < col1 do prepare col4 from refre refre refre refre refre regque refre refre execute col4 using col3 deallocate prepare col4 set col3 = col3 + codint end while end delimiter	0
Q_135	t_sql execute procedure obtain parameter value from table	C_135_0	use col0 go _ col1 codint / * create col2 col3 tab0 . * / create type col4 as table1 ( col5 varchar ( codint ) , col6 int ) go _ col1 codint / * create col2 procedure to col7 data for col8 col3 _ col9 tab1 . * / create procedure tab2 . col10 col11 col4 col12 as begin set col13 on insert into tab3 . tab4 . location ( col14 , col6 , col15 , col16 ) select * , codint , getdate ( ) from col11 end go	1
Q_135	t_sql execute procedure obtain parameter value from table	C_135_1	/ * declare col0 col1 variable col2 references col3 tab0 . * / declare col4 as col5 _ col6 col7 col8 in col9 codint tab1 . / * add data to col3 col1 tab2 . col10 col6 col11 col12 col3 col13 as col14 declare cursor sql except col15 col16 into col0 col1 col17 parameter col4 * / insert into locationtvp ( col18 , col19 ) select col20 , number from tab3 . tab4 . col21 / * col22 col3 col1 variable data in col4 to col0 col23 procedure col2 now col24 col0 col1 col17 parameter as input * / exec col25 col4 go	0
Q_135	t_sql execute procedure obtain parameter value from table	C_135_2	create type col0 as table1 ( col1 varchar ( codint ) not null ) go _ col2 old col3 col4 col5 , to col6 col7 new type create procedure update_product_xml_tvp ( col8 col0 col9 ) as begin select * from col8 _ col10 col11 col12 col13 using col14 col15 col16 col17 is col18 to col19 col20 col14 col21 end	0
Q_135	t_sql execute procedure obtain parameter value from table	C_135_3	insert col0 select distinct col0 from col1 where col0 like refre order by col0	0
Q_135	t_sql execute procedure obtain parameter value from table	C_135_4	insert into col0 select distinct col0 from col1 where col0 like refre order by col0	0
Q_135	t_sql execute procedure obtain parameter value from table	C_135_5	codint . col0 col1 defined col2 type col3 col4 create type col5 as table1 ( col6 varchar ( codint ) not null ) codint . col0 col7 procedure col8 col9 col8 col2 type create col10 tab0 . [ mn_pass_id_table ] ( col11 col5 col12 ) as begin set col13 on select distinct col4 from col14 where col4 like refre order by col4 end codint . and col0 col15 to col16 col7 procedure col8 col17 tab1 . from alter procedure update_product_xml_single ( col4 varchar ( codint ) ) to alter procedure update_product_xml_tvp ( col11 col5 col12 )	0
Q_135	t_sql execute procedure obtain parameter value from table	C_135_6	where tab0 . col0 in ( select col1 from col2 )	0
Q_135	t_sql execute procedure obtain parameter value from table	C_135_7	declare col0 as col1 insert into col0 select col2 from real_table ( col3 col4 col5 col6 col7 col8 col9 col10 use to declare col6 cursor ) exec col11 col0	0
Q_136	write data to flat file in a loop use utl_file	C_136_0	create type col0 as col1 of number ( codint ) /	1
Q_136	write data to flat file in a loop use utl_file	C_136_1	create or replace procedure print_names ( col0 in col1 , col2 in varchar2 )	0
Q_136	write data to flat file in a loop use utl_file	C_136_2	for col0 in ( select * from col1 where col2 col3 of col4 ) loop col5 = rpad ( refre , codint ) rpad ( refre , codint ) to_char ( trunc ( col6 ) , refre ) rpad ( tab0 . col7 , codint ) tab1 . put_line ( col8 , convert ( col5 , refre , refre ) ) end loop	0
Q_136	write data to flat file in a loop use utl_file	C_136_3	create or replace procedure print_names ( col0 in col1 , col2 in varchar2 ) is col3 varchar ( codint ) = refre col4 tab0 . file_type col5 varchar2 ( codint ) begin col4 = tab0 . fopen ( col3 , col2 , refre ) _ file col6 col5 = rpad ( refre , codint ) to_char ( trunc ( col7 ) , refre ) refre tab0 . put_line ( col4 , convert ( col5 , refre , refre ) ) _ file col8 _ col9 section col10 col11 col12 in col13 loop for col14 in ( select * from col15 where col16 col17 of col0 ) loop col5 = rpad ( refre , codint ) rpad ( refre , codint ) to_char ( trunc ( col7 ) , refre ) rpad ( tab1 . col18 , codint ) tab0 . put_line ( col4 , convert ( col5 , refre , refre ) ) end loop _ file col19 col5 = rpad ( refre , codint ) to_char ( trunc ( col7 ) , refre ) refre tab0 . put_line ( col4 , convert ( col5 , refre , refre ) ) tab0 . fclose ( col4 ) end /	0
Q_136	write data to flat file in a loop use utl_file	C_136_4	begin print_names ( col0 = > employeeids ( codint , codint ) , col1 = > refre ) end /	0
Q_136	write data to flat file in a loop use utl_file	C_136_5	col0 codint col1 codint col2 col1 codint col3 col4 codint	0
Q_136	write data to flat file in a loop use utl_file	C_136_6	declare col0 col1 begin _ col2 col3 col4 from col3 col5 using col6 col7 col8 select col9 col10 collect into col0 from col11 where col9 in ( codint , codint ) print_names ( col12 = > col0 , col13 = > refre ) end /	0
Q_137	divide element of column by a sum of element group by element of another column	C_137_0	col0 tab0 . tab1 . tab2 . tab3 . tab4 . window col1 col2 = tab5 . partitionby ( refre ) . rowsbetween ( tab6 . minvalue , tab6 . maxvalue )	1
Q_137	divide element of column by a sum of element group by element of another column	C_137_1	col0 tab0 . tab1 . tab2 . tab3 . tab4 . sum col1 col2 = refre / sum ( refre ) . over ( col3 ) col1 col4 = tab5 . withcolumn ( refre , col2 )	0
Q_137	divide element of column by a sum of element group by element of another column	C_137_2	col0 tab0 . tab1 . tab2 . tab3 . tab4 . col1 tab5 . groupby ( refre ) . agg ( ( _ sum ( refre * log2 ( refre ) ) ) . alias ( refre ) )	0
Q_137	divide element of column by a sum of element group by element of another column	C_137_3	col0 col1 = seq ( ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) ) . col2	0
Q_137	divide element of column by a sum of element group by element of another column	C_137_4	+ _ + _ + col0 col1 + _ + _ + codint number codint number + _ + _ +	0
Q_137	divide element of column by a sum of element group by element of another column	C_137_5	tab0 . groupby ( refre ) . agg ( sum ( refre ) . alias ( refre ) ) . join ( col0 , seq ( refre ) , refre ) . withcolumn ( refre , refre / refre ) . groupby ( refre ) . agg ( ( _ sum ( refre * log2 ( refre ) ) ) . alias ( refre ) )	0
Q_137	divide element of column by a sum of element group by element of another column	C_137_6	tab0 . groupby ( refre ) . agg ( sum ( refre ) . alias ( refre ) )	0
Q_137	divide element of column by a sum of element group by element of another column	C_137_7	tab0 . join ( col0 , seq ( refre ) , refre )	0
Q_137	divide element of column by a sum of element group by element of another column	C_137_8	tab0 . withcolumn ( refre , refre / refre )	0
Q_137	divide element of column by a sum of element group by element of another column	C_137_9	tab0 . groupby ( refre ) . agg ( ( _ sum ( refre * log2 ( refre ) ) ) . alias ( refre ) )	0
Q_138	compare string in postgres use comparison operator	C_138_0	select refre < refre _ true col0 refre = refre and refre < refre .	1
Q_138	compare string in postgres use comparison operator	C_138_1	select refre < refre _ col0 true for col1 col2 tab0 .	0
Q_138	compare string in postgres use comparison operator	C_138_2	create function btrsort_nextunit ( col0 ) returns col0 as select case when codint refre regsta refre [ ^ 0 _ 9 ] refre regplu refre then coalesce ( substr ( codint , length ( substring ( codint from refre [ ^ 0 _ 9 ] refre regplu refre ) ) + codint ) , refre ) else coalesce ( substr ( codint , length ( substring ( codint from refre [ 0 _ 9 ] refre regplu refre ) ) + codint ) , refre ) end language sql create function btrsort ( col0 ) returns col0 as select case when char_length ( codint ) > codint then case when codint refre regsta refre [ ^ 0 _ 9 ] refre regplu refre then rpad ( substr ( coalesce ( substring ( codint from refre regsta refre [ ^ 0 _ 9 ] refre regplu refre ) , refre ) , codint , codint ) , codint , refre ) btrsort ( btrsort_nextunit ( codint ) ) else lpad ( substr ( coalesce ( substring ( codint from refre regsta refre [ 0 _ 9 ] refre regplu refre ) , refre ) , codint , codint ) , codint , refre ) btrsort ( btrsort_nextunit ( codint ) ) end else codint end language sql	0
Q_138	compare string in postgres use comparison operator	C_138_3	select * from col0 order by btrsort ( col1 )	0
Q_138	compare string in postgres use comparison operator	C_138_4	create col0 col1 on things ( btrsort ( col2 ) )	0
Q_138	compare string in postgres use comparison operator	C_138_5	select case when refre < refre then refre end from col0 output null	0
Q_138	compare string in postgres use comparison operator	C_138_6	select case when refre < refre then refre end _ col0	0
Q_139	sql server _ distinct combination of three columns_ order do not matter	C_139_0	select col0 , count ( * ) as col1 from col2 cross apply ( select refre + cast ( col3 as varchar ( codint ) ) from ( values ( col4 ) , ( col5 ) , ( col6 ) ) as t ( col3 ) order by col3 for xml path ( refre ) ) v ( col0 ) group by col0	1
Q_139	sql server _ distinct combination of three columns_ order do not matter	C_139_1	col0 col1 codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_139	sql server _ distinct combination of three columns_ order do not matter	C_139_2	select col0 , count ( * ) as col1 from ( select cast ( ( cast ( refre as xml ) ) . query ( refre refre refre col2 refre refre refre refre col3 refre refre refre refre col4 refre refre refre ) as varchar ( max ) ) as col0 from col5 ) col5 group by col0	0
Q_139	sql server _ distinct combination of three columns_ order do not matter	C_139_3	col0 col1 _ _ codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_139	sql server _ distinct combination of three columns_ order do not matter	C_139_4	select col0 , col1 , col2 , count ( * ) as col3 from ( select row , col4 , row_number ( ) over ( partition by row order by col4 ) as col5 from col6 unpivot ( col4 for col7 in ( col8 , col9 , col10 ) ) col11 ) col6 pivot ( max ( col4 ) for col5 in ( col0 , col1 , col2 ) ) col12 group by col0 , col1 , col2	0
Q_139	sql server _ distinct combination of three columns_ order do not matter	C_139_5	codint codint codint col0 _ _ _ _ codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_139	sql server _ distinct combination of three columns_ order do not matter	C_139_6	select col0 , col1 , col2 , count ( * ) as col3 from ( select ( select col4 from ( values ( col5 ) , ( col6 ) , ( col7 ) ) as t ( col4 ) order by col4 offset codint rows fetch first codint row only ) as col0 , ( select col4 from ( values ( col5 ) , ( col6 ) , ( col7 ) ) as t ( col4 ) order by col4 offset codint rows fetch first codint row only ) as col1 , ( select col4 from ( values ( col5 ) , ( col6 ) , ( col7 ) ) as t ( col4 ) order by col4 offset codint rows fetch first codint row only ) as col2 from col8 ) col8 group by col0 , col1 , col2	0
Q_139	sql server _ distinct combination of three columns_ order do not matter	C_139_7	codint codint codint col0 _ _ _ _ codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_140	create table that replace tagstr with default value during insertion	C_140_0	create col0 t ( col1 int , col2 varchar ( codint ) , col3 varchar ( codint ) )	1
Q_140	create table that replace tagstr with default value during insertion	C_140_1	create col0 t_stg ( col1 int identity , col2 varchar ( codint ) , col3 varchar ( codint ) )	0
Q_140	create table that replace tagstr with default value during insertion	C_140_2	truncate col0 col1 _ col2 insert col3 col4 col5 load insert into t_stg ( col6 , col7 , col8 ) values ( codint , refre , refre ) , ( codint , refre , refre ) , ( codint , refre , refre ) insert into t ( col6 , col7 , col8 ) select col6 , case when col7 = refre then refre else col7 end as col7 , case when col8 = refre then refre else col8 end as col8 from col1	0
Q_140	create table that replace tagstr with default value during insertion	C_140_3	select * from col0 + _ + _ + _ + col1 col2 col3 + _ + _ + _ + codint col4 col5 + _ + _ + _ + codint col6 col7 + _ + _ + _ + codint col6 col5 + _ + _ + _ +	0
Q_140	create table that replace tagstr with default value during insertion	C_140_4	create view col0 as select col1 , case when col2 = refre then refre else col2 end as col2 , case when col3 = refre then refre else col3 end as col3 from col4	0
Q_140	create table that replace tagstr with default value during insertion	C_140_5	_ col0 insert col1 col2 col3 load insert into t ( col4 , col5 , col6 ) values ( codint , refre , refre ) , ( codint , refre , refre ) , ( codint , refre , refre )	0
Q_140	create table that replace tagstr with default value during insertion	C_140_6	select * from col0 + _ + _ + _ + col1 col2 col3 + _ + _ + _ + codint col4 col5 + _ + _ + _ + codint col6 col7 + _ + _ + _ + codint col6 col5 + _ + _ + _ +	0
Q_140	create table that replace tagstr with default value during insertion	C_140_7	alter col0 col1 add col2 varchar ( codint ) generated col3 as ( case when col4 = refre then refre else col4 end ) col5 alter col0 col1 add col6 varchar ( codint ) generated col3 as ( case when col7 = refre then refre else col7 end ) col5	0
Q_140	create table that replace tagstr with default value during insertion	C_140_8	_ col0 insert col1 col2 col3 load insert into t ( col4 , col5 , col6 ) values ( codint , refre , refre ) , ( codint , refre , refre ) , ( codint , refre , refre )	0
Q_140	create table that replace tagstr with default value during insertion	C_140_9	select * from col0 + _ + _ + _ + _ + _ + col1 col2 col3 col4 col5 + _ + _ + _ + _ + _ + codint col6 _ col6 col7 + _ + _ + _ + _ + _ + codint _ col8 col9 col8 + _ + _ + _ + _ + _ + codint _ _ col9 col7 + _ + _ + _ + _ + _ +	0
Q_141	implement convolution in sql	C_141_0	create or replace function wkernel ( col0 numeric , col1 numeric , col2 numeric ) returns numeric language sql as select codint . / pow ( col0 , sqrt ( col1 * col1 + col2 * col2 ) )	1
Q_141	implement convolution in sql	C_141_1	select tab0 . col0 , tab0 . col1 , sum ( tab1 . col2 * wkernel ( codint , tab1 . col0 _ tab0 . col0 , tab1 . col1 _ tab0 . col1 ) ) as col3 from col4 col5 cross join col4 col6 group by tab0 . col0 , tab0 . col1 col0 col1 col3 _ + _ + _ codint codint number codint codint number codint codint number codint codint number ( codint rows )	0
Q_141	implement convolution in sql	C_141_2	select tab0 . col0 , tab0 . col1 , sum ( tab1 . col2 * wkernel ( codint , tab1 . col0 _ tab0 . col0 , tab1 . col1 _ tab0 . col1 ) ) as col3 from col4 col5 cross join col4 col6 where abs ( tab1 . col0 _ tab0 . col0 ) + abs ( tab1 . col1 _ tab0 . col1 ) < number group by tab0 . col0 , tab0 . col1 col0 col1 col3 _ + _ + _ codint codint number codint codint number codint codint number codint codint number ( codint rows )	0
Q_141	implement convolution in sql	C_141_3	select tab0 . col0 , tab0 . col1 , sum ( tab1 . col2 * wkernel ( codint , tab1 . col0 _ tab0 . col0 , tab1 . col1 _ tab0 . col1 ) ) / sum ( wkernel ( codint , tab1 . col0 _ tab0 . col0 , tab1 . col1 _ tab0 . col1 ) ) as col3 from col4 col5 cross join col4 col6 where abs ( tab1 . col0 _ tab0 . col0 ) + abs ( tab1 . col1 _ tab0 . col1 ) < number group by tab0 . col0 , tab0 . col1	0
Q_141	implement convolution in sql	C_141_4	select min ( col0 ) , max ( col0 ) , min ( col1 ) , max ( col1 ) , codint , codint from col2 min max min max col3 column col3 col3 column col3 _ + _ + _ + _ + _ + _ codint codint codint codint codint codint	0
Q_141	implement convolution in sql	C_141_5	select tab0 . * , tab1 . * , coalesce ( col0 , codint ) from col1 cross join generate_series ( col2 _ scope , col3 + scope ) col4 cross join generate_series ( col5 _ scope , col6 + scope ) col7 left join col8 on tab2 . col4 = tab0 . * and tab2 . col7 = tab1 . * col4 col7 coalesce _ + _ + _ _ codint _ codint codint _ codint codint codint _ codint codint codint _ codint codint codint codint _ codint codint codint codint number codint codint number codint codint codint codint _ codint codint codint codint number codint codint number codint codint codint codint _ codint codint codint codint codint codint codint codint codint codint codint ( codint rows )	0
Q_141	implement convolution in sql	C_141_6	select tab0 . col0 , tab0 . col1 , sum ( tab1 . col2 * wkernel ( col3 , tab1 . col0 _ tab0 . col0 , tab1 . col1 _ tab0 . col1 ) ) / sum ( wkernel ( col3 , tab1 . col0 _ tab0 . col0 , tab1 . col1 _ tab0 . col1 ) ) as col4 from col5 cross join col6 col7 cross join col6 col8 where tab0 . col0 between col9 and col10 and tab0 . col1 between col11 and col12 and abs ( tab1 . col0 _ tab0 . col0 ) + abs ( tab1 . col1 _ tab0 . col1 ) < = scope group by tab0 . col0 , tab0 . col1 col0 col1 col4 _ + _ + _ codint codint number codint codint number codint codint number codint codint number ( codint rows )	0
Q_141	implement convolution in sql	C_141_7	with cfg ( col0 , col1 , col2 , col3 , scope , col4 ) as ( select min ( col5 ) , max ( col5 ) , min ( col6 ) , max ( col6 ) , codint , codint from col7 ) , completed ( col5 , col6 , col8 ) as ( select tab0 . * , tab1 . * , coalesce ( col8 , codint ) from col9 cross join generate_series ( col0 _ scope , col1 + scope ) col5 cross join generate_series ( col2 _ scope , col3 + scope ) col6 left join col7 on tab2 . col5 = tab0 . * and tab2 . col6 = tab1 . * ) select tab3 . col5 , tab3 . col6 , sum ( tab4 . col8 * wkernel ( col4 , tab4 . col5 _ tab3 . col5 , tab4 . col6 _ tab3 . col6 ) ) / sum ( wkernel ( col4 , tab4 . col5 _ tab3 . col5 , tab4 . col6 _ tab3 . col6 ) ) as col10 from col9 cross join col11 col12 cross join col11 col13 where tab3 . col5 between col0 and col1 and tab3 . col6 between col2 and col3 and abs ( tab4 . col5 _ tab3 . col5 ) + abs ( tab4 . col6 _ tab3 . col6 ) < = scope group by tab3 . col5 , tab3 . col6	0
Q_142	cumulate array from early row	C_142_0	col0 tab0 . tab1 . col1 as col2 from tab0 . tab1 . window col0 window	1
Q_142	cumulate array from early row	C_142_1	col0 = tab0 . partitionby ( refre ) . orderby ( refre )	0
Q_142	cumulate array from early row	C_142_2	( col0 col1 tab0 . withcolumn ( refre , tab1 . explode ( refre ) ) collect tab2 . withcolumn ( refre , tab1 . collect_set ( refre ) . over ( col2 ) ) drop col3 for col4 col5 tab3 . groupby ( refre , refre ) . agg ( tab1 . max ( tab1 . struct ( tab1 . size ( refre ) , tab1 . col ( refre ) . alias ( refre ) , tab1 . col ( refre ) . alias ( refre ) ) ) . alias ( refre ) ) col6 by col7 and tab4 . select ( refre , refre , refre , tab1 . lag ( refre , codint ) . over ( col2 ) . alias ( refre ) ) )	0
Q_142	cumulate array from early row	C_142_3	+ _ + _ + _ + _ + col0 col1 col2 col3 + _ + _ + _ + _ + col4 codint col5 null col4 codint col6 col5 col7 codint col8 null col7 codint col9 col8 col7 codint col10 col11 col7 codint col12 col13 + _ + _ + _ + _ +	0
Q_142	cumulate array from early row	C_142_4	col0 tab0 . tab1 . col1 as col2 from tab0 . tab1 . window col0 window from tab0 . sql col0 column from tab0 . tab1 . col3 col0 col4 , col5 from col6 col0 col7 , union col8 / / tab2 . col9 / col10 / col11 from col11 col0 unique , concat , col12	0
Q_142	cumulate array from early row	C_142_5	col0 flatten_distinct ( col1 union col2 ) _ > column col0 flatten_distinct_ ( col3 union [ col4 [ col4 col5 ] , none ] ) _ > col4 col5 return compose ( col4 , unique , concat ) ( col3 or col6 ) return tab0 . udf ( col7 , arraytype ( stringtype ( ) ) ) ( col1 )	0
Q_142	cumulate array from early row	C_142_6	( col0 collect tab0 . withcolumn ( refre , tab1 . collect_list ( refre ) . over ( col1 ) ) col2 and drop tab2 . withcolumn ( refre , flatten_distinct ( refre ) ) col3 by tab3 . withcolumn ( refre , tab1 . lag ( refre , codint ) . over ( col1 ) ) for col4 tab4 . orderby ( refre ) )	0
Q_142	cumulate array from early row	C_142_7	+ _ + _ + _ + _ + col0 col1 col2 col3 + _ + _ + _ + _ + col4 codint col5 null col6 codint col7 null col4 codint col8 col5 col4 codint col9 col10 col4 codint col11 col12 col6 codint col13 col7 + _ + _ + _ + _ +	0
Q_143	panda equivalent to sql window function	C_143_0	select col0 , col1 , sum ( col1 ) over ( ) as col2 from col3 order by col0	1
Q_143	panda equivalent to sql window function	C_143_1	tab0 . assign ( col0 = tab0 . tab1 . sum ( ) ) . sort_values ( refre )	0
Q_143	panda equivalent to sql window function	C_143_2	select col0 , col1 , col2 , sum ( col1 ) over ( partition by col2 ) as col3 from col4 order by col0	0
Q_143	panda equivalent to sql window function	C_143_3	tab0 . assign ( col0 = tab0 . groupby ( refre ) tab1 . transform ( refre ) ) . sort_values ( refre )	0
Q_143	panda equivalent to sql window function	C_143_4	in col0 col1 out col0 col2 col3 col4 codint codint col5 codint codint codint col6 codint codint codint col7 codint codint codint col8 codint codint codint col9 codint codint codint col10 codint	0
Q_143	panda equivalent to sql window function	C_143_5	in col0 tab0 . assign ( col1 = tab0 . tab1 . sum ( ) ) . sort_values ( refre ) out col0 col2 col3 col4 col1 codint codint col5 codint codint codint codint col6 codint codint codint codint col7 codint codint codint codint col8 codint codint codint codint col9 codint codint codint codint col10 codint codint	0
Q_143	panda equivalent to sql window function	C_143_6	in col0 tab0 . assign ( col1 = tab0 . groupby ( refre ) tab1 . transform ( refre ) ) . . sort_values ( refre ) out col0 col2 col3 col4 col1 codint codint col5 codint codint codint codint col6 codint codint codint codint col7 codint codint codint codint col8 codint codint codint codint col9 codint codint codint codint col10 codint codint	0
Q_144	how to aggregate over rolling time window with group in spark	C_144_0	from tab0 . tab1 . col0 col1 coalesce , col2 , col3 , col4 , col5 , sum as col6 from tab0 . tab1 . window col1 window	1
Q_144	how to aggregate over rolling time window with group in spark	C_144_1	col0 = tab0 . partitionby ( refre ) . orderby ( refre )	0
Q_144	how to aggregate over rolling time window with group in spark	C_144_2	col0 = tab0 . withcolumn ( refre , col ( refre ) . cast ( refre ) )	0
Q_144	how to aggregate over rolling time window with group in spark	C_144_3	col0 from col1 col2 col3 or codint if col4 is col1 first col5 col6 = coalesce ( datediff ( refre , lag ( refre , codint ) . over ( col7 ) ) , lit ( codint ) ) codint if col6 < = codint , codint col8 indicator = ( col6 > codint ) . cast ( refre ) col9 sum of col10 over col1 window col11 = sum_ ( indicator ) . over ( col7 ) . alias ( refre )	0
Q_144	how to aggregate over rolling time window with group in spark	C_144_4	tab0 . select ( refre regast refre , col0 ) . groupby ( refre , refre ) . avg ( refre )	0
Q_144	how to aggregate over rolling time window with group in spark	C_144_5	+ _ + _ + _ + col0 col1 avg ( col2 ) + _ + _ + _ + col3 codint number col4 codint number col4 codint number + _ + _ + _ +	0
Q_144	how to aggregate over rolling time window with group in spark	C_144_6	from tab0 . tab1 . col0 col1 window tab2 . groupby ( window ( refre , col2 = refre ) ) . count ( )	0
Q_144	how to aggregate over rolling time window with group in spark	C_144_7	+ _ + _ + window count + _ + _ + col0 codint col1 codint col2 codint + _ + _ +	0
Q_145	how to combine two nullable boolean field in sql	C_145_0	select ( isnull ( col0 , codint ) isnull ( col1 , codint ) ) as col2 from .	1
Q_145	how to combine two nullable boolean field in sql	C_145_1	select . where ( isnull ( col0 , codint ) = codint or isnull ( col1 , codint ) = codint )	0
Q_145	how to combine two nullable boolean field in sql	C_145_2	select . where ( col0 = codint or col1 = codint )	0
Q_145	how to combine two nullable boolean field in sql	C_145_3	select iif ( ( isnull ( col0 , codint ) + isnull ( col1 , codint ) ) > codint , codint , codint )	0
Q_145	how to combine two nullable boolean field in sql	C_145_4	select case when col0 = codint then codint else iif ( col1 = codint , codint , codint ) end	0
Q_145	how to combine two nullable boolean field in sql	C_145_5	select case when ( col0 = codint or col1 = codint ) then codint else codint end	0
Q_145	how to combine two nullable boolean field in sql	C_145_6	select iif ( col0 = codint or col1 = codint ) , codint , codint )	0
Q_146	calculate interest across multiple interest rate	C_146_0	declare col0 date = refre _ col1 is some col2 end of time col3 col4 col5 col6 declare col7 date = refre _ col5 col8 col1 col9 to col10 more col11 declare col12 date = refre declare col13 float = number _ col5 col14 col15 to col16 col17 number	1
Q_146	calculate interest across multiple interest rate	C_146_1	+ _ + _ + col0 col1 + _ + _ + codint codint _ codint _ codint number codint _ codint _ codint number codint _ codint _ codint number codint _ codint _ codint + _ + _ +	0
Q_146	calculate interest across multiple interest rate	C_146_2	+ _ + _ + _ + col0 col1 col2 + _ + _ + _ + codint codint _ codint _ codint codint _ codint _ codint number codint _ codint _ codint codint _ codint _ codint number codint _ codint _ codint codint _ codint _ codint number codint _ codint _ codint codint _ codint _ codint + _ + _ + _ +	0
Q_146	calculate interest across multiple interest rate	C_146_3	select tab0 . col0 , tab0 . col1 as col2 , isnull ( min ( tab1 . col1 ) _ codint , col3 ) as col4 from col5 col6 left join col5 col7 on tab1 . col1 > tab0 . col1 group by tab0 . col0 , tab0 . col1	0
Q_146	calculate interest across multiple interest rate	C_146_4	with col0 as ( _ col1 col2 col3 / col4 ) select * from col0 where col5 > = ( select col5 _ col6 col1 first col7 col8 by col9 col10 interval from col0 where col11 between col5 and col12 ) and col12 < = ( select col12 _ col6 col1 last col7 col8 by col9 col10 interval from col0 where col13 between col5 and col12 )	0
Q_146	calculate interest across multiple interest rate	C_146_5	+ _ + _ + _ + col0 col1 col2 + _ + _ + _ + codint codint _ codint _ codint codint _ codint _ codint number codint _ codint _ codint codint _ codint _ codint number codint _ codint _ codint codint _ codint _ codint + _ + _ + _ +	0
Q_146	calculate interest across multiple interest rate	C_146_6	datediff ( col0 , case when col1 > col2 then col1 else col2 end , case when col3 < col4 then col3 else col4 end )	0
Q_146	calculate interest across multiple interest rate	C_146_7	with col0 as ( . ) _ col1 as col2 select * , datediff ( col3 , case when col4 > col5 then col4 else col5 end , case when col6 < col7 then col6 else col7 end ) as col8 , col9 * ( power ( ( codint + col10 / codint ) , convert ( float , datediff ( col3 , case when col4 > col5 then col4 else col5 end , case when col6 < col7 then col6 else col7 end ) ) / number ) ) _ col9 as col11 from . _ col1 as col2	0
Q_146	calculate interest across multiple interest rate	C_146_8	+ _ + _ + _ + _ + _ + col0 col1 col2 col3 col4 + _ + _ + _ + _ + _ + codint codint _ codint _ codint codint _ codint _ codint codint number number codint _ codint _ codint codint _ codint _ codint codint number number codint _ codint _ codint codint _ codint _ codint codint number + _ + _ + _ + _ + _ +	0
Q_147	extract value of unnamed record from json in postgres	C_147_0	{ refre refre , refre refre col0 refre no refre refre col1 refre refre < link col2 refre refre col3 refre col4 = refre col5 / / tab0 . col6 / codint refre / > refre refre refre uid refre refre , refre refre }	1
Q_147	extract value of unnamed record from json in postgres	C_147_1	{ refre refre , refre refre col0 refre no refre refre col1 refre refre < link col2 refre refre col3 refre col4 = refre col5 / / tab0 . col6 / codint refre / > refre refre refre uid refre refre , refre refre }	0
Q_147	extract value of unnamed record from json in postgres	C_147_2	"[ { refre refre , refre [ "" < link col0"	0
Q_147	extract value of unnamed record from json in postgres	C_147_3	"select col0 _ > refre refre col1 refre no refre refre col2 refre refre < link col3 "" from col4"	0
Q_147	extract value of unnamed record from json in postgres	C_147_4	"refre col0 refre col1 / / tab0 . col2 / codint refre refre refre ] , refre codint } ] """	0
Q_147	extract value of unnamed record from json in postgres	C_147_5	{ refre refre , refre [ { refre refre , refre col0 , refre codint } ] , refre refre }	0
Q_147	extract value of unnamed record from json in postgres	C_147_6	select ( col0 _ > refre _ codint ) json _ refre from col1	0
Q_147	extract value of unnamed record from json in postgres	C_147_7	refre regque refre + encodeuricomponent ( data ) + refre + encodeuricomponent ( col0 ) + refre + count	0
Q_148	my_sql count number of substring occurrence in column	C_148_0	select tab0 . col0 from col1 col2 group by tab0 . col0	1
Q_148	my_sql count number of substring occurrence in column	C_148_1	select tab0 . col0 from ( select tab1 . col0 from col1 col2 group by tab1 . col0 ) col3 order by tab0 . col0	0
Q_148	my_sql count number of substring occurrence in column	C_148_2	select tab0 . col0 , count ( codint ) as count from ( select tab1 . col0 from col1 col2 group by tab1 . col0 ) col3 join col1 col4 on tab2 . col0 like concat ( refre , tab0 . col0 , refre ) group by tab0 . col0 order by tab0 . col0	0
Q_148	my_sql count number of substring occurrence in column	C_148_3	replace ( replace ( tab0 . col0 , refre , refre ) , refre , refre )	0
Q_148	my_sql count number of substring occurrence in column	C_148_4	select tab0 . col0 , count ( codint ) as count from ( select tab1 . col0 from col1 col2 group by tab1 . col0 ) col3 join col1 col4 on tab2 . col0 like concat ( refre , replace ( replace ( tab0 . col0 , refre , refre ) , refre , refre ) , refre ) group by tab0 . col0 order by tab0 . col0	0
Q_148	my_sql count number of substring occurrence in column	C_148_5	col0 count col1 _ _ _ col2 codint col2 , col2 col3 , col4 col2 col3 codint col2 col3 col4 codint col4 col5 codint col5 col6 codint col6 , col7 , col8 col7 codint col7 , col8 col8 codint col8	0
Q_148	my_sql count number of substring occurrence in column	C_148_6	group_concat ( distinct tab0 . col0 order by tab0 . col0 ) as col1	0
Q_148	my_sql count number of substring occurrence in column	C_148_7	replace ( replace ( replace ( tab0 . col0 , refre , refre ) , refre , refre ) , refre , refre ) ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^	0
Q_149	how to aggregate base on one repeat value in a column	C_149_0	create col0 mytable ( col1 number , col2 number , col3 number , col4 number , col5 number ) insert into col6 values ( codint , codint , codint , codint , codint ) insert into col6 values ( codint , codint , codint , codint , codint ) insert into col6 values ( codint , codint , codint , codint , codint ) insert into col6 values ( codint , codint , codint , codint , codint ) commit	1
Q_149	how to aggregate base on one repeat value in a column	C_149_1	sql > select col0 codint from col1 codint group by col0 codint codint codint	0
Q_149	how to aggregate base on one repeat value in a column	C_149_2	sql > select col0 , min ( col1 ) as col1 codint from col2 codint group by col0 codint order by col0 asc , col1 asc codint codint codint codint codint codint	0
Q_149	how to aggregate base on one repeat value in a column	C_149_3	sql > select col0 , codint min ( col1 ) keep ( col2 last order by col3 asc ) as col1 , codint min ( col4 ) as col4 codint from col5 codint group by col0 codint order by col0 asc , col1 asc , col4 asc codint codint codint codint codint codint codint codint codint	0
Q_149	how to aggregate base on one repeat value in a column	C_149_4	sql > select col0 , codint min ( col1 ) keep ( col2 last order by col3 desc ) as col1 , codint min ( col4 ) as col4 codint from col5 codint group by col0 codint order by col0 asc , col1 asc , col4 asc codint codint codint codint codint codint codint codint codint	0
Q_149	how to aggregate base on one repeat value in a column	C_149_5	sql > select codint min ( col0 ) as col0 , codint min ( col1 ) as col1 , codint col2 as col2 , codint min ( col3 ) keep ( col4 last order by col1 asc ) as col3 , codint min ( col5 ) as col5 codint from col6 codint group by col2 codint order by col2 asc , col0 asc , col1 asc , col3 asc , col5 asc codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_149	how to aggregate base on one repeat value in a column	C_149_6	create col0 movie ( col1 varchar2 ( codint ) not null primary key , col2 varchar2 ( codint ) not null , col3 number ( codint , codint ) not null , col4 number ( codint , codint ) not null ) insert into col5 values ( refre , refre , codint , codint ) insert into col5 values ( refre , refre , codint , codint ) _ not true col6 _ col7 , col8 col9 col10 insert into col5 values ( refre , refre , codint , codint ) insert into col5 values ( refre , refre , codint , codint ) insert into col5 values ( refre , refre , codint , codint ) commit	0
Q_149	how to aggregate base on one repeat value in a column	C_149_7	sql > select col0 , max ( col1 ) from col2 codint group by col0 col0 max ( col1 ) col3 codint col4 codint	0
Q_149	how to aggregate base on one repeat value in a column	C_149_8	select col0 , max ( col1 ) keep ( col2 last order by col3 asc ) as col1 from col4 group by col0 col0 col1 col5 col6 col7 col8	0
Q_149	how to aggregate base on one repeat value in a column	C_149_9	select col0 , min ( col1 ) keep ( col2 last order by col3 asc ) as col1 from col4 group by col0 col0 col1 col5 col6 col7 col8	0
Q_149	how to aggregate base on one repeat value in a column	C_149_10	select col0 , min ( col1 ) keep ( col2 first order by col3 asc ) as col1 from col4 group by col0 col0 col1 col5 col6 col7 col8	0
Q_150	feather j sequelize _ service with relation between two model	C_150_0	col0 { associate ( ) { tab0 . hasone ( tab1 . tab2 . col1 , { as refre , col2 refre } ) } , } ,	1
Q_150	feather j sequelize _ service with relation between two model	C_150_1	col0 { associate ( ) { tab0 . belongsto ( tab1 . tab2 . col1 , { col2 true } ) } , } ,	0
Q_150	feather j sequelize _ service with relation between two model	C_150_2	. tab0 . set ( refre , tab1 . col0 ) . tab2 . keys ( tab1 . col0 ) . foreach ( function ( col1 ) { if ( refre in tab1 . col0 col2 ) { tab1 . col0 tab3 . associate ( ) } } )	0
Q_150	feather j sequelize _ service with relation between two model	C_150_3	tab0 . find ( { include col0 , col1 { sort { col2 codint } } } ) . then ( col3 = > { tab1 . tab2 . reverse ( ) tab3 . col4 = tab1 . data } )	0
Q_150	feather j sequelize _ service with relation between two model	C_150_4	tab0 . before = { . col0 [ { function ( col1 ) { if ( tab1 . tab2 . tab3 . include ) { col2 col3 = tab1 . tab4 . tab5 . tab6 . col4 tab1 . tab2 . col5 = { include col6 } } return tab7 . resolve ( col1 ) } } ] , . }	0
Q_150	feather j sequelize _ service with relation between two model	C_150_5	. tab0 . before = { all col0 , col1 col2 , get col2 , create col0 , update col0 , col3 col0 , col4 col0 } . function getcategory ( ) { return function ( col5 ) { col6 col7 = tab1 . tab2 . tab3 . tab4 . col8 tab1 . tab5 . col9 = { include col10 } return tab6 . resolve ( col5 ) } }	0
Q_150	feather j sequelize _ service with relation between two model	C_150_6	col0 { associate ( ) { tab0 . hasone ( tab1 . tab2 . col1 , { as refre , col2 refre , col3 refre } ) } , } ,	0
Q_150	feather j sequelize _ service with relation between two model	C_150_7	col0 { associate ( ) { tab0 . belongsto ( tab1 . tab2 . col1 , { col2 false , as refre } ) tab0 . belongsto ( tab1 . tab2 . col3 , { col2 false , as refre } ) } , } ,	0
Q_150	feather j sequelize _ service with relation between two model	C_150_8	function getrelatedinfo ( ) { return function ( col0 ) { tab0 . tab1 . col1 = { include col2 } return tab2 . resolve ( col0 ) } }	0
Q_150	feather j sequelize _ service with relation between two model	C_150_9	col0 col1 = io ( ) col0 col2 = feathers ( ) . configure ( tab0 . socketio ( col1 ) ) . configure ( tab0 . hooks ( ) ) col0 col3 = tab1 . service ( refre ) col0 col4 = tab1 . service ( refre ) col0 col5 = tab1 . service ( refre ) . mounted ( ) { tab2 . find ( { include [ { col6 tab3 . col6 , as refre , col7 { select col8 } } ] , col7 { sort { col9 codint } , select [ refre , col10 , refre , refre , refre ] } } ) . then ( col11 = > { tab4 . col12 = tab5 . data } ) }	0
Q_151	cross join column of a table with it data	C_151_0	select * from tab0 . [ udf _ eav ] ( ( select * from col0 for xml raw ) )	1
Q_151	cross join column of a table with it data	C_151_1	col0 col1 col2 codint col3 codint _ < < notice col4 is not col5 row codint col6 col5 codint col7 col5 codint col3 codint codint col6 col8 codint col7 col8 codint col3 codint codint col6 col9 codint col7 col9	0
Q_151	cross join column of a table with it data	C_151_2	select * from tab0 . [ udf _ eav ] ( ( select col0 = row_number ( ) over ( order by col1 ) , * from col2 for xml raw ) )	0
Q_151	cross join column of a table with it data	C_151_3	col0 col1 col2 codint col3 codint _ < < notice col3 is col4 tab0 . col5 column is row_number ( ) codint col6 codint codint col7 col4 codint col8 col4 codint col3 codint codint col6 codint codint col7 col9 codint col8 col9 codint col3 codint codint col6 codint codint col7 col10 codint col8 col10	0
Q_151	cross join column of a table with it data	C_151_4	select tab0 . * from col0 col1 cross col2 tab1 . [ udf _ eav ] ( ( select tab2 . * for xml raw ) ) col3	0
Q_151	cross join column of a table with it data	C_151_5	col0 col1 col2 codint col3 codint codint col4 col5 codint col6 col5 codint col3 codint codint col4 col7 codint col6 col7 codint col3 codint codint col4 col8 codint col6 col8	0
Q_151	cross join column of a table with it data	C_151_6	create function tab0 . [ udf _ eav ] ( xml xml ) returns col0 as return ( with ctekey ( col1 ) as ( select col2 codint tab1 . value ( refre refre refre , refre refre refre ) from tab2 . nodes ( refre refre ) as a ( col3 ) cross col4 tab3 . tab4 . nodes ( refre refre regast refre ) as b ( col5 ) ) select col6 = tab4 . value ( refre regast refre [ 1 ] refre , refre refre refre ) , col7 = tab1 . value ( refre refre refre , refre refre refre ) , col8 = tab1 . value ( refre , refre refre refre ) from tab2 . nodes ( refre refre ) as a ( col3 ) cross col4 tab3 . tab4 . nodes ( refre refre regast refre ) as b ( col5 ) where tab1 . value ( refre refre refre , refre refre refre ) not in ( select col1 from col9 ) ) _ col10 first col11 in col12 col13 col14 col15 col6 _ select * from tab0 . [ udf _ eav ] ( ( select col16 = getutcdate ( ) , * from tab5 . col17 for xml raw ) )	0
Q_152	max and group by in mongodb	C_152_0	select * from col0 where col1 in ( select col1 from col2 ) and col3 between col4 and col5	1
Q_152	max and group by in mongodb	C_152_1	tab0 . getcollection ( refre ) . aggregate ( col0 )	0
Q_152	max and group by in mongodb	C_152_2	select col0 , max ( col1 ) col2 from col3 where col0 in ( select col0 from col4 ) and col5 between col6 and col7 group by col0	0
Q_152	max and group by in mongodb	C_152_3	tab0 . getcollection ( refre ) . aggregate ( col0 )	0
Q_152	max and group by in mongodb	C_152_4	select col0 codint tab0 . col1 , tab0 . col2 as col3 from ( select col1 , max ( col4 ) col2 from col5 where col1 in ( select col1 from col6 ) and col7 between col8 and col9 group by col1 ) col10	0
Q_152	max and group by in mongodb	C_152_5	tab0 . getcollection ( refre ) . aggregate ( col0 )	0
Q_152	max and group by in mongodb	C_152_6	tab0 . getcollection ( refre ) . aggregate ( col0 )	0
Q_152	max and group by in mongodb	C_152_7	/ * codint * / { refre codint , refre codint } / * codint * / { refre codint , refre codint }	0
Q_153	oracle group by only one column	C_153_0	col0 col1 col2 col3 col3 codint col4 col3 codint col5 col3 codint	1
Q_153	oracle group by only one column	C_153_1	col0 col1 col2 col3 col4 col3 codint col4 col5 col4 codint col4 col6 col4 codint col4	0
Q_153	oracle group by only one column	C_153_2	select col0 , col1 , col2 from col3 where col2 = refre	0
Q_153	oracle group by only one column	C_153_3	+ _ + _ + _ + col0 col1 col2 + _ + _ + _ + codint some col3 codint codint codint some col3 codint codint codint some col3 codint codint codint some col3 codint codint + _ + _ + _ +	0
Q_153	oracle group by only one column	C_153_4	select col0 , col1 , col2 from col3 where col2 = refre group by col0 _ col4 + _ + _ + _ + col0 col1 col2 + _ + _ + _ + codint some col5 codint codint codint some col5 codint codint codint some col5 codint codint col6 some col5 codint col6 codint col6 + _ + _ + _ +	0
Q_153	oracle group by only one column	C_153_5	select col0 , col1 , col2 from col3 where col2 = refre group by col0 , col1 , col2 + _ + _ + _ + col0 col1 col2 + _ + _ + _ + codint some col4 codint codint codint some col4 codint codint _ col5 col6 codint some col4 codint codint + _ + _ + _ +	0
Q_153	oracle group by only one column	C_153_6	select col0 , col1 , col2 , col3 from col4 where col3 = refre group by col0 , col1 , col2 , col3 + _ + _ + _ + _ + col0 col1 col2 col3 + _ + _ + _ + _ + codint codint some col5 codint codint _ col0 = codint codint codint some col5 codint codint codint codint some col5 codint codint codint codint some col5 codint codint _ col0 = codint + _ + _ + _ + _ +	0
Q_153	oracle group by only one column	C_153_7	select min ( col0 ) , col1 , col2 , col3 from col4 where col3 = refre group by col1 , col2 , col3 _ col5 , min ( ) is col6 aggregate function , col7 col0 col8 not col9 in col10 group by	0
Q_153	oracle group by only one column	C_153_8	+ _ + _ + _ + _ + col0 col1 col2 col3 + _ + _ + _ + _ + codint codint some col4 codint codint codint codint some col4 codint codint codint codint some col4 codint codint + _ + _ + _ + _ +	0
Q_153	oracle group by only one column	C_153_9	+ _ + _ + _ + _ + col0 col1 col2 col3 + _ + _ + _ + _ + codint codint some col4 codint codint codint codint some col4 codint codint + _ + _ + _ + _ +	0
Q_154	how to use data_frame window expression and with_column and not to change partition	C_154_0	col0 > col1 col2 = tab0 . range ( codint , codint , codint , codint ) . col3 col2 tab1 . tab2 . tab0 . tab3 . col4 = col5 col0 > tab4 . show + _ + col6 + _ + codint codint codint codint codint codint codint codint + _ + col0 > tab4 . tab5 . col7 col8 int = codint	1
Q_154	how to use data_frame window expression and with_column and not to change partition	C_154_1	col0 > col1 tab0 . tab1 . tab2 . tab3 . tab4 . window col1 tab0 . tab1 . tab2 . tab3 . tab4 . window col0 > col2 col3 = tab5 . withcolumn ( refre , sum ( refre ) . over ( tab6 . orderby ( refre ) ) ) col3 tab0 . tab1 . tab2 . tab3 . col4 = col5	0
Q_154	how to use data_frame window expression and with_column and not to change partition	C_154_2	col0 > tab0 . tab1 . col1 codint / codint / codint codint codint codint col2 col3 no partition defined for window operation col4 all data to col5 col6 partition , col7 col8 col9 col10 col11 tab2 . col12 int = codint col0 > tab0 . show codint / codint / codint codint codint codint col2 col3 no partition defined for window operation col4 all data to col5 col6 partition , col7 col8 col9 col10 col11 tab2 . + _ + _ + col13 col14 + _ + _ + codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint + _ + _ +	0
Q_154	how to use data_frame window expression and with_column and not to change partition	C_154_3	col0 > col1 col2 = tab0 . withcolumn ( refre , when ( refre < codint , lit ( refre ) ) . otherwise ( refre ) ) col2 tab1 . tab2 . tab3 . tab4 . col3 = col4	0
Q_154	how to use data_frame window expression and with_column and not to change partition	C_154_4	col0 > tab0 . tab1 . col1 col2 int = codint	0
Q_154	how to use data_frame window expression and with_column and not to change partition	C_154_5	col0 > col1 col2 = tab0 . withcolumn ( refre , sum ( refre ) . over ( tab1 . orderby ( refre ) . partitionby ( refre ) ) ) col2 tab2 . tab3 . tab4 . tab5 . col3 = col4 col0 > tab6 . show + _ + _ + _ + col5 col6 col7 + _ + _ + _ + codint col8 codint codint col8 codint codint col8 codint codint col8 codint codint col9 codint codint col9 codint codint col9 codint codint col9 codint + _ + _ + _ +	0
Q_154	how to use data_frame window expression and with_column and not to change partition	C_154_6	col0 > tab0 . tab1 . col1 col2 int = codint	0
Q_155	how to update row base on value of another row sql server	C_155_0	_ create col0 data if object_id ( refre ) is not null drop col1 temp create col1 temp ( col2 int , col3 varchar ( codint ) , col4 int ) insert into temp select codint , refre , codint insert into temp select codint , refre , null insert into temp select codint , refre , null insert into temp select codint , refre , null insert into temp select codint , refre , codint insert into temp select codint , refre , null insert into temp select codint , refre , null insert into temp select codint , refre , null insert into temp select codint , refre , null	1
Q_155	how to update row base on value of another row sql server	C_155_1	with col0 as ( select col1 , max ( col2 ) as maxvalue from temp group by col1 ) update col3 set col2 = case when tab0 . col1 = refre and tab1 . maxvalue is not null then null when tab0 . col1 = refre and tab1 . maxvalue is not null then tab1 . maxvalue end from temp col3 cross join col0 col4 where tab0 . col1 in ( refre , refre ) and tab1 . col1 = refre select * from temp	0
Q_155	how to update row base on value of another row sql server	C_155_2	with col0 as ( select col1 , ( col1 _ codint ) / codint as col2 , col3 , col4 from temp ) , col5 as ( select col2 , col3 , max ( col4 ) as maxvalue from col0 group by col2 , col3 ) update col6 set col4 = case when tab0 . col3 = refre and tab1 . maxvalue is not null then null when tab0 . col3 = refre and tab1 . maxvalue is not null then tab1 . maxvalue end from temp col6 inner join col0 col7 on tab2 . col1 = tab0 . col1 inner join col5 col8 on tab1 . col2 = tab2 . col2 where tab0 . col3 in ( refre , refre ) and tab1 . col3 = refre	0
Q_155	how to update row base on value of another row sql server	C_155_3	_ create col0 data if object_id ( refre ) is not null drop col1 temp create col1 temp ( col2 int , col3 varchar ( codint ) , col4 int ) insert into temp select codint , refre , codint insert into temp select codint , refre , null insert into temp select codint , refre , null insert into temp select codint , refre , null insert into temp select codint , refre , null insert into temp select codint , refre , null insert into temp select codint , refre , null insert into temp select codint , refre , codint insert into temp select codint , refre , null insert into temp select codint , refre , codint insert into temp select codint , refre , null insert into temp select codint , refre , null	0
Q_155	how to update row base on value of another row sql server	C_155_4	with col0 as ( select ( col1 _ codint ) / codint as col2 , col1 , col3 , col4 from temp ) , col5 as ( select col2 , col1 , col3 , col4 from col0 where col4 is not null ) update col6 set col4 = case when tab0 . col3 = refre and tab1 . col3 = refre then null when tab0 . col3 = refre and tab1 . col3 = refre then tab1 . col4 when tab0 . col3 = refre and tab1 . col3 = refre then null when tab0 . col3 = refre and tab1 . col3 = refre then tab1 . col4 when tab0 . col3 = refre and tab1 . col3 = refre then null when tab0 . col3 = refre and tab1 . col3 = refre then tab1 . col4 when tab0 . col3 = refre and tab1 . col3 = refre then null when tab0 . col3 = refre and tab1 . col3 = refre then tab1 . col4 end from temp col6 inner join col0 col7 on tab2 . col1 = tab0 . col1 inner join col5 col8 on tab1 . col2 = tab2 . col2	0
Q_155	how to update row base on value of another row sql server	C_155_5	col0 col1 col2 codint col3 codint codint col4 null codint col5 null codint col6 null codint col3 null codint col4 null codint col5 null codint col6 codint codint col3 null codint col4 codint codint col5 null codint col6 null	0
Q_155	how to update row base on value of another row sql server	C_155_6	col0 col1 col2 codint col3 null codint col4 codint codint col5 null codint col6 null codint col3 codint codint col4 null codint col5 null codint col6 null codint col3 null codint col4 null codint col5 codint codint col6 null	0
Q_155	how to update row base on value of another row sql server	C_155_7	col0 col1 col2 codint col3 null codint col4 null codint col5 codint codint col6 null codint col3 null codint col4 codint codint col5 null codint col6 null codint col3 null codint col4 null codint col5 null codint col6 codint	0
Q_155	how to update row base on value of another row sql server	C_155_8	with col0 as ( select ( col1 _ codint ) / codint as col2 , col1 , col3 , col4 from temp ) , col5 as ( select col2 , col1 , col3 , col4 from col0 where col4 is not null ) update col6 set col4 = case _ col7 to col8 when tab0 . col3 = refre and tab1 . col3 = refre then tab1 . col4 _ col9 to col10 when tab0 . col3 = refre and tab1 . col3 = refre then tab1 . col4 _ col10 to d ( col11 col12 col13 ) when tab0 . col3 = refre and tab1 . col3 = refre then tab1 . col4 _ col8 to col7 when tab0 . col3 = refre and tab1 . col3 = refre then tab1 . col4 _ set col14 col15 col16 to null when tab0 . col3 = tab1 . col3 then null end from temp col6 inner join col0 col17 on tab2 . col1 = tab0 . col1 inner join col5 col9 on tab1 . col2 = tab2 . col2	0
Q_156	search comma separate value in oracle tagint	C_156_0	codint . codint , codint , codint , codint codint . codint , codint , codint , codint codint . codint , codint , codint , codint	1
Q_156	search comma separate value in oracle tagint	C_156_1	create col0 temp_table_name ( col1 number ( codint ) , col2 varchar2 ( codint ) ) insert into col3 values ( codint , refre refre ) insert into col3 values ( codint , refre refre refre refre )	0
Q_156	search comma separate value in oracle tagint	C_156_2	select rownum col0 , refre refre refre refre col1 from col2 connect by rownum < = ( length ( refre refre refre refre ) _ length ( replace ( refre refre refre refre , refre refre , refre ) ) ) + codint	0
Q_156	search comma separate value in oracle tagint	C_156_3	length of col0 _ length of col0 without refre refre + codint col1	0
Q_156	search comma separate value in oracle tagint	C_156_4	parsing_string ( refre refre refre refre , codint ) col0 col1 return codint . create or replace function parsing_string ( col2 in varchar2 , col3 in number ) return varchar2 is col4 number col5 number begin if col3 < codint then return null end if col4 = instr ( col2 , refre refre , codint , col3 ) if col4 = codint then col4 = length ( col2 ) + codint end if if col3 = codint then col5 = codint else col5 = instr ( col2 , refre refre , codint , col3 _ codint ) + codint end if return substr ( col2 , col5 , col4 _ col5 ) end /	0
Q_156	search comma separate value in oracle tagint	C_156_5	select tab0 . * , parsing_string ( col0 , col1 ) from col2 col3 , ( select rownum col1 , refre refre refre refre col0 from col4 connect by rownum < = ( select ( length ( refre refre refre refre ) _ length ( replace ( refre refre refre refre , refre refre , refre ) ) ) + codint from col4 ) ) col5	0
Q_156	search comma separate value in oracle tagint	C_156_6	where / * for when col0 col1 is in col0 col2 of col0 col3 col4 * / col5 like refre refre parsing_string ( col6 , col7 ) refre refre or / * for when col0 col1 is in col0 start of col0 col8 col9 col10 col0 first position col11 col12 col1 to match * / parsing_string ( col5 , codint ) = parsing_string ( col6 , col7 ) or / * for when col0 col1 is in col0 end of col0 col8 col13 col10 col0 last position col11 col12 col1 to match * / parsing_string ( col5 , ( length ( col5 ) _ length ( replace ( col5 , refre refre , refre ) ) ) + codint ) = parsing_string ( col6 , col7 )	0
Q_156	search comma separate value in oracle tagint	C_156_7	select distinct col0 from col1 col2 , ( select rownum col3 , refre refre refre refre col4 from col5 connect by rownum < = ( select ( length ( refre refre refre refre ) _ length ( replace ( refre refre refre refre , refre refre , refre ) ) ) + codint from col5 ) ) col6 where col7 like refre refre parsing_string ( col4 , col3 ) refre refre or parsing_string ( col7 , codint ) = parsing_string ( col4 , col3 ) or parsing_string ( col7 , ( length ( col7 ) _ length ( replace ( col7 , refre refre , refre ) ) ) + codint ) = parsing_string ( col4 , col3 )	0
Q_157	date intersection and space availability	C_157_0	with col0 as ( select col1 as col2 , unnest ( array col3 ) as col4 , unnest ( array col5 ) as col6 from col7 where col8 is null or col8 > = refre ) , col9 as ( select col2 _ col10 inner sum col11 col12 and col13 col14 on col10 col15 _ date to col16 col17 col18 col19 , col10 outer is col10 col20 tab0 . col21 _ col22 col10 col23 where col10 order of col14 col12 or col13 _ on col10 col15 date is col24 and col25 col26 col27 col28 _ col29 values for col18 , if all col12 col14 col30 col31 col32 to _ col33 tab1 . , sum ( sum ( col6 ) ) over ( partition by col2 order by col4 ) as col34 from col0 group by col2 , col4 ) select * from space where not exists ( select from col9 where tab2 . col2 = tab3 . col35 and tab3 . col36 _ tab2 . col34 < codint )	1
Q_157	date intersection and space availability	C_157_1	from col0 col1 col2 from tab0 . tab1 . col3 col1 array col4 = tab2 . query ( tab3 . col5 , tab4 . unnest ( array ( col6 ) ) . label ( refre ) , tab4 . unnest ( array ( col7 ) ) . label ( refre ) ) . filter ( or_ ( tab3 . col8 = = none , tab3 . col8 > = refre ) ) . cte ( ) col9 = tab2 . query ( tab5 . tab6 . col5 , tab4 . sum ( tab4 . sum ( tab5 . tab6 . col10 ) ) . over ( col11 = tab5 . tab6 . col5 , col12 = tab5 . tab6 . date ) . label ( refre ) ) . group_by ( tab5 . tab6 . col5 , tab5 . tab6 . date ) . cte ( ) col13 = tab2 . query ( space ) . filter ( tab2 . query ( col9 ) . filter ( tab7 . tab6 . col5 = = tab8 . col14 , tab8 . col15 _ tab7 . tab6 . col10 < codint ) . exists ( ) )	0
Q_157	date intersection and space availability	C_157_2	select * from col0 where daterange ( col1 , col2 , refre refre refre ) daterange ( refre , null , refre refre refre )	0
Q_157	date intersection and space availability	C_157_3	_ codint . . . . _ codint . . . . . _ codint . . . . . . . _ codint . . . . codint codint codint codint	0
Q_157	date intersection and space availability	C_157_4	with col0 as ( select * from col1 where daterange ( col2 , col3 , refre refre refre ) daterange ( refre , null , refre refre refre ) ) select distinct tab0 . col4 , sum ( tab1 . col5 ) as sum from col0 col6 join col0 col7 on tab0 . col2 < daterange ( tab1 . col2 , tab1 . col3 , refre refre refre ) and tab0 . col4 = tab1 . col4 group by tab0 . col8 , tab0 . col4	0
Q_157	date intersection and space availability	C_157_5	col0 sum _ + _ codint codint ( codint row )	0
Q_157	date intersection and space availability	C_157_6	with col0 as ( select * from col1 where daterange ( col2 , col3 , refre refre refre ) daterange ( refre , null , refre refre refre ) ) , col4 as ( select distinct tab0 . col5 , sum ( tab1 . col6 ) as sum from col0 col7 join col0 col8 on tab0 . col2 < daterange ( tab1 . col2 , tab1 . col3 , refre refre refre ) and tab0 . col5 = tab1 . col5 _ col9 col10 use distinct sum ( ) over ( partition by tab0 . col11 ) instead group by tab0 . col11 , tab0 . col5 ) select * from space where not exists ( select codint from col4 where tab2 . col5 = tab3 . col11 _ check if col12 is not col13 space and tab3 . col14 _ tab2 . sum < codint )	0
Q_157	date intersection and space availability	C_157_7	from col0 col1 partial from tab0 . tab1 . col2 col1 col3 tab2 . col4 type for col5 col3 values is tab3 . tab4 . col3 , col6 col7 col8 not col9 col10 col11 tab5 . col3 = partial ( tab6 . col3 , col12 = col3 ) col13 = tab7 . query ( col14 ) . filter ( daterange ( tab8 . col15 , tab8 . col16 , refre refre refre ) . overlaps ( daterange ( refre , none , refre refre refre ) ) ) . cte ( ) col17 = tab9 . alias ( ) col18 = tab9 . alias ( ) col19 = tab7 . query ( tab10 . tab11 . col20 , tab6 . sum ( tab12 . tab11 . col21 ) . label ( refre ) ) . distinct ( ) . join ( col18 , ( tab12 . tab11 . col20 = = tab10 . tab11 . col20 ) daterange ( tab12 . tab11 . col15 , tab12 . tab11 . col16 ) . contains ( tab10 . tab11 . col15 ) ) . group_by ( tab10 . tab11 . col22 , tab10 . tab11 . col20 ) . cte ( ) col23 = tab7 . query ( space ) . filter ( tab7 . query ( col19 ) . filter ( tab13 . tab11 . col20 = = tab14 . col22 , tab14 . col24 _ tab13 . tab11 . sum < codint ) . exists ( ) )	0
Q_158	how to multiply sql value	C_158_0	col0 col1 = refre + tab0 . col2 + refre + tab0 . table_name + refre refre + tab0 . col2 + refre regast refre + tab0 . col3 + refre refre refre	1
Q_158	how to multiply sql value	C_158_1	col0 col1 = tab0 . getwritabledatabase ( ) _ > col1 = tab0 . getreadabledatabase ( )	0
Q_158	how to multiply sql value	C_158_2	col0 < col1 > col2 = new col3 < > ( ) cursor cursor = tab0 . rawquery ( col4 , null ) tab1 . movetofirst ( ) while ( tab1 . isafterlast ( ) ) { do { double col5 = tab2 . parsedouble ( tab1 . getstring ( codint ) ) tab3 . add ( new food ( col5 ) ) } tab1 . movetonext ( ) } tab1 . close ( ) return col2 }	0
Q_158	how to multiply sql value	C_158_3	col0 col1 = tab0 . getinstance ( tab1 . col2 ) col3 < col4 > col5 = new col3 < > ( )	0
Q_158	how to multiply sql value	C_158_4	col0 col1 = ( col0 ) findviewbyid ( tab0 . tab1 . col2 ) col3 col4 = new linearlayoutmanager ( col5 , tab2 . col6 , false ) tab3 . setlayoutmanager ( col4 ) col7 col8 = new foodfatrecyclerviewadapter ( tab4 . col5 , col9 ) tab5 . setadapter ( col8 )	0
Q_158	how to multiply sql value	C_158_5	public class col0 col1 tab0 . col2 < col3 > { col4 < col5 > col6 col7 col8 public foodfatrecyclerviewadapter ( col7 col7 , col4 < col5 > array ) { col8 = col7 col6 = array } col9 public col3 oncreateviewholder ( col10 col11 , int col12 ) { view view = tab1 . from ( tab2 . getcontext ( ) ) . inflate ( tab3 . tab4 . col13 , col11 , false ) col3 col14 = new foodfatviewholder ( view ) return col14 } col9 public col15 onbindviewholder ( col3 col16 , final int position ) { tab5 . tab6 . settext ( tab7 . get ( position ) ) } col9 public int getitemcount ( ) { return tab7 . size ( ) } }	0
Q_158	how to multiply sql value	C_158_6	public class col0 col1 tab0 . col2 { col3 col4 public foodfatviewholder ( view col5 ) { super ( col5 ) col4 = ( col3 ) tab1 . findviewbyid ( tab2 . tab3 . col6 ) } }	0
Q_159	mssql create incremental row label per group	C_159_0	with col0 as ( select tab0 . col1 , tab0 . col2 , col3 = case when datediff ( col4 , tab0 . col2 , lag ( tab0 . col2 , codint ) over ( partition by tab0 . col1 order by tab0 . col2 ) ) = _ codint then codint else row_number ( ) over ( partition by tab0 . col1 order by tab0 . col2 ) end from col5 col6 ) , col7 as ( select tab1 . col1 , tab1 . col2 , col8 = max ( tab1 . col3 ) over ( partition by tab1 . col1 order by tab1 . col2 rows unbounded col9 ) from col0 col10 ) select tab2 . col1 , tab2 . col2 , col11 = dense_rank ( ) over ( partition by tab2 . col1 order by tab2 . col8 ) from col7 col12	1
Q_159	mssql create incremental row label per group	C_159_1	with col0 as ( select tab0 . col1 , tab0 . col2 , col3 = case when datediff ( col4 , tab0 . col2 , lag ( tab0 . col2 , codint ) over ( partition by tab0 . col1 order by tab0 . col2 ) ) = _ codint then codint else row_number ( ) over ( partition by tab0 . col1 order by tab0 . col2 ) end from col5 col6 ) select * from col0	0
Q_159	mssql create incremental row label per group	C_159_2	col0 col1 col2 _ _ _ codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint	0
Q_159	mssql create incremental row label per group	C_159_3	with col0 as ( select tab0 . col1 , tab0 . col2 , col3 = case when datediff ( col4 , tab0 . col2 , lag ( tab0 . col2 , codint ) over ( partition by tab0 . col1 order by tab0 . col2 ) ) = _ codint then codint else row_number ( ) over ( partition by tab0 . col1 order by tab0 . col2 ) end from col5 col6 ) , col7 as ( select tab1 . col1 , tab1 . col2 , col8 = max ( tab1 . col3 ) over ( partition by tab1 . col1 order by tab1 . col2 rows unbounded col9 ) from col0 col10 ) select * from col7	0
Q_159	mssql create incremental row label per group	C_159_4	col0 col1 col2 _ _ _ codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint	0
Q_159	mssql create incremental row label per group	C_159_5	with col0 as ( select tab0 . col1 , tab0 . col2 , col3 = case when datediff ( col4 , tab0 . col2 , lag ( tab0 . col2 , codint ) over ( partition by tab0 . col1 order by tab0 . col2 ) ) = _ codint then codint else row_number ( ) over ( partition by tab0 . col1 order by tab0 . col2 ) end from col5 col6 ) , col7 as ( select tab1 . col1 , tab1 . col2 , col8 = max ( tab1 . col3 ) over ( partition by tab1 . col1 order by tab1 . col2 rows unbounded col9 ) from col0 col10 ) select tab2 . col1 , tab2 . col2 , col11 = dense_rank ( ) over ( partition by tab2 . col1 order by tab2 . col8 ) from col7 col12	0
Q_159	mssql create incremental row label per group	C_159_6	col0 col1 col2 _ _ _ codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint	0
Q_160	how to make parent child order with postgresql	C_160_0	"_ col0 col1 create col2 col3 + primary key ( col4 "" col5 not col6 col7 col8 data type is ) create col3 test ( col9 serial primary key , col10 integer , col11 col12 )"	1
Q_160	how to make parent child order with postgresql	C_160_1	"insert into test ( col0 , col1 ) values ( null , refre col2 col3 codint "" )"	0
Q_160	how to make parent child order with postgresql	C_160_2	"insert into test ( col0 , col1 ) values ( null , refre col2 col3 codint "" )"	0
Q_160	how to make parent child order with postgresql	C_160_3	"insert into test ( col0 , col1 ) values ( null , refre col2 col3 codint "" )"	0
Q_160	how to make parent child order with postgresql	C_160_4	insert into test ( col0 , col1 ) values ( codint , refre )	0
Q_160	how to make parent child order with postgresql	C_160_5	insert into test ( col0 , col1 ) values ( codint , refre )	0
Q_160	how to make parent child order with postgresql	C_160_6	insert into test ( col0 , col1 ) values ( codint , refre )	0
Q_160	how to make parent child order with postgresql	C_160_7	insert into test ( col0 , col1 ) values ( codint , refre )	0
Q_160	how to make parent child order with postgresql	C_160_8	insert into test ( col0 , col1 ) values ( codint , refre )	0
Q_160	how to make parent child order with postgresql	C_160_9	select tab0 . col0 , tab1 . col0 , tab1 . col1 from col2 col3 join col2 col4 = tab0 . col0 = tab1 . col5 order by tab1 . col1	0
Q_160	how to make parent child order with postgresql	C_160_10	tab0 . col0 tab1 . col0 tab1 . col1 codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_160	how to make parent child order with postgresql	C_160_11	insert into test ( col0 , col1 ) values ( codint , refre )	0
Q_160	how to make parent child order with postgresql	C_160_12	tab0 . col0 tab1 . col0 tab1 . col1 codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_161	how to refer to data in spark sql use column name	C_161_0	case class shades ( col0 int , col1 int , col2 col3 )	1
Q_161	how to refer to data in spark sql use column name	C_161_1	col0 col1 = tab0 . textfile ( refre ) col0 col2 = tab1 . map ( line = > tab2 . split ( refre ) ) . map ( col3 = > shades ( elem ( codint ) . tab3 . col4 , elem ( codint ) . tab3 . col4 , elem ( codint ) . trim ) ) col5 col6 = tab4 . todf ( )	0
Q_161	how to refer to data in spark sql use column name	C_161_2	+ _ + _ + _ + col0 col1 col2 + _ + _ + _ + codint codint col3 col4 codint codint col5 col4 codint codint col3 col6 codint codint col5 col7 codint codint col8 col7 + _ + _ + _ +	0
Q_161	how to refer to data in spark sql use column name	C_161_3	tab0 . filter ( refre = = = refre ) . show ( false )	0
Q_161	how to refer to data in spark sql use column name	C_161_4	+ _ + _ + _ + col0 col1 col2 + _ + _ + _ + codint codint col3 col4 + _ + _ + _ +	0
Q_161	how to refer to data in spark sql use column name	C_161_5	col0 schema = structtype ( array ( structfield ( refre , col1 , true ) , structfield ( refre , col1 , true ) , structfield ( refre , col2 , true ) ) )	0
Q_161	how to refer to data in spark sql use column name	C_161_6	col0 col1 = tab0 . tab1 . format ( refre ) . option ( refre , refre ) . schema ( schema ) . option ( refre , true ) . option ( refre , true ) . load ( refre )	0
Q_161	how to refer to data in spark sql use column name	C_161_7	col0 col1 = tab0 . textfile ( refre ) col0 col2 = tab1 . map ( line = > tab2 . split ( refre ) . map ( tab3 . trim ) ) . map ( col3 = > tab4 . fromseq ( seq ( elem ( codint ) . col4 , elem ( codint ) . col4 , elem ( codint ) ) ) ) tab5 . createdataframe ( col2 , schema ) . show ( false )	0
Q_162	divide between two row of the same column and store the answer in a already exist column	C_162_0	col0 col1 _ codint col2 codint codint col3 codint codint col4 codint codint col5 codint	1
Q_162	divide between two row of the same column and store the answer in a already exist column	C_162_1	public class col0 { public decimal col1 { get set } public decimal col2 { get set } public int col3 { get set } }	0
Q_162	divide between two row of the same column and store the answer in a already exist column	C_162_2	col0 col1 , double col2 , double , double col3	0
Q_162	divide between two row of the same column and store the answer in a already exist column	C_162_3	col0 col1 = from col2 in tab0 . col3 where tab1 . col4 = = col4 tab1 . col5 = = col5 tab1 . col6 = col6 select col2	0
Q_162	divide between two row of the same column and store the answer in a already exist column	C_162_4	public static col0 calculatepercentagesforid ( int col1 ) { col2 col3 rows = tab0 . tab1 . where ( col4 = > tab2 . col1 = = col1 ) . toarray ( ) / / . ( col5 col6 next col7 block ) }	0
Q_162	divide between two row of the same column and store the answer in a already exist column	C_162_5	col0 col1 rows = tab0 . tab1 . where ( col2 = > tab2 . col3 = = col3 ) . orderby ( col2 = > tab2 . col4 ) . toarray ( )	0
Q_162	divide between two row of the same column and store the answer in a already exist column	C_162_6	/ / col0 first col1 is col2 col0 refre col3 , col4 col2 codint . rows tab0 . col5 = codint for ( int col6 = codint col6 < tab1 . length col6 + + ) { col7 col8 = rows col9 col7 current = rows col10 tab2 . col5 = calculatedifferenceinpercentage ( tab3 . col3 , tab2 . col3 ) } / / col11 col12 all col0 col13 in refre col14 to col0 database	0
Q_162	divide between two row of the same column and store the answer in a already exist column	C_162_7	public static decimal calculatedifferenceinpercentage ( decimal col0 , decimal col1 ) { / / codint . col2 col3 col4 / / col2 col5 are col6 output when col0 = number , col1 = number col7 col8 = col1 / col0 / / = tab0 . col7 col9 = tab1 . round ( col8 , codint ) / / = number col7 col10 = col9 _ codint / / = number return col10 }	0
Q_162	divide between two row of the same column and store the answer in a already exist column	C_162_8	public static decimal calculatedifferenceinpercentage ( decimal col0 , decimal col1 ) { return tab0 . round ( col1 / col0 , codint ) _ codint }	0
Q_163	postgre_sql how to combine regex_split_to_array and foreach loop	C_163_0	create col0 tablename ( col1 integer primary key , col2 col3 ) create col0 lookup ( col4 varchar ( codint ) , col5 col3 ) insert into col6 values ( codint , refre refre refre ) , ( codint , refre refre ) , ( codint , refre refre ) insert into col7 values ( refre , refre ) , ( refre , refre ) , ( refre , refre ) , ( refre , refre ) , ( refre , refre )	1
Q_163	postgre_sql how to combine regex_split_to_array and foreach loop	C_163_1	select tab0 . col0 , trim ( unnest ( string_to_array ( tab0 . col1 , refre refre ) ) ) as col2 from col3 col4	0
Q_163	postgre_sql how to combine regex_split_to_array and foreach loop	C_163_2	col0 col1 _ + _ codint col2 codint col3 codint col4 codint col3 codint col5 codint col5 codint col6	0
Q_163	postgre_sql how to combine regex_split_to_array and foreach loop	C_163_3	with col0 as ( select tab0 . col1 , trim ( unnest ( string_to_array ( tab0 . col2 , refre refre ) ) ) as col3 from col4 col5 ) select tab1 . col1 , tab1 . col3 , tab2 . col6 from col0 col7 join col8 col9 on tab2 . col3 = tab1 . col3	0
Q_163	postgre_sql how to combine regex_split_to_array and foreach loop	C_163_4	col0 col1 col2 _ + _ + _ codint col3 at codint col4 col5 codint col6 col7 codint col3 at codint col8 col9 codint col8 col9 codint col10 col11	0
Q_163	postgre_sql how to combine regex_split_to_array and foreach loop	C_163_5	with col0 as ( select tab0 . col1 , trim ( unnest ( string_to_array ( tab0 . col2 , refre refre ) ) ) as col3 from col4 col5 ) select tab1 . col1 , string_agg ( tab2 . col6 , refre refre ) as col7 from col0 col8 join col9 col10 on tab2 . col3 = tab1 . col3 group by tab1 . col1	0
Q_163	postgre_sql how to combine regex_split_to_array and foreach loop	C_163_6	with col0 as ( select tab0 . col1 , trim ( unnest ( string_to_array ( tab0 . col2 , refre refre ) ) ) as col3 from col4 col5 ) , col6 as ( select tab1 . col1 , string_agg ( tab2 . col7 , refre refre ) as col8 from col0 col9 join col10 col11 on tab2 . col3 = tab1 . col3 group by tab1 . col1 ) update col4 col12 set col2 = tab3 . col8 from col6 col13 where tab3 . col1 = tab4 . col1	0
Q_163	postgre_sql how to combine regex_split_to_array and foreach loop	C_163_7	col0 col1 _ + _ codint col2 , at , col3 codint col4 , at codint col4 , col5	0
Q_164	postgre_sql _ create database from a template database	C_164_0	col0 = create database col1 create database time number col2 col0 = col3 col1 col4 are now col5 to database refre as col6 refre .	1
Q_164	postgre_sql _ create database from a template database	C_164_1	col0 = create col1 b ( col2 int ) create col1 time number col3 col0 = insert into col4 select codint insert codint codint time number col3	0
Q_164	postgre_sql _ create database from a template database	C_164_2	col0 = create function a ( ) returns int as select codint language sql create function time number col1	0
Q_164	postgre_sql _ create database from a template database	C_164_3	col0 = create col1 col2 create col1 time number col3	0
Q_164	postgre_sql _ create database from a template database	C_164_4	col0 = create database col1 template col0 create database time number col2 col0 = col3 col1 col4 are now col5 to database refre as col6 refre .	0
Q_164	postgre_sql _ create database from a template database	C_164_5	col0 = select count ( codint ) from col1 count _ codint ( codint row ) time number col2	0
Q_164	postgre_sql _ create database from a template database	C_164_6	col0 = select count ( codint ) from col1 count _ codint ( codint row ) time number col2	0
Q_164	postgre_sql _ create database from a template database	C_164_7	col0 = select a ( ) col1 _ codint ( codint row ) time number col2	0
Q_165	how can i make a condition for left join	C_165_0	col0 col1 col2 _ _ _ codint col3 codint codint col4 codint codint col5 codint	1
Q_165	how can i make a condition for left join	C_165_1	col0 type _ _ codint col1 codint col2 codint col3	0
Q_165	how can i make a condition for left join	C_165_2	select tab0 . col0 , tab0 . col1 , tab1 . type as col2 from col3 left join tab0 . col4 = tab1 . col0	0
Q_165	how can i make a condition for left join	C_165_3	col0 col1 col2 _ _ _ codint col3 col4 codint col5 col4 codint col6 col7	0
Q_165	how can i make a condition for left join	C_165_4	col0 col1 col2 _ _ _ codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_165	how can i make a condition for left join	C_165_5	col0 comment _ _ codint codint col1 codint col2 codint col3 col4 codint codint col5 codint col6	0
Q_165	how can i make a condition for left join	C_165_6	select tab0 . col0 , tab0 . col1 , tab1 . type as col2 , trim ( group_concat ( refre , tab2 . comment ) ) as col3 from col4 left join col5 on tab0 . col6 = tab1 . col0 left join col7 on tab0 . col0 = col8 left join col3 on tab3 . col9 = tab2 . col0 group by tab0 . col0	0
Q_165	how can i make a condition for left join	C_165_7	select tab0 . col0 , tab0 . col1 , tab1 . type as col2 , trim ( group_concat ( refre , tab2 . comment ) ) as col3 from col4 col5 left join col6 col7 on tab0 . col8 = tab1 . col0 left join col9 col10 on tab0 . col0 = tab3 . col11 left join col3 col12 on tab3 . col13 = tab2 . col0 group by tab0 . col0	0
Q_165	how can i make a condition for left join	C_165_8	col0 col1 col2 col3 _ _ _ _ codint col4 col5 col6 , col7 , codint col8 codint col9 col5 col6 , col7 , codint col10 codint col11 col12 col13 col14	0
Q_166	my_sql operator in only this value	C_166_0	select col0 from col1 where col0 = any ( select col0 from col2 ) select col0 from col1 where col0 in ( select col0 from col2 )	1
Q_166	my_sql operator in only this value	C_166_1	create col0 if not exists topic ( col1 int ( codint ) unsigned not null auto_increment , col2 date , col3 varchar ( codint ) , col4 col5 , primary key ( col1 ) ) engine = col6 default charset = col7 auto_increment = codint create col0 if not exists topic_keywords ( col8 int ( codint ) unsigned not null , col9 varchar ( codint ) , foreign key ( col8 ) references topic ( col1 ) , unique index1 ( col8 , col9 ) ) engine = col6	0
Q_166	my_sql operator in only this value	C_166_2	create col0 if not exists topic ( col1 int ( codint ) unsigned not null auto_increment , col2 date , col3 varchar ( codint ) , col4 col5 , col6 varchar ( codint ) , primary key ( col1 ) , fulltext ( col6 ) ) engine = col7 default charset = col8 auto_increment = codint	0
Q_166	my_sql operator in only this value	C_166_3	insert into topic ( col0 ) values ( refre refre ) , ( refre ) , ( refre refre ) , ( refre ) , ( refre refre ) , ( refre refre refre refre )	0
Q_166	my_sql operator in only this value	C_166_4	select col0 from col1 where match ( col0 ) against ( refre regplu refre regplu refre in boolean mode ) + _ + col0 + _ + col2 , col3 col2 , col3 , sql , col4 + _ + codint rows in set ( number col5 )	0
Q_166	my_sql operator in only this value	C_166_5	create col0 if not exists topic ( col1 int ( codint ) unsigned not null auto_increment , col2 date , col3 varchar ( codint ) , col4 col5 , col6 varchar ( codint ) , col7 varchar ( codint ) , primary key ( col1 ) , fulltext ( col6 ) ) engine = col8 default charset = col9 auto_increment = codint	0
Q_166	my_sql operator in only this value	C_166_6	insert into topic ( col0 , col1 ) values ( refre refre , md5 ( refre refre ) )	0
Q_166	my_sql operator in only this value	C_166_7	select col0 from col1 where col2 = md5 ( refre refre )	0
Q_167	store detail data in sql server	C_167_0	create col0 tab0 . client ( col1 int identity ( codint , codint ) , col2 varchar ( codint ) , _ col3 col4 col5 split col6 into col7 , col8 and col9 , col10 refre col11 refre refre refre col12 col13 col14 col15 tab1 . col16 date , col17 varchar ( codint ) ) go	1
Q_167	store detail data in sql server	C_167_1	create col0 tab0 . country ( col1 int identity ( codint , codint ) , col2 varchar ( codint ) , col3 char ( codint ) ) _ for col4 col5 for col6 col7 , col8 for col9 , col10 go	0
Q_167	store detail data in sql server	C_167_2	"create col0 tab0 . content ( col1 int identity ( codint , codint ) , col2 int , _ col3 col4 col5 col6 , col7 col8 , col9 , col10 col11 col12 col13 no col14 to col5 col15 ) col16 int , _ col9 are col17 to col18 content ( col19 like col20 on col21 ) col11 col12 refre col22 col23 col24 nvarchar ( max ) ) _ col25 col12 col13 no col14 col26 "" col22 col27 in col28 _ col29 simple col24 type col0 create col0 tab0 . contenttype ( col30 int identity ( codint , codint ) , col31 varchar ( codint ) ) go"	0
Q_167	store detail data in sql server	C_167_3	create col0 tab0 . vote ( col1 int identity ( codint , codint ) , col2 int , col3 int , col4 bit ) _ codint for col4 , codint for col5 , null for col6 / col7 col8 col9 go	0
Q_167	store detail data in sql server	C_167_4	insert into tab0 . country ( col0 , col1 ) values ( refre , refre ) , ( refre , refre ) , ( refre , refre ) go insert into tab0 . client ( col2 , col3 , col4 , col5 ) values ( refre , codint , refre , refre ) , ( refre , codint , refre , refre ) go insert into tab0 . contenttype ( col6 ) values ( refre ) , ( refre ) , ( refre ) go insert into tab0 . content ( col7 , col8 , col9 ) values ( codint , null , refre refre ) , ( codint , codint , refre refre ) , ( codint , null , refre refre refre ) go _ and now some col10 insert into tab0 . vote ( col11 , col12 , col13 ) values ( codint , codint , codint ) , ( codint , codint , codint ) , ( codint , codint , codint ) , ( codint , codint , codint ) go	0
Q_167	store detail data in sql server	C_167_5	select tab0 . col0 , tab1 . col1 , count ( case tab2 . col2 when codint then codint end ) as col3 , count ( case tab2 . col2 when codint then codint end ) as col4 from tab3 . col5 col6 join tab3 . col7 col8 on tab0 . col0 = tab2 . col0 join tab3 . col9 col10 on tab2 . col11 = tab4 . col11 join tab3 . col12 col13 on tab4 . col14 = tab1 . col15 group by tab0 . col0 , tab1 . col1	0
Q_167	store detail data in sql server	C_167_6	drop col0 tab0 . col1 drop col0 tab0 . col2 drop col0 tab0 . col3 drop col0 tab0 . col4 drop col0 tab0 . col5 go	0
Q_168	postgresql how to get value from array of jsonb	C_168_0	col0 = values ( codint , refre ) , ( codint , refre ) col1 col2 _ + _ codint col3 codint bbb ( codint rows )	1
Q_168	postgresql how to get value from array of jsonb	C_168_1	col0 = values ( ( codint , refre ) , ( codint , refre ) ) col1 col2 _ + _ ( codint , col3 ) ( codint , col4 ) ( codint row )	0
Q_168	postgresql how to get value from array of jsonb	C_168_2	with responses ( col0 , col1 ) as ( values ( codint , refre refre col0 refre codint refre refre alias refre col2 refre refre col3 refre col4 refre refre col5 refre codint refre refre col6 refre col7 refre refre col8 refre refre col0 refre codint refre refre alias refre col9 refre refre col3 refre col4 refre refre col5 refre col10 refre refre col6 refre col4 refre refre col8 refre refre json ) , ( codint , refre refre col0 refre codint refre refre alias refre col2 refre refre col3 refre col4 refre refre col5 refre _ codint refre refre col6 refre col7 refre refre col8 refre refre col0 refre codint refre refre alias refre col9 refre refre col3 refre col4 refre refre col5 refre no refre refre col6 refre col4 refre refre col8 refre refre json ) ) select * from col11	0
Q_168	postgresql how to get value from array of jsonb	C_168_3	with responses ( col0 , col1 ) as ( values . ) select col0 , json_array_elements ( col1 ) from col2	0
Q_168	postgresql how to get value from array of jsonb	C_168_4	. ) , extra ( col0 , col1 ) as ( select col0 , json_array_elements ( col2 ) from col3 ) .	0
Q_168	postgresql how to get value from array of jsonb	C_168_5	. select col0 , col1 _ refre as col2 , col1 _ refre as alias , col1 _ refre as col3 , col1 _ refre as col4 from col5	0
Q_168	postgresql how to get value from array of jsonb	C_168_6	with responses ( col0 , col1 ) as ( values ( codint , refre refre col0 refre codint refre refre alias refre col2 refre refre col3 refre col4 refre refre col5 refre codint refre refre col6 refre col7 refre refre col8 refre refre col0 refre codint refre refre alias refre col9 refre refre col3 refre col4 refre refre col5 refre col10 refre refre col6 refre col4 refre refre col8 refre refre json ) , ( codint , refre refre col0 refre codint refre refre alias refre col2 refre refre col3 refre col4 refre refre col5 refre _ codint refre refre col6 refre col7 refre refre col8 refre refre col0 refre codint refre refre alias refre col9 refre refre col3 refre col4 refre refre col5 refre no refre refre col6 refre col4 refre refre col8 refre refre json ) ) , extra ( col0 , col11 ) as ( select col0 , json_array_elements ( col1 ) from col12 ) select col0 as col13 , col11 _ refre as col14 , col11 _ refre as alias , col11 _ refre as col6 , col11 _ refre as col5 from col15	0
Q_168	postgresql how to get value from array of jsonb	C_168_7	col0 col1 alias col2 col3 _ + _ + _ + _ + _ codint codint col4 col5 codint codint codint col6 col7 col8 codint codint col4 col5 _ codint codint codint col6 col7 no ( codint rows )	0
Q_169	how to query the value that have change _ tagint of the value from first encounter of each patient in sql server	C_169_0	select col0 , min ( col1 ) as col2 , max ( col1 ) as col3 from col4 group by col0 having min ( col1 ) < > max ( col1 )	1
Q_169	how to query the value that have change _ tagint of the value from first encounter of each patient in sql server	C_169_1	select tab0 . col0 , tab0 . col1 , tab0 . col2 , tab1 . col3 as col4 , tab2 . col3 as col5 , tab1 . col3 _ tab2 . col3 as col6 from ( select col0 , min ( col7 ) as col1 , max ( col7 ) as col8 from col9 group by col0 having min ( col7 ) < > max ( col7 ) col10 inner join col9 col11 on tab1 . col0 = tab0 . col0 and tab1 . col12 = tab0 . col1 inner join col9 col13 on tab2 . col0 = tab0 . col0 and tab2 . col12 = tab0 . col8 where tab1 . col3 _ tab2 . col3 > = codint or tab1 . col3 _ tab2 . col3 < = _ codint	0
Q_169	how to query the value that have change _ tagint of the value from first encounter of each patient in sql server	C_169_2	select col0 , min ( col1 ) as col2 from col3 group by col0	0
Q_169	how to query the value that have change _ tagint of the value from first encounter of each patient in sql server	C_169_3	select tab0 . col0 , col1 , tab1 . col2 from ( select col0 , min ( col3 ) as col1 from col4 group by col0 ) col5 inner join col4 col6 on tab0 . col1 = tab2 . col3 and tab0 . col0 = tab2 . col0	0
Q_169	how to query the value that have change _ tagint of the value from first encounter of each patient in sql server	C_169_4	select tab0 . col0 , tab0 . col1 , tab1 . col2 , tab0 . col3 , tab1 . col3 , tab0 . col3 _ tab1 . col3 as col4 from ( select tab0 . col0 , col1 , tab1 . col3 from ( select col0 , min ( col5 ) as col1 from col6 group by col0 ) col7 inner join col6 col8 on tab0 . col1 = tab1 . col5 and tab0 . col0 = tab1 . col0 ) col7 inner join col6 col8 on tab0 . col0 = tab1 . col0 where tab0 . col3 _ tab1 . col3 > = codint or tab0 . col3 _ tab1 . col3 < = _ codint	0
Q_169	how to query the value that have change _ tagint of the value from first encounter of each patient in sql server	C_169_5	select col0 , min ( col1 ) from ( col2 ) col3	0
Q_169	how to query the value that have change _ tagint of the value from first encounter of each patient in sql server	C_169_6	select tab0 . col0 , tab1 . col1 , tab1 . col2 from ( select col0 , min ( col1 ) as col3 from ( col4 ) col5 ) col5 inner join col6 col7 on tab0 . col0 = tab1 . col0 and tab0 . col3 < = tab1 . col1	0
Q_169	how to query the value that have change _ tagint of the value from first encounter of each patient in sql server	C_169_7	select tab0 . col0 , tab1 . col1 , tab1 . col2 , tab2 . col2 as col3 , tab2 . col2 _ tab1 . col2 as col4 from ( select col0 , min ( col1 ) as col5 from ( select tab0 . col0 , tab0 . col6 , tab1 . col7 , tab0 . col2 , tab1 . col2 , tab0 . col2 _ tab1 . col2 as col4 from ( select tab0 . col0 , col6 , tab1 . col2 from ( select col0 , min ( col1 ) as col6 from col8 group by col0 ) col9 inner join col8 col10 on tab0 . col6 = tab1 . col1 and tab0 . col0 = tab1 . col0 ) col9 inner join col8 col10 on tab0 . col0 = tab1 . col0 where tab0 . col2 _ tab1 . col2 > = codint or tab0 . col2 _ tab1 . col2 < = _ codint ) col9 ) col9 inner join col8 col10 on tab0 . col0 = tab1 . col0 and tab0 . col5 < = tab1 . col1 inner join ( select tab0 . col0 , col6 , tab3 . col2 from ( select col0 , min ( col1 ) as col6 from col8 group by col0 ) col9 inner join col8 col10 on tab0 . col6 = tab1 . col1 and tab0 . col0 = tab1 . col0 ) col11 on tab2 . col0 = tab0 . col0	0
Q_170	sql join two table and duplicate row appear	C_170_0	col0 col1 col2 col3 col4 col5 col6 col7 _ + _ + _ _ + _ + _ codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	1
Q_170	sql join two table and duplicate row appear	C_170_1	select * from col0 inner join col1 on tab0 . col2 = tab1 . col3 and tab0 . col4 = tab1 . col5	0
Q_170	sql join two table and duplicate row appear	C_170_2	select * from col0 inner join col1 on tab0 . col2 = tab1 . col3	0
Q_170	sql join two table and duplicate row appear	C_170_3	col0 col1 col2 col3 col4 col5 _ + _ + _ + _ + _ + _ codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_170	sql join two table and duplicate row appear	C_170_4	select tab0 . col0 , tab0 . col1 , tab0 . col2 from col3 inner join col4 on tab0 . col0 = tab1 . col5	0
Q_170	sql join two table and duplicate row appear	C_170_5	col0 col1 col2 _ + _ + _ codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_170	sql join two table and duplicate row appear	C_170_6	col0 col1 month col2 month col3 col4 _ + _ _ + _ + _ codint refre codint codint codint codint refre codint codint codint codint refre codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_170	sql join two table and duplicate row appear	C_170_7	select * from col0 inner join ( select month , sum ( col1 ) as col1 from col2 group by month ) as col3 on tab0 . month = tab1 . month	0
Q_171	sql roll window unique count	C_171_0	col0 with tab0 . tab1 . col1 as ( select time refre col2 , codint col3 union all select time refre , codint union all select time refre , codint union all select time refre , codint union all select time refre , codint union all select time refre , codint union all select time refre , codint ) select col2 , col3 , ( select count ( distinct col4 ) from unnest ( col5 ) col4 ) col6 from ( select col2 , col3 , array_agg ( col3 ) over ( order by time_diff ( col2 , time refre , second ) range between codint col7 and current row ) col5 from tab0 . tab1 . col1 ) _ order by col2	1
Q_171	sql roll window unique count	C_171_1	row col0 col1 col2 codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_171	sql roll window unique count	C_171_2	order by time_diff ( col0 , time refre , second )	0
Q_171	sql roll window unique count	C_171_3	order by timestamp_diff ( col0 , timestamp refre , second )	0
Q_171	sql roll window unique count	C_171_4	col0 with tab0 . tab1 . col1 as ( select timestamp refre col2 , codint col3 union all select timestamp refre , codint union all select timestamp refre , codint union all select timestamp refre , codint union all select timestamp refre , codint union all select timestamp refre , codint union all select timestamp refre , codint ) select col2 , col3 , ( select count ( distinct col4 ) from unnest ( col5 ) col4 ) col6 from ( select col2 , col3 , array_agg ( col3 ) over ( order by timestamp_diff ( col2 , timestamp refre , second ) range between codint col7 and current row ) col5 from tab0 . tab1 . col1 ) _ order by col2	0
Q_171	sql roll window unique count	C_171_5	row col0 col1 col2 codint codint _ codint _ codint codint codint number col3 codint codint codint codint _ codint _ codint codint codint number col3 codint codint codint codint _ codint _ codint codint codint number col3 codint codint codint codint _ codint _ codint codint codint number col3 codint codint codint codint _ codint _ codint codint codint number col3 codint codint codint codint _ codint _ codint codint codint number col3 codint codint codint codint _ codint _ codint codint codint number col3 codint codint	0
Q_171	sql roll window unique count	C_171_6	col0 with tab0 . tab1 . col1 as ( select time refre col2 , codint col3 union all select time refre , codint union all select time refre , codint union all select time refre , codint union all select time refre , codint union all select time refre , codint union all select time refre , codint union all select time refre , codint ) select col2 , col3 , ( select count ( distinct col4 ) from unnest ( col5 ) col4 ) col6 from ( select col2 , col3 , array_agg ( col3 ) over ( order by time_diff ( col2 , time refre , col7 ) + codint * rand ( ) range between codint col8 and current row ) col5 from tab0 . tab1 . col1 ) _ order by col2	0
Q_171	sql roll window unique count	C_171_7	row col0 col1 col2 codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_171	sql roll window unique count	C_171_8	col0 with tab0 . tab1 . col1 as ( select time refre col2 , codint col3 union all select time refre , codint union all select time refre , codint union all select time refre , codint union all select time refre , codint union all select time refre , codint union all select time refre , codint union all select time refre , codint ) select col2 , col3 , ( select count ( distinct col4 ) from unnest ( col5 ) col4 ) col6 from ( select col2 , col3 , array_agg ( col3 ) over ( order by col7 range between codint col8 and current row ) col5 from ( select col2 , col3 , time_diff ( col2 , time refre , col9 ) + codint * rand ( ) col7 from tab0 . tab1 . col1 ) ) _ order by col2	0
Q_172	group sql result from a union	C_172_0	col0 col1 _ codint codint codint codint codint codint codint codint	1
Q_172	group sql result from a union	C_172_1	select col0 = coalesce ( tab0 . col0 , tab1 . col0 ) , col1 = coalesce ( tab0 . col1 , codint ) , col2 = coalesce ( tab1 . col2 , codint ) from ( select col0 , count ( * ) as col1 from col3 where col4 is not null and col5 is not null group by col0 ) as col6 full join ( select col0 , count ( * ) as col2 from col3 where col4 is null and col5 is null group by col0 ) as col7 on tab0 . col0 = tab1 . col0	0
Q_172	group sql result from a union	C_172_2	select col0 = coalesce ( tab0 . col0 , tab1 . col0 ) , col1 = coalesce ( tab0 . col1 , codint ) , col2 = coalesce ( tab1 . col2 , codint ) , col3 = codint * coalesce ( tab0 . col1 , codint ) / ( coalesce ( tab0 . col1 , codint ) + coalesce ( tab1 . col2 , codint ) ) , col4 = codint * coalesce ( tab1 . col2 , codint ) / ( coalesce ( tab0 . col1 , codint ) + coalesce ( tab1 . col2 , codint ) ) from ( select col0 , count ( * ) as col1 from col5 where col6 is not null and col7 is not null group by col0 ) as col8 full join ( select col0 , count ( * ) as col2 from col5 where col6 is null and col7 is null group by col0 ) as col9 on tab0 . col0 = tab1 . col0 order by col3	0
Q_172	group sql result from a union	C_172_3	select col0 , col1 , col2 , col3 = codint * col1 / ( col1 + col2 ) , col4 = codint * col2 / ( col1 + col2 ) from ( select col0 = coalesce ( tab0 . col0 , tab1 . col0 ) , col1 = coalesce ( tab0 . col1 , codint ) , col2 = coalesce ( tab1 . col2 , codint ) from ( select col0 , count ( * ) as col1 from col5 where col6 is not null and col7 is not null group by col0 ) as col8 full join ( select col0 , count ( * ) as col2 from col5 where col6 is null and col7 is null group by col0 ) as col9 on tab0 . col0 = tab1 . col0 ) as col10 order by col3	0
Q_172	group sql result from a union	C_172_4	with col0 as ( select col1 = coalesce ( tab0 . col1 , tab1 . col1 ) , col2 = coalesce ( tab0 . col2 , codint ) , col3 = coalesce ( tab1 . col3 , codint ) from ( select col1 , count ( * ) as col2 from col4 where col5 is not null and col6 is not null group by col1 ) as col7 full join ( select col1 , count ( * ) as col3 from col4 where col5 is null and col6 is null group by col1 ) as col8 on tab0 . col1 = tab1 . col1 ) select col1 , col2 , col3 , col9 = codint * col2 / ( col2 + col3 ) , col10 = codint * col3 / ( col2 + col3 ) from col0 order by col9	0
Q_172	group sql result from a union	C_172_5	with col0 as ( select col1 , count ( * ) as col2 from col3 where col4 is not null and col5 is not null group by col1 ) , col6 as ( select col1 , count ( * ) as col7 from col3 where col4 is null and col5 is null group by col1 ) , col8 as ( select col1 = coalesce ( tab0 . col1 , tab1 . col1 ) , col2 = coalesce ( tab0 . col2 , codint ) , col7 = coalesce ( tab1 . col7 , codint ) from col0 full join col6 on tab0 . col1 = tab1 . col1 ) select col1 , col2 , col7 , col9 = codint * col2 / ( col2 + col7 ) , col10 = codint * col7 / ( col2 + col7 ) from col8 order by col9	0
Q_172	group sql result from a union	C_172_6	with col0 as ( select col1 , col2 = sum ( case when col3 is not null and col4 is not null then codint else codint end ) , col5 = sum ( case when col3 is null and col4 is null then codint else codint end ) from col6 group by col1 ) select col1 , col2 , col5 , col7 = codint * col2 / ( col2 + col5 ) , col8 = codint * col5 / ( col2 + col5 ) from col0 order by col7	0
Q_173	for xml path how to keep attribute and value in the same node	C_173_0	select codint as col0 , codint as col0 for xml path ( refre ) , root ( refre )	1
Q_173	for xml path how to keep attribute and value in the same node	C_173_1	select codint as col0 , refre as col1 , codint as col0 for xml path ( refre ) , root ( refre )	0
Q_173	for xml path how to keep attribute and value in the same node	C_173_2	select codint as col0 , refre , codint as col0 for xml path ( refre ) , root ( refre )	0
Q_173	for xml path how to keep attribute and value in the same node	C_173_3	select refre as col0 , codint as col1 , codint as col1 for xml path ( refre ) , root ( refre )	0
Q_173	for xml path how to keep attribute and value in the same node	C_173_4	select refre as col0 , codint as col1 , refre , refre as col0 , codint as col1 for xml path ( refre ) , root ( refre )	0
Q_173	for xml path how to keep attribute and value in the same node	C_173_5	select codint as col0 , refre as col1 , refre as col2 for xml path ( refre ) , root ( refre )	0
Q_173	for xml path how to keep attribute and value in the same node	C_173_6	select codint as col0 , null , refre as col1 for xml path ( refre ) , root ( refre )	0
Q_174	sql select all of tagint column multiply by another column from table tagint and insert in table tagint	C_174_0	"col0 "" col1 not col2 col3 col4 _ col5 no col6 col7"	1
Q_174	sql select all of tagint column multiply by another column from table tagint and insert in table tagint	C_174_1	col0 col1 col2 col3 with col4 col5 col6 col7 col8	0
Q_174	sql select all of tagint column multiply by another column from table tagint and insert in table tagint	C_174_2	col0 col1 to col2 col3 values in col3 refre col4 and insert col5 into col3 refre col4	0
Q_174	sql select all of tagint column multiply by another column from table tagint and insert in table tagint	C_174_3	after col0 insert , col1 col2 to update col0 refre col3 with col0 values from refre col3	0
Q_174	sql select all of tagint column multiply by another column from table tagint and insert in table tagint	C_174_4	col0 > select * from col1 + _ + _ + _ + _ + col2 col3 col4 col5 + _ + _ + _ + _ + codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint + _ + _ + _ + _ +	0
Q_174	sql select all of tagint column multiply by another column from table tagint and insert in table tagint	C_174_5	col0 > desc col1 + _ + _ + _ + _ + _ + _ + col2 type null key default col3 + _ + _ + _ + _ + _ + _ + col4 int ( codint ) col5 null col6 int ( codint ) col5 null col7 double col5 null col8 double col5 null col9 double col5 null + _ + _ + _ + _ + _ + _ + codint rows in set ( number col10 )	0
Q_174	sql select all of tagint column multiply by another column from table tagint and insert in table tagint	C_174_6	col0 > select col1 , col2 , ( col3 / codint ) as col4 , ( ( col3 / codint ) * col5 ) as col6 , ( ( ( col3 / codint ) * col5 ) _ ( col3 / codint ) ) as col7 from col8 where col3 > codint + _ + _ + _ + _ + _ + col1 col2 col4 col6 col7 + _ + _ + _ + _ + _ + codint codint number number number codint codint number number number codint codint number number number + _ + _ + _ + _ + _ + codint rows in set ( number col9 )	0
Q_174	sql select all of tagint column multiply by another column from table tagint and insert in table tagint	C_174_7	insert into col0 select col1 , col2 , ( col3 / codint ) , ( ( col3 / codint ) * col4 ) , ( ( ( col3 / codint ) * col4 ) _ ( col3 / codint ) ) from col5 where col3 > codint col6 col7 , codint rows affected ( number col8 ) col9 codint col10 codint col11 codint	0
Q_174	sql select all of tagint column multiply by another column from table tagint and insert in table tagint	C_174_8	col0 > select * from col1 + _ + _ + _ + _ + _ + col2 col3 col4 col5 col6 + _ + _ + _ + _ + _ + codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint + _ + _ + _ + _ + _ + codint rows in set ( number col7 )	0
Q_174	sql select all of tagint column multiply by another column from table tagint and insert in table tagint	C_174_9	col0 > update col1 join col2 using ( col3 ) set col4 = col5 col6 col7 , codint rows affected ( number col8 ) rows col9 codint col10 codint col11 codint col0 > select * from col1 + _ + _ + _ + _ + col12 col3 col4 col13 + _ + _ + _ + _ + codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint + _ + _ + _ + _ + codint rows in set ( number col8 )	0
Q_175	what be the best way to design a tag_based data table with sqlite	C_175_0	drop col0 if exists col1 create col0 if not exists object_table ( col2 integer primary key , col3 ) drop col0 if exists col4 create col0 if not exists tag_table ( col2 integer primary key , col5 )	1
Q_175	what be the best way to design a tag_based data table with sqlite	C_175_1	insert into object_table ( col0 ) values ( refre ) , ( refre ) , ( refre ) , ( refre ) insert into tag_table ( col1 ) values ( refre ) , ( refre ) , ( refre ) , ( refre ) , ( refre ) , ( refre ) , ( refre ) , ( refre ) , ( refre ) , ( refre ) , ( refre ) _ and col2 on	0
Q_175	what be the best way to design a tag_based data table with sqlite	C_175_2	drop col0 if exists col1 create col0 if not exists object_tag_mapping ( col2 integer , col3 integer )	0
Q_175	what be the best way to design a tag_based data table with sqlite	C_175_3	insert into col0 values ( codint , codint ) , _ col1 col2 col3 pineapple ( codint , codint ) , _ col1 col2 apple ( codint , codint ) , _ col1 col2 paris ( codint , codint ) , _ col1 col2 green ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , _ some col4 for object codint ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , _ some col4 for object codint ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) _ all col4 for object codint	0
Q_175	what be the best way to design a tag_based data table with sqlite	C_175_4	select col0 , group_concat ( col1 , refre ) as col2 from col3 join col4 on col5 = tab0 . col6 join col7 on col8 = tab1 . col6 group by col0	0
Q_175	what be the best way to design a tag_based data table with sqlite	C_175_5	select col0 , col1 from col2 join col3 on col4 = tab0 . col5 join col6 on col7 = tab1 . col5 where col1 = refre or col7 = codint	0
Q_175	what be the best way to design a tag_based data table with sqlite	C_175_6	with cte1 ( col0 , col1 , col2 , col3 , col4 , col5 ) as ( select * from col6 join col7 on col8 = tab0 . col9 join col10 on col11 = tab1 . col9 where col12 = refre or col12 = refre ) select col5 , group_concat ( col3 ) , count ( ) as col13 from col14 group by col0 having col13 = codint	0
Q_176	postgresql how to take incremental backup with wal_e	C_176_0	col0 _ get col1 col2 _ col3 col2 _ col4 col5 _ col3 col6 col7 col8 col9 col0 _ get col1 _ col10 col11 _ col12 col9 col0 _ get col1 col13 _ col14 col15 _ col3 col16 _ col3 col9 col0 _ get col1 _ col10 col11 _ col17	1
Q_176	postgresql how to take incremental backup with wal_e	C_176_1	col0 col1 _ col2 col3 / col4 / col5 _ col6 source / col4 / col5 _ col6 / col7 / col8	0
Q_176	postgresql how to take incremental backup with wal_e	C_176_2	col0 / col1 / col2 _ col3 / col4 / col5 col6 col2 _ col3 col7	0
Q_176	postgresql how to take incremental backup with wal_e	C_176_3	"col0 col1 = col2 , col3 = col4 , col5 = col6 _ col7 / col8 / col9 _ tab0 . col10 / col11 col12 _ col13 _ col1 col14 col15 refre > / col8 / col9 _ tab0 . col10 / col11 / col16 col15 refre > / col8 / col9 _ tab0 . col10 / col11 / col17 col15 refre refre refre refre refre refre col18 / / some _ col19 / directory / or / col20 "" > / col8 / col9 _ tab0 . col10 / col11 / col21 col12 col22 _ col23 col14 col24 / col8 / col9 _ tab0 . col10"	0
Q_176	postgresql how to take incremental backup with wal_e	C_176_4	col0 col1 / col2 / col3 / codint / col4 / tab0 . col5 col6 = col7 col8 = on col9 = refre refre refre refre refre refre refre refre refre refre refre col10 = codint col0 col11 restart col3	0
Q_176	postgresql how to take incremental backup with wal_e	C_176_5	col0 _ col1 _ col2 col3 / col4 / col5 / col6 / col7 / col8 _ tab0 . col9 / col10 / col11 / col8 _ col12 / col5 / col8 _ col12 backup _ col13	0
Q_176	postgresql how to take incremental backup with wal_e	C_176_6	/ col0 / col1 / col2 / col3 / col4 _ tab0 . col5 / col6 / col7 / col4 _ col8 / col1 / col4 _ col8 backup _ col9 / col10 / col11 / col12 / codint / col13	0
Q_176	postgresql how to take incremental backup with wal_e	C_176_7	col0 _ col1 _ col2 col3 col4 col5 col6 tab0 . col7 col6 tab1 . col7 col8 _ col9 codint codint * * * / col10 / col11 / col12 / col13 / col14 _ tab2 . col15 / col16 / col17 / col14 _ col9 / col11 / col14 _ col9 backup _ col18 / col19 / col20 / col21 / codint / col22 > / col5 / tab0 . col7 codint > codint codint codint * * * / col10 / col11 / col12 / col13 / col14 _ tab2 . col15 / col16 / col17 / col14 _ col9 / col11 / col14 _ col9 delete _ col23 col24 codint > / col5 / tab1 . col7 codint > codint	0
Q_177	sql how to pivot row base on it value	C_177_0	col0 select col1 , max ( if ( key = refre , col2 , null ) ) col3 , max ( if ( key = refre , col2 , null ) ) col4 , max ( if ( key = refre , col2 , null ) ) col5 from tab0 . tab1 . col6 , unnest ( [ col7 < key col8 , col2 col8 > ( split ( col9 , refre ) col10 , split ( col9 , refre ) col11 ) ] ) group by col1	1
Q_177	sql how to pivot row base on it value	C_177_1	col0 with tab0 . tab1 . col1 as ( select codint col2 , refre col3 union all select codint , refre union all select codint , refre union all select codint , refre ) select col2 , max ( if ( key = refre , col4 , null ) ) col5 , max ( if ( key = refre , col4 , null ) ) col6 , max ( if ( key = refre , col4 , null ) ) col7 from tab0 . tab1 . col1 , unnest ( [ col8 < key col9 , col4 col9 > ( split ( col3 , refre ) col10 , split ( col3 , refre ) col11 ) ] ) group by col2 _ order by col2	0
Q_177	sql how to pivot row base on it value	C_177_2	row col0 col1 col2 col3 codint codint codint codint codint codint codint codint null null	0
Q_177	sql how to pivot row base on it value	C_177_3	col0 select concat ( refre refre , string_agg ( concat ( refre refre refre refre refre refre refre refre refre refre refre , key ) ) , refre refre refre refre refre refre refre refre refre refre = refre refre [ offset ( 0 ) ] refre refre refre refre = refre refre [ offset ( 1 ) ] refre refre refre refre ) from ( select split ( col1 , refre ) col2 key from tab0 . tab1 . col3 group by key )	0
Q_177	sql how to pivot row base on it value	C_177_4	col0 with tab0 . tab1 . col1 as ( select codint col2 , refre col3 union all select codint , refre union all select codint , refre union all select codint , refre ) select concat ( refre refre , string_agg ( concat ( refre refre refre refre refre refre refre refre refre refre refre , key ) ) , refre refre refre refre refre refre refre refre refre refre = refre refre [ offset ( 0 ) ] refre refre refre refre = refre refre [ offset ( 1 ) ] refre refre refre refre ) from ( select split ( col3 , refre ) col4 key from tab0 . tab1 . col1 group by key )	0
Q_177	sql how to pivot row base on it value	C_177_5	select col0 , max ( if ( key = refre , col1 , null ) ) as col2 , max ( if ( key = refre , col1 , null ) ) as col3 , max ( if ( key = refre , col1 , null ) ) as col4 from tab0 . tab1 . col5 , unnest ( [ col6 < key col7 , col1 col7 > ( split ( col8 , refre ) col9 , split ( col8 , refre ) col10 ) ] ) group by col0	0
Q_177	sql how to pivot row base on it value	C_177_6	col0 with tab0 . tab1 . col1 as ( select codint col2 , refre col3 union all select codint , refre union all select codint , refre union all select codint , refre ) select col2 , max ( if ( key = refre , col4 , null ) ) as col5 , max ( if ( key = refre , col4 , null ) ) as col6 , max ( if ( key = refre , col4 , null ) ) as col7 from tab0 . tab1 . col1 , unnest ( [ col8 < key col9 , col4 col9 > ( split ( col3 , refre ) col10 , split ( col3 , refre ) col11 ) ] ) group by col2	0
Q_177	sql how to pivot row base on it value	C_177_7	col0 with tab0 . tab1 . col1 as ( select codint col2 , refre col3 union all select codint , refre union all select codint , refre union all select codint , refre ) select col2 , split ( col3 , refre ) col4 key , split ( col3 , refre ) col5 col6 from tab0 . tab1 . col1	0
Q_177	sql how to pivot row base on it value	C_177_8	row col0 key col1 codint codint col2 codint codint codint col3 codint codint codint col4 codint codint codint col2 codint	0
Q_178	filter out data for sql android	C_178_0	"select replace ( replace ( col0 , refre refre , refre ) , refre refre refre "" ) from col1"	1
Q_178	filter out data for sql android	C_178_1	"drop col0 if exists col1 create col0 if not exists cpluspluscode ( col2 col3 ) insert into col1 values ( refre refre refre col4 col3 refre ) select * from col1 select replace ( replace ( col2 , refre refre , refre ) , refre refre refre "" ) as col5 from col1"	0
Q_178	filter out data for sql android	C_178_2	select replace ( replace ( col0 , char ( codint ) , refre ) , char ( codint ) , refre ) as col1 from col2	0
Q_178	filter out data for sql android	C_178_3	public static final col0 col1 = refre public static final col0 col2 = refre . col3 public col4 oncreate ( col5 col6 ) { col0 col7 = refre + col1 + refre refre + col2 + refre + refre refre tab0 . execsql ( col7 ) }	0
Q_178	filter out data for sql android	C_178_4	"public long cppinsert ( col0 col1 ) { col2 col3 = tab0 . getwritabledatabase ( ) col4 col5 = new contentvalues ( ) tab1 . put ( col6 , col1 ) return tab2 . insert ( col7 , null , col5 ) } public cursor getfiltered ( ) { col2 col3 = tab0 . getwritabledatabase ( ) col0 col8 col9 = new col0 col8 { refre refre refre + col6 + refre refre refre refre refre refre refre refre refre , refre ) as "" + col6 } return tab2 . query ( col7 , col9 , null , null , null , null , null ) } public cursor getunfiltered ( ) { col2 col3 = tab0 . getwritabledatabase ( ) return tab2 . query ( col7 , null , null , null , null , null , null ) }"	0
Q_178	filter out data for sql android	C_178_5	col0 col1 = new databasehelper ( col2 ) tab0 . cppinsert ( refre refre refre col3 data refre ) cursor col4 = tab0 . getunfiltered ( ) while ( tab1 . movetonext ( ) ) { tab2 . d ( refre , tab1 . getstring ( tab1 . getcolumnindex ( tab3 . col5 ) ) ) } tab1 . close ( ) cursor col6 = tab0 . getfiltered ( ) while ( tab4 . movetonext ( ) ) { tab2 . d ( refre , tab4 . getstring ( tab4 . getcolumnindex ( tab3 . col5 ) ) ) }	0
Q_178	filter out data for sql android	C_178_6	codint _ codint codint codint number codint _ codint / tab0 . col0 col1 / col2 refre col3 refre refre codint _ codint codint codint number codint _ codint / tab0 . col0 col1 / col4 col3 col5 data	0
Q_179	how to validate check if an image already exist in a data_base	C_179_0	col0 int col1 varbinary ( max ) col2 varchar ( codint )	1
Q_179	how to validate check if an image already exist in a data_base	C_179_1	public col0 calculatehash ( col0 col1 ) { col2 col3 = new sha1cryptoserviceprovider ( ) / / col4 col3 = new md5cryptoserviceprovider ( ) col0 col5 = tab0 . col6 using ( col7 col8 = new filestream ( col1 , tab1 . open , tab2 . read ) ) { col9 col10 col11 = tab3 . computehash ( col8 ) foreach ( col9 col12 in col11 ) col5 + = tab4 . tostring ( refre ) } return ( col5 ) }	0
Q_179	how to validate check if an image already exist in a data_base	C_179_2	call col0 with col1 col2 = calculatehash ( refre )	0
Q_179	how to validate check if an image already exist in a data_base	C_179_3	select count ( codint ) from col0 where col1 = col1	0
Q_179	how to validate check if an image already exist in a data_base	C_179_4	tab0 . tab1 . add ( refre , tab2 . varchar , codint ) tab0 . parameters tab3 . col0 = col1	0
Q_179	how to validate check if an image already exist in a data_base	C_179_5	"int result = ( int ) tab0 . executescalar ( ) if ( result = = codint ) { / / insert col0 col1 , col2 "" col3 col4 to insert col5 col6 into col5 col7 column or col8 col9 col10 col11 tab1 . }"	0
Q_179	how to validate check if an image already exist in a data_base	C_179_6	public col0 imageexists ( col1 col2 ) { col0 result = false using ( col3 connection = tab0 . getconnection ( ) ) { using ( col4 col5 = new sqlcommand ( refre refre refre , connection ) ) { tab1 . open ( ) int col6 = ( int ) tab2 . executescalar ( ) result = col6 = = codint tab1 . close ( ) } } return ( result ) }	0
Q_179	how to validate check if an image already exist in a data_base	C_179_7	using ( col0 select = new sqlcommand ( refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre , col1 ) )	0
Q_179	how to validate check if an image already exist in a data_base	C_179_8	col0 col1 = calculatehash ( col2 ) if ( imageexists ( col1 ) { tab0 . show ( refre ) return } / / col3 col4 of col5 col6 col7 col8 including col9 col10 parameter to col11 col3 tab1 .	0
Q_179	how to validate check if an image already exist in a data_base	C_179_9	col0 col1 = calculatehash ( tab0 . tab1 . tostring ( ) )	0
Q_179	how to validate check if an image already exist in a data_base	C_179_10	using ( col0 col1 = new openfiledialog ( ) ) { if ( tab0 . showdialog ( ) = = tab1 . col2 ) { tab2 . col3 = tab3 . fromfile ( tab0 . col4 ) tab2 . col5 = tab0 . col4 } }	0
Q_179	how to validate check if an image already exist in a data_base	C_179_11	using ( col0 col1 = new openfiledialog ( ) ) { if ( tab0 . showdialog ( ) = = tab1 . col2 ) { tab2 . col3 = tab3 . fromfile ( tab0 . col4 ) tab2 . col5 = calculatehash ( tab0 . col4 ) } }	0
Q_179	how to validate check if an image already exist in a data_base	C_179_12	if ( imageexists ( tab0 . tab1 . tostring ( ) ) ) { tab2 . show ( refre ) return }	0
Q_180	nest loop to retrieve a value from several table in oracle	C_180_0	create col0 player_01 ( col1 , col2 ) as select level , tab0 . string ( refre , codint ) from col3 connect by level < = codint create col0 player_02 ( col1 , col2 ) as select level , tab0 . string ( refre , codint ) from col3 connect by level < = codint create col0 player_03 ( col1 , col2 ) as select level , tab0 . string ( refre , codint ) from col3 connect by level < = codint	1
Q_180	nest loop to retrieve a value from several table in oracle	C_180_1	_ col0 all col1 tables and col2 col3 col4 col5 values declare col6 number = codint col7 varchar2 ( codint ) = refre col8 varchar2 ( codint ) = refre begin for col9 in ( select table_name from col10 where table_name like refre order by table_name ) loop _ tab0 . put_line ( refre refre tab1 . table_name ) col8 = refre refre refre tab1 . table_name execute immediate col8 into col6 tab0 . put_line ( refre col6 refre tab1 . table_name ) end loop end / _ result col11 col5 is codint for col12 col13 col11 col5 is codint for col12 col14 col11 col5 is codint for col12 col15	0
Q_180	nest loop to retrieve a value from several table in oracle	C_180_2	create col0 player_01 ( col1 , col2 , col3 ) as select level , tab0 . string ( refre , codint ) , abs ( tab0 . random ( ) ) from col4 connect by level < = codint create col0 player_02 ( col1 , col2 , col3 ) as select level , tab0 . string ( refre , codint ) , abs ( tab0 . random ( ) ) from col4 connect by level < = codint create col0 player_03 ( col1 , col2 , col3 ) as select level , tab0 . string ( refre , codint ) , abs ( tab0 . random ( ) ) from col4 connect by level < = codint	0
Q_180	nest loop to retrieve a value from several table in oracle	C_180_3	select * from col0 col1 col2 col3 codint col4 codint codint codint col5 codint codint codint col6 codint select * from col7 col1 col2 col3 codint col8 codint codint col9 codint codint col10 codint codint col11 codint select * from col12 col1 col2 col3 codint col13 codint codint col14 codint codint codint col15 codint codint col16 codint	0
Q_180	nest loop to retrieve a value from several table in oracle	C_180_4	declare col0 number = codint col1 varchar2 ( codint ) = refre col2 varchar2 ( codint ) = refre col3 varchar2 ( codint ) = refre col4 number = codint begin for col5 in ( select table_name from col6 where table_name like refre order by table_name ) loop col2 = refre refre regast refre refre tab0 . table_name execute immediate col2 into col4 tab1 . put_line ( col4 ) for col7 in codint . col4 loop _ tab1 . put_line ( col7 ) col3 = refre refre refre refre refre refre refre refre refre tab0 . table_name refre refre refre col7 _ tab1 . put_line ( col3 ) execute immediate col3 into col0 tab1 . put_line ( refre col0 refre tab0 . table_name ) end loop end loop end /	0
Q_180	nest loop to retrieve a value from several table in oracle	C_180_5	codint col0 col1 is codint for col2 col3 col0 col1 is codint for col2 col3 col0 col1 is codint for col2 col3 codint col0 col1 is codint for col2 col4 col0 col1 is codint for col2 col4 col0 col1 is codint for col2 col4 col0 col1 is codint for col2 col4 codint col0 col1 is codint for col2 col5 col0 col1 is codint for col2 col5 col0 col1 is codint for col2 col5 col0 col1 is codint for col2 col5	0
Q_180	nest loop to retrieve a value from several table in oracle	C_180_6	select col0 from ( select col0 , row_number ( ) over ( order by col1 ) col2 from col3 ) where col2 = codint _ col4 result col0 codint	0
Q_180	nest loop to retrieve a value from several table in oracle	C_180_7	select col0 , row_number ( ) over ( order by col1 ) col2 from col3 _ result col0 col2 codint codint codint codint codint codint	0
Q_181	subtract day from a date ignore weekend day	C_181_0	refre _ codint col0 = > refre _ ( codint + codint * ( codint ) ) col1 = > refre _ codint col1 / * codint col2 col3 * / refre _ codint col1 = > refre _ ( codint + codint * ( codint ) ) col1 = > refre _ codint col1 / * codint col2 col3 * / refre _ codint col1 = > refre _ ( codint + codint * ( codint ) ) col1 = > refre _ codint col1 / * codint col2 col3 * / . refre _ codint col1 = > refre _ ( codint + codint * ( codint ) ) col1 = > refre _ codint col1 / * codint col4 col3 * / .	1
Q_181	subtract day from a date ignore weekend day	C_181_1	refre _ codint col0 = > refre _ ( codint + codint * ( codint ) ) col1 = > refre _ codint col1 / * codint col2 col3 * / refre _ codint col1 = > refre _ ( codint + codint * ( codint ) ) col1 = > refre _ codint col1 / * codint col4 col3 * / refre _ codint col1 = > refre _ ( codint + codint * ( codint ) ) col1 = > refre _ codint col1 / * codint col4 col3 * / . refre _ codint col1 = > refre _ ( codint + codint * ( codint ) ) col1 = > refre _ codint col1 / * codint col4 col3 * / refre _ codint col1 = > refre _ ( codint + codint * ( codint ) ) col1 = > refre _ codint col1 / * codint col2 col3 * / .	0
Q_181	subtract day from a date ignore weekend day	C_181_2	refre _ codint col0 = > refre _ ( codint + codint * ( codint ) ) col1 = > refre _ codint col1 / * codint col2 col3 * / refre _ codint col1 = > refre _ ( codint + codint * ( codint ) ) col1 = > refre _ codint col1 / * codint col2 col3 * / refre _ codint col1 = > refre _ ( codint + codint * ( codint ) ) col1 = > refre _ codint col1 / * codint col4 col3 * / . refre _ codint col1 = > refre _ ( codint + codint * ( codint ) ) col1 = > refre _ codint col1 / * codint col4 col3 * / refre _ codint col1 = > refre _ ( codint + codint * ( codint ) ) col1 = > refre _ codint col1 / * codint col4 col3 * / refre _ codint col1 = > refre _ ( codint + codint * ( codint ) ) col1 = > refre _ codint col1 / * codint col2 col3 * / .	0
Q_181	subtract day from a date ignore weekend day	C_181_3	codint < _ > col0 codint < _ > col1 codint < _ > col2 codint < _ > col3 codint < _ > col4	0
Q_181	subtract day from a date ignore weekend day	C_181_4	col0 _ col1 col2 = > col0 _ col1 col2 + codint * ceil ( ( col1 _ index_of ( col0 ) ) / codint ) col2 where index_of ( ) is col3 function col4 returns col5 col6 col7 for tab0 .	0
Q_181	subtract day from a date ignore weekend day	C_181_5	refre _ codint col0 = > refre _ codint + codint * ceil ( ( codint _ codint ) / codint ) refre _ codint col0 = > refre _ codint + codint * ceil ( codint / codint ) refre _ codint col0 = > refre _ codint + codint * codint refre _ codint col0 = > refre _ codint + codint refre _ codint col0 = > refre _ codint col0	0
Q_181	subtract day from a date ignore weekend day	C_181_6	refre _ codint col0 = > refre _ codint + codint * ceil ( ( codint _ codint ) / codint ) refre _ codint col0 = > refre _ codint + codint * ceil ( codint / codint ) refre _ codint col0 = > refre _ codint + codint * codint / * col1 col2 are col3 * / refre _ codint col0 = > refre _ codint + codint refre _ codint col0 = > refre _ codint col0	0
Q_181	subtract day from a date ignore weekend day	C_181_7	select date as col0 , dayofweek ( date ) _ codint as col1 , col2 as col3 , codint * ceil ( ( col2 _ ( dayofweek ( date ) _ codint ) ) / codint ) as col4 , date_sub ( date , interval col2 + ( codint * ceil ( ( col2 _ ( dayofweek ( date ) _ codint ) ) / codint ) ) col5 ) as col6 from col7	0
Q_182	data table retrieval use column name or integer	C_182_0	col0 col1 col2 col3 col4 lastname ( int ) ( col5 ) ( col5 ) _ codint col6 col7	1
Q_182	data table retrieval use column name or integer	C_182_1	col0 col1 = refre [ i ] refre [ 2 ] refre refre refre [ i ] refre [ 3 ] refre refre refre	0
Q_182	data table retrieval use column name or integer	C_182_2	col0 col1 = refre [ i ] refre refre col2 refre refre refre refre [ i ] refre refre col3 refre refre refre refre	0
Q_182	data table retrieval use column name or integer	C_182_3	public class col0 { public int col1 { get set } public col2 col3 { get set } public col2 col4 { get set } }	0
Q_182	data table retrieval use column name or integer	C_182_4	col0 col1 = tab0 . tab1 . firstordefault ( col2 = > tab2 . col3 = = codint ) / / or col0 col1 = tab0 . set < col1 > ( ) . firstordefault ( col2 = > tab2 . col3 = = codint )	0
Q_182	data table retrieval use column name or integer	C_182_5	col0 col1 = tab0 . col2 < col1 > ( refre regast refre ) . firstordefault ( )	0
Q_182	data table retrieval use column name or integer	C_182_6	col0 col1 = tab0 . get < col1 > ( col2 )	0
Q_182	data table retrieval use column name or integer	C_182_7	public class col0 { public int col1 { get set } public col2 col3 { get set } public col2 col4 { get set } public col5 col6 { get set } public boolean col7 { get set } public col2 col8 { get { return refre } } }	0
Q_182	data table retrieval use column name or integer	C_182_8	/ / col0 else col1 col2 class col3 col4 col5 for col6 public class tab0 .	0
Q_182	data table retrieval use column name or integer	C_182_9	col0 col1 = tab0 . tab1 . firstordefault ( col2 = > tab2 . col3 = = refre ) if ( tab3 . col4 ) . if ( tab3 . col5 > tab4 . now ) .	0
Q_183	py_spark insert a constant sparse_vector in a dataframe column	C_183_0	ref = tab0 . select ( col ( refre ) . alias ( refre ) ) . limit ( codint ) tab1 . crossjoin ( ref )	1
Q_183	py_spark insert a constant sparse_vector in a dataframe column	C_183_1	from tab0 . tab1 . col0 col1 col2 , col3 , col4 , col5 , col6 from tab0 . tab2 . col7 col1 col8 col9 vector_lit ( col10 ) col11 isinstance ( col10 , col4 ) return udf ( col12 col10 , vectorudt ( ) ) ( )	0
Q_183	py_spark insert a constant sparse_vector in a dataframe column	C_183_2	tab0 . range ( codint ) . select ( vector_lit ( tab1 . sparse ( codint , col0 , col1 ) ) . alias ( refre ) ) . show ( )	0
Q_183	py_spark insert a constant sparse_vector in a dataframe column	C_183_3	+ _ + ref + _ + ( codint , col0 , col1 ) + _ +	0
Q_183	py_spark insert a constant sparse_vector in a dataframe column	C_183_4	tab0 . range ( codint ) . select ( vector_lit ( tab1 . dense ( col0 ) ) . alias ( refre ) ) . show ( )	0
Q_183	py_spark insert a constant sparse_vector in a dataframe column	C_183_5	+ _ + ref + _ + col0 + _ +	0
Q_183	py_spark insert a constant sparse_vector in a dataframe column	C_183_6	col0 json from tab0 . tab1 . col1 col0 col2 , col3 from tab0 . tab1 . col4 col0 col5 , col6 col7 as_column ( col8 ) col9 isinstance ( col8 , col10 ) if isinstance ( col8 , col11 ) col12 = lit ( tab2 . dumps ( { refre { refre codint , refre tab3 . values . tolist ( ) } } ) ) else col12 = lit ( tab2 . dumps ( { refre { refre codint , refre tab3 . size , refre tab3 . tab4 . tolist ( ) , refre tab3 . values . tolist ( ) } } ) ) return from_json ( col12 , structtype ( col13 ) ) col14	0
Q_183	py_spark insert a constant sparse_vector in a dataframe column	C_183_7	tab0 . range ( codint ) . select ( as_column ( tab1 . sparse ( codint , col0 , col1 ) ) . alias ( refre ) ) . show ( )	0
Q_183	py_spark insert a constant sparse_vector in a dataframe column	C_183_8	+ _ + ref + _ + ( codint , col0 , col1 ) + _ +	0
Q_183	py_spark insert a constant sparse_vector in a dataframe column	C_183_9	tab0 . range ( codint ) . select ( as_column ( tab1 . dense ( col0 ) ) . alias ( refre ) ) . show ( )	0
Q_183	py_spark insert a constant sparse_vector in a dataframe column	C_183_10	+ _ + ref + _ + col0 + _ +	0
Q_184	a very difficult query i need to preform in order to create my model	C_184_0	col0 tab0 . col1 { public class date { public col2 col3 public col4 col4 public col5 col5 public col6 col6 public int col7 , col8 } }	1
Q_184	a very difficult query i need to preform in order to create my model	C_184_1	col0 tab0 . col1 { public class col2 { public col3 col4 , col5 , col6 , col7 , col8 , col9 , col10 public int role , col11 } }	0
Q_184	a very difficult query i need to preform in order to create my model	C_184_2	col0 tab0 . col1 { public class col2 col3 { public col4 col5 } }	0
Q_184	a very difficult query i need to preform in order to create my model	C_184_3	col0 tab0 . col1 { public class col2 col3 { public col4 col4 } }	0
Q_184	a very difficult query i need to preform in order to create my model	C_184_4	col0 tab0 . col1 { public class col2 { public col3 col3 public col4 col5 public col4 col6 } }	0
Q_184	a very difficult query i need to preform in order to create my model	C_184_5	col0 tab0 . col1 { public class col2 { public col3 col4 public int col5 } }	0
Q_184	a very difficult query i need to preform in order to create my model	C_184_6	( select tab0 . col0 as col1 , tab0 . col2 as col3 , tab1 . col4 as col5 , tab1 . col6 from col7 full outer join col8 on tab0 . col4 = tab1 . col4 ) as col9 ,	0
Q_184	a very difficult query i need to preform in order to create my model	C_184_7	( select tab0 . col0 as col1 , tab1 . col2 as col3 , tab1 . col4 as col5 , tab1 . col6 , tab2 . * from col7 , col8 , ( select col9 as col10 , col11 as col12 , col13 as col14 , col15 as col16 , role as col17 , col18 as col19 , col20 as col21 , col22 as col23 , col24 as col25 , col2 as col26 from col27 left join col28 on col9 = col29 ) as col30 where tab2 . col26 = tab1 . col2 and tab1 . col4 = tab0 . col4 ) as col31 ,	0
Q_184	a very difficult query i need to preform in order to create my model	C_184_8	( select col0 as col1 , col2 as col3 , col4 as col5 , col6 as col7 , role as col8 , col9 as col10 , col11 as col12 , col13 as col14 , col15 as col16 , col17 from col18 left join col19 on col0 = col20 ) as col21	0
Q_184	a very difficult query i need to preform in order to create my model	C_184_9	select col0 , col1 , tab0 . col2 as col3 , tab1 . * , tab2 . * , tab3 . * from col4 , col5 , col6 , col7 where tab0 . col8 = tab1 . col9 and tab0 . col10 = tab2 . col11 and tab0 . col12 = tab3 . col13	0
Q_185	sqlite table user function	C_185_0	create col0 if not exists user_info ( col1 integer primary key references user_reg ( col1 ) , col2 col3 , col4 col3 )	1
Q_185	sqlite table user function	C_185_1	create col0 if not exists user_info ( col1 integer primary key , col2 col3 , col4 col3 , col5 col3 ) create col0 if not exists user_reg ( col1 integer references col6 , col7 col3 )	0
Q_185	sqlite table user function	C_185_2	insert into col0 values ( codint , refre , refre , refre ) , ( codint , refre , refre , refre ) , ( codint , refre , refre , refre ) insert into col1 values ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre )	0
Q_185	sqlite table user function	C_185_3	select * from col0 join col1 on tab0 . col2 = tab1 . col2 order by col3	0
Q_185	sqlite table user function	C_185_4	insert into col0 values ( codint , refre ) _ col1 no col2 col3 col4	0
Q_185	sqlite table user function	C_185_5	insert into col0 values ( codint , refre ) _ col1 no col2 col3 col4 > foreign key constraint col5	0
Q_185	sqlite table user function	C_185_6	"public class col0 col1 col2 { col3 col4 col5 col6 col7 col8 col9 oncreate ( col10 col11 ) { tab0 . oncreate ( col11 ) setcontentview ( tab1 . tab2 . col12 ) col6 = col13 col4 = new studentdbhelper ( col13 ) tab3 . adduserinfo ( refre , refre , refre ) / / < < < < < < < < < < col14 return codint as col13 col14 col15 col16 generated value ( first col17 only ) tab3 . adduserinfo ( refre , refre , refre ) tab3 . adduserinfo ( refre , refre , refre ) tab3 . adduserreg ( codint , refre ) tab3 . adduserreg ( codint , refre ) tab3 . adduserreg ( codint , refre ) tab3 . adduserreg ( codint , refre ) tab3 . adduserreg ( codint , refre ) tab3 . adduserreg ( codint , refre ) / / < < < < < < < < < col18 col19 "" col20 insert return col14 col15 _ codint tab3 . logstudentsincourses ( ) } }"	0
Q_186	replace string pattern in sqldf	C_186_0	library ( col0 ) sqldf ( refre regast refre refre refre refre [ col1 ] refre refre refre refre _ refre refre refre _ refre refre _ refre refre )	1
Q_186	replace string pattern in sqldf	C_186_1	col0 col1 col2 new codint col3 end codint codint col3 _ end codint col4 col5 codint codint col4 _ col5 codint codint codint codint codint codint _ codint codint codint codint codint codint codint _ codint	0
Q_186	replace string pattern in sqldf	C_186_2	sqldf ( refre regast refre refre refre refre codint refre refre refre refre refre refre refre _ refre refre refre refre refre refre _ refre refre )	0
Q_186	replace string pattern in sqldf	C_186_3	col0 col1 col2 new codint col3 end codint codint col3 _ end codint col4 col5 codint codint col4 _ col5 codint codint codint codint codint codint _ codint codint codint codint codint codint codint _ codint	0
Q_186	replace string pattern in sqldf	C_186_4	col0 < _ refre col1 < _ refre col2 sqldf ( refre regast refre refre refre refre col0 refre refre refre refre refre refre refre _ refre refre refre refre col1 refre refre refre refre refre refre refre _ refre refre )	0
Q_186	replace string pattern in sqldf	C_186_5	col0 col1 col2 new codint col3 end codint codint col3 _ end codint col4 col5 codint codint col4 _ col5 codint codint codint codint codint codint _ codint codint codint codint codint codint codint _ codint	0
Q_186	replace string pattern in sqldf	C_186_6	col0 sqldf ( refre regast refre refre refre refre refre refre refre refre refre refre refre refre col1 refre refre refre refre refre refre refre _ refre refre refre refre refre refre refre refre refre refre refre refre col2 refre refre refre refre refre refre refre _ refre refre )	0
Q_186	replace string pattern in sqldf	C_186_7	col0 < _ refre refre refre refre refre refre refre refre refre refre refre col1 < _ tab0 . csv ( col2 = col0 , as . is = true , tab1 . col3 = true )	0
Q_187	select from my_sql table order by the match number of category	C_187_0	create col0 items ( col1 int , col2 varchar ( codint ) , primary key ( col1 ) , index1 ( col2 ) ) create col0 categories ( col1 int , col2 varchar ( codint ) , primary key ( col1 ) , index1 ( col2 ) ) create col0 items_categories ( col3 int , col4 int , primary key ( col3 , col4 ) , index1 ( col4 , col3 ) , foreign key ( col3 ) references items ( col1 ) , foreign key ( col4 ) references categories ( col1 ) ) insert into items ( col1 , col2 ) values ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) insert into categories ( col1 , col2 ) values ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) insert into items_categories ( col3 , col4 ) values ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint )	1
Q_187	select from my_sql table order by the match number of category	C_187_1	select tab0 . * , count ( * ) as col0 from col1 col2 join col3 col4 on tab1 . col5 = tab0 . col6 join col7 col8 on tab2 . col6 = tab1 . col9 where tab2 . col10 in ( refre , refre ) group by tab0 . col6 order by col0 desc , tab0 . col10	0
Q_187	select from my_sql table order by the match number of category	C_187_2	col0 col1 col2 _ _ _ codint col3 codint codint col4 codint codint col5 codint codint col6 codint	0
Q_187	select from my_sql table order by the match number of category	C_187_3	where tab0 . col0 in ( refre , refre )	0
Q_187	select from my_sql table order by the match number of category	C_187_4	col0 col1 col2 _ _ _ codint col3 codint codint col4 codint codint col5 codint	0
Q_187	select from my_sql table order by the match number of category	C_187_5	select tab0 . * , group_concat ( tab1 . col0 col1 refre refre ) as col2 from col3 col4 join col5 col6 on tab2 . col7 = tab0 . col8 join col2 col9 on tab1 . col8 = tab2 . col10 group by tab0 . col8	0
Q_187	select from my_sql table order by the match number of category	C_187_6	col0 col1 col2 _ _ _ codint col3 col4 , col5 , col6 codint col7 col4 , col5 codint col8 col4 , col6 codint col9 col5	0
Q_188	how to find multiple pair in one oracle table	C_188_0	create col0 bills ( col1 primary key , col2 , col3 , col4 , col5 ) as select codint , codint , codint , number , null from col6 union all select codint , codint , codint , number , null from col6 union all select codint , codint , codint , number , null from col6 union all select codint , codint , codint , _ number , codint from col6 union all select codint , codint , codint , _ number , codint from col6 union all select codint , codint , codint , _ number , null from col6 union all select codint , codint , codint , _ number , null from col6 union all select codint , codint , codint , number , codint from col6 union all select codint , codint , codint , _ number , null from col6 union all select codint , codint , codint , _ number , null from col6 union all select codint , codint , codint , number , codint from col6	1
Q_188	how to find multiple pair in one oracle table	C_188_1	_ col0 create col1 col0 as select col2 , col3 as col4 , col5 as col6 , col7 * _ codint as col8 , col9 as col10 from col11 where col7 < codint _ col12 create col1 col12 as select col2 , col3 as col13 , col5 as col14 , col7 as col15 , col9 as col16 from col11 where col7 > = codint	0
Q_188	how to find multiple pair in one oracle table	C_188_2	create or replace view col0 as with recursiveclause ( col1 , col2 , col3 , col4 ) as ( select _ col5 col6 col7 as col1 , col2 as col2 , col8 as col3 _ col9 col10 , to_char ( col7 ) as col4 from col11 union all select _ recursive col6 tab0 . col7 , tab1 . col2 , tab1 . col3 + tab0 . col8 , tab1 . col4 refre refre to_char ( tab0 . col7 ) from col12 col13 join col11 col14 on tab0 . col7 > tab1 . col1 and tab0 . col2 = tab1 . col2 ) _ select col2 , col3 as col15 , col4 as col16 , col17 from col12 col13 , lateral ( select col17 from col18 col19 where tab1 . col3 = tab2 . col20 ) where col3 in ( select col20 from col18 where col17 is not null ) and col17 is not null	0
Q_188	how to find multiple pair in one oracle table	C_188_3	sql > select * from col0 col1 col2 col3 col4 codint number codint , codint codint codint number codint , codint codint sql > select * from col5 col6 col7 col8 col9 codint number codint codint codint number codint , codint codint	0
Q_188	how to find multiple pair in one oracle table	C_188_4	create col0 allcomponents ( col1 , col2 , col3 , col4 , col5 ) as select refre as col1 , tab0 . * from col6 col7 union all select refre , tab1 . * from col8 col9 sql > select * from col10 col1 col2 col3 col4 col5 col11 of col12 codint number codint codint col11 of col12 codint number codint , codint codint col11 of minus codint number codint , codint codint col11 of minus codint number codint , codint codint	0
Q_188	how to find multiple pair in one oracle table	C_188_5	_ col0 row for each csv ( col1 _ col2 col3 ) of col4 create col5 col6 as select unique col7 , col8 , col9 , trim ( regexp_substr ( col10 , refre [ ^ , ] refre regplu refre , codint , level ) ) col10 , col11 from ( select col7 , col8 , col9 , col10 , col11 from col4 ) col12 connect by instr ( col10 , refre refre , codint , level _ codint ) > codint order by col8 , col11 sql > select * from col6 col7 col8 col9 col10 col11 col13 of col14 codint number codint codint col13 of col14 codint number codint codint col13 of col14 codint number codint codint col13 of minus codint number codint codint col13 of minus codint number codint codint col13 of minus codint number codint codint col13 of minus codint number codint codint codint rows tab0 .	0
Q_188	how to find multiple pair in one oracle table	C_188_6	select tab0 . col0 , col1 , col2 , col3 , case when tab0 . col4 is null then tab1 . col5 else tab0 . col4 end as col4 from col6 col7 left join col8 col9 on tab0 . col0 = tab1 . col10 order by codint _ result col0 col1 col2 col3 col4 codint codint codint number codint codint codint codint number codint codint codint codint number codint codint codint codint _ number codint codint codint codint _ number codint codint codint codint _ number codint codint codint codint _ number codint codint codint codint number codint codint codint codint _ number codint codint codint codint _ number codint codint codint codint number codint codint rows tab2 .	0
Q_189	how do i compare two integer column in different table	C_189_0	select tab0 . col0 , count ( distinct tab1 . col0 ) filter ( where tab1 . col1 > tab0 . col1 ) from col2 col3 join col4 col5 on ( tab0 . col0 = tab2 . col6 ) join col7 col8 on ( tab3 . col4 = tab2 . col0 ) join col9 col10 on ( tab1 . col0 = tab3 . col9 ) group by codint	1
Q_189	how do i compare two integer column in different table	C_189_1	col0 count _ + _ codint codint codint codint codint codint .	0
Q_189	how do i compare two integer column in different table	C_189_2	select tab0 . col0 , tab0 . col1 , tab1 . col0 , tab1 . col2 , count ( tab2 . * ) filter ( where tab2 . col3 > tab0 . col3 ) from col4 col5 join col6 col7 on ( tab0 . col0 = tab1 . col8 ) join col9 col10 on ( tab3 . col6 = tab1 . col0 ) join col11 col12 on ( tab2 . col0 = tab3 . col11 ) group by codint , codint , codint , codint	0
Q_189	how do i compare two integer column in different table	C_189_3	col0 col1 col0 col2 count _ + _ + _ + _ + _ codint col3 col4 codint col5 codint codint col6 col7 codint col8 codint codint col9 col10 codint col11 codint .	0
Q_189	how do i compare two integer column in different table	C_189_4	select tab0 . col0 , tab0 . col1 , array_agg ( tab1 . col2 ) filter ( where tab0 . col3 > tab2 . col3 ) from col4 col5 join col6 col7 on ( tab2 . col0 = tab1 . col8 ) join col9 col10 on ( tab3 . col6 = tab1 . col0 ) join col11 col12 on ( tab0 . col0 = tab3 . col11 ) group by codint order by codint	0
Q_189	how do i compare two integer column in different table	C_189_5	col0 col1 col2 _ + _ + _ codint col3 col4 codint col5 col6 { col7 , col8 } codint col9 col10 { col7 } codint col11 col12 { col7 } codint col13 tab0 .	0
Q_189	how do i compare two integer column in different table	C_189_6	insert into teacher ( col0 , col1 , col2 ) values ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) insert into student ( col0 , col1 , col2 ) values ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) insert into course ( col0 , col3 , col4 ) values ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) insert into enrolment ( col5 , col6 ) select tab0 . col0 as col5 , tab1 . col0 as col6 from generate_series ( codint , codint ) as c ( col0 ) cross join generate_series ( codint , codint ) as s ( col0 )	0
Q_190	mysql get second max date limit tagint base on user id join table log	C_190_0	+ _ + _ + _ + _ + col0 col1 type col2 + _ + _ + _ + _ + codint codint col3 codint _ codint _ codint codint codint codint codint codint col3 codint _ codint _ codint codint codint codint codint codint col4 codint _ codint _ codint codint codint codint codint codint col3 codint _ codint _ codint codint codint codint codint codint col4 codint _ codint _ codint codint codint codint codint codint col3 codint _ codint _ codint codint codint codint codint codint col4 codint _ codint _ codint codint codint codint codint codint col3 codint _ codint _ codint codint codint codint codint codint col3 codint _ codint _ codint codint codint codint + _ + _ + _ + _ +	1
Q_190	mysql get second max date limit tagint base on user id join table log	C_190_1	select col0 , max ( col1 ) as col2 from col3 where type = refre group by col0	0
Q_190	mysql get second max date limit tagint base on user id join table log	C_190_2	+ _ + _ + col0 col1 + _ + _ + codint codint _ codint _ codint codint codint codint codint codint _ codint _ codint codint codint codint codint codint _ codint _ codint codint codint codint + _ + _ +	0
Q_190	mysql get second max date limit tagint base on user id join table log	C_190_3	select tab0 . col0 , tab0 . type , tab0 . col1 , tab1 . col2 from col3 col4 left join ( select col0 , max ( col1 ) as col2 from col3 where type = refre group by col0 ) col5 on tab0 . col0 = tab1 . col0	0
Q_190	mysql get second max date limit tagint base on user id join table log	C_190_4	+ _ + _ + _ + _ + col0 type col1 col2 + _ + _ + _ + _ + codint col3 codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint col4 codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint col3 codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint col4 codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint col3 codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint col3 codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint col4 codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint col3 codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint col3 codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint + _ + _ + _ + _ +	0
Q_190	mysql get second max date limit tagint base on user id join table log	C_190_5	select tab0 . col0 , tab0 . type , tab0 . col1 , tab1 . col2 from col3 col4 left join ( select col0 , max ( col1 ) as col2 from col3 where type = refre group by col0 ) col5 on tab0 . col0 = tab1 . col0 where tab0 . col1 = tab1 . col2 and type = refre	0
Q_190	mysql get second max date limit tagint base on user id join table log	C_190_6	+ _ + _ + _ + _ + col0 type col1 col2 + _ + _ + _ + _ + codint col3 codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint col3 codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint col3 codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint + _ + _ + _ + _ +	0
Q_190	mysql get second max date limit tagint base on user id join table log	C_190_7	select tab0 . col0 , tab0 . col1 , tab1 . type , tab1 . col2 from col3 col4 left join ( select tab2 . col5 , tab2 . type , max ( tab2 . col6 ) as col2 from col7 col8 left join ( select col5 , max ( col6 ) as col9 from col7 where type = refre group by col5 ) col10 on tab2 . col5 = tab3 . col5 where tab2 . col6 = tab3 . col9 and type = refre group by tab2 . col5 ) col11 on tab0 . col0 = tab1 . col5	0
Q_190	mysql get second max date limit tagint base on user id join table log	C_190_8	+ _ + _ + _ + _ + col0 col1 type col2 + _ + _ + _ + _ + codint col3 col4 codint _ codint _ codint codint codint codint codint col5 col4 codint _ codint _ codint codint codint codint codint col6 null null + _ + _ + _ + _ +	0
Q_191	overwrite exist ship sqlite db with the new db version on my next android app update	C_191_0	col0 { copyandcreatedatabase ( ) } catch ( col1 col2 ) { tab0 . printstacktrace ( ) } / * new handler ( ) . post ( new runnable ( ) { col3 public col4 run ( ) { / / if col5 col6 to copy database from tab1 . col0 { copyandcreatedatabase ( ) } catch ( col1 col2 ) { tab0 . printstacktrace ( ) } } } ) * /	1
Q_191	overwrite exist ship sqlite db with the new db version on my next android app update	C_191_1	codint _ codint codint codint number codint _ codint / tab0 . col0 col1 / col2 col3 database / data / col4 / codint / tab0 . col0 / col5 / tab1 . col6 col7 tab2 . codint _ codint codint codint number codint _ codint / tab0 . col0 col1 / col6 col8 database col9 exists codint _ codint codint codint number codint _ codint / tab0 . col0 col1 / database col10 old codint new codint	0
Q_191	overwrite exist ship sqlite db with the new db version on my next android app update	C_191_2	public class col0 col1 col2 { col3 col4 col5 oncreate ( col6 col7 ) { tab0 . oncreate ( col7 ) setcontentview ( tab1 . tab2 . col8 ) col9 col10 = tab3 . getinstance ( col11 ) cursor col12 = tab4 . getwritabledatabase ( ) . query ( refre , null , null , null , null , null , null ) tab5 . dumpcursor ( col12 ) } }	0
Q_191	overwrite exist ship sqlite db with the new db version on my next android app update	C_191_3	public class col0 col1 col2 { col3 col4 col5 oncreate ( col6 col7 ) { tab0 . oncreate ( col7 ) setcontentview ( tab1 . tab2 . col8 ) col9 col10 = tab3 . getinstance ( col11 ) cursor col12 = tab4 . getwritabledatabase ( ) . query ( refre , null , null , null , null , null , null ) tab5 . dumpcursor ( col12 ) } }	0
Q_191	overwrite exist ship sqlite db with the new db version on my next android app update	C_191_4	codint _ codint _ codint codint codint number codint _ codint / tab0 . col0 col1 / col2 col3 copy col4 codint _ codint _ codint codint codint number codint _ codint / tab0 . col0 col1 / col2 database tab1 . codint col5 tab1 . codint _ codint _ codint codint codint number codint _ codint / tab0 . col0 col1 / col3 col6 col7 col8 _ codint _ codint _ codint codint codint number codint _ codint / tab0 . col0 col9 / tab2 . out col10 cursor tab3 . tab4 . tab5 . col11 col12 codint _ codint _ codint codint codint number codint _ codint / tab0 . col0 col9 / tab2 . out codint {	0
Q_191	overwrite exist ship sqlite db with the new db version on my next android app update	C_191_5	codint _ codint codint codint number codint _ codint / col0 col1 / col2 col3 col4 database version is codint codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out col6 cursor tab1 . tab2 . tab3 . col7 col8	0
Q_191	overwrite exist ship sqlite db with the new db version on my next android app update	C_191_6	codint _ codint _ codint codint codint number codint _ codint / col0 col1 / col2 col3 col4 database version is codint codint _ codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out col6 cursor tab1 . tab2 . tab3 . col7 codint col8	0
Q_191	overwrite exist ship sqlite db with the new db version on my next android app update	C_191_7	codint _ codint codint codint number codint _ codint / col0 col1 / col2 col3 col4 database version is codint codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out col6 cursor tab1 . tab2 . tab3 . col7 col8 codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out codint { codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out type = col9 codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out col10 = col11 codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out col12 = col11 codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out col13 = codint codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out sql = create col9 android_metadata ( col14 col15 ) codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out } codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out codint { codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out type = col9 codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out col10 = col16	0
Q_191	overwrite exist ship sqlite db with the new db version on my next android app update	C_191_8	codint _ codint _ codint codint codint number codint _ codint / tab0 . col0 col1 / col2 col3 col4 database version is codint codint _ codint _ codint codint codint number codint _ codint / tab0 . col0 col1 / col5 col6 copy col7 codint _ codint _ codint codint codint number codint _ codint / tab0 . col0 col1 / col5 database tab1 . codint col8 tab1 . codint _ codint _ codint codint codint number codint _ codint / tab0 . col0 col1 / col6 col9 col10 col11 _ codint _ codint _ codint codint codint number codint _ codint / tab0 . col0 col1 / database col12 old codint new codint .	0
Q_191	overwrite exist ship sqlite db with the new db version on my next android app update	C_191_9	codint _ codint codint codint number codint _ codint / col0 col1 / col2 col3 col4 database version is codint codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out col6 cursor tab1 . tab2 . tab3 . col7 col8 codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out codint { codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out type = col9 codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out col10 = col11 codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out col12 = col11 codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out col13 = codint codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out sql = create col9 android_metadata ( col14 col15 ) codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out } codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out codint { codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out type = col9 codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out col10 = col16 codint _ codint codint codint number codint _ codint / col0 col5 / tab0 . out col12 = col16	0
Q_192	display all the parent till the top most in comma separate string	C_192_0	with [ hierarchies ] ( col0 , col1 , col2 ) as ( select col3 , codint , col4 from col5 ) select * from col6 order by col0 , col1	1
Q_192	display all the parent till the top most in comma separate string	C_192_1	col0 level col1 codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_192	display all the parent till the top most in comma separate string	C_192_2	with [ hierarchies ] ( col0 , col1 , col2 ) as ( select col3 , codint , col4 from col5 union all select col0 , col1 + codint , col4 from col5 inner join col6 on col2 = col3 ) select * from col6 order by col0 , col1	0
Q_192	display all the parent till the top most in comma separate string	C_192_3	col0 level col1 codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_192	display all the parent till the top most in comma separate string	C_192_4	with [ hierarchies ] ( col0 , col1 , col2 , col3 ) as ( select col4 , codint , col5 , cast ( col5 as varchar ( max ) ) from col6 union all select col0 , col1 + codint , col5 , col3 + refre refre + cast ( col5 as varchar ( max ) ) from col6 inner join col7 on col2 = col4 ) select * from col7 order by col0 , col1	0
Q_192	display all the parent till the top most in comma separate string	C_192_5	col0 level col1 hierarchy codint codint codint codint codint codint codint codint , codint codint codint codint codint codint codint codint codint , codint codint codint codint codint , codint , codint codint codint codint codint codint codint codint codint , codint codint codint codint codint codint codint codint codint	0
Q_192	display all the parent till the top most in comma separate string	C_192_6	with [ hierarchies ] ( col0 , col1 , col2 , col3 ) as ( select col4 , codint , col5 , cast ( col5 as varchar ( max ) ) from col6 union all select col0 , col1 + codint , col5 , col3 + refre refre + cast ( col5 as varchar ( max ) ) from col6 inner join col7 on col2 = col4 ) select col4 , col5 , col3 from col6 cross apply ( select top ( codint ) col3 from col7 where col0 = col4 order by col1 desc ) as col8	0
Q_192	display all the parent till the top most in comma separate string	C_192_7	col0 col1 hierarchy codint codint codint , codint codint codint codint , codint , codint codint codint codint , codint codint codint codint codint codint codint	0
Q_193	i need to pivot some data in sql multiple date column for each combination	C_193_0	create col0 allgroup ( col1 nvarchar ( codint ) , col2 int , col3 int , col4 date , col5 char ( codint ) , col6 char ( codint ) , col7 date , col8 date ) insert col9 values ( refre , codint , codint , refre , refre , refre , refre , refre ) , ( refre , codint , codint , refre , refre , refre , refre , refre ) , ( refre , codint , codint , refre , refre , refre , refre , refre )	1
Q_193	i need to pivot some data in sql multiple date column for each combination	C_193_1	select col0 , col1 , col2 , col3 , col4 , col5 , col6 , col7 , col8 from col9 col10 pivot ( max ( col11 ) for col12 in ( col6 , col7 , col8 ) ) col13	0
Q_193	i need to pivot some data in sql multiple date column for each combination	C_193_2	select col0 , col1 , col2 , col3 , col4 = max ( iif ( col5 = refre , col6 , null ) ) , col7 = max ( iif ( col5 = refre , col8 , null ) ) , col9 = max ( iif ( col5 = refre , col10 , null ) ) , col11 = max ( iif ( col5 = refre , col6 , null ) ) , col12 = max ( iif ( col5 = refre , col8 , null ) ) , col13 = max ( iif ( col5 = refre , col10 , null ) ) , col14 = max ( iif ( col5 = refre , col6 , null ) ) , col15 = max ( iif ( col5 = refre , col8 , null ) ) , col16 = max ( iif ( col5 = refre , col10 , null ) ) from col17 col18 group by col0 , col1 , col2 , col3	0
Q_193	i need to pivot some data in sql multiple date column for each combination	C_193_3	declare col0 table1 ( col1 col2 , col3 varchar ( max ) ) insert pivotcols ( col1 ) values ( refre ) , ( refre ) , ( refre )	0
Q_193	i need to pivot some data in sql multiple date column for each combination	C_193_4	update col0 set col1 = replace ( refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre , refre , col2 )	0
Q_193	i need to pivot some data in sql multiple date column for each combination	C_193_5	declare sql nvarchar ( max ) = refre select sql + = col0 from col1	0
Q_193	i need to pivot some data in sql multiple date column for each combination	C_193_6	set sql = refre refre refre refre refre + left ( sql , len ( sql ) _ codint ) + _ col0 col1 of col2 final col3 refre refre refre refre	0
Q_193	i need to pivot some data in sql multiple date column for each combination	C_193_7	if object_id ( refre ) is not null drop col0 col1 exec ( sql ) select * from col1	0
Q_194	how to print the student name in this query	C_194_0	create view col0 as select tab0 . col1 , tab0 . col2 , tab0 . col3 , sum ( tab1 . col4 ) as col5 from col6 col7 , col8 col9 where tab0 . col3 = tab1 . col10 group by tab0 . col3	1
Q_194	how to print the student name in this query	C_194_1	create view col0 as select col1 , max ( col2 ) col3 from col4 group by col1	0
Q_194	how to print the student name in this query	C_194_2	select tab0 . col0 , tab0 . col1 , tab0 . col2 from col3 col4 join col5 col6 on tab0 . col0 = tab1 . col0 and tab0 . col7 = tab1 . col8	0
Q_194	how to print the student name in this query	C_194_3	select tab0 . col0 , tab0 . col1 , tab0 . col2 from ( select tab1 . col0 , tab1 . col2 , tab1 . col1 , sum ( tab2 . col3 ) as col4 from col5 col6 , col7 col8 where tab1 . col1 = tab2 . col9 group by tab1 . col1 ) col10 join ( select col0 , max ( col4 ) col11 from ( select tab1 . col0 , tab1 . col2 , tab1 . col1 , sum ( tab2 . col3 ) as col4 from col5 col6 , col7 col8 where tab1 . col1 = tab2 . col9 group by tab1 . col1 ) col12 group by col0 ) col13 on tab0 . col0 = tab3 . col0 and tab0 . col4 = tab3 . col11	0
Q_194	how to print the student name in this query	C_194_4	create col0 depts ( col1 int primary key auto_increment , col2 varchar ( codint ) ) create col0 students ( col3 int primary key auto_increment , col4 varchar ( codint ) not null , col1 int , foreign key ( col1 ) references depts ( col1 ) ) create col0 course ( col5 int , col6 varchar ( codint ) , col7 int , foreign key ( col5 ) references students ( col3 ) )	0
Q_194	how to print the student name in this query	C_194_5	insert into depts ( col0 ) values ( refre ) , ( refre ) , ( refre ) insert into students ( col1 , col2 ) values ( refre , codint ) , ( refre , codint ) , ( refre , codint ) , ( refre , codint ) , ( refre , codint ) , ( refre , codint ) , ( refre , codint ) , ( refre , codint ) , ( refre , codint ) insert into course ( col3 , col4 , col5 ) values ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint )	0
Q_194	how to print the student name in this query	C_194_6	+ _ + _ + _ + col0 col1 col2 + _ + _ + _ + codint codint col3 codint codint col4 codint codint col5 + _ + _ + _ +	0
Q_194	how to print the student name in this query	C_194_7	select * from col0 + _ + _ + _ + _ + col1 col2 col3 col4 + _ + _ + _ + _ + codint col5 codint codint codint col6 codint codint codint col7 codint codint codint col8 codint codint codint col9 codint codint codint col10 codint codint codint col11 codint codint codint col12 codint codint codint col13 col14 codint codint + _ + _ + _ + _ + select * from col15 + _ + _ + col1 col16 + _ + _ + codint codint codint codint codint codint + _ + _ +	0
Q_195	"compare row of two dataframes to find the match column count of tagint "" s"	C_195_0	col0 col1 as col2 from tab0 . tab1 . col3 col0 col4 from tab0 . sql col0 col5 as col6 col7 = tab2 . createdataframe ( col8 , col9 ) col10 = tab2 . createdataframe ( col11 , col9 )	1
Q_195	"compare row of two dataframes to find the match column count of tagint "" s"	C_195_1	col0 = vectorassembler ( col1 = col2 , col3 = refre ) col4 = tab0 . transform ( col5 ) col6 = tab0 . transform ( col7 )	0
Q_195	"compare row of two dataframes to find the match column count of tagint "" s"	C_195_2	tab0 . show ( ) + _ + _ + _ + _ + col0 col1 col2 col3 + _ + _ + _ + _ + codint codint codint col4 codint codint codint col4 codint codint codint col4 + _ + _ + _ + _ +	0
Q_195	"compare row of two dataframes to find the match column count of tagint "" s"	C_195_3	col0 get_nonzero_index ( col1 ) ( row , col2 ) = col1 col3 = tab0 . array ( tab1 . col4 ) return ( col2 , tab2 . nonzero ( ) tab3 . tolist ( ) ) col5 = tab4 . tab5 . zipwithindex ( ) . map ( col6 ) col7 = tab6 . tab5 . zipwithindex ( ) . map ( col6 )	0
Q_195	"compare row of two dataframes to find the match column count of tagint "" s"	C_195_4	tab0 . collect ( ) [ ( codint , col0 ) , ( codint , col1 ) , ( codint , col0 ) ] tab1 . collect ( ) [ ( codint , col2 ) , ( codint , col3 ) , ( codint , col0 ) ]	0
Q_195	"compare row of two dataframes to find the match column count of tagint "" s"	C_195_5	col0 = tab0 . createdataframe ( col1 , col2 ) col3 = tab0 . createdataframe ( col4 , col5 ) col6 = tab1 . join ( col3 , tab1 . col7 = = tab2 . col8 )	0
Q_195	"compare row of two dataframes to find the match column count of tagint "" s"	C_195_6	col0 = tab0 . withcolumn ( refre , tab1 . explode ( tab0 . col1 ) ) . withcolumn ( refre , tab1 . explode ( tab0 . col2 ) )	0
Q_195	"compare row of two dataframes to find the match column count of tagint "" s"	C_195_7	col0 = tab0 . withcolumn ( refre , tab0 . col1 = = tab0 . col2 ) col3 = tab1 . withcolumn ( refre , tab1 . tab2 . cast ( refre ) )	0
Q_195	"compare row of two dataframes to find the match column count of tagint "" s"	C_195_8	tab0 . show ( ) + _ + _ + _ + _ + _ + _ + _ + col0 col1 col2 col3 col4 col5 col6 + _ + _ + _ + _ + _ + _ + _ + codint col7 codint col8 codint codint true codint col7 codint col8 codint codint false codint col9 codint col9 codint codint true + _ + _ + _ + _ + _ + _ + _ +	0
Q_195	"compare row of two dataframes to find the match column count of tagint "" s"	C_195_9	tab0 . groupby ( ) . sum ( refre ) . collect ( ) col0 col0 codint	0
Q_196	how to make use of an if in mysql within a store procedure	C_196_0	where tab0 . col0 = col0 and if col1 > codint then tab0 . col1 = col1 end if and tab0 . col2 = codint .	1
Q_196	how to make use of an if in mysql within a store procedure	C_196_1	where tab0 . col0 = col0 and if ( col1 > codint , tab0 . col1 = col1 , true ) and tab0 . col2 = codint .	0
Q_196	how to make use of an if in mysql within a store procedure	C_196_2	where tab0 . col0 = col0 and case when col1 > codint then tab0 . col1 = col1 else true end and tab0 . col2 = codint .	0
Q_196	how to make use of an if in mysql within a store procedure	C_196_3	where tab0 . col0 = col0 and ( not ( col1 > codint ) or tab0 . col1 = col1 ) and tab0 . col2 = codint .	0
Q_196	how to make use of an if in mysql within a store procedure	C_196_4	where tab0 . col0 = col0 and ( col1 < = codint or tab0 . col1 = col1 ) and tab0 . col2 = codint .	0
Q_196	how to make use of an if in mysql within a store procedure	C_196_5	where tab0 . col0 = col0 and ( col1 < = codint or col1 is null or tab0 . col1 = col1 ) and tab0 . col2 = codint .	0
Q_196	how to make use of an if in mysql within a store procedure	C_196_6	where tab0 . col0 = col0 and ( col1 = codint or tab0 . col1 = col1 ) and tab0 . col2 = codint .	0
Q_197	how to convert any delimit text file to parquet avro _ dynamically change column number stucture into avro parquet use spark sql	C_197_0	codint col0 col1 codint new col2 codint col3 col4 codint new col5 codint col6 col7 codint new col8 codint col9 col10 codint new col11 codint col12 col13 codint new col14 codint col15 col16 codint new col17 codint col18 col19 codint new col20 codint col21 col22 codint new col23 codint col24 col25 codint new col26 codint col27 col28 codint new col29	1
Q_197	how to convert any delimit text file to parquet avro _ dynamically change column number stucture into avro parquet use spark sql	C_197_1	/ / col0 col1 session col2 col1 = tab0 . builder ( ) . appname ( refre ) . master ( refre [ * ] refre ) . getorcreate ( ) col3 tab1 . tab2 . col4 / / col5 values to col6 col7 col2 col8 = args ( codint ) . tab3 . tostring ( ) col2 delimiter = refre / / col9 col10 col11 col12 dynamic by col13 col12 as col14 col15 col2 col16 = args ( codint ) . trim ( ) . tostring ( ) col2 col17 = args ( codint ) . trim ( ) . tostring ( )	0
Q_197	how to convert any delimit text file to parquet avro _ dynamically change column number stucture into avro parquet use spark sql	C_197_2	/ / col0 data from col1 file col2 col3 = tab0 . tab1 . textfile ( col4 ) / / split col5 input data using col5 delimiter ( col6 are col7 pipe ( ) as delimiter for col8 col9 ) col2 col10 col11 [ array col12 ] = tab2 . map ( col13 = > tab3 . split ( delimiter , _ codint ) )	0
Q_197	how to convert any delimit text file to parquet avro _ dynamically change column number stucture into avro parquet use spark sql	C_197_3	/ / col0 col1 into col2 with only col3 column _ col4 col5 col6 col2 = tab0 . todf ( refre ) / / col7 temp col8 on col9 of col6 with col10 col11 col8 tab1 . createorreplacetempview ( refre )	0
Q_197	how to convert any delimit text file to parquet avro _ dynamically change column number stucture into avro parquet use spark sql	C_197_4	select cast ( col0 col1 as bigint ) as col2 , col0 col3 as col4 , col0 col5 as col6 , cast ( col0 col7 as decimal ( codint , codint ) ) as col8 , col0 col9 as col10 from col11	0
Q_197	how to convert any delimit text file to parquet avro _ dynamically change column number stucture into avro parquet use spark sql	C_197_5	/ / col0 col1 col2 , col3 col4 are col0 only col1 first row from col1 file / / select sql col5 col6 only col7 row in col1 tab0 . col8 file col9 col10 = tab1 . tab2 . textfile ( col11 ) . first ( ) . tostring ( ) / / col12 col1 output using col1 col13 col9 col14 = tab1 . sql ( col10 )	0
Q_197	how to convert any delimit text file to parquet avro _ dynamically change column number stucture into avro parquet use spark sql	C_197_6	tab0 . tab1 . mode ( tab2 . overwrite ) . parquet ( col0 )	0
Q_197	how to convert any delimit text file to parquet avro _ dynamically change column number stucture into avro parquet use spark sql	C_197_7	col0 _ col1 long ( nullable = true ) _ col2 string ( nullable = true ) _ col3 string ( nullable = true ) _ col4 decimal ( codint , codint ) ( nullable = true ) _ col5 string ( nullable = true )	0
Q_198	how to get the count of distinct i_ds each month which be different from the previous month	C_198_0	count of col0 for each month col1 only include col0 col2 col3 not col4 in col5	1
Q_198	how to get the count of distinct i_ds each month which be different from the previous month	C_198_1	col0 select month , count ( codint ) col1 from ( select * , ifnull ( date_diff ( month , lag ( month ) over ( partition by col2 order by month ) , month ) , codint ) = codint col3 from ( select distinct date_trunc ( col4 , month ) month , col2 from tab0 . tab1 . col5 ) ) where col3 group by month	0
Q_198	how to get the count of distinct i_ds each month which be different from the previous month	C_198_2	col0 with tab0 . tab1 . col1 as ( select date refre col2 , codint col3 , codint col4 , codint col5 union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint ) select month , count ( codint ) col6 from ( select * , ifnull ( date_diff ( month , lag ( month ) over ( partition by col3 order by month ) , month ) , codint ) = codint col7 from ( select distinct date_trunc ( col2 , month ) month , col3 from tab0 . tab1 . col1 ) ) where col7 group by month _ order by month	0
Q_198	how to get the count of distinct i_ds each month which be different from the previous month	C_198_3	row month col0 codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint	0
Q_198	how to get the count of distinct i_ds each month which be different from the previous month	C_198_4	col0 select col1 , count ( codint ) count from ( select * , count ( codint ) over ( partition by col2 order by col1 ) = codint col3 from tab0 . tab1 . col4 ) where col3 group by col1	0
Q_198	how to get the count of distinct i_ds each month which be different from the previous month	C_198_5	row col0 count codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint	0
Q_198	how to get the count of distinct i_ds each month which be different from the previous month	C_198_6	col0 with tab0 . tab1 . col1 as ( select date refre col2 , codint col3 , codint col4 , codint col5 union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint ) select col2 , count ( codint ) count from ( select * , count ( codint ) over ( partition by col3 order by col2 ) = codint col6 from tab0 . tab1 . col1 ) where col6 group by col2 _ order by col2	0
Q_198	how to get the count of distinct i_ds each month which be different from the previous month	C_198_7	col0 with tab0 . tab1 . col1 as ( select date refre col2 , codint col3 , codint col4 , codint col5 union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint union all select refre , codint , codint , codint ) select date_trunc ( col2 , month ) month , count ( codint ) count from ( select * , count ( codint ) over ( partition by col3 order by col2 ) = codint col6 from tab0 . tab1 . col1 ) where col6 group by month _ order by month	0
Q_198	how to get the count of distinct i_ds each month which be different from the previous month	C_198_8	row month count codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint	0
Q_199	index with include in sql server	C_199_0	create col0 col1 col2 on table1 ( col3 , col4 , col5 )	1
Q_199	index with include in sql server	C_199_1	select col0 , col1 , col2 from col3 where col0 = codint and col1 = codint and col2 = codint	0
Q_199	index with include in sql server	C_199_2	create col0 col1 col2 on table1 ( col3 ) include ( col4 , col5 )	0
Q_199	index with include in sql server	C_199_3	select col0 , col1 , col2 from col3 where col0 = codint and col2 = codint	0
Q_199	index with include in sql server	C_199_4	create col0 col1 col2 on table1 ( col3 ) include ( col4 , col5 )	0
Q_199	index with include in sql server	C_199_5	_ col0 _ col1 key ( only col2 values in col2 col0 column are col3 to col4 col2 structure of col2 search col5 ) _ col6 , col7 _ values col8 col9 with col2 col1 key ( col10 are not col3 in col11 col2 structure of col2 search col5 , col10 are col12 / col8 at each col13 level , col9 with col2 col1 key col14 col15 col16 do not col17 to do col6 col18 for col19 column values )	0
Q_199	index with include in sql server	C_199_6	select col0 , col1 , col2 from col3 where col1 = codint	0
Q_199	index with include in sql server	C_199_7	create col0 col1 col2 on table1 ( col3 ) include ( col4 , col5 )	0
Q_199	index with include in sql server	C_199_8	select col0 , col1 , col2 from col3 where col0 = codint and col1 = codint and col2 = codint	0
Q_199	index with include in sql server	C_199_9	create col0 col1 col2 on table1 ( col3 , col4 , col5 )	0
Q_200	how to delete filter the specific row from a spark dataframe	C_200_0	col0 col1 = seq ( ( refre , refre , refre ) , ( refre , refre , refre ) , ( refre , refre , refre ) , ( refre , refre , refre ) , ( refre , refre , refre ) , ( refre , refre , refre ) , ( refre , refre , refre ) , ( refre , refre , refre ) , ( refre , refre , refre ) ) . todf ( refre , refre , refre )	1
Q_200	how to delete filter the specific row from a spark dataframe	C_200_1	col0 col1 = list ( refre , refre , refre ) col0 col2 = list ( codint , codint )	0
Q_200	how to delete filter the specific row from a spark dataframe	C_200_2	tab0 . filter ( ( col ( refre ) . isin ( col0 col1 * ) col ( refre ) . isin ( col2 col1 * ) ) ) . show	0
Q_200	how to delete filter the specific row from a spark dataframe	C_200_3	+ _ + _ + _ + col0 col1 col2 + _ + _ + _ + col3 codint col4 col3 codint col5 col6 codint col7 col6 codint col8 col9 codint col8 col10 codint col11 + _ + _ + _ +	0
Q_200	how to delete filter the specific row from a spark dataframe	C_200_4	col0 col1 = tab0 . filter ( col ( refre ) . isin ( col2 col3 * ) col ( refre ) . isin ( col4 col3 * ) )	0
Q_200	how to delete filter the specific row from a spark dataframe	C_200_5	tab0 . alias ( refre ) . join ( tab1 . alias ( refre ) , seq ( refre , refre ) , refre ) . show	0
Q_200	how to delete filter the specific row from a spark dataframe	C_200_6	+ _ + _ + _ + col0 col1 col2 + _ + _ + _ + col3 codint col4 col3 codint col5 col6 codint col7 col6 codint col8 col9 codint col8 col10 codint col11 + _ + _ + _ +	0
Q_201	match and remove duplicate value from delimit string against another column	C_201_0	select * , stuff ( replace ( refre + col0 , refre + col1 , refre ) , codint , codint , refre ) as col2 from col3	1
Q_201	match and remove duplicate value from delimit string against another column	C_201_1	create col0 yourtable ( names varchar ( codint ) , col1 varchar ( codint ) ) go	0
Q_201	match and remove duplicate value from delimit string against another column	C_201_2	insert into yourtable ( names , col0 ) values ( refre , refre ) , ( refre , refre ) , ( refre , refre ) , ( refre , refre ) go	0
Q_201	match and remove duplicate value from delimit string against another column	C_201_3	_ _ simple replace col0 _ col1 col2 col3 col4 col5 _ select tab0 . * , stuff ( replace ( refre + col6 , refre + col7 , refre ) , codint , codint , refre ) as col8 from col9 col10 go	0
Q_201	match and remove duplicate value from delimit string against another column	C_201_4	_ _ not col0 simple col1 col2 replace _ select tab0 . * , isnull ( left ( stuff ( replace ( refre + col3 + refre , refre + col4 + refre , refre ) , codint , codint , refre ) , nullif ( len ( stuff ( replace ( refre + col3 + refre , refre + col4 + refre , refre ) , codint , codint , refre ) ) , codint ) _ codint ) , refre ) as col5 from col6 col7 go	0
Q_201	match and remove duplicate value from delimit string against another column	C_201_5	_ _ replace trim _ sql col0 codint + _ select tab0 . * , trim ( refre from replace ( refre + col1 + refre , refre + col2 + refre , refre ) ) as col3 from col4 col5 go	0
Q_201	match and remove duplicate value from delimit string against another column	C_201_6	_ _ col0 col1 _ sql col2 codint + _ select tab0 . * , tab1 . col3 from col4 col5 cross apply ( select string_agg ( tab2 . col6 , refre ) as col3 from string_split ( tab0 . col7 , refre ) col8 where tab2 . col6 = tab0 . col9 ) col10 go	0
Q_202	get min max group by two column	C_202_0	create col0 offers ( col1 int , col2 int , col3 int ) insert into offers ( col1 , col2 , col3 ) values ( codint , codint , codint ) , ( codint , codint , codint ) , ( codint , codint , codint ) , ( codint , codint , codint ) , ( codint , codint , codint )	1
Q_202	get min max group by two column	C_202_1	create col0 parts ( col1 int , col2 int , col3 int ) insert into parts ( col1 , col2 , col3 ) values ( codint , null , codint ) , ( codint , codint , codint ) , ( codint , null , codint ) , ( codint , null , codint )	0
Q_202	get min max group by two column	C_202_2	select tab0 . col0 , tab0 . col1 , tab0 . col2 from col3 col4 inner join col5 col6 on tab1 . col7 = tab0 . col1 where col8 = codint and tab1 . col1 is null	0
Q_202	get min max group by two column	C_202_3	select * from ( select tab0 . col0 , tab0 . col1 , tab0 . col2 from col3 col4 inner join col5 col6 on tab1 . col7 = tab0 . col1 where col8 = codint order by col2 limit codint ) col9 union all ( select tab0 . col0 , tab0 . col1 , tab0 . col2 from col3 col4 inner join col5 col6 on tab1 . col7 = tab0 . col1 where col8 = codint order by col2 desc limit codint )	0
Q_202	get min max group by two column	C_202_4	select tab0 . col0 , tab0 . col1 , tab0 . col2 from col3 col4 inner join col5 col6 on tab1 . col7 = tab0 . col1 where col8 = codint order by tab0 . col0 desc limit codint	0
Q_202	get min max group by two column	C_202_5	select tab0 . col0 , tab0 . col1 , tab0 . col2 from col3 col4 inner join col5 col6 on tab1 . col7 = tab0 . col1 where col8 = codint and tab1 . col1 is null order by tab0 . col0 asc limit codint	0
Q_202	get min max group by two column	C_202_6	select min ( tab0 . col0 ) , tab0 . col1 , min ( ( select tab1 . col2 from col3 as col4 where tab1 . col0 = tab0 . col0 order by tab1 . col2 desc limit codint ) ) as col5 from col3 as col6 join col7 col8 on tab2 . col9 = tab0 . col1 where tab2 . col10 = codint and tab2 . col1 is null group by col1 order by col5 asc	0
Q_203	how to filter out from count distinct query	C_203_0	create col0 tab0 . col1 ( col2 col3 identity ( codint , codint ) not null , col4 col3 null , col5 col5 null , constraint col6 primary key ( col2 )	1
Q_203	how to filter out from count distinct query	C_203_1	insert into tab0 . [ customer_invoice ] ( col0 , col1 ) values ( codint , convert ( date , refre ) ) , ( codint , convert ( date , refre ) ) , ( codint , convert ( date , refre ) ) , ( codint , convert ( date , refre ) ) , ( codint , convert ( date , refre ) )	0
Q_203	how to filter out from count distinct query	C_203_2	select col0 , min ( datediff ( col1 , date , getdate ( ) ) ) as col2 from col3 group by col0	0
Q_203	how to filter out from count distinct query	C_203_3	col0 col1 codint codint codint codint codint codint codint codint	0
Q_203	how to filter out from count distinct query	C_203_4	select col0 , col1 , case when col1 < codint then refre when col1 < codint then refre else refre end as col2 from ( select col0 , min ( datediff ( col3 , date , getdate ( ) ) ) as col1 from col4 group by col0 ) as col5	0
Q_203	how to filter out from count distinct query	C_203_5	col0 col1 col2 codint codint col3 col4 codint col5 codint codint col3 col4 codint col5 codint codint col3 col4 codint col5 codint codint not col3	0
Q_203	how to filter out from count distinct query	C_203_6	select col0 , count ( * ) as col1 from ( select col2 , col3 , case when col3 < codint then refre when col3 < codint then refre else refre end as col0 from ( select col2 , min ( datediff ( col4 , date , getdate ( ) ) ) as col3 from col5 group by col2 ) as col6 ) as col7 group by col0	0
Q_203	how to filter out from count distinct query	C_203_7	col0 col1 col2 col3 codint col4 codint col2 col3 codint col4 codint not col2 codint	0
Q_203	how to filter out from count distinct query	C_203_8	select col0 , count ( * ) col1 from ( select min ( datediff ( curdate ( ) , date ) ) as col2 , if ( min ( datediff ( curdate ( ) , date ) ) < codint , refre , if ( min ( datediff ( curdate ( ) , date ) ) < codint , refre , refre ) ) col0 from col3 group by col4 ) as col5 group by col0	0
Q_204	many to many relationship in sql can t get more than one result	C_204_0	create col0 genres ( col1 number ( codint , codint ) generated col2 as identity constraint col3 primary key , col4 varchar2 ( codint ) constraint col5 not null constraint col6 unique )	1
Q_204	many to many relationship in sql can t get more than one result	C_204_1	insert into genres ( col0 ) select refre from col1 union all select refre from col1 union all select refre from col1 union all select refre from col1	0
Q_204	many to many relationship in sql can t get more than one result	C_204_2	create col0 people ( col1 number ( codint , codint ) generated col2 as identity constraint col3 primary key , col4 varchar2 ( codint ) constraint col5 not null , col6 varchar2 ( codint ) constraint col7 not null , col8 date constraint col9 not null )	0
Q_204	many to many relationship in sql can t get more than one result	C_204_3	create col0 roles ( col1 number ( codint , codint ) generated col2 as identity constraint col3 primary key , role varchar2 ( codint ) constraint col4 not null constraint col5 unique )	0
Q_204	many to many relationship in sql can t get more than one result	C_204_4	insert into roles ( role ) select refre from col0 union all select refre from col0 union all select refre from col0	0
Q_204	many to many relationship in sql can t get more than one result	C_204_5	create col0 movies ( col1 number ( codint , codint ) generated col2 as identity constraint col3 primary key , col4 varchar2 ( codint ) constraint col5 not null , length interval col6 to second , col7 date , col8 number ( codint , codint ) , col9 number ( codint , codint ) )	0
Q_204	many to many relationship in sql can t get more than one result	C_204_6	create col0 movie_people ( col1 number ( codint , codint ) generated col2 as identity constraint col3 primary key , col4 number ( codint , codint ) constraint col5 not null constraint col6 references movies ( col1 ) , col7 number ( codint , codint ) constraint col8 not null constraint col9 references roles ( col1 ) , col10 number ( codint , codint ) constraint col11 not null constraint col12 references people ( col1 ) , constraint col13 unique ( col4 , col7 , col10 ) )	0
Q_204	many to many relationship in sql can t get more than one result	C_204_7	create col0 movie_genres ( col1 number ( codint , codint ) generated col2 as identity constraint col3 primary key , col4 number ( codint , codint ) constraint col5 not null constraint col6 references movies ( col1 ) , col7 number ( codint , codint ) constraint col8 not null constraint col9 references genres ( col1 ) , constraint col10 unique ( col4 , col7 ) )	0
Q_204	many to many relationship in sql can t get more than one result	C_204_8	insert into movie_people ( col0 , col1 , col2 ) values ( ( select col3 from col4 where col5 = refre ) , ( select col3 from roles where role = refre ) , ( select col3 from col6 where col7 = refre and col8 = refre ) )	0
Q_204	many to many relationship in sql can t get more than one result	C_204_9	select col0 from col1 where col2 in ( select col3 from col4 where col5 in ( refre , refre ) ) group by col0 having count ( col2 ) = codint	0
Q_205	flatten only deep level in scala spark dataframe	C_205_0	col0 col1 = tab0 . tab1 . map { row = > col2 unnest ( col3 row ) map col4 = { tab2 . tab3 . tab4 . tab5 . col5 { case ( col6 , col7 ) = > ( tab6 . col8 , tab6 . col9 ) match { case ( refre , col10 col11 ) = > col0 col12 = tab2 . col13 [ row ] ( tab6 . col8 ) map ( tab6 . col8 _ > tab7 . tab3 . tab4 . col5 { col14 = > col0 col15 = tab7 . col13 [ row ] ( tab8 . col8 ) tab9 . tab3 . tab4 . map { col16 = > col17 refre _ > tab9 . get ( tab9 . fieldindex ( tab10 . col8 ) ) } } . col18 ) case ( col19 , col10 col11 ) = > map ( col19 _ > unnest ( tab2 . col13 [ row ] ( col19 ) ) ) case ( col19 , arraytype ( col10 col11 , col10 ) ) = > map ( col19 _ > tab2 . col13 [ col20 col21 ] ( col19 ) . map ( unnest ) ) case col10 = > map ( tab6 . col8 _ > tab2 . get ( col7 ) ) } } } . col18 col0 col22 = unnest ( row ) new objectmapper ( ) . registermodule ( col23 ) . writevalueasstring ( col22 ) } col0 col24 = tab11 . tab12 . json ( tab13 . col25 ) . cache	1
Q_205	flatten only deep level in scala spark dataframe	C_205_1	tab0 . printschema ( ) tab0 . show ( false ) tab0 . select ( refre regast refre ) . show ( )	0
Q_205	flatten only deep level in scala spark dataframe	C_205_2	col0 _ col1 string ( nullable = true ) _ col2 struct ( nullable = true ) _ tab0 . col1 string ( nullable = true ) _ tab0 . col3 boolean ( nullable = true ) _ tab0 . col4 long ( nullable = true ) _ tab0 . col5 string ( nullable = true ) _ col6 string ( nullable = true ) + _ + _ + _ + col1 col2 col6 + _ + _ + _ + col7 col8 col9 + _ + _ + _ + + _ + _ + _ + _ + tab0 . col1 tab0 . col3 tab0 . col4 tab0 . col5 + _ + _ + _ + _ + col10 true codint col11 + _ + _ + _ + _ +	0
Q_205	flatten only deep level in scala spark dataframe	C_205_3	col0 col1 = refre refre col2 refre refre col3 refre col4 refre col5 refre refre col6 refre col7 refre refre col8 refre type refre col9 refre refre col4 refre col10 refre refre col11 refre refre col12 refre col13 refre refre refre . tab0 . printschema ( ) tab0 . show ( false )	0
Q_205	flatten only deep level in scala spark dataframe	C_205_4	col0 _ col1 array ( nullable = true ) _ col2 struct ( col3 = true ) _ col4 struct ( nullable = true ) _ col5 string ( nullable = true ) _ col6 struct ( nullable = true ) _ tab0 . col5 string ( nullable = true ) _ tab0 . col7 boolean ( nullable = true ) _ tab0 . col8 long ( nullable = true ) _ tab0 . col9 string ( nullable = true ) _ col10 string ( nullable = true ) + _ + col0 + _ + [ [ [ col11 , col12 , col13 ] ] ] + _ +	0
Q_205	flatten only deep level in scala spark dataframe	C_205_5	col0 unnest ( col1 row ) map col2 = { tab0 . tab1 . tab2 . tab3 . col3 { case ( col4 , col5 ) = > ( tab4 . col6 , tab4 . col7 ) match { case ( refre , col8 col9 ) = > col10 col11 = tab0 . col12 [ row ] ( tab4 . col6 ) map ( tab4 . col6 _ > tab5 . tab1 . tab2 . col3 { col13 = > col10 col14 = option ( tab5 . col12 [ row ] ( tab6 . col6 ) ) tab7 . tab8 . col3 { col15 = > tab9 . tab1 . tab2 . map { col16 = > col17 refre _ > tab9 . get ( tab9 . fieldindex ( tab10 . col6 ) ) } } } . col18 ) case ( col19 , col8 col9 ) = > map ( col19 _ > unnest ( tab0 . col12 [ row ] ( col19 ) ) ) case ( col19 , arraytype ( col8 col9 , col8 ) ) = > map ( col19 _ > tab0 . col12 [ col20 col21 ] ( col19 ) . map ( unnest ) ) case col8 = > map ( tab4 . col6 _ > tab0 . get ( col5 ) ) } } } . col18	0
Q_205	flatten only deep level in scala spark dataframe	C_205_6	col0 _ col1 string ( nullable = true ) _ col2 struct ( nullable = true ) _ tab0 . col1 string ( nullable = true ) _ tab0 . col3 boolean ( nullable = true ) _ tab0 . col4 long ( nullable = true ) _ tab0 . col5 string ( nullable = true ) _ tab1 . col1 string ( nullable = true ) _ tab1 . col3 boolean ( nullable = true ) _ tab1 . col4 long ( nullable = true ) _ tab1 . col5 string ( nullable = true ) _ col6 string ( nullable = true )	0
Q_206	how to assure a deterministic result of a query that use mode in snowflake	C_206_0	with data as ( select col0 , col1 , col2 , col3 from values ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) v ( col0 , col1 , col2 , col3 ) ) select col0 , mode ( col1 ) , mode ( col2 ) , mode ( col3 ) from data group by codint order by codint	1
Q_206	how to assure a deterministic result of a query that use mode in snowflake	C_206_1	with data as ( select col0 , col1 , col2 , col3 from values ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) v ( col0 , col1 , col2 , col3 ) ) select col0 , col1 , col2 , col3 , count ( col1 ) over ( partition by col0 , col1 ) col4 , count ( col2 ) over ( partition by col0 , col2 ) col5 , count ( col3 ) over ( partition by col0 , col3 ) col6 from data	0
Q_206	how to assure a deterministic result of a query that use mode in snowflake	C_206_2	with data as ( select col0 , col1 , col2 , col3 from values ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) v ( col0 , col1 , col2 , col3 ) ) select col0 , col1 , col2 , col3 , row_number ( ) over ( partition by col0 order by col4 desc , col1 ) as col5 , row_number ( ) over ( partition by col0 order by col6 desc , col2 ) as col7 , row_number ( ) over ( partition by col0 order by col8 desc , col3 ) as col9 from ( select col0 , col1 , col2 , col3 , count ( col1 ) over ( partition by col0 , col1 ) col4 , count ( col2 ) over ( partition by col0 , col2 ) col6 , count ( col3 ) over ( partition by col0 , col3 ) col8 from data ) order by codint	0
Q_206	how to assure a deterministic result of a query that use mode in snowflake	C_206_3	col0 col1 col2 col3 col4 col5 col6 codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_206	how to assure a deterministic result of a query that use mode in snowflake	C_206_4	col0 row_number ( ) over ( partition by col1 order by col2 desc , col3 ) = codint and row_number ( ) over ( partition by col1 order by col4 desc , col5 ) = codint and row_number ( ) over ( partition by col1 order by col6 desc , col7 desc ) = codint	0
Q_206	how to assure a deterministic result of a query that use mode in snowflake	C_206_5	with data as ( select col0 , col1 , col2 , col3 from values ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) , ( codint , codint , codint , codint ) v ( col0 , col1 , col2 , col3 ) ) , col4 as ( select col0 , col1 , count ( * ) as col5 from data group by codint , codint col6 row_number ( ) over ( partition by col0 order by col5 desc , col1 ) = codint ) , col7 as ( select col0 , col2 , count ( * ) as col5 from data group by codint , codint col6 row_number ( ) over ( partition by col0 order by col5 desc , col2 ) = codint ) , col8 as ( select col0 , col3 , count ( * ) as col5 from data group by codint , codint col6 row_number ( ) over ( partition by col0 order by col5 desc , col3 ) = codint ) , col9 as ( select distinct col0 from data ) select tab0 . col0 , tab1 . col1 , tab2 . col2 , tab3 . col3 from col9 as col10 left join col4 as col11 on tab0 . col0 = tab1 . col0 left join col7 as col12 on tab0 . col0 = tab2 . col0 left join col8 as col13 on tab0 . col0 = tab3 . col0 order by codint	0
Q_206	how to assure a deterministic result of a query that use mode in snowflake	C_206_6	col0 col1 col2 col3 codint codint codint codint codint codint codint codint	0
Q_207	how to have a column at true for only one in several link row and the rest at false	C_207_0	start transaction update col0 set col1 = true where number = refre _ col2 for col3 col4 col5 are col6 col1 col7 for col3 tab0 . update col0 set col1 = false where number = refre commit _ col8 col9 col10 col11 col1 number tab1 .	1
Q_207	how to have a column at true for only one in several link row and the rest at false	C_207_1	start transaction update col0 set col1 = false where number = refre _ col2 for col3 col4 col5 are only col6 col7 for col3 tab0 . update col0 set col1 = true where number = refre commit _ col8 col9 col10 col11 col1 number tab1 .	0
Q_207	how to have a column at true for only one in several link row and the rest at false	C_207_2	start transaction update col0 set col1 = true where number = refre commit _ col2 are col3 col1 col4 now for col5 tab0 .	0
Q_207	how to have a column at true for only one in several link row and the rest at false	C_207_3	start transaction update col0 set col1 = false where number = refre commit _ col2 are only col3 col4 now for col5 tab0 .	0
Q_207	how to have a column at true for only one in several link row and the rest at false	C_207_4	create col0 user_phone ( col1 int not null , col2 varchar ( codint ) not null , col3 int not null , unique ( col1 , col2 ) , unique ( col1 , col3 ) )	0
Q_207	how to have a column at true for only one in several link row and the rest at false	C_207_5	select col0 , col1 , case when row_number ( ) over ( partition by col0 order by col2 ) = codint then refre else refre end as type from col3 order by col0 , type	0
Q_207	how to have a column at true for only one in several link row and the rest at false	C_207_6	update col0 set col1 = col1 + codint where col2 = codint _ col3 col4 col5 order , col3 col4 col5 col6 tab0 . update col0 set col1 = codint where col2 = codint and col7 = refre _ col7 refre is col4 new col6 number for col8 codint .	0
Q_208	how to sort an eav model that have null value	C_208_0	select * from col0 col1 left join col0 col2 on ( tab0 . col3 = tab1 . col3 and tab1 . col4 = codint ) where tab0 . col4 = codint _ col5 all col6 col7 col8 col9 order by tab1 . col0	1
Q_208	how to sort an eav model that have null value	C_208_1	col0 col1 col2 col0 col1 col2 _ _ _ _ codint codint refre codint codint refre codint codint refre codint codint refre codint codint refre null null null	0
Q_208	how to sort an eav model that have null value	C_208_2	select tab0 . col0 , tab1 . col1 , tab0 . col2 , tab2 . col1 , tab3 . col2 from col2 col3 join col4 col5 on tab0 . col6 = tab1 . col6 left join col2 col7 on ( tab0 . col0 = tab3 . col0 and tab3 . col6 = codint ) left join col4 col8 on tab3 . col6 = tab2 . col6 where tab1 . col1 = refre _ col9 all col10 col11 col12 col1 order by tab3 . col2	0
Q_208	how to sort an eav model that have null value	C_208_3	col0 col1 col2 col1 col2 _ _ _ _ codint refre refre refre refre codint refre refre refre refre codint refre refre null null	0
Q_208	how to sort an eav model that have null value	C_208_4	insert into col0 values ( codint ) insert into col0 values ( codint ) insert into col1 values ( codint , codint , refre )	0
Q_208	how to sort an eav model that have null value	C_208_5	select * from col0 col1 left join col2 col3 on ( tab0 . col4 = tab1 . col4 and tab1 . col5 = codint ) _ col6 left join col2 col7 on ( tab0 . col4 = tab2 . col4 and tab2 . col5 = codint ) _ col8 _ order by tab2 . col2 is null _ col8 nulls last	0
Q_208	how to sort an eav model that have null value	C_208_6	col0 col0 col1 col2 col0 col1 col2 _ _ _ _ _ _ _ codint codint codint refre codint codint refre codint codint codint refre codint codint refre codint null null null codint codint refre codint codint codint refre null null null codint null null null null null null	0
Q_209	add output generate from an exist column as a new column to the table	C_209_0	alter col0 col1 add column col2 date as ( current_date + interval codint week ) select * from col1	1
Q_209	add output generate from an exist column as a new column to the table	C_209_1	create view col0 as select * , current_date + interval codint week as col1 from col2 select * from col0	0
Q_209	add output generate from an exist column as a new column to the table	C_209_2	current_date col0 codint _ codint _ codint codint _ codint _ codint codint _ codint _ codint codint _ codint _ codint codint _ codint _ codint codint _ codint _ codint codint _ codint _ codint codint _ codint _ codint	0
Q_209	add output generate from an exist column as a new column to the table	C_209_3	select * , current_date + interval codint week as col0 from col1	0
Q_209	add output generate from an exist column as a new column to the table	C_209_4	current_date col0 codint _ codint _ codint codint _ codint _ codint codint _ codint _ codint codint _ codint _ codint codint _ codint _ codint codint _ codint _ codint codint _ codint _ codint codint _ codint _ codint	0
Q_209	add output generate from an exist column as a new column to the table	C_209_5	select * , current_date + interval codint week as col0 from col1	0
Q_209	add output generate from an exist column as a new column to the table	C_209_6	current_date col0 codint _ codint _ codint codint _ codint _ codint codint _ codint _ codint codint _ codint _ codint codint _ codint _ codint codint _ codint _ codint codint _ codint _ codint codint _ codint _ codint	0
Q_210	how to pass parameter of oracle sql script file to sqlplus from shell prompt	C_210_0	/ col0 / col1 col2 = refre col3 = refre host = codint . tab0 . tab1 . col4 col5 = codint col6 = col7 col8 = host col5 / col6 col9 col2 col2 col9 col3 col3 col9 host host col9 col5 col5 col9 col6 col10 col9 col8 col8 col9 _ col11 refre col12 _ col13 col2 / col3 col8	1
Q_210	how to pass parameter of oracle sql script file to sqlplus from shell prompt	C_210_1	col0 col1 > . / tab0 . col2 col3 refre col4 refre host codint . tab1 . tab2 . col5 col6 codint col7 col8 codint . tab1 . tab2 . col5 codint / col1 col9 is refre codint _ codint col10 _ codint _ col11 _ codint col0 col1 >	0
Q_210	how to pass parameter of oracle sql script file to sqlplus from shell prompt	C_210_2	/ col0 / col1 col2 = refre col3 = refre col4 col2 col2 col4 col3 col3 col5 = ( col6 _ col7 col2 / col3 < < col8 set col9 codint col10 off col11 off col12 off col4 off show col13 select to_char ( col14 , refre ) refre from col15 tab0 . sql exit col8 ) col4 col5	0
Q_210	how to pass parameter of oracle sql script file to sqlplus from shell prompt	C_210_3	col0 col1 > . / tab0 . col2 col3 refre col4 refre col5 is refre codint _ codint _ codint codint codint col6 col7 col0 col1 >	0
Q_210	how to pass parameter of oracle sql script file to sqlplus from shell prompt	C_210_4	/ col0 / col1 col2 _ col3 _ col4 _ col5 col6 _ col7 refre refre refre refre	0
Q_210	how to pass parameter of oracle sql script file to sqlplus from shell prompt	C_210_5	tab0 . / tab1 . col0 col1 refre col2 refre col3 is refre codint _ codint _ codint codint codint col4 col5	0
Q_210	how to pass parameter of oracle sql script file to sqlplus from shell prompt	C_210_6	/ col0 / col1 col2 = refre col3 = refre col4 col2 col2 col4 col3 col3 col5 = ( col6 / col0 / col7 _ col8 col2 / col3 < < col9 set col10 codint col11 off col12 off col13 off col4 off show col14 select to_char ( col15 , refre ) refre from col16 / col17 / col18 / tab0 . sql exit col9 ) col4 col5	0
Q_211	how to convert joi_ns to i_ns clause	C_211_0	select distinct * from col0 where tab0 . col1 in ( select tab1 . col1 from col2 where tab1 . col3 in ( select tab2 . col3 from col4 where col5 < col6 ) ) group by tab0 . col1	1
Q_211	how to convert joi_ns to i_ns clause	C_211_1	create col0 price ( col1 decimal ( codint , codint ) not null , col2 varchar ( codint ) not null , col3 decimal ( codint , codint ) default null , col4 decimal ( codint , codint ) default null , primary key ( col1 ) )	0
Q_211	how to convert joi_ns to i_ns clause	C_211_2	create col0 movie ( col1 decimal ( codint , codint ) not null , col2 varchar ( codint ) not null , col3 decimal ( codint , codint ) default null , col4 decimal ( codint , codint ) default null , col5 varchar ( codint ) default null , col6 decimal ( codint , codint ) default null , primary key ( col1 ) , key price_code ( col6 ) , constraint col7 foreign key ( col6 ) references price ( col6 ) )	0
Q_211	how to convert joi_ns to i_ns clause	C_211_3	create col0 video ( col1 decimal ( codint , codint ) not null , col2 date default null , col3 decimal ( codint , codint ) default null , primary key ( col1 ) , key movie_num ( col3 ) , constraint col4 foreign key ( col3 ) references movie ( col3 ) )	0
Q_211	how to convert joi_ns to i_ns clause	C_211_4	create col0 membership ( col1 decimal ( codint , codint ) not null , col2 varchar ( codint ) not null , col3 varchar ( codint ) not null , col4 varchar ( codint ) default null , col5 varchar ( codint ) default null , col6 char ( codint ) default null , col7 char ( codint ) default null , col8 decimal ( codint , codint ) default null , primary key ( col1 ) )	0
Q_211	how to convert joi_ns to i_ns clause	C_211_5	create col0 rental ( col1 decimal ( codint , codint ) not null , col2 date default null , col3 decimal ( codint , codint ) default null , primary key ( col1 ) , key mem_num ( col3 ) , constraint col4 foreign key ( col3 ) references membership ( col3 ) )	0
Q_211	how to convert joi_ns to i_ns clause	C_211_6	create col0 detailrental ( col1 decimal ( codint , codint ) not null , col2 decimal ( codint , codint ) not null , col3 decimal ( codint , codint ) default null , col4 date default null , col5 date default null , col6 decimal ( codint , codint ) default null , primary key ( col1 , col2 ) , key vid_num ( col2 ) , constraint col7 foreign key ( col1 ) references rental ( col1 ) , constraint col8 foreign key ( col2 ) references video ( col2 ) )	0
Q_211	how to convert joi_ns to i_ns clause	C_211_7	select distinct * from col0 where tab0 . col1 in ( select tab1 . col1 from col2 where tab1 . col3 in ( select tab2 . col3 from col4 where col5 < col6 ) ) group by tab0 . col1	0
Q_212	how can i show data from tagint table use ajax and laravel	C_212_0	create col0 employer_profiles ( col1 bigint ( codint ) unsigned not null auto_increment , col2 varchar ( codint ) collate col3 not null , col4 varchar ( codint ) collate col3 not null , col5 timestamp null default null , col6 timestamp null default null , primary key ( col1 ) ) engine = col7 auto_increment = codint default charset = col8 collate = col3	1
Q_212	how can i show data from tagint table use ajax and laravel	C_212_1	create col0 job_posts ( col1 bigint ( codint ) unsigned not null auto_increment , col2 int ( codint ) unsigned not null , col3 varchar ( codint ) collate col4 not null , col5 timestamp null default null , col6 timestamp null default null , primary key ( col1 ) ) engine = col7 auto_increment = codint default charset = col8 collate = col4	0
Q_212	how can i show data from tagint table use ajax and laravel	C_212_2	insert into employer_profiles ( col0 , col1 , col2 , col3 , col4 ) values ( codint , refre , refre , refre , refre ) , ( codint , refre , refre , refre , refre ) , ( codint , refre , refre , refre , refre )	0
Q_212	how can i show data from tagint table use ajax and laravel	C_212_3	insert into job_posts ( col0 , col1 , col2 , col3 , col4 ) values ( codint , codint , refre , refre , refre ) , ( codint , codint , refre , refre , refre ) , ( codint , codint , refre , refre , refre ) , ( codint , codint , refre , refre , refre )	0
Q_212	how can i show data from tagint table use ajax and laravel	C_212_4	col0 col1 use col2 database col3 col4 class col5 col6 col4 { public function jobposts ( ) { return col7 _ > hasmany ( refre ) } }	0
Q_212	how can i show data from tagint table use ajax and laravel	C_212_5	col0 col1 use col2 database col3 col4 class col5 col6 col4 { / / }	0
Q_212	how can i show data from tagint table use ajax and laravel	C_212_6	use col0 col1 use col0 col2 all = col2 all ( ) foreach ( all as col3 ) { col4 _ > line ( col3 _ > col5 ) foreach ( col3 _ > col6 as col7 ) { col4 _ > line ( refre . col7 _ > col8 ) } }	0
Q_212	how can i show data from tagint table use ajax and laravel	C_212_7	col0 col1 col2 col3 use col4 col2 col5 use col1 col6 class col7 col8 col9 { public function index1 ( ) { all = col6 all ( ) output = col10 foreach ( all as col11 ) { foreach ( col11 _ > col12 as col13 ) { output col10 = col14 } } / / output json return response ( ) _ > json ( output ) } }	0
Q_213	spark parse a date timestamps with different format in same column of a dataframe	C_213_0	col0 tab0 . tab1 . col1 col0 tab0 . tab1 . col2 col0 tab0 . tab1 . localtime col0 tab0 . tab1 . tab2 . col3 col0 tab3 . tab4 . col4 col5 totimestamp ( date col6 , col7 col8 col9 ) option col10 = { col11 out = ( for ( col12 < _ col7 ) col13 { col11 col14 = new datetimeformatterbuilder ( ) . parsecaseinsensitive ( ) . appendpattern ( col12 ) . toformatter ( ) if ( try ( tab0 . tab5 . tab6 . valueof ( tab7 . parse ( date , col14 ) ) ) . col15 ) option ( tab0 . tab5 . tab6 . valueof ( tab7 . parse ( date , col14 ) ) ) else none } ) . filter ( tab8 . col16 ) if ( tab9 . col17 ) none else tab9 . col18 }	1
Q_213	spark parse a date timestamps with different format in same column of a dataframe	C_213_1	col0 utotimestamp ( col1 col2 col3 ) = tab0 . tab1 . tab2 . tab3 . tab4 . udf ( ( date col4 ) = > totimestamp ( date , col1 ) )	0
Q_213	spark parse a date timestamps with different format in same column of a dataframe	C_213_2	"col0 col1 = seq ( ( refre ) , ( refre ) , ( refre ) , ( refre refre refre ) , ( refre refre refre ) , ( refre refre refre ) , ( refre refre refre ) ) . todf ( refre ) col0 col2 = seq ( refre , refre refre refre ) tab0 . select ( utotimestamp ( col2 ) ( "" col3 ) ) . show"	0
Q_213	spark parse a date timestamps with different format in same column of a dataframe	C_213_3	+ _ + udf ( col0 ) + _ + codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint + _ +	0
Q_213	spark parse a date timestamps with different format in same column of a dataframe	C_213_4	col0 withtimestampparsed ( col1 col2 , col3 col4 col5 , col6 col4 col5 ) col2 = { col7 col8 = tab0 . tab1 . map { col9 = > { if ( tab2 . contains ( col9 ) ) utotimestamp ( col6 ) ( col ( col9 ) ) alias ( col9 ) else col ( col9 ) } }	0
Q_213	spark parse a date timestamps with different format in same column of a dataframe	C_213_5	/ / col0 col1 col2 as col3 column names in col4 sequence to col5 col6 withtimestampparsed ( col7 , seq ( refre ) , col8 ) . show	0
Q_213	spark parse a date timestamps with different format in same column of a dataframe	C_213_6	+ _ + col0 + _ + codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint codint _ codint _ codint codint codint codint + _ +	0
Q_213	spark parse a date timestamps with different format in same column of a dataframe	C_213_7	col0 to_timestamp_simple ( col1 tab0 . tab1 . tab2 . tab3 . column , col2 col3 col4 ) tab0 . tab1 . tab2 . tab3 . column = { coalesce ( tab4 . map ( col5 = > to_timestamp ( col1 , col5 ) ) col6 * ) }	0
Q_213	spark parse a date timestamps with different format in same column of a dataframe	C_213_8	col0 withtimestampparsedsimple ( col1 col2 , col3 col4 col5 , col6 col4 col5 ) col2 = { col7 col8 = tab0 . tab1 . map { col9 = > { if ( tab2 . contains ( col9 ) ) to_timestamp_simple ( col ( col9 ) , col6 ) alias ( col9 ) else col ( col9 ) } } tab0 . select ( col8 col10 * ) }	0
Q_213	spark parse a date timestamps with different format in same column of a dataframe	C_213_9	"tab0 . select ( to_timestamp_simple ( refre refre refre refre refre refre refre refre refre col0 "" ) , col1 ) . show"	0
Q_214	sql table join with weight	C_214_0	row_number ( ) over ( order by seq4 ( ) )	1
Q_214	sql table join with weight	C_214_1	col0 col1 col2 col3 col4 col5 col6 codint col7 codint codint _ codint _ codint codint _ codint _ codint number codint number codint col7 codint codint _ codint _ codint codint _ codint _ codint number codint number codint col7 codint codint _ codint _ codint codint _ codint _ codint number codint number codint col7 codint codint _ codint _ codint codint _ codint _ codint number codint number codint col7 codint codint _ codint _ codint codint _ codint _ codint number codint number codint col7 codint codint _ codint _ codint codint _ codint _ codint number codint tab0 .	0
Q_214	sql table join with weight	C_214_2	select tab0 . col0 , tab1 . col1 , sum ( tab0 . col2 * tab1 . col3 ) as col4 , round ( col4 / codint , codint ) as col5 from col6 col7 join col8 col9 on tab0 . col10 = tab1 . col11 group by codint , codint order by codint , codint	0
Q_214	sql table join with weight	C_214_3	col0 col1 col2 col3 codint col4 codint number number codint col4 codint number number codint col4 codint number number codint col4 codint number number codint col4 codint number number codint col4 codint number number codint col4 codint number number codint col4 codint number number codint col4 codint number number codint col4 codint number number codint col4 codint number number codint col4 codint number number	0
Q_214	sql table join with weight	C_214_4	, max ( tab0 . col0 ) as col1 / * month in col2 where col3 col4 col5 col6 * /	0
Q_214	sql table join with weight	C_214_5	col0 , col1 , col2 , sum ( col3 ) / codint as col4 from ( select tab0 . col0 , tab1 . col1 , tab1 . col5 , tab1 . col6 , tab0 . col7 , tab1 . col8 , tab0 . col7 * tab1 . col8 as col3 , first_value ( tab1 . col6 ) over ( partition by tab0 . col0 , tab1 . col1 order by tab0 . col7 desc ) as col2 from col9 col10 join col11 col12 on tab0 . col13 = tab1 . col6 ) group by codint , codint , codint order by codint , codint	0
Q_214	sql table join with weight	C_214_6	col0 col1 col2 col3 codint col4 codint codint _ codint _ codint number codint col4 codint codint _ codint _ codint number codint col4 codint codint _ codint _ codint number codint col4 codint codint _ codint _ codint number codint col4 codint codint _ codint _ codint number codint col4 codint codint _ codint _ codint number codint col4 codint codint _ codint _ codint number codint col4 codint codint _ codint _ codint number codint col4 codint codint _ codint _ codint number codint col4 codint codint _ codint _ codint number codint col4 codint codint _ codint _ codint number codint col4 codint codint _ codint _ codint number	0
Q_215	pyspark aggregate while find the first value of the group	C_215_0	+ _ + _ + _ + _ + _ + col0 date month col1 col2 + _ + _ + _ + _ + _ + codint codint _ codint _ codint codint _ codint codint codint codint codint _ codint _ codint codint _ codint codint codint codint codint _ codint _ codint codint _ codint codint codint codint codint _ codint _ codint codint _ codint codint codint codint codint _ codint _ codint codint _ codint codint codint codint codint _ codint _ codint codint _ codint codint codint codint codint _ codint _ codint codint _ codint codint codint codint codint _ codint _ codint codint _ codint codint codint codint codint _ codint _ codint codint _ codint codint codint + _ + _ + _ + _ + _ +	1
Q_215	pyspark aggregate while find the first value of the group	C_215_1	col0 = tab0 . groupby ( refre , refre ) . agg ( tab1 . sum ( refre ) , tab1 . min ( refre ) , tab1 . max ( refre ) , tab1 . expr ( refre refre refre refre ) ) tab2 . show ( )	0
Q_215	pyspark aggregate while find the first value of the group	C_215_2	+ _ + _ + _ + _ + _ + _ + col0 month sum ( col1 ) min ( col1 ) max ( col1 ) max_by ( col2 , date ) + _ + _ + _ + _ + _ + _ + codint codint _ codint codint codint codint codint codint codint _ codint codint codint codint codint + _ + _ + _ + _ + _ + _ +	0
Q_215	pyspark aggregate while find the first value of the group	C_215_3	col0 = tab0 . partitionby ( refre , refre ) . orderby ( tab1 . desc ( refre ) ) col1 = tab2 . withcolumn ( refre , tab1 . row_number ( ) . over ( col0 ) ) . where ( refre ) . drop ( refre ) . select ( refre , refre , refre ) tab3 . show ( )	0
Q_215	pyspark aggregate while find the first value of the group	C_215_4	+ _ + _ + _ + col0 month col1 + _ + _ + _ + codint codint _ codint codint codint codint _ codint codint + _ + _ + _ +	0
Q_215	pyspark aggregate while find the first value of the group	C_215_5	col0 = tab0 . join ( col1 , col2 ) tab1 . show ( )	0
Q_215	pyspark aggregate while find the first value of the group	C_215_6	+ _ + _ + _ + _ + _ + _ + col0 month sum ( col1 ) min ( col1 ) max ( col1 ) col2 + _ + _ + _ + _ + _ + _ + codint codint _ codint codint codint codint codint codint codint _ codint codint codint codint codint + _ + _ + _ + _ + _ + _ +	0
Q_216	deduplication of row that almost the same in big_query	C_216_0	col0 select as col1 any_value ( col2 ) from tab0 . tab1 . col3 col2 group by format ( refre , ( select as col4 * except ( col5 ) from unnest ( col6 ) ) )	1
Q_216	deduplication of row that almost the same in big_query	C_216_1	col0 with tab0 . tab1 . col1 as ( select codint col2 , refre col3 , codint col4 union all select codint , refre , codint union all select codint , refre , codint union all select codint , refre , codint ) select as col5 any_value ( col6 ) from tab0 . tab1 . col1 col6 group by format ( refre , ( select as col7 * except ( col4 ) from unnest ( col8 ) ) )	0
Q_216	deduplication of row that almost the same in big_query	C_216_2	row col0 col1 col2 codint codint col3 codint codint codint col4 codint	0
Q_216	deduplication of row that almost the same in big_query	C_216_3	col0 select as col1 array_agg ( col2 order by col3 desc limit codint ) col4 from tab0 . tab1 . col5 col2 group by format ( refre , ( select as col6 * except ( col3 ) from unnest ( col7 ) ) )	0
Q_216	deduplication of row that almost the same in big_query	C_216_4	row col0 col1 col2 codint codint col3 codint codint codint col4 codint	0
Q_216	deduplication of row that almost the same in big_query	C_216_5	col0 select array_agg ( col1 order by col2 desc limit codint ) tab0 . * , array_agg ( col2 ) col3 from tab1 . tab2 . col4 col5 , unnest ( [ ( select as col6 * except ( col2 ) from unnest ( col7 ) ) ] ) col1 group by format ( refre , col1 )	0
Q_216	deduplication of row that almost the same in big_query	C_216_6	row col0 col1 col2 codint codint col3 codint codint codint codint col4 codint codint	0
Q_217	be there a way to store both a panda dataframe and separate string var in the same sq_lite table	C_217_0	col0 col1 col0 col2 col0 col3 as col4 col0 col5 col6 = tab0 . dataframe ( { refre range ( codint ) , refre range ( codint , codint ) } ) col7 = tab1 . encode ( tab2 . dumps ( col6 ) , refre ) . decode ( )	1
Q_217	be there a way to store both a panda dataframe and separate string var in the same sq_lite table	C_217_1	col0 col1 codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_217	be there a way to store both a panda dataframe and separate string var in the same sq_lite table	C_217_2	col0 = tab0 . connect ( refre ) col1 = tab1 . cursor ( ) tab2 . execute ( refre refre refre refre refre refre ) tab2 . execute ( refre refre refre refre , { refre refre , refre col2 } ) tab1 . commit ( ) tab2 . execute ( refre regast refre ) result = tab2 . fetchall ( ) col3 = tab3 . loads ( tab4 . decode ( result col4 tab5 . encode ( ) , refre ) ) tab1 . close ( )	0
Q_217	be there a way to store both a panda dataframe and separate string var in the same sq_lite table	C_217_3	col0 col1 codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_217	be there a way to store both a panda dataframe and separate string var in the same sq_lite table	C_217_4	col0 col1 as col2 from col3 col0 col4 col5 = tab0 . dataframe ( { refre range ( codint ) , refre range ( codint , codint ) } )	0
Q_217	be there a way to store both a panda dataframe and separate string var in the same sq_lite table	C_217_5	col0 col1 codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_217	be there a way to store both a panda dataframe and separate string var in the same sq_lite table	C_217_6	col0 col1 = refre engine = create_engine ( refre refre refre , col2 = false ) tab0 . to_sql ( refre , col3 = engine ) col4 = tab1 . execute ( refre regast refre ) . fetchall ( ) col4 = tab2 . read_sql ( refre , col3 = engine )	0
Q_217	be there a way to store both a panda dataframe and separate string var in the same sq_lite table	C_217_7	index col0 col1 col2 codint codint codint codint col3 col4 col2 codint codint codint codint col3 col4 col2 codint codint codint codint col3 col4 col2 codint codint codint codint col3 col4 col2 codint codint codint codint col3 col4 col2	0
Q_218	oracle update record with tagint to many table relationship in a trigger	C_218_0	create col0 person ( col1 number primary key , col2 varchar2 ( codint ) unique , col3 varchar2 ( codint ) _ , col4 varchar2 ( codint ) < _ not col5 ) create col0 consolidated_numbers ( col6 varchar2 ( codint ) references person ( col2 ) , col7 number references person ( col1 ) ) create col0 code ( col8 varchar2 ( codint ) primary key ) _ check constraint col9 to col10 only col11 col12 create col0 history_transaction ( col13 varchar2 ( codint ) references code ( col8 ) _ valid col14 col15 by col16 constraint , col7 number references person ( col1 ) , col17 number check ( col17 in ( codint , codint , codint , codint , codint , codint , codint , codint , codint , codint _ only col10 col18 col12 ) ) , col19 date )	1
Q_218	oracle update record with tagint to many table relationship in a trigger	C_218_1	_ insert col0 initial col1 data begin insert into person ( col2 , col3 , col4 ) values ( codint , refre , null ) insert into person ( col2 , col3 , col4 ) values ( codint , refre , refre ) insert into consolidated_numbers ( col5 , col6 ) values ( refre , codint ) insert into code ( col7 ) values ( refre ) insert into code ( col7 ) values ( refre ) insert into code ( col7 ) values ( refre ) insert into history_transaction ( col8 , col6 , col9 , col10 ) values ( refre , codint , codint , date refre ) commit end /	0
Q_218	oracle update record with tagint to many table relationship in a trigger	C_218_2	create or replace view col0 as with col1 as ( select distinct col2 from col3 ) select col2 , refre as col4 _ col5 all col6 from col3 from col1 union select tab0 . col7 , refre as col4 _ col8 all col6 col9 with col10 from col11 from col12 col13 join col14 col15 on tab0 . col16 = tab1 . col17 and tab1 . col2 in ( select col2 from col1 ) _ with col18 initial col19 data , col20 get select * from col0 + _ + _ + col2 col4 + _ + _ + codint col21 codint col21 + _ + _ +	0
Q_218	oracle update record with tagint to many table relationship in a trigger	C_218_3	_ col0 codint delete from col1 select * from col2 _ result no rows col3 _ > col4 _ col0 codint insert into history_transaction ( col5 , col6 , col7 , col8 ) values ( refre , codint , codint , date refre ) select * from col2 + _ + _ + col6 col9 + _ + _ + codint col10 codint col10 + _ + _ + _ col0 codint add more col11 begin _ new col12 codint col13 with col12 codint insert into person ( col14 , col15 , col16 ) values ( codint , refre , refre ) insert into consolidated_numbers ( col17 , col6 ) values ( refre , codint ) commit end / select * from col2 + _ + _ + col6 col9 + _ + _ + codint col10 codint col10 codint col10 + _ + _ +	0
Q_218	oracle update record with tagint to many table relationship in a trigger	C_218_4	_ col0 codint _ add more col1 _ no col2 in col3 for person ( col4 ) codint begin insert into person ( col4 , col5 , col6 ) values ( codint , refre , null ) insert into person ( col4 , col5 , col6 ) values ( codint , refre , refre ) insert into consolidated_numbers ( col7 , col8 ) values ( refre , codint ) commit end / _ output col9 col10 col11 col12 as before _ > result col13 select * from col14 + _ + _ + col8 col15 + _ + _ + codint col16 codint col16 codint col16 + _ + _ +	0
Q_218	oracle update record with tagint to many table relationship in a trigger	C_218_5	create col0 person ( col1 number primary key , col2 varchar2 ( codint ) unique , col3 varchar2 ( codint ) , col4 varchar2 ( codint ) check ( col4 in ( null , refre ) ) ) _ all col5 tables col6 as before	0
Q_218	oracle update record with tagint to many table relationship in a trigger	C_218_6	create or replace package col0 is _ col1 out col2 col3 col4 id ( col5 col6 ) is col3 refre or col3 refre function isparent ( col7 number ) return boolean _ set refre values col7 is col3 refre procedure setx_parentchildren ( col7 number ) _ set refre values col7 is col3 refre procedure setx_childsiblings ( col7 number ) end col0 /	0
Q_218	oracle update record with tagint to many table relationship in a trigger	C_218_7	create or replace trigger col0 after insert or update on col1 for each row begin if tab0 . isparent ( tab1 . col2 ) then tab0 . setx_parentchildren ( tab1 . col2 ) else tab0 . setx_childsiblings ( tab1 . col2 ) end if end col0 /	0
Q_219	my_sql order by weight field	C_219_0	create col0 article_tags ( col1 bigint ( codint ) not null auto_increment , col2 bigint ( codint ) default null , col3 varchar ( codint ) default null , col4 int ( codint ) default null , primary key ( col1 ) ) engine = col5 default charset = col6	1
Q_219	my_sql order by weight field	C_219_1	insert into article_tags ( col0 , col1 , col2 ) values ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint ) , ( codint , refre , codint )	0
Q_219	my_sql order by weight field	C_219_2	insert into article_tags ( col0 , col1 , col2 ) values ( codint , refre , codint ) , ( codint , refre , codint )	0
Q_219	my_sql order by weight field	C_219_3	select tab0 . col0 , col1 , ( col2 / codint * col3 ) col4 from col5 col6 inner join ( select col0 , sum ( col2 ) / count ( * ) col3 from col5 group by col0 ) col7 on tab0 . col0 = tab1 . col0	0
Q_219	my_sql order by weight field	C_219_4	select col0 , sum ( col1 ) / count ( * ) col2 from col3 group by col0	0
Q_219	my_sql order by weight field	C_219_5	select col0 , sum ( col1 ) / count ( * ) col2 , count ( * ) col3 from col4 group by col0	0
Q_219	my_sql order by weight field	C_219_6	all col0 col1 col2 col3 col4 and col5 col6 col7 col8 codint col9 codint select col10 from ( select tab0 . col10 , col3 , ( col7 / codint * col11 ) col12 from col13 col14 inner join ( select col10 , sum ( col7 ) / count ( * ) col11 from col13 group by col10 ) col15 on tab0 . col10 = tab1 . col10 ) col16 where col3 = refre and col12 between codint and codint	0
Q_219	my_sql order by weight field	C_219_7	select tab0 . col0 , tab0 . col1 , ( tab0 . col2 / codint * tab1 . col2 ) col3 from col4 col5 inner join ( select col1 , col2 from col4 where col0 = codint ) col6 on tab0 . col1 = tab1 . col1 and tab0 . col1 = refre and tab0 . col0 = codint	0
Q_219	my_sql order by weight field	C_219_8	select tab0 . col0 , tab0 . col1 , ( tab0 . col2 / codint * tab1 . col2 ) col3 from col4 col5 inner join ( select col1 , col2 from col4 where col0 = codint ) col6 on tab0 . col1 = tab1 . col1 where tab0 . col1 = refre and tab0 . col0 = codint	0
Q_219	my_sql order by weight field	C_219_9	select tab0 . col0 , tab0 . col1 , ( tab0 . col2 / codint * ( select col2 from col3 where col0 = codint and col1 = tab0 . col1 ) ) col4 from col3 col5 where tab0 . col1 = refre and tab0 . col0 = codint	0
Q_220	postgres recursive with o pl how many group be there	C_220_0	with recursive col0 as ( select distinct least ( col1 , col2 ) as col3 , greatest ( col1 , col2 ) as col4 from col5 ) ,	1
Q_220	postgres recursive with o pl how many group be there	C_220_1	col0 as ( select col1 , col1 array_agg ( col2 order by col2 ) as col3 from col4 group by col1 union select col2 , array_agg ( col1 order by col1 ) col2 as col3 from col4 group by col2 ) ,	0
Q_220	postgres recursive with o pl how many group be there	C_220_2	col0 as ( select col1 col2 as col3 , col1 , array [ col1 col2 ] as col4 from col5 col6 union all select tab0 . col3 , tab0 . col1 tab1 . col1 , tab0 . col4 tab1 . col1 col2 from col0 col7 join col5 col6 on tab1 . col1 tab0 . col1 and not tab1 . col1 col2 = any ( tab0 . col4 ) ) ,	0
Q_220	postgres recursive with o pl how many group be there	C_220_3	col0 as ( select distinct array_agg ( distinct tab0 . col1 order by tab0 . col1 ) as col2 from col3 col4 cross join lateral unnest ( col2 ) as m ( col1 ) join col5 on tab1 . col6 = tab0 . col1 group by tab2 . col7 )	0
Q_220	postgres recursive with o pl how many group be there	C_220_4	select rank ( ) over ( order by col0 col1 ) as col2 , col0 from col3 order by col2	0
Q_220	postgres recursive with o pl how many group be there	C_220_5	select * from group_consolidate ( ) notice col0 codint _ codint _ codint codint codint number _ codint notice col0 codint _ codint _ codint codint codint number _ codint col1 col2 _ + _ codint { codint , codint , codint , codint , codint } codint { codint } codint { codint , codint } ( codint rows )	0
Q_220	postgres recursive with o pl how many group be there	C_220_6	select * from onetab_consolidate ( ) col0 col1 _ + _ codint { codint , codint , codint , codint , codint } codint { codint } codint { codint , codint } ( codint rows )	0
Q_220	postgres recursive with o pl how many group be there	C_220_7	select * from group_consolidate ( ) col0 join ( select * from onetab_consolidate ( ) ) col1 on tab0 . col2 = tab1 . col2 and tab0 . col3 = tab1 . col3 notice col4 codint _ codint _ codint codint codint number _ codint notice col4 codint _ codint _ codint codint codint number _ codint col2 col3 col2 col3 _ + _ + _ + _ ( codint rows ) time number ms ( codint number ) select count ( * ) from group_consolidate ( ) notice col4 codint _ codint _ codint codint codint number _ codint notice col4 codint _ codint _ codint codint codint number _ codint count _ codint ( codint row ) time number col5 select count ( * ) from onetab_consolidate ( ) count _ codint ( codint row ) time number ms ( codint number )	0
Q_220	postgres recursive with o pl how many group be there	C_220_8	_ truncate col0 col1 with col2 as ( select floor ( random ( ) * codint + codint ) int as col3 , floor ( random ( ) * codint + codint ) int as col4 from generate_series ( codint , codint ) ) insert into col1 select * from col2 where col3 = col4 _ truncate col0 col0 insert into col0 select * from generate_series ( codint , codint ) where random ( ) > number	0
Q_221	retrieve and display data from oracle database	C_221_0	select coalesce ( tab0 . col0 , tab0 . col1 ) from col2 col3 left join col4 col5 on tab1 . table_name = tab0 . table_name and tab1 . column_name = tab0 . col1 where tab0 . table_name = refre order by tab1 . col6 , tab0 . col1	1
Q_221	retrieve and display data from oracle database	C_221_1	coalesce ( tab0 . col0 _ col1 codint column codint col1 codint column codint col2 col1 codint column codint col1 codint column codint	0
Q_221	retrieve and display data from oracle database	C_221_2	col0 col1 col2 col0 col3 col2 declare col4 varchar2 ( codint ) = refre col5 varchar2 ( codint ) begin select refre listagg ( refre refre coalesce ( tab0 . col6 , tab0 . col7 ) refre refre , refre refre ) col8 group ( order by tab1 . col9 , tab0 . col7 ) refre into col5 from col10 col11 left join col12 col13 on tab1 . table_name = tab0 . table_name and tab1 . column_name = tab0 . col7 where tab0 . table_name = col4 tab2 . put_line ( col5 ) open col1 for col5 select refre listagg ( coalesce ( tab1 . column_name , refre ) refre tab0 . col7 , refre refre ) col8 group ( order by tab1 . col9 , tab0 . col7 ) refre col4 into col5 from col10 col11 left join col12 col13 on tab1 . table_name = tab0 . table_name and tab1 . column_name = tab0 . col7 where tab0 . table_name = col4 tab2 . put_line ( col5 ) open col3 for col5 end /	0
Q_221	retrieve and display data from oracle database	C_221_3	select refre , refre , refre , refre , refre from col0 select col1 as col1 , col2 as col2 , col3 as col3 , col4 as col4 , null as col5 from col6	0
Q_221	retrieve and display data from oracle database	C_221_4	"print col0 refre refre refre col1 refre col2 "" _ _ _ _ _ col3 codint column codint col3 codint column codint col4 col3 codint column codint col3 codint column codint print col5 col6 col7 col4 col8 col9 _ _ _ _ _ col10 col11 col12 col13 col14 col11 col15 col13 col16 col11 col17 col13"	0
Q_221	retrieve and display data from oracle database	C_221_5	col0 group ( order by case tab0 . col1 when refre then codint when refre then codint else codint end , tab1 . col2 , tab0 . col1 )	0
Q_221	retrieve and display data from oracle database	C_221_6	"refre refre refre col0 refre col1 "" _ _ _ _ _ col2 codint column codint col2 codint column codint col3 col2 codint column codint col2 codint column codint col4 col5 col3 col6 col7 _ _ _ _ _ col8 col9 col10 col11 col12 col9 col13 col11 col14 col9 col15 col11"	0
Q_221	retrieve and display data from oracle database	C_221_7	select refre regast refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre refre listagg ( level , refre refre ) col0 group ( order by level ) refre refre refre into col1 from col2 connect by level < = ( select count ( * ) from col3 where table_name = col4 ) tab0 . put_line ( col1 ) open col5 for col1 using col4	0
Q_221	retrieve and display data from oracle database	C_221_8	select * from ( select row_number ( ) over ( order by case tab0 . col0 when refre then codint when refre then codint else codint end , tab1 . col1 , tab0 . col0 ) as col2 , coalesce ( tab0 . col3 , tab0 . col0 ) as col4 from col5 col6 left join col7 col8 on tab1 . table_name = tab0 . table_name and tab1 . column_name = tab0 . col0 where tab0 . table_name = col9 ) pivot ( max ( col4 ) as col10 for ( col2 ) in ( codint , codint , codint , codint , codint ) )	0
Q_221	retrieve and display data from oracle database	C_221_9	col0 col1 col2 col3 col4 _ _ _ _ _ col5 codint column codint col5 codint column codint col6 col5 codint column codint col5 codint column codint	0
Q_222	how to retrieve auto reference row recursive	C_222_0	alter col0 col1 add origin ( varchar ( codint ) ) default null	1
Q_222	how to retrieve auto reference row recursive	C_222_1	col0 col1 col2 method col3 codint col4 col5 codint col6 col4 col7 codint col8 col6 col7 codint col8 col9 col6 col7 codint col10 col5 codint col11 col10 col12 codint col13 col11 col12	0
Q_222	how to retrieve auto reference row recursive	C_222_2	with recursive col0 as ( select * , col1 as col2 from col3 where col4 is null union all select tab0 . * , tab1 . col2 from col3 col5 join col0 col6 on tab1 . col1 = tab0 . col4 where tab0 . col1 < > tab0 . col4 ) select * from col0 col7 col1 col4 method col8 col2 codint col9 col10 col9 codint col11 col10 col11 codint col12 col9 col13 col9 codint col14 col11 col15 col11 codint col16 col12 col13 col9 codint col16 col17 col12 col13 col9 codint col18 col14 col15 col11	0
Q_222	how to retrieve auto reference row recursive	C_222_3	with recursive col0 as ( select * , col1 as col2 from col3 where col4 is null union all select tab0 . * , tab1 . col2 from col3 col5 join col0 col6 on tab1 . col1 = tab0 . col4 where tab0 . col1 < > tab0 . col4 ) update col3 col5 , col0 col6 set tab0 . col7 = tab1 . col2 where tab0 . col1 = tab1 . col1	0
Q_222	how to retrieve auto reference row recursive	C_222_4	select * from col0 col1 col2 col3 method col4 codint col5 col6 col5 codint col7 col5 col8 col5 codint col9 col7 col8 col5 codint col9 col10 col7 col8 col5 codint col11 col6 col11 codint col12 col11 col13 col11 codint col14 col12 col13 col11	0
Q_222	how to retrieve auto reference row recursive	C_222_5	select col0 from col1 where col2 = ( select col2 from col1 where col0 = refre ) col0 col3 col4 col5 col5 col6	0
Q_222	how to retrieve auto reference row recursive	C_222_6	select col0 from col1 where col2 = ( select col2 from col1 where col0 = refre ) col0 col3 col4 col5 col5 col6	0
Q_222	how to retrieve auto reference row recursive	C_222_7	select col0 from col1 where col2 = ( select col2 from col1 where col0 = refre ) col0 col3 col4 col5	0
Q_223	how to update value in tagint table irrespective of whether the value exist or not with or without join	C_223_0	create col0 activities ( no bigint ( codint ) not null auto_increment , col1 varchar ( codint ) default null , col2 varchar ( codint ) default null , col3 varchar ( codint ) null , col4 bigint ( codint ) not null , col5 bigint ( codint ) default null , type enum ( refre , refre , refre ) not null , date timestamp null default current_timestamp , primary key ( no ) )	1
Q_223	how to update value in tagint table irrespective of whether the value exist or not with or without join	C_223_1	create col0 activitiyusers ( no bigint not null auto_increment , col1 varchar ( codint ) not null , col2 enum ( refre , refre ) not null , col3 smallint null , col4 varchar ( codint ) not null , col5 varchar ( codint ) null , col6 varchar ( codint ) null , col7 varchar ( codint ) null , col8 timestamp not null default current_timestamp col9 varchar ( codint ) null default current_timestamp on update current_timestamp , primary key ( no ) )	0
Q_223	how to update value in tagint table irrespective of whether the value exist or not with or without join	C_223_2	insert into activitiyusers ( col0 , col1 , col2 , col3 , col4 , col5 , col6 ) values ( refre , refre , refre , refre , refre , refre , refre ) insert into activitiyusers ( col0 , col1 , col2 , col3 , col4 , col5 , col6 ) values ( refre , refre , refre , refre , refre , refre , refre ) insert into activitiyusers ( col0 , col1 , col2 , col3 , col4 , col5 , col6 ) values ( refre , refre , refre , refre , refre , refre , refre )	0
Q_223	how to update value in tagint table irrespective of whether the value exist or not with or without join	C_223_3	insert into activities ( col0 , col1 , col2 , type ) values ( refre , refre , null , refre ) insert into activities ( col0 , col1 , col2 , type ) values ( refre , refre , null , refre ) insert into activities ( col0 , col1 , col2 , type ) values ( refre , refre , null , refre )	0
Q_223	how to update value in tagint table irrespective of whether the value exist or not with or without join	C_223_4	insert into activities ( col0 , col1 , col2 , type ) values ( refre , refre , refre , refre ) insert into activities ( col0 , col1 , col2 , type ) values ( refre , refre , refre , refre )	0
Q_223	how to update value in tagint table irrespective of whether the value exist or not with or without join	C_223_5	insert into activities ( col0 , col1 , col2 , type ) values ( refre , refre , refre , refre ) insert into activities ( col0 , col1 , col2 , type ) values ( refre , refre , refre , refre )	0
Q_223	how to update value in tagint table irrespective of whether the value exist or not with or without join	C_223_6	select tab0 . no as col0 , tab0 . col1 , tab0 . col2 , tab0 . col3 , tab0 . type , tab0 . date , tab1 . no as col4 , tab1 . col5 , tab1 . col6 , tab1 . col7 , tab1 . col8 , tab1 . col9 , tab1 . col10 , tab1 . col11 , tab1 . col12 , tab1 . col13 from col14 col15 join col16 col17 on tab0 . col18 = tab1 . no where col5 = refre	0
Q_223	how to update value in tagint table irrespective of whether the value exist or not with or without join	C_223_7	select tab0 . no as col0 , tab0 . col1 , tab0 . col2 , tab0 . col3 , tab0 . type , tab0 . date , tab1 . no as col4 , tab1 . col5 , tab1 . col6 , tab1 . col7 , tab1 . col8 , tab1 . col9 , tab1 . col10 , tab1 . col11 , tab1 . col12 , tab1 . col13 from col14 col15 join col16 col17 on tab0 . col18 = tab1 . no where col5 = refre and tab0 . type = refre col19 col15 col20 col21 col22 col23 col24 col25 / no of refre , update col26 col27 for col26 col28 col29 to col22 col21 update col16 set col8 = refre , col7 = codint , col11 = codint where no = ( select col18 from col14 where no = codint )	0
Q_223	how to update value in tagint table irrespective of whether the value exist or not with or without join	C_223_8	select tab0 . no as col0 , tab1 . no as col1 , tab0 . col2 as col3 , tab1 . col2 as col4 , tab1 . col5 , tab0 . col6 , tab1 . type , tab0 . date as col7 , tab1 . date as col8 , tab2 . no as col9 , tab2 . col10 , tab2 . col11 , tab2 . col12 , tab2 . col13 , tab2 . col14 , tab2 . col15 , tab2 . col16 , tab2 . col17 , tab2 . col18 from col19 col20 join col19 col21 on tab1 . col22 = tab0 . no join col23 col24 on tab0 . col25 = tab2 . no where tab0 . no = codint	0
Q_224	how to pass a string array like to store procedure	C_224_0	"int col0 col1 = new col0 { codint , codint , codint } / / col2 int col0 col3 = refre [ ] refre refre refre / / col4 "" col5 work"	1
Q_224	how to pass a string array like to store procedure	C_224_1	select * from col0 where col1 in ( refre refre refre )	0
Q_224	how to pass a string array like to store procedure	C_224_2	"select * from col0 where col1 in ( refre , refre ) . _ col2 select * from col0 where col1 in ( refre refre refre refre refre refre ) . _ valid , col3 col4 refre col5 refre col6 """	0
Q_224	how to pass a string array like to store procedure	C_224_3	select * from col0 where col1 in ( col2 , col3 , col4 )	0
Q_224	how to pass a string array like to store procedure	C_224_4	create type tab0 . col0 as table1 ( col1 int not null )	0
Q_224	how to pass a string array like to store procedure	C_224_5	col0 col1 = new datatable ( ) tab0 . tab1 . add ( refre , typeof ( int ) )	0
Q_224	how to pass a string array like to store procedure	C_224_6	tab0 . tab1 . addwithvalue ( refre , col0 ) . col1 = tab2 . col2	0
Q_224	how to pass a string array like to store procedure	C_224_7	select * from col0 where col1 in ( col2 )	0
Q_224	how to pass a string array like to store procedure	C_224_8	select * from col0 join col1 col2 on tab0 . col3 = tab1 . col3	0
Q_224	how to pass a string array like to store procedure	C_224_9	select * from col0 where col1 in ( select col1 from col2 )	0
Q_225	how to insert json data in mysql with php	C_225_0	col0 col1 col2 function file_get_contents ( ) col3 col4 read col2 col5 file and returns col6 as col7 tab0 .	1
Q_225	how to insert json data in mysql with php	C_225_1	/ / read col0 json file contents col1 = file_get_contents ( refre )	0
Q_225	how to insert json data in mysql with php	C_225_2	/ / convert json object to col0 col1 array data = json_decode ( col2 , true )	0
Q_225	how to insert json data in mysql with php	C_225_3	col0 first parameter col1 contains col0 json file tab0 . col0 second parameter true col2 convert col0 col3 into col4 col5 tab1 .	0
Q_225	how to insert json data in mysql with php	C_225_4	/ / get col0 col1 col2 = data col3 col4 = data col5 col6 col7 = data col5 col8 col9 = data col5 col10 col11 col12 = data col5 col10 col13 col14 = data col5 col10 col15 col16 = data col5 col10 col17	0
Q_225	how to insert json data in mysql with php	C_225_5	/ / insert into col0 col1 sql = refre refre refre refre refre refre refre refre refre refre col2 refre refre col3 refre refre col4 refre refre col5 refre refre col6 refre refre col7 refre refre col8 refre refre if ( mysqli_query ( col9 , sql ) ) { die ( refre . mysql_error ( ) ) }	0
Q_225	how to insert json data in mysql with php	C_225_6	{ refre refre , refre { refre refre , refre refre , refre { refre refre , refre refre , refre refre , refre refre } } }	0
Q_226	insert into temp table fail in sql server but same statement run perfectly in postgre_sql my_sql sq_lite	C_226_0	select * into tab0 . col0 from tab0 . col1 alter col2 col0 add constraint col3 default refre for col4 alter col2 col0 add constraint col5 default refre for tab1 . tab2 . ( col6 are codint col7 in col8 col1 col2 )	1
Q_226	insert into temp table fail in sql server but same statement run perfectly in postgre_sql my_sql sq_lite	C_226_1	insert into tab0 . tmpjobs ( col0 , col1 , . ) values ( . )	0
Q_226	insert into temp table fail in sql server but same statement run perfectly in postgre_sql my_sql sq_lite	C_226_2	use col0 drop col1 col2 select col3 , col4 , col5 , col6 into tab0 . col2 from tab0 . col7 alter col1 col2 add constraint col8 default refre for col3 alter col1 col2 add constraint col9 default refre for col4 alter col1 col2 add constraint col10 default refre for col5 alter col1 col2 add constraint col11 default refre for col6 insert into tab0 . tmpjobs ( col3 ) values ( refre )	0
Q_226	insert into temp table fail in sql server but same statement run perfectly in postgre_sql my_sql sq_lite	C_226_3	use col0 select refre as col1 , refre as col2 , codint as col3 into col4 from tab0 . col5 where rowid < = codint insert into tmptest ( col1 ) values ( refre )	0
Q_226	insert into temp table fail in sql server but same statement run perfectly in postgre_sql my_sql sq_lite	C_226_4	( codint rows col0 ) col1 codint , level codint , col2 codint , line codint col3 insert col4 col5 null into column refre , col6 refre column col7 not col8 tab0 . insert tab1 . col4 statement col9 col10 tab2 .	0
Q_226	insert into temp table fail in sql server but same statement run perfectly in postgre_sql my_sql sq_lite	C_226_5	use col0 drop col1 col2 select refre as col3 , refre as col4 , codint as col5 into col2 from tab0 . col6 where rowid < = codint alter col1 col2 alter column col4 null	0
Q_226	insert into temp table fail in sql server but same statement run perfectly in postgre_sql my_sql sq_lite	C_226_6	col0 codint , level codint , col1 codint , line codint col2 col3 col4 col5 col6 refre .	0
Q_226	insert into temp table fail in sql server but same statement run perfectly in postgre_sql my_sql sq_lite	C_226_7	use col0 select refre as col1 , refre as col2 , codint as col3 into col4 from tab0 . col5 where rowid < = codint alter col6 col4 add constraint col7 default refre for col2 alter col6 col4 add constraint col8 default codint for col3 insert into tmptest ( col1 ) values ( refre )	0
Q_226	insert into temp table fail in sql server but same statement run perfectly in postgre_sql my_sql sq_lite	C_226_8	use col0 drop col1 col2 select col3 , refre as col4 , refre as col5 , codint as col6 into col2 from tab0 . col7 where rowid < = codint alter col1 col2 add constraint col8 default refre for col3 alter col1 col2 add constraint col9 default refre for col4 alter col1 col2 add constraint col10 default refre for col5 alter col1 col2 add constraint col11 default codint for col6 insert into tmptest ( col3 ) values ( refre )	0
Q_226	insert into temp table fail in sql server but same statement run perfectly in postgre_sql my_sql sq_lite	C_226_9	col0 codint , level codint , col1 codint , line codint col2 column col3 refre .	0
Q_226	insert into temp table fail in sql server but same statement run perfectly in postgre_sql my_sql sq_lite	C_226_10	use col0 drop col1 col2 select col3 , refre as col4 , refre as col5 , codint as col6 into col2 from tab0 . col7 where rowid < = codint alter col1 col2 add constraint col8 default refre for col3 alter col1 col2 add constraint col9 default refre for col4 alter col1 col2 add constraint col10 default refre for col5 alter col1 col2 add constraint col11 default codint for col6 insert into tmptest ( col4 ) values ( refre )	0
Q_227	how to structure the database to avoid duplicate in a table	C_227_0	_ col0 col1 tab0 . _ col0 { col1 } col2 { col1 }	1
Q_227	how to structure the database to avoid duplicate in a table	C_227_1	_ col0 col1 tab0 . _ col0 { col1 } col2 { col1 }	0
Q_227	how to structure the database to avoid duplicate in a table	C_227_2	_ time col0 col1 tab0 . _ col0 { col1 } col2 { col1 }	0
Q_227	how to structure the database to avoid duplicate in a table	C_227_3	_ col0 col1 col2 col3 tab0 . _ col4 { col1 , col5 } col6 { col1 , col5 } col7 { col1 } references col0 { col1 } col8 { col5 } references col3 { col5 }	0
Q_227	how to structure the database to avoid duplicate in a table	C_227_4	_ col0 col1 col2 time col3 col4 for col5 tab0 . _ col6 { col1 , col4 , col7 } col8 { col1 , col4 } col9 { col1 , col4 , col7 } col10 { col1 , col7 } references col11 { col1 , col7 } col12 { col4 } references col3 { col4 }	0
Q_227	how to structure the database to avoid duplicate in a table	C_227_5	_ student ( col0 ) col1 tab0 . _ col0 { col1 } col2 { col1 }	0
Q_227	how to structure the database to avoid duplicate in a table	C_227_6	_ col0 col1 signed _ col2 for col3 tab0 . _ col4 { col1 , col5 } col6 { col1 , col5 } col7 { col1 } references col8 { col1 } col9 { col5 } references col3 { col5 }	0
Q_227	how to structure the database to avoid duplicate in a table	C_227_7	_ col0 col1 col2 time col3 col4 _ for col5 col6 with col7 tab0 . _ col8 { col1 , col4 , col6 , col9 } col10 { col1 , col4 } col11 { col1 , col6 } references col12 { col1 , col6 } col13 { col9 , col4 , col6 } references col14 { col9 , col4 , col6 }	0
Q_227	how to structure the database to avoid duplicate in a table	C_227_8	all attributes ( col0 ) not null col1 = primary key col2 = col3 key ( unique ) col4 = col5 superkey ( unique ) col6 = foreign key	0
Q_228	same string but different byte length	C_228_0	select col0 , dump ( col0 ) from col1 where col2 = refre group by col0 order by col0 asc	1
Q_228	same string but different byte length	C_228_1	create function createstring ( col0 varchar2 ) return varchar2 deterministic is col1 varchar2 ( codint ) begin tab0 . convert_raw_value ( hextoraw ( col0 ) , col1 ) return col1 end /	0
Q_228	same string but different byte length	C_228_2	create col0 table_name ( col1 varchar2 ( codint ) ) / insert into table_name ( col1 ) select refre from col2 union all select refre createstring ( refre ) from col2 union all select refre createstring ( refre ) from col2 /	0
Q_228	same string but different byte length	C_228_3	select col0 , dump ( col0 ) as dump , length ( trim ( col0 ) ) as length from table_name	0
Q_228	same string but different byte length	C_228_4	col0 dump length _ _ _ col1 col2 = codint len = codint codint , codint , codint , codint , codint , codint , codint , codint codint col1 col2 = codint len = codint codint , codint , codint , codint , codint , codint , codint , codint , codint codint col1 col2 = codint len = codint codint , codint , codint , codint , codint , codint , codint , codint , codint codint	0
Q_228	same string but different byte length	C_228_5	select dump ( col0 ) from < col1 of col2 col3 >	0
Q_228	same string but different byte length	C_228_6	col0 col1 = codint len = codint codint , codint , codint , codint , codint , codint , codint , codint col0 col1 = codint len = codint codint , codint , codint , codint , codint , codint , codint , codint , codint	0
Q_228	same string but different byte length	C_228_7	create function createstringfromhex ( col0 varchar2 ) return varchar2 deterministic is col1 varchar2 ( codint ) begin tab0 . convert_raw_value ( hextoraw ( col0 ) , col1 ) return col1 end /	0
Q_228	same string but different byte length	C_228_8	update col0 set col1 = rtrim ( col1 , createstringfromhex ( refre ) ) where substr ( col1 , _ codint ) = createstringfromhex ( refre )	0
Q_228	same string but different byte length	C_228_9	select upper ( col0 ) as col0 , length ( upper ( col0 ) ) as length from col1 _ where col2 = refre group by upper ( col0 ) order by upper ( col0 ) asc	0
Q_229	my_sql like be case sensitive but i do not want it to be	C_229_0	create col0 users_user ( col1 col2 ) engine = col3 default charset = col4 insert into col5 set col1 = refre	1
Q_229	my_sql like be case sensitive but i do not want it to be	C_229_1	col0 > select * from col1 where col2 like refre + _ + col2 + _ + col3 _ codint + _ +	0
Q_229	my_sql like be case sensitive but i do not want it to be	C_229_2	col0 > select * from col1 where col2 collate col3 like refre col4 set ( number col5 )	0
Q_229	my_sql like be case sensitive but i do not want it to be	C_229_3	col0 > select * from col1 where col2 like refre collate col3 col4 set ( number col5 )	0
Q_229	my_sql like be case sensitive but i do not want it to be	C_229_4	create col0 users_user ( col1 col2 collate col3 ) engine = col4 default charset = col5 collate = col3 insert into col6 set col1 = refre col7 > select * from col6 where col1 like refre col8 set ( number col9 )	0
Q_229	my_sql like be case sensitive but i do not want it to be	C_229_5	col0 > select character_set_name , collation_name from tab0 . col1 where table_name = refre and column_name = refre + _ + _ + character_set_name collation_name + _ + _ + col2 col3 + _ + _ +	0
Q_229	my_sql like be case sensitive but i do not want it to be	C_229_6	col0 > select * from col1 where col2 like refre collate col3 + _ + col2 + _ + col4 _ codint + _ +	0
Q_229	my_sql like be case sensitive but i do not want it to be	C_229_7	col0 > select * from col1 where col2 collate col3 like refre + _ + col2 + _ + col4 _ codint + _ +	0
Q_230	how to recreate the data into user when the user already create	C_230_0	insert into rooms ( col0 ) values ( refre )	1
Q_230	how to recreate the data into user when the user already create	C_230_1	insert into subjects ( col0 ) values ( refre )	0
Q_230	how to recreate the data into user when the user already create	C_230_2	insert into subjectsperroom ( col0 , col1 ) values ( codint , codint )	0
Q_230	how to recreate the data into user when the user already create	C_230_3	insert into students ( col0 ) values ( refre ) insert into students ( col0 ) values ( refre ) insert into students ( col0 ) values ( refre )	0
Q_230	how to recreate the data into user when the user already create	C_230_4	insert into subjectsperstudentperroom ( col0 , col1 , col2 ) values ( codint , codint , codint ) insert into subjectsperstudentperroom ( col0 , col1 , col2 ) values ( codint , codint , codint ) insert into subjectsperstudentperroom ( col0 , col1 , col2 ) values ( codint , codint , codint )	0
Q_230	how to recreate the data into user when the user already create	C_230_5	insert into subjects ( col0 ) values ( refre )	0
Q_230	how to recreate the data into user when the user already create	C_230_6	insert into subjectsperroom ( col0 , col1 ) values ( codint , codint )	0
Q_230	how to recreate the data into user when the user already create	C_230_7	select * from col0 join col1 on tab0 . col2 = tab1 . col2 where tab1 . col3 = codint and tab1 . col4 = codint	0
Q_231	parse xml with unknown structure in snowflake	C_231_0	with data as ( select parse_xml ( refre refre refre refre codint refre refre refre refre refre codint refre refre refre refre refre refre codint refre refre refre refre refre codint refre refre refre refre refre refre codint refre refre refre refre refre codint refre refre refre refre refre refre refre refre refre refre refre refre codint refre refre refre refre refre refre refre refre refre refre refre refre codint refre refre refre refre refre refre refre refre refre refre refre refre codint refre refre refre refre refre codint refre refre refre refre refre refre refre refre refre refre refre refre refre refre ) as xml ) select get ( tab0 . col0 , refre ) as col1 , tab0 . path as path , len ( path ) as col2 from data , table1 ( flatten ( input = > get ( xml , refre ) , recursive = > true ) ) col3 where get ( tab0 . col0 , refre ) = refre	1
Q_231	parse xml with unknown structure in snowflake	C_231_1	col0 path col1 codint col2 codint codint col2 col3 col3 col2 codint codint col2 col3 col3 col4 codint codint col2 col3 col3 col4 col3 col3 col2 codint codint col2 col3 col3 col4 col3 col3 col4 codint codint col2 col3 col3 col4 col3 col3 col4 col3 col3 codint codint col2 col3 col3 col4 col3 col3 col5 codint codint col2 col3 col3 col5 codint codint col4 codint codint col4 col3 col3 codint	0
Q_231	parse xml with unknown structure in snowflake	C_231_2	select get ( tab0 . col0 , refre ) as col1 , get ( tab1 . col0 , refre ) as col1 , tab0 . col0 , tab1 . * , get ( tab1 . col0 , refre ) from data , table1 ( flatten ( input = > get ( xml , refre ) , recursive = > true ) ) col2 , table1 ( flatten ( input = > get ( xmlget ( tab0 . col0 , refre ) , refre ) ) ) col3 where get ( tab0 . col0 , refre ) = refre	0
Q_231	parse xml with unknown structure in snowflake	C_231_3	get ( tab0 . col0 , refre ) = refre	0
Q_231	parse xml with unknown structure in snowflake	C_231_4	select get ( tab0 . col0 , refre ) as col1 , iff ( get ( tab1 . col0 , refre ) = refre , get ( tab1 . col0 , refre ) , get ( xmlget ( xmlget ( tab0 . col0 , refre ) , refre ) , refre ) ) as col2 from data , table1 ( flatten ( input = > get ( xml , refre ) , recursive = > true ) ) col3 , table1 ( flatten ( input = > get ( xmlget ( tab0 . col0 , refre ) , refre ) ) ) col4 where get ( tab0 . col0 , refre ) = refre and ( get ( tab1 . col0 , refre ) = refre or tab1 . col0 = refre )	0
Q_231	parse xml with unknown structure in snowflake	C_231_5	col0 col1 codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint	0
Q_231	parse xml with unknown structure in snowflake	C_231_6	col0 col1 null codint codint codint codint codint codint codint codint codint codint codint codint codint codint codint null codint codint codint	0
Q_232	how to get postgres record in high date resolution from tagint hour timestamp table	C_232_0	create col0 table1 ( refre integer , refre timestamp , refre varchar ( codint ) , refre integer ) insert into table1 ( refre , refre , refre , refre ) values ( refre , refre regplu refre , refre , refre ) , ( refre , refre regplu refre , refre , refre ) , ( refre , refre regplu refre , refre , refre ) , ( refre , refre regplu refre , refre , refre ) , ( refre , refre regplu refre , refre , refre ) , ( refre , refre regplu refre , refre , refre ) , ( refre , refre regplu refre , refre , refre ) , ( refre , refre regplu refre , refre , refre ) , ( refre , refre regplu refre , refre , refre ) , ( refre , refre regplu refre , refre , refre )	1
Q_232	how to get postgres record in high date resolution from tagint hour timestamp table	C_232_1	with col0 as ( select refre , refre , refre , refre , row_number ( ) over ( partition by refre , extract ( col1 from refre ) , extract ( month from refre ) , extract ( col2 from refre ) , trunc ( extract ( hour from refre ) / codint ) order by refre ) as col3 from col4 ) select refre , date_trunc ( refre , refre ) , refre , refre from col0 where tab0 . col3 = codint order by refre	0
Q_232	how to get postgres record in high date resolution from tagint hour timestamp table	C_232_2	select refre , refre , refre , refre , row_number ( ) over ( partition by refre , extract ( col0 from refre ) , extract ( month from refre ) , extract ( col1 from refre ) , trunc ( extract ( hour from refre ) / codint ) order by refre ) as col2 from col3	0
Q_232	how to get postgres record in high date resolution from tagint hour timestamp table	C_232_3	select min ( refre ) , min ( refre ) , refre , sum ( refre ) from col0 group by refre , extract ( col1 from refre ) , extract ( month from refre ) , extract ( col2 from refre ) , trunc ( extract ( hour from refre ) / codint )	0
Q_232	how to get postgres record in high date resolution from tagint hour timestamp table	C_232_4	select min ( refre ) , min ( refre ) , refre , sum ( refre ) from col0 group by refre , extract ( col1 from refre ) , extract ( month from refre ) , extract ( col2 from refre ) , trunc ( extract ( hour from refre ) / codint )	0
Q_232	how to get postgres record in high date resolution from tagint hour timestamp table	C_232_5	select min ( refre ) , min ( refre ) , refre , sum ( refre ) from col0 group by refre , extract ( col1 from refre ) , extract ( month from refre ) , extract ( col2 from refre )	0
Q_232	how to get postgres record in high date resolution from tagint hour timestamp table	C_232_6	select min ( refre ) , min ( refre ) , refre , sum ( refre ) from col0 group by refre , extract ( col1 from refre ) , extract ( month from refre ) , extract ( week from refre )	0
Q_232	how to get postgres record in high date resolution from tagint hour timestamp table	C_232_7	select min ( refre ) , min ( refre ) , refre , sum ( refre ) from col0 group by refre , extract ( col1 from refre ) , extract ( month from refre )	0
Q_233	i want the parquet file data to be into the below string format can some one help me	C_233_0	col0 col1 = tab0 . withcolumn ( refre , when ( size ( refre ) > codint , expr ( refre refre refre refre refre refre refre refre refre refre refre refre refre refre ) ) )	1
Q_233	i want the parquet file data to be into the below string format can some one help me	C_233_1	col0 _ col1 string ( nullable = true ) _ col2 string ( nullable = true )	0
Q_233	i want the parquet file data to be into the below string format can some one help me	C_233_2	+ _ + _ + col0 col1 + _ + _ + col2 col3 col4 col5 col6 col7 col3 col8 col5 col9 col10 col3 col11 col5 col12 col13 null + _ + _ +	0
Q_233	i want the parquet file data to be into the below string format can some one help me	C_233_3	tab0 . repartition ( codint ) . tab1 . format ( refre ) . option ( refre , refre ) . save ( refre refre refre refre )	0
Q_233	i want the parquet file data to be into the below string format can some one help me	C_233_4	col0 / col1 / col2 / data > col3 col4 _ codint _ col5 _ col6 _ codint _ col7 _ codint col8 _ tab0 . col2 col9 , col10 col11 , col12 col13 col14 col15 col16 , col12 col17 col14 col18 col19 , col12 col20 col14 col21 col22 , refre	0
Q_233	i want the parquet file data to be into the below string format can some one help me	C_233_5	col0 > col1 col2 = udf ( ( row col3 col4 ) = > { tab0 . map ( col5 = > tab1 . col6 [ string ] ( refre ) + refre + tab1 . col6 [ string ] ( refre ) ) . reduce ( col7 + refre + col7 ) } )	0
Q_233	i want the parquet file data to be into the below string format can some one help me	C_233_6	col0 > tab0 . withcolumn ( refre , when ( size ( refre ) > codint , combine ( refre ) ) ) . show ( false )	0
Q_233	i want the parquet file data to be into the below string format can some one help me	C_233_7	+ _ + _ + _ + col0 col1 col2 + _ + _ + _ + col3 [ col4 , col5 ] col6 col7 col8 col9 col10 [ col11 , col12 ] col6 col13 col8 col14 col15 [ col16 , col17 ] col6 col18 col8 col19 col20 col21 null + _ + _ + _ +	0
Q_234	how to fetch data from tagint table in sql with null entry	C_234_0	create col0 t1 ( col1 int , col2 varchar ( codint ) )	1
Q_234	how to fetch data from tagint table in sql with null entry	C_234_1	insert into col0 values ( codint , refre ) , ( codint , refre )	0
Q_234	how to fetch data from tagint table in sql with null entry	C_234_2	create col0 t2 ( col1 int , col2 varchar ( codint ) )	0
Q_234	how to fetch data from tagint table in sql with null entry	C_234_3	insert into col0 values ( codint , refre ) , ( codint , refre )	0
Q_234	how to fetch data from tagint table in sql with null entry	C_234_4	select tab0 . col0 , tab0 . col1 , tab1 . col2 from col3 left join col4 using ( col0 ) union select tab1 . col0 , tab0 . col1 , tab1 . col2 from col3 right join col4 using ( col0 )	0
Q_234	how to fetch data from tagint table in sql with null entry	C_234_5	select tab0 . col0 , tab0 . col1 , tab1 . col2 from col3 left join col4 using ( col0 ) where tab0 . col0 > codint union select tab1 . col0 , tab0 . col1 , tab1 . col2 from col3 right join col4 using ( col0 ) where tab1 . col0 > codint	0
Q_234	how to fetch data from tagint table in sql with null entry	C_234_6	select * from ( select tab0 . col0 , tab0 . col1 , tab1 . col2 from col3 left join col4 on tab0 . col0 = tab1 . col0 union select tab1 . col0 , tab0 . col1 , tab1 . col2 from col3 right join col4 on tab0 . col0 = tab1 . col0 ) col3 where col0 > codint	0
Q_235	how can i read a string column as a list in my_sql	C_235_0	create col0 pivot ( col1 int auto_increment primary key , col2 varchar ( codint ) )	1
Q_235	how can i read a string column as a list in my_sql	C_235_1	insert into pivot ( col0 ) values ( refre refre refre refre ) , ( refre ) , ( refre refre refre refre ) , ( refre refre refre ) , ( refre refre refre ) , ( refre refre refre refre )	0
Q_235	how can i read a string column as a list in my_sql	C_235_2	with recursive seq ( col0 ) as ( select codint union all select col0 + codint from col1 where col0 < = codint ) select distinct tab0 . * , replace ( trim ( leading substring_index ( tab0 . col2 , refre refre , tab1 . col0 _ codint ) from substring_index ( tab0 . col2 , refre refre , tab1 . col0 ) ) , refre refre , refre ) as col3 from col4 as col5 join col1 on tab1 . col0 > codint and substring_index ( tab0 . col2 , refre refre , tab1 . col0 _ codint ) < > substring_index ( tab0 . col2 , refre refre , tab1 . col0 ) order by col6 , col3	0
Q_235	how can i read a string column as a list in my_sql	C_235_3	+ _ + _ + _ + col0 col1 col2 + _ + _ + _ + codint col3 , col4 , col5 , col3 col3 codint col3 , col4 , col5 , col3 col4 codint col3 , col4 , col5 , col3 col5 codint col4 col4 codint col6 , col7 , col6 , col6 col6 codint col6 , col7 , col6 , col6 col7 codint col7 , col7 , col6 col6 codint col7 , col7 , col6 col7 codint col7 , col7 , col6 col6 codint col7 , col7 , col6 col7 codint col3 , col5 , col4 , col3 col3 codint col3 , col5 , col4 , col3 col4 codint col3 , col5 , col4 , col3 col5 + _ + _ + _ +	0
Q_235	how can i read a string column as a list in my_sql	C_235_4	with recursive seq ( col0 ) as ( select codint union all select col0 + codint from col1 where col0 < = codint ) , col2 as ( select distinct tab0 . * , replace ( trim ( leading substring_index ( tab0 . col3 , refre refre , tab1 . col0 _ codint ) from substring_index ( tab0 . col3 , refre refre , tab1 . col0 ) ) , refre refre , refre ) as col4 from col5 as col6 join col1 on tab1 . col0 > codint and substring_index ( tab0 . col3 , refre refre , tab1 . col0 _ codint ) < > substring_index ( tab0 . col3 , refre refre , tab1 . col0 ) ) select col7 , col3 from col2 where col4 in ( refre , refre ) group by col7 having count ( distinct col4 ) = codint order by col7 , col3	0
Q_235	how can i read a string column as a list in my_sql	C_235_5	+ _ + _ + col0 col1 + _ + _ + codint col2 , col3 , col4 , col2 codint col2 , col4 , col3 , col2 + _ + _ + codint rows in set ( number col5 )	0
Q_235	how can i read a string column as a list in my_sql	C_235_6	with recursive seq ( col0 ) as ( select codint union all select col0 + codint from col1 where col0 < = codint ) , col2 as ( select distinct tab0 . * , replace ( trim ( leading substring_index ( tab0 . col3 , refre refre , tab1 . col0 _ codint ) from substring_index ( tab0 . col3 , refre refre , tab1 . col0 ) ) , refre refre , refre ) as col4 from col5 as col6 join col1 on tab1 . col0 > codint and substring_index ( tab0 . col3 , refre refre , tab1 . col0 _ codint ) < > substring_index ( tab0 . col3 , refre refre , tab1 . col0 ) ) select col7 , col3 from col2 group by col7 having count ( distinct case when col4 in ( refre , refre , refre , refre ) then col4 end ) = count ( distinct col4 ) order by col7 , col3	0
Q_235	how can i read a string column as a list in my_sql	C_235_7	+ _ + _ + col0 col1 + _ + _ + codint col2 + _ + _ + codint row in set ( number col3 )	0
Q_235	how can i read a string column as a list in my_sql	C_235_8	insert into pivot ( col0 ) values ( refre refre ) , ( refre refre refre ) , ( refre refre refre )	0
Q_235	how can i read a string column as a list in my_sql	C_235_9	with recursive seq ( col0 ) as ( select codint union all select col0 + codint from col1 where col0 < = codint ) , col2 as ( select distinct tab0 . * , replace ( trim ( leading substring_index ( tab0 . col3 , refre refre , tab1 . col0 _ codint ) from substring_index ( tab0 . col3 , refre refre , tab1 . col0 ) ) , refre refre , refre ) as col4 from col5 as col6 join col1 on tab1 . col0 > codint and substring_index ( tab0 . col3 , refre refre , tab1 . col0 _ codint ) < > substring_index ( tab0 . col3 , refre refre , tab1 . col0 ) ) select col7 , col3 from col2 group by col7 having count ( distinct case when col4 in ( refre , refre , refre , refre , refre , refre , refre ) then col4 end ) = count ( distinct col4 ) order by col7 , col3	0
Q_235	how can i read a string column as a list in my_sql	C_235_10	+ _ + _ + col0 col1 + _ + _ + codint col2 , col3 + _ + _ + codint row in set ( number col4 )	0
Q_236	need to get late record for two value then use that to get the old _my_sql tagint 7	C_236_0	create col0 tablea ( col1 integer , col2 integer , col3 col4 , col5 int ) insert into tablea ( col1 , col2 , col3 ) values ( refre , refre , refre ) , ( refre , refre , refre ) , ( refre , refre , refre ) , ( refre , refre , refre ) , ( refre , refre , refre ) , ( refre , refre , refre )	1
Q_236	need to get late record for two value then use that to get the old _my_sql tagint 7	C_236_1	create col0 tableb ( col1 int , type varchar ( codint ) )	0
Q_236	need to get late record for two value then use that to get the old _my_sql tagint 7	C_236_2	insert into col0 values ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre )	0
Q_236	need to get late record for two value then use that to get the old _my_sql tagint 7	C_236_3	with col0 as ( select tab0 . col1 , tab0 . col2 , tab0 . col3 , tab1 . type from col4 col5 join col6 col7 on tab0 . col2 = tab1 . col8 ) select col1 , col2 , col3 , type from ( select tab2 . * , row_number ( ) over ( partition by col1 order by col3 asc ) col9 from col0 col10 inner join ( select col1 , type from ( select * , row_number ( ) over ( partition by col1 order by col3 desc ) col9 from col0 ) col11 where col9 = codint ) col12 on tab2 . col1 = tab3 . col1 and tab2 . type = tab3 . type ) col13 where col9 = codint	0
Q_236	need to get late record for two value then use that to get the old _my_sql tagint 7	C_236_4	create col0 tablea ( col1 integer , col2 integer , col3 col4 , col5 int ) insert into tablea ( col1 , col2 , col3 ) values ( refre , refre , refre ) , ( refre , refre , refre ) , ( refre , refre , refre ) , ( refre , refre , refre ) , ( refre , refre , refre ) , ( refre , refre , refre )	0
Q_236	need to get late record for two value then use that to get the old _my_sql tagint 7	C_236_5	create col0 tableb ( col1 int , type varchar ( codint ) )	0
Q_236	need to get late record for two value then use that to get the old _my_sql tagint 7	C_236_6	insert into col0 values ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre ) , ( codint , refre )	0
Q_236	need to get late record for two value then use that to get the old _my_sql tagint 7	C_236_7	select col0 , col1 , col2 , type from ( select if ( tab0 . col0 = profile , col3 = col3 + codint , col3 = codint ) col3 , tab0 . col1 , tab0 . col2 , tab1 . type , profile = tab0 . col0 as col0 from col4 col5 join col6 col7 on tab0 . col1 = tab1 . col8 join ( select col0 , type from ( select if ( tab0 . col0 = profile , col3 = col3 + codint , col3 = codint ) col3 , tab0 . col1 , tab0 . col2 , tab1 . type , profile = tab0 . col0 as col0 from col4 col5 join col6 col7 on tab0 . col1 = tab1 . col8 , ( select profile = codint , col3 = codint ) col9 order by tab0 . col0 , tab0 . col2 desc ) col10 where col3 = codint ) col11 on tab0 . col0 = tab2 . col0 and tab1 . type = tab2 . type , ( select profile = codint , col3 = codint ) col9 order by tab0 . col0 , tab0 . col2 asc ) col12 where col3 = codint	0
Q_237	sql increment counter that reset on zero _ optimization	C_237_0	_ = = = = = col0 col1 col2 codint , codint , codint row col3 col4 every date in col5 col6 _ col7 range similar to col5 col8 col9 col10 by col5 tab0 . drop col3 if exists col11 with col12 as ( select top ( datediff ( col13 , refre , refre ) + codint ) col14 = convert ( date , dateadd ( col13 , row_number ( ) over ( order by col15 ) _ codint , refre ) ) from tab1 . col16 col17 cross join tab1 . col16 col18 _ col19 col20 refre ) select col14 , col21 = iif ( abs ( checksum ( newid ( ) ) codint ) > codint , codint , abs ( checksum ( newid ( ) ) codint ) + codint ) into col11 from col12	1
Q_237	sql increment counter that reset on zero _ optimization	C_237_1	drop col0 if exists result set statistics time , col1 on with col2 as ( select * , col3 = count ( case when col4 < > codint then codint end ) over ( order by col5 rows unbounded col6 ) from col7 ) select col5 , col4 , col8 = row_number ( ) over ( partition by col3 order by col5 ) into result from col2 set statistics time , col1 off	0
Q_237	sql increment counter that reset on zero _ optimization	C_237_2	table refre . col0 count codint , col1 reads codint , col2 reads codint , read _ col3 reads codint , col4 col1 reads codint , col4 col2 reads codint , col4 read _ col3 reads codint . col5 refre . col0 count codint , col1 reads codint , col2 reads codint , read _ col3 reads codint , col4 col1 reads codint , col4 col2 reads codint , col4 read _ col3 reads codint . sql col6 col7 col8 col9 time = codint col10 , col11 time = codint tab0 . col12 null col13 is col14 by col15 aggregate or col16 set tab1 . ( codint rows col17 )	0
Q_237	sql increment counter that reset on zero _ optimization	C_237_3	drop col0 if exists result set statistics time , col1 on with col2 as ( select * , col3 = count ( case when col4 < > codint then codint end ) over ( order by col5 rows unbounded col6 ) from col7 ) select col5 , col4 , col8 = row_number ( ) over ( partition by col3 order by col5 ) into result from col2 option ( col9 codint ) _ < _ < < < < col10 col11 set statistics time , col1 off	0
Q_237	sql increment counter that reset on zero _ optimization	C_237_4	table refre . col0 count codint , col1 reads codint , col2 reads codint , read _ col3 reads codint , col4 col1 reads codint , col4 col2 reads codint , col4 read _ col3 reads codint . col5 refre . col0 count codint , col1 reads codint , col2 reads codint , read _ col3 reads codint , col4 col1 reads codint , col4 col2 reads codint , col4 read _ col3 reads codint . sql col6 col7 col8 col9 time = codint col10 , col11 time = codint tab0 . col12 null col13 is col14 by col15 aggregate or col16 set tab1 . ( codint rows col17 )	0
Q_237	sql increment counter that reset on zero _ optimization	C_237_5	drop col0 if exists result set statistics time , col1 on with col2 as ( _ = = = = count number of values of refre over col3 select * , col4 = sum ( sign ( col5 ) ) over ( order by col6 rows unbounded col7 ) from col8 ) _ = = = = create col9 col10 at col11 first row and restart at codint when col5 > codint select col6 , col5 , col12 = row_number ( ) over ( partition by col4 order by col6 ) into result from col2 order by col6 option ( col13 codint ) set statistics time , col1 off	0
Q_237	sql increment counter that reset on zero _ optimization	C_237_6	col0 null col1 is col2 by col3 aggregate or col4 set tab0 .	0
Q_237	sql increment counter that reset on zero _ optimization	C_237_7	table refre . col0 count codint , col1 reads codint , col2 reads codint , read _ col3 reads codint , col4 col1 reads codint , col4 col2 reads codint , col4 read _ col3 reads codint . col5 refre . col0 count codint , col1 reads codint , col2 reads codint , read _ col3 reads codint , col4 col1 reads codint , col4 col2 reads codint , col4 read _ col3 reads codint . sql col6 col7 col8 col9 time = codint col10 , col11 time = codint tab0 . col12 null col13 is col14 by col15 aggregate or col16 set tab1 . ( codint rows col17 )	0
Q_238	how to make database for vocabulary list app with multiple language like google translate one	C_238_0	create col0 if not exists language ( col1 integer primary key , language col2 unique ) create col0 if not exists wordv1 ( col1 integer primary key , col3 integer references language ( col1 ) , col4 integer references language ( col1 ) , col5 col2 , col6 col2 ) insert or ignore into language ( language ) values ( refre ) , ( refre ) , ( refre ) insert or ignore into wordv1 ( col3 , col4 , col5 , col6 ) values ( codint , codint , refre , refre ) , ( codint , codint , refre , refre ) , ( codint , codint , refre , refre ) , ( codint , codint , refre , refre ) , ( codint , codint , refre , refre ) , ( codint , codint , refre , refre ) , ( codint , codint , refre , refre ) , ( codint , codint , refre , refre ) select col5 , col6 from col7 where ( col4 = codint or col3 = codint ) and ( col4 = codint or col3 = codint )	1
Q_238	how to make database for vocabulary list app with multiple language like google translate one	C_238_1	create col0 if not exists wordv2 ( col1 integer primary key , col2 col3 , language integer references language ( col1 ) )	0
Q_238	how to make database for vocabulary list app with multiple language like google translate one	C_238_2	insert into wordv2 ( col0 , language ) values ( refre , codint ) , ( refre , codint ) , ( refre , codint ) , ( refre , codint ) , ( refre , codint ) , ( refre , codint ) , ( refre , codint ) , ( refre , codint ) , ( refre , codint ) , ( refre , codint ) , ( refre , codint ) , ( refre , codint )	0
Q_238	how to make database for vocabulary list app with multiple language like google translate one	C_238_3	create col0 if not exists wordtranslatemap ( col1 integer references wordv2 ( col2 ) , col3 integer references wordv2 ( col2 ) , check ( col1 < > col3 ) , primary key ( col3 , col1 ) )	0
Q_238	how to make database for vocabulary list app with multiple language like google translate one	C_238_4	insert into col0 values ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint )	0
Q_238	how to make database for vocabulary list app with multiple language like google translate one	C_238_5	data class wordwithlanguage ( col0 col1 col2 col2 , relation ( col3 = language class , col4 = refre , col5 = refre ) col1 language language )	0
Q_238	how to make database for vocabulary list app with multiple language like google translate one	C_238_6	data class transaltedword ( col0 col1 col2 , col0 col3 long , col0 col4 col2 , col0 col5 long , col0 col6 col2 , col0 col7 long , col0 col8 col2 , col0 col9 long )	0
Q_238	how to make database for vocabulary list app with multiple language like google translate one	C_238_7	col0 / col1 from = bread ( col2 ) is brot ( col3 ) col0 / col1 from = brot ( col3 ) is bread ( col2 ) col0 / col1 from = bread ( col2 ) is pain ( col4 ) col0 / col1 from = pain ( col4 ) is bread ( col2 ) col0 / col1 from = pain ( col4 ) is brot ( col3 ) col0 / col1 from = brot ( col3 ) is pain ( col4 ) col0 / col1 from = milk ( col2 ) is milch ( col3 ) col0 / col1 from = milk ( col2 ) is lait ( col4 ) col0 / col1 from = milch ( col3 ) is lait ( col4 ) col0 / col1 from = milch ( col3 ) is milk ( col2 ) col0 / col1 from = lait ( col4 ) is milk ( col2 ) col0 / col1 from = lait ( col4 ) is milch ( col3 )	0
Q_239	transaction in golang with pgx	C_239_0	/ / col0 by * tab0 . row * tab0 . rows type row col1 { scan ( tab1 . col1 { } ) col2 } / / col0 by col3 refre type col4 col1 { scanrow ( col5 row ) col2 }	1
Q_239	transaction in golang with pgx	C_239_1	type col0 col1 { col2 int col3 col4 } func ( col5 * col0 ) scanrow ( col6 row ) col7 { return tab0 . scan ( tab1 . col2 , tab1 . col3 , ) }	0
Q_239	transaction in golang with pgx	C_239_2	func ( col0 * col1 ) read ( col2 col3 , col4 col5 ) ( col6 col7 ) { col8 , col6 = tab0 . tab1 . acquire ( tab2 . todo ( ) ) if col6 = col9 { return col6 } col10 tab3 . release ( ) col11 , col6 = tab3 . begintx ( tab2 . todo ( ) , tab4 . col12 { } ) if col6 = col9 { return col6 } col10 func ( ) { if col6 = col9 { tab5 . rollback ( tab2 . todo ( ) ) } else { tab5 . commit ( tab2 . todo ( ) ) } } ( ) row = tab5 . queryrow ( tab2 . todo ( ) , col2 ) if col6 = col9 { return col9 , col6 } return tab6 . scanrow ( row ) }	0
Q_239	transaction in golang with pgx	C_239_3	col0 = new ( col1 ) if col2 = tab0 . read ( refre refre , col0 ) col2 = col3 { panic ( col2 ) }	0
Q_239	transaction in golang with pgx	C_239_4	type col0 col1 * col2 func ( col3 * col0 ) scanrow ( col4 row ) col5 { col6 = new ( col2 ) if col7 = tab0 . scanrow ( col4 ) col7 = col8 { return col7 } * col3 = append ( * col3 , col6 ) return col8 }	0
Q_239	transaction in golang with pgx	C_239_5	func ( col0 * col1 ) list ( col2 col3 , col4 col5 ) ( col6 col7 ) { col8 , col6 = tab0 . tab1 . acquire ( tab2 . todo ( ) ) if col6 = col9 { return col6 } col10 tab3 . release ( ) col11 , col6 = tab3 . begintx ( tab2 . todo ( ) , tab4 . col12 { } ) if col6 = col9 { return col6 } col10 func ( ) { if col6 = col9 { tab5 . rollback ( tab2 . todo ( ) ) } else { tab5 . commit ( tab2 . todo ( ) ) } } ( ) rows , col6 = tab5 . query ( tab2 . todo ( ) , col2 ) if col6 = col9 { return col6 } col10 tab6 . close ( ) for tab6 . next ( ) { if col6 = tab7 . scanrow ( rows ) col6 = col9 { return col6 } } return tab6 . err ( ) }	0
Q_239	transaction in golang with pgx	C_239_6	col0 = new ( col1 ) if col2 = tab0 . list ( refre refre , col0 ) col2 = col3 { panic ( col2 ) }	0
Q_240	my_sql full text search _ multiple search for the same field	C_240_0	create col0 table ( col1 integer , col2 integer , col3 varchar ( codint ) , col4 integer , col5 idx ( col3 ) ) insert into table1 ( col1 , col2 , col3 , col4 ) values ( refre , refre , refre , refre ) , ( refre , refre , refre , refre ) , ( refre , refre , refre , refre ) , ( refre , refre , refre , refre ) , ( refre , refre , refre , refre ) , ( refre , refre , refre , refre ) , ( refre , refre , refre , refre ) , ( refre , refre , refre , refre ) , ( refre , refre , refre , refre ) , ( refre , refre , refre , refre )	1
Q_240	my_sql full text search _ multiple search for the same field	C_240_1	select * from col0 where ( col1 = codint and match ( col2 ) against ( refre regast refre regast refre in boolean mode ) ) and exists ( select codint from col0 where col1 = codint and match ( col2 ) against ( refre regast refre regast refre in boolean mode ) )	0
Q_240	my_sql full text search _ multiple search for the same field	C_240_2	select * from col0 where ( col1 = codint and match ( col2 ) against ( refre regast refre regast refre in boolean mode ) )	0
Q_240	my_sql full text search _ multiple search for the same field	C_240_3	select codint as col0 from col1 where col2 = codint and match ( col3 ) against ( refre regast refre regast refre in boolean mode )	0
Q_240	my_sql full text search _ multiple search for the same field	C_240_4	select * from col0 where ( col1 = codint and match ( col2 ) against ( refre regast refre regast refre in boolean mode ) ) and exists ( select codint from col0 where col1 = codint and match ( col2 ) against ( refre regast refre in boolean mode ) )	0
Q_240	my_sql full text search _ multiple search for the same field	C_240_5	select * from col0 where ( col1 = codint and match ( col2 ) against ( refre regast refre regast refre in boolean mode ) )	0
Q_240	my_sql full text search _ multiple search for the same field	C_240_6	select codint as col0 from col1 where col2 = codint and match ( col3 ) against ( refre regast refre in boolean mode )	0
Q_240	my_sql full text search _ multiple search for the same field	C_240_7	select * from col0 col1 where ( col2 = codint and match ( col3 ) against ( refre regast refre regast refre in boolean mode ) ) and exists ( select codint from col0 where col2 = codint and match ( col3 ) against ( refre regast refre in boolean mode ) and col4 = tab0 . col4 )	0
Q_241	access query counter per group	C_241_0	select * , row_number ( ) over ( partition by col0 order by col1 , col2 ) as rownum from col3	1
Q_241	access query counter per group	C_241_1	select * , ( select count ( * ) from col0 col1 where tab0 . col2 = tab1 . col2 and ( tab0 . col3 < tab1 . col3 or ( tab0 . col3 = tab1 . col3 and tab0 . col4 < = tab1 . col4 ) ) ) as rownum from col0 col5	0
Q_241	access query counter per group	C_241_2	create col0 yourtable ( col1 int identity ( codint , codint ) primary key , col2 int , col3 int ) insert into yourtable ( col2 , col3 ) values ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint ) , ( codint , codint )	0
Q_241	access query counter per group	C_241_3	_ _ row_number ( to get col0 sequence col1 group ) _ select * , row_number ( ) over ( partition by col2 order by col3 , col4 ) as rownum from col5 order by col2 , rownum	0
Q_241	access query counter per group	C_241_4	_ _ col0 col1 col2 col3 col4 col5 _ col6 _ select * , ( select count ( * ) from col7 col8 where tab0 . col9 = tab1 . col9 and ( tab0 . col10 < tab1 . col10 or ( tab0 . col10 = tab1 . col10 and tab0 . col11 < = tab1 . col11 ) ) ) as rownum from col7 col12 order by col9 , rownum	0
Q_241	access query counter per group	C_241_5	_ _ rank ( col0 values get col0 col1 , col2 with col3 ) _ select * , rank ( ) over ( partition by col4 order by col5 ) as col6 from col7 order by col4 , col6	0
Q_241	access query counter per group	C_241_6	_ _ col0 col1 col2 col3 col4 col5 _ col6 _ select * , ( select count ( tab0 . col7 ) + codint from col8 col9 where tab0 . col10 = tab1 . col10 and tab0 . col7 < tab1 . col7 ) as col11 from col8 col12 order by col10 , col11	0
Q_241	access query counter per group	C_241_7	_ _ dense_rank ( col0 values get col0 col1 , without col2 ) _ select * , dense_rank ( ) over ( partition by col3 order by col4 ) as col5 from col6 order by col3 , col5	0
Q_241	access query counter per group	C_241_8	_ _ col0 col1 col2 col3 col4 col5 _ col6 _ select * , ( select count ( distinct tab0 . col7 ) from col8 col9 where tab0 . col10 = tab1 . col10 and tab0 . col7 < = tab1 . col7 ) as col11 from col8 col12 order by col10 , col11	0
Q_242	how to replace single digit zero tagstr with a string value in sql query	C_242_0	isnull ( nullif ( cast ( count ( tab0 . col0 ) as char ( codint ) ) , refre ) , refre refre )	1
Q_242	how to replace single digit zero tagstr with a string value in sql query	C_242_1	select left ( tab0 . col0 , codint ) as col1 , right ( tab0 . col0 , codint ) as col2 , tab0 . col0 as col0 , isnull ( nullif ( cast ( count ( tab1 . col3 ) as char ( codint ) ) , refre ) , refre refre ) as col4 , count ( tab1 . col3 ) as col5 , replace ( count ( case when tab2 . col6 is not null then refre end ) , codint , refre refre ) as col7 , replace ( count ( case when tab2 . col6 = refre then refre end ) , refre , refre refre ) as col8 , replace ( count ( case when tab2 . col6 < > refre then refre end ) , refre , refre refre ) as col9 from col10 col11 left join col12 col13 on tab0 . col0 = tab1 . col14 and tab1 . col15 = tab0 . col16 left join col17 col18 on tab1 . col3 = tab2 . col3 and tab1 . col14 = tab2 . col0 left join col0 col19 on tab3 . col0 = tab2 . col0 where tab0 . col0 in ( select col14 from col12 where col20 = refre ) group by tab0 . col0 order by col2 , col1	0
Q_242	how to replace single digit zero tagstr with a string value in sql query	C_242_2	select cast ( count ( tab0 . col0 ) as char ( codint ) )	0
Q_242	how to replace single digit zero tagstr with a string value in sql query	C_242_3	select nullif ( refre , refre ) _ * * col0 null col1 both col2 col3 nullif col4 col5 tab0 .	0
Q_242	how to replace single digit zero tagstr with a string value in sql query	C_242_4	select nullif ( refre , refre ) _ * * result null col0 both col1 col2 nullif col3 col4 tab0 .	0
Q_242	how to replace single digit zero tagstr with a string value in sql query	C_242_5	select nullif ( refre , refre ) _ * * col0 codint col1 col2 col3 nullif col4 not col5 tab0 .	0
Q_242	how to replace single digit zero tagstr with a string value in sql query	C_242_6	select isnull ( null , refre ) _ * * col0 in replace tab0 .	0
Q_242	how to replace single digit zero tagstr with a string value in sql query	C_242_7	select isnull ( refre , refre ) _ * * col0 in any tab0 .	0
Q_243	how to return all name that appear multiple time in table	C_243_0	select col0 from col1 group by col0 having count ( * ) > codint	1
Q_243	how to return all name that appear multiple time in table	C_243_1	select * from col0 inner join ( select col1 from col0 group by col1 having count ( * ) > codint ) col2 on tab0 . col1 = tab1 . col1	0
Q_243	how to return all name that appear multiple time in table	C_243_2	select tab0 . * , count ( * ) over ( partition by col0 ) col1 from col2	0
Q_243	how to return all name that appear multiple time in table	C_243_3	col0 , col1 col0 , col2 col3 , col4 col3 , col5 col3 , col6 col7 , col8	0
Q_243	how to return all name that appear multiple time in table	C_243_4	col0 , col1 , codint col0 , col2 , codint col3 , col4 , codint col3 , col5 , codint col3 , col6 , codint col7 , col8 , codint	0
Q_243	how to return all name that appear multiple time in table	C_243_5	select * from ( select tab0 . * , count ( * ) over ( partition by col0 ) col1 from col2 ) col3 where tab1 . col1 > codint	0
Q_243	how to return all name that appear multiple time in table	C_243_6	select * from col0 inner join ( select col1 , count ( * ) as col2 from col0 group by col1 ) col3 on tab0 . col1 = tab1 . col1	0
Q_243	how to return all name that appear multiple time in table	C_243_7	count ( * ) over ( partition by col0 )	0
Q_244	summary from pivot table for each id	C_244_0	, lag ( column , codint ) over ( col0 col0 col0 ) as col1 , lag ( column , codint ) over ( col0 col0 col0 ) as col1	1
Q_244	summary from pivot table for each id	C_244_1	, lag ( column ) ignore col0 over ( col1 col1 col1 ) as col2	0
Q_244	summary from pivot table for each id	C_244_2	coalesce ( col0 , col1 , col2 , col3 , col4 ) as col5	0
Q_244	summary from pivot table for each id	C_244_3	select distinct col0 , first_value ( col1 ) ignore col2 over ( partition by col0 order by col3 desc ) as col1 , first_value ( col4 ) ignore col2 over ( partition by col0 order by col3 desc ) as col4 , first_value ( col5 ) ignore col2 over ( partition by col0 order by col3 desc ) as col5 , first_value ( col6 ) ignore col2 over ( partition by col0 order by col3 desc ) as col6 , first_value ( col7 ) ignore col2 over ( partition by col0 order by col3 desc ) as col7 from values ( codint , codint , null , codint , null , null , null ) , ( codint , codint , null , null , codint , null , null ) , ( codint , codint , null , null , null , codint , null ) , ( codint , codint , null , null , null , null , codint ) , ( codint , codint , null , codint , null , null , null ) , ( codint , codint , null , null , codint , null , null ) , ( codint , codint , null , null , null , codint , null ) , ( codint , codint , null , null , null , null , codint ) v ( col0 , col3 , col1 , col4 , col5 , col6 , col7 ) order by codint , codint	0
Q_244	summary from pivot table for each id	C_244_4	from values ( codint , codint , null , codint , codint , codint , codint ) , ( codint , codint , null , codint , null , null , null ) , ( codint , codint , null , null , codint , null , null ) , ( codint , codint , null , null , null , codint , null ) , ( codint , codint , null , null , null , null , codint ) , ( codint , codint , null , codint , null , null , null ) , ( codint , codint , null , null , codint , null , null ) , ( codint , codint , null , null , null , codint , null ) , ( codint , codint , null , null , null , null , codint )	0
Q_244	summary from pivot table for each id	C_244_5	select col0 , max ( col1 ) as col1 , max ( col2 ) as col2 , max ( col3 ) as col3 , max ( col4 ) as col4 , max ( col5 ) as col5 from values ( codint , codint , null , codint , codint , codint , codint ) , ( codint , codint , null , codint , null , null , null ) , ( codint , codint , null , null , codint , null , null ) , ( codint , codint , null , null , null , codint , null ) , ( codint , codint , null , null , null , null , codint ) , ( codint , codint , null , codint , null , null , null ) , ( codint , codint , null , null , codint , null , null ) , ( codint , codint , null , null , null , codint , null ) , ( codint , codint , null , null , null , null , codint ) v ( col0 , col6 , col1 , col2 , col3 , col4 , col5 ) group by codint order by codint , codint	0
Q_244	summary from pivot table for each id	C_244_6	select col0 , get ( array_agg ( col1 ) col2 group ( order by col3 desc ) , codint ) as col1 , get ( array_agg ( col4 ) col2 group ( order by col3 desc ) , codint ) as col4 , get ( array_agg ( col5 ) col2 group ( order by col3 desc ) , codint ) as col5 , get ( array_agg ( col6 ) col2 group ( order by col3 desc ) , codint ) as col6 , get ( array_agg ( col7 ) col2 group ( order by col3 desc ) , codint ) as col7 from values ( codint , codint , null , codint , codint , codint , codint ) , ( codint , codint , null , codint , null , null , null ) , ( codint , codint , null , null , codint , null , null ) , ( codint , codint , null , null , null , codint , null ) , ( codint , codint , null , null , null , null , codint ) , ( codint , codint , null , codint , null , null , null ) , ( codint , codint , null , null , codint , null , null ) , ( codint , codint , null , null , null , codint , null ) , ( codint , codint , null , null , null , null , codint ) v ( col0 , col3 , col1 , col4 , col5 , col6 , col7 ) group by codint order by codint	0
Q_245	query for a view to get list of date in a date range and divide amount	C_245_0	_ = = = = col0 col1 declare rows int = codint with e1 ( col2 ) as ( select codint from ( values ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) ) as x ( col3 ) ) , itally ( col2 ) as ( select row_number ( ) over ( order by ( select null ) ) from col4 , col4 as col5 ) select tab0 . col2 from col6 as col7 where tab0 . col2 < = rows	1
Q_245	query for a view to get list of date in a date range and divide amount	C_245_1	col0 _ codint codint codint codint codint codint codint codint codint codint	0
Q_245	query for a view to get list of date in a date range and divide amount	C_245_2	_ = = = = codint . col0 data declare col1 table1 ( col2 int , col3 date , col4 date , col5 int ) insert col1 values ( codint , refre , refre , codint ) , ( codint , refre , refre , codint ) _ = = = = codint . col6 of col7 and col8 col5 by col7 for refre select col2 = tab0 . col2 , col7 = tab1 . col7 , col5 = tab0 . col5 / tab1 . col7 from col1 as col1 cross apply ( values ( datediff ( month , tab0 . col3 , tab0 . col4 ) + codint ) ) as mo ( col7 )	0
Q_245	query for a view to get list of date in a date range and divide amount	C_245_3	col0 col1 col2 _ _ _ codint codint codint codint codint codint	0
Q_245	query for a view to get list of date in a date range and divide amount	C_245_4	_ = = = = codint . col0 with e1 ( col1 ) as ( select codint from ( values ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) ) as x ( col2 ) ) , itally ( col1 ) as ( select row_number ( ) over ( order by ( select null ) ) from col3 , col3 as col4 ) select col5 = tab0 . col5 , col6 = dateadd ( month , tab1 . col1 _ codint , tab0 . col6 ) , col7 = tab0 . col7 / tab2 . col8 from col9 as col9 cross col10 col11 as col12 cross apply ( values ( datediff ( month , tab0 . col6 , tab0 . col13 ) + codint ) ) as mo ( col8 ) where tab1 . col1 < = tab2 . col8 order by tab0 . col5 _ not col14	0
Q_245	query for a view to get list of date in a date range and divide amount	C_245_5	col0 col1 col2 _ _ _ codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint codint codint _ codint _ codint codint	0
Q_245	query for a view to get list of date in a date range and divide amount	C_245_6	create view tab0 . col0 as with e1 ( col1 ) as ( select codint from ( values ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) , ( codint ) ) as x ( col2 ) ) , itally ( col1 ) as ( select row_number ( ) over ( order by ( select null ) ) from col3 , col3 as col4 ) select col5 = tab1 . col5 , col6 = dateadd ( month , tab2 . col1 _ codint , tab1 . col6 ) , col7 = tab1 . col7 / tab3 . col8 from col9 as col9 cross col10 col11 as col12 cross apply ( values ( datediff ( month , tab1 . col6 , tab1 . col13 ) + codint ) ) as mo ( col8 ) where tab2 . col1 < = tab3 . col8 order by tab1 . col5 _ not col14	0
Q_246	how can i convert from sq_lite3 format to dictionary	C_246_0	from tab0 . database col0 connect col1 = connect ( refre , refre )	1
Q_246	how can i convert from sq_lite3 format to dictionary	C_246_1	col0 col1 some_func ( ) col2 = col3 tab0 . to_dict ( refre , codint , refre , refre , . )	0
Q_246	how can i convert from sq_lite3 format to dictionary	C_246_2	col0 = col1 tab0 . to_dict ( refre , codint , refre regast refre )	0
Q_246	how can i convert from sq_lite3 format to dictionary	C_246_3	col0 col1 some_func ( ) . col2 tab0 . to_sql ( refre , codint , col3 )	0
Q_246	how can i convert from sq_lite3 format to dictionary	C_246_4	col0 = col1 tab0 . select ( refre , refre )	0
Q_246	how can i convert from sq_lite3 format to dictionary	C_246_5	col0 = col1 tab0 . select ( refre , refre , limit = codint )	0
Q_246	how can i convert from sq_lite3 format to dictionary	C_246_6	col0 = col1 tab0 . select ( refre , refre , col2 = refre , col3 = false )	0
Q_247	mysql return tagint row for distance calculation	C_247_0	create col0 if not exists mobile_ppl ( col1 int ( codint ) not null auto_increment , col2 varchar ( codint ) not null , col3 varchar ( codint ) not null , col4 varchar ( codint ) not null , col5 varchar ( codint ) not null , primary key ( col1 ) ) auto_increment = codint	1
Q_247	mysql return tagint row for distance calculation	C_247_1	insert into mobile_ppl ( col0 , col1 , col2 , col3 ) values ( refre , refre , refre , refre ) insert into mobile_ppl ( col0 , col1 , col2 , col3 ) values ( refre , refre , refre , refre ) insert into mobile_ppl ( col0 , col1 , col2 , col3 ) values ( refre , refre , refre , refre ) insert into mobile_ppl ( col0 , col1 , col2 , col3 ) values ( refre , refre , refre , refre )	0
Q_247	mysql return tagint row for distance calculation	C_247_2	select tab0 . col0 , st_distance_sphere ( point ( _ number , number ) , point ( tab0 . col1 , tab0 . col2 ) ) / codint as col3 from col4 as col5 where tab0 . col1 = _ number and tab0 . col2 = number and tab0 . col6 = codint having col3 < codint	0
Q_247	mysql return tagint row for distance calculation	C_247_3	select tab0 . col0 , st_distance_sphere ( point ( _ number , number ) , point ( tab0 . col1 , tab0 . col2 ) ) / codint as col3 from col4 as col5 where tab0 . col1 = _ number and tab0 . col2 = number and tab0 . col6 = codint having col3 < codint	0
Q_247	mysql return tagint row for distance calculation	C_247_4	create col0 mobile_ppl ( col1 int , col2 varchar ( codint ) , col3 varchar ( codint ) , col4 varchar ( codint ) )	0
Q_247	mysql return tagint row for distance calculation	C_247_5	insert into col0 values ( codint , refre , refre , refre ) , ( codint , refre , refre , refre )	0
Q_247	mysql return tagint row for distance calculation	C_247_6	select tab0 . col0 , st_distance_sphere ( point ( _ number , number ) , point ( tab0 . col1 , tab0 . col2 ) ) / codint as col3 from col4 as col5 where tab0 . col1 = _ number and tab0 . col2 = number and tab0 . col6 = codint having col3 < codint	0
Q_248	pypsark groupby merge json into single object	C_248_0	from tab0 . tab1 . col0 col1 col2 , collect_list first , group col3 col4 col5 col6 on col3 uid col7 = tab2 . groupby ( refre ) . agg ( collect_list ( refre ) . alias ( refre ) , collect_list ( refre ) . alias ( refre ) , collect_list ( refre ) . alias ( refre ) ) col8 on col9 col10 col11 with each col12 col13 in col3 col14 row tab3 . show ( )	1
Q_248	pypsark groupby merge json into single object	C_248_1	+ _ + _ + _ + _ + uid col0 count col1 + _ + _ + _ + _ + codint col2 col3 col4 + _ + _ + _ + _ +	0
Q_248	pypsark groupby merge json into single object	C_248_2	create col0 col1 function to create col2 dictionary using col2 values of each column ( col3 ) udf ( stringtype ( ) ) col4 new_column ( col5 , count , col6 ) col7 = dict ( ) for col8 in range ( len ( col5 ) ) col7 [ col5 col9 + refre ] = col6 col9 col7 [ col5 col9 + refre ] = count col9 return col7 result = tab0 . withcolumn ( refre , new_column ( col10 col11 , col10 col12 , col10 col13 ) ) . select ( refre , refre ) tab1 . show ( truncate = false )	0
Q_248	pypsark groupby merge json into single object	C_248_3	+ _ + _ + uid result + _ + _ + codint { col0 = codint , col1 = codint , col2 = codint , col3 = codint } + _ + _ +	0
Q_248	pypsark groupby merge json into single object	C_248_4	col0 col1 col2 for col1 col3 values of col1 column col4 and join col5 col6 to get all col1 col3 values in col1 col7 row col8 col9 col10 rename col1 col11 if col12 col13 = tab0 . filter ( col ( refre ) = = refre ) . withcolumnrenamed ( refre , refre ) . withcolumnrenamed ( refre , refre ) . join ( tab0 . filter ( col ( refre ) = = refre ) . withcolumnrenamed ( refre , refre ) . withcolumnrenamed ( refre , refre ) , on = refre , col14 = refre ) . drop ( refre ) tab1 . show ( )	0
Q_248	pypsark groupby merge json into single object	C_248_5	+ _ + _ + _ + _ + _ + uid col0 col1 col2 col3 + _ + _ + _ + _ + _ + codint codint codint codint codint + _ + _ + _ + _ + _ +	0
Q_248	pypsark groupby merge json into single object	C_248_6	col0 create col1 column as col2 col3 in col4 col5 col6 = tab0 . withcolumn ( refre , to_json ( struct ( col ( refre ) , col ( refre ) , col ( refre ) , col ( refre ) ) ) ) . select ( refre , refre ) tab1 . show ( truncate = false )	0
Q_248	pypsark groupby merge json into single object	C_248_7	+ _ + _ + uid col0 + _ + _ + codint { refre codint , refre codint , refre codint , refre codint } + _ + _ +	0
Q_249	sql _ select all unique where tagint column can have same value	C_249_0	select concat ( greatest ( col0 , col1 ) , least ( col0 , col1 ) ) as col2 , max ( col3 ) as col4 from col5 group by codint	1
Q_249	sql _ select all unique where tagint column can have same value	C_249_1	select col0 , max ( col1 ) as col2 from ( select col1 , concat ( greatest ( col3 , col4 ) , least ( col3 , col4 ) ) as col0 from col5 ) col6 group by col0	0
Q_249	sql _ select all unique where tagint column can have same value	C_249_2	select * from col0 where col1 in ( select max ( col1 ) from ( select col1 , concat ( greatest ( col2 , col3 ) , least ( col2 , col3 ) ) as col4 from col0 ) col5 group by col4 )	0
Q_249	sql _ select all unique where tagint column can have same value	C_249_3	select * from col0 where col1 in ( select max ( col1 ) from col0 group by concat ( greatest ( col2 , col3 ) , least ( col2 , col3 ) ) )	0
Q_249	sql _ select all unique where tagint column can have same value	C_249_4	select tab0 . * from col0 col1 join ( select concat ( greatest ( col2 , col3 ) , least ( col2 , col3 ) ) as col4 , max ( col5 ) as col6 from col0 group by codint ) col7 on tab0 . col5 = tab1 . col6	0
Q_249	sql _ select all unique where tagint column can have same value	C_249_5	select tab0 . * from col0 col1 join ( select concat ( greatest ( col2 , col3 ) , least ( col2 , col3 ) ) as col4 , max ( col5 ) as col6 from col0 group by codint ) col7 on tab0 . col5 = tab1 . col6	0
Q_249	sql _ select all unique where tagint column can have same value	C_249_6	select * from col0 where col1 in ( select max ( col1 ) from ( select col1 , concat ( greatest ( col2 , col3 ) , least ( col2 , col3 ) ) as col4 from col0 where col3 = refre or col2 = refre ) col5 group by col4 )	0
